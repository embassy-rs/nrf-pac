#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (f379958 2025-11-16))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "0 - VPRCLIC_0"]
    VPRCLIC_0 = 0,
    #[doc = "1 - VPRCLIC_1"]
    VPRCLIC_1 = 1,
    #[doc = "2 - VPRCLIC_2"]
    VPRCLIC_2 = 2,
    #[doc = "3 - VPRCLIC_3"]
    VPRCLIC_3 = 3,
    #[doc = "4 - VPRCLIC_4"]
    VPRCLIC_4 = 4,
    #[doc = "5 - VPRCLIC_5"]
    VPRCLIC_5 = 5,
    #[doc = "6 - VPRCLIC_6"]
    VPRCLIC_6 = 6,
    #[doc = "7 - VPRCLIC_7"]
    VPRCLIC_7 = 7,
    #[doc = "8 - VPRCLIC_8"]
    VPRCLIC_8 = 8,
    #[doc = "9 - VPRCLIC_9"]
    VPRCLIC_9 = 9,
    #[doc = "10 - VPRCLIC_10"]
    VPRCLIC_10 = 10,
    #[doc = "11 - VPRCLIC_11"]
    VPRCLIC_11 = 11,
    #[doc = "12 - VPRCLIC_12"]
    VPRCLIC_12 = 12,
    #[doc = "13 - VPRCLIC_13"]
    VPRCLIC_13 = 13,
    #[doc = "14 - VPRCLIC_14"]
    VPRCLIC_14 = 14,
    #[doc = "15 - VPRCLIC_15"]
    VPRCLIC_15 = 15,
    #[doc = "16 - VPRCLIC_16"]
    VPRCLIC_16 = 16,
    #[doc = "17 - VPRCLIC_17"]
    VPRCLIC_17 = 17,
    #[doc = "18 - VPRCLIC_18"]
    VPRCLIC_18 = 18,
    #[doc = "19 - VPRCLIC_19"]
    VPRCLIC_19 = 19,
    #[doc = "20 - VPRCLIC_20"]
    VPRCLIC_20 = 20,
    #[doc = "21 - VPRCLIC_21"]
    VPRCLIC_21 = 21,
    #[doc = "22 - VPRCLIC_22"]
    VPRCLIC_22 = 22,
    #[doc = "23 - VPRCLIC_23"]
    VPRCLIC_23 = 23,
    #[doc = "24 - VPRCLIC_24"]
    VPRCLIC_24 = 24,
    #[doc = "25 - VPRCLIC_25"]
    VPRCLIC_25 = 25,
    #[doc = "26 - VPRCLIC_26"]
    VPRCLIC_26 = 26,
    #[doc = "27 - VPRCLIC_27"]
    VPRCLIC_27 = 27,
    #[doc = "28 - VPRCLIC_28"]
    VPRCLIC_28 = 28,
    #[doc = "29 - VPRCLIC_29"]
    VPRCLIC_29 = 29,
    #[doc = "30 - VPRCLIC_30"]
    VPRCLIC_30 = 30,
    #[doc = "31 - VPRCLIC_31"]
    VPRCLIC_31 = 31,
    #[doc = "64 - SPU00"]
    SPU00 = 64,
    #[doc = "65 - MPC00"]
    MPC00 = 65,
    #[doc = "74 - AAR00_CCM00"]
    AAR00_CCM00 = 74,
    #[doc = "75 - ECB00"]
    ECB00 = 75,
    #[doc = "76 - VPR00"]
    VPR00 = 76,
    #[doc = "77 - SERIAL00"]
    SERIAL00 = 77,
    #[doc = "78 - RRAMC"]
    RRAMC = 78,
    #[doc = "82 - CTRLAP"]
    CTRLAP = 82,
    #[doc = "85 - TIMER00"]
    TIMER00 = 85,
    #[doc = "88 - EGU00"]
    EGU00 = 88,
    #[doc = "89 - CRACEN"]
    CRACEN = 89,
    #[doc = "90 - USBHS"]
    USBHS = 90,
    #[doc = "128 - SPU10"]
    SPU10 = 128,
    #[doc = "133 - TIMER10"]
    TIMER10 = 133,
    #[doc = "135 - EGU10"]
    EGU10 = 135,
    #[doc = "138 - RADIO_0"]
    RADIO_0 = 138,
    #[doc = "139 - RADIO_1"]
    RADIO_1 = 139,
    #[doc = "192 - SPU20"]
    SPU20 = 192,
    #[doc = "198 - SERIAL20"]
    SERIAL20 = 198,
    #[doc = "199 - SERIAL21"]
    SERIAL21 = 199,
    #[doc = "200 - SERIAL22"]
    SERIAL22 = 200,
    #[doc = "201 - EGU20"]
    EGU20 = 201,
    #[doc = "202 - TIMER20"]
    TIMER20 = 202,
    #[doc = "203 - TIMER21"]
    TIMER21 = 203,
    #[doc = "204 - TIMER22"]
    TIMER22 = 204,
    #[doc = "205 - TIMER23"]
    TIMER23 = 205,
    #[doc = "206 - TIMER24"]
    TIMER24 = 206,
    #[doc = "208 - PDM20"]
    PDM20 = 208,
    #[doc = "209 - PDM21"]
    PDM21 = 209,
    #[doc = "210 - PWM20"]
    PWM20 = 210,
    #[doc = "211 - PWM21"]
    PWM21 = 211,
    #[doc = "212 - PWM22"]
    PWM22 = 212,
    #[doc = "213 - SAADC"]
    SAADC = 213,
    #[doc = "214 - NFCT"]
    NFCT = 214,
    #[doc = "215 - TEMP"]
    TEMP = 215,
    #[doc = "218 - GPIOTE20_0"]
    GPIOTE20_0 = 218,
    #[doc = "219 - GPIOTE20_1"]
    GPIOTE20_1 = 219,
    #[doc = "224 - QDEC20"]
    QDEC20 = 224,
    #[doc = "225 - QDEC21"]
    QDEC21 = 225,
    #[doc = "226 - GRTC_0"]
    GRTC_0 = 226,
    #[doc = "227 - GRTC_1"]
    GRTC_1 = 227,
    #[doc = "228 - GRTC_2"]
    GRTC_2 = 228,
    #[doc = "229 - GRTC_3"]
    GRTC_3 = 229,
    #[doc = "232 - TDM"]
    TDM = 232,
    #[doc = "237 - SERIAL23"]
    SERIAL23 = 237,
    #[doc = "238 - SERIAL24"]
    SERIAL24 = 238,
    #[doc = "239 - TAMPC"]
    TAMPC = 239,
    #[doc = "256 - SPU30"]
    SPU30 = 256,
    #[doc = "260 - SERIAL30"]
    SERIAL30 = 260,
    #[doc = "262 - COMP_LPCOMP"]
    COMP_LPCOMP = 262,
    #[doc = "264 - WDT30"]
    WDT30 = 264,
    #[doc = "265 - WDT31"]
    WDT31 = 265,
    #[doc = "268 - GPIOTE30_0"]
    GPIOTE30_0 = 268,
    #[doc = "269 - GPIOTE30_1"]
    GPIOTE30_1 = 269,
    #[doc = "270 - CLOCK_POWER"]
    CLOCK_POWER = 270,
    #[doc = "289 - VREGUSB"]
    VREGUSB = 289,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    unsafe extern "C" {
        fn VPRCLIC_0();
        fn VPRCLIC_1();
        fn VPRCLIC_2();
        fn VPRCLIC_3();
        fn VPRCLIC_4();
        fn VPRCLIC_5();
        fn VPRCLIC_6();
        fn VPRCLIC_7();
        fn VPRCLIC_8();
        fn VPRCLIC_9();
        fn VPRCLIC_10();
        fn VPRCLIC_11();
        fn VPRCLIC_12();
        fn VPRCLIC_13();
        fn VPRCLIC_14();
        fn VPRCLIC_15();
        fn VPRCLIC_16();
        fn VPRCLIC_17();
        fn VPRCLIC_18();
        fn VPRCLIC_19();
        fn VPRCLIC_20();
        fn VPRCLIC_21();
        fn VPRCLIC_22();
        fn VPRCLIC_23();
        fn VPRCLIC_24();
        fn VPRCLIC_25();
        fn VPRCLIC_26();
        fn VPRCLIC_27();
        fn VPRCLIC_28();
        fn VPRCLIC_29();
        fn VPRCLIC_30();
        fn VPRCLIC_31();
        fn SPU00();
        fn MPC00();
        fn AAR00_CCM00();
        fn ECB00();
        fn VPR00();
        fn SERIAL00();
        fn RRAMC();
        fn CTRLAP();
        fn TIMER00();
        fn EGU00();
        fn CRACEN();
        fn USBHS();
        fn SPU10();
        fn TIMER10();
        fn EGU10();
        fn RADIO_0();
        fn RADIO_1();
        fn SPU20();
        fn SERIAL20();
        fn SERIAL21();
        fn SERIAL22();
        fn EGU20();
        fn TIMER20();
        fn TIMER21();
        fn TIMER22();
        fn TIMER23();
        fn TIMER24();
        fn PDM20();
        fn PDM21();
        fn PWM20();
        fn PWM21();
        fn PWM22();
        fn SAADC();
        fn NFCT();
        fn TEMP();
        fn GPIOTE20_0();
        fn GPIOTE20_1();
        fn QDEC20();
        fn QDEC21();
        fn GRTC_0();
        fn GRTC_1();
        fn GRTC_2();
        fn GRTC_3();
        fn TDM();
        fn SERIAL23();
        fn SERIAL24();
        fn TAMPC();
        fn SPU30();
        fn SERIAL30();
        fn COMP_LPCOMP();
        fn WDT30();
        fn WDT31();
        fn GPIOTE30_0();
        fn GPIOTE30_1();
        fn CLOCK_POWER();
        fn VREGUSB();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[unsafe(link_section = ".vector_table.interrupts")]
    #[unsafe(no_mangle)]
    pub static __INTERRUPTS: [Vector; 290] = [
        Vector {
            _handler: VPRCLIC_0,
        },
        Vector {
            _handler: VPRCLIC_1,
        },
        Vector {
            _handler: VPRCLIC_2,
        },
        Vector {
            _handler: VPRCLIC_3,
        },
        Vector {
            _handler: VPRCLIC_4,
        },
        Vector {
            _handler: VPRCLIC_5,
        },
        Vector {
            _handler: VPRCLIC_6,
        },
        Vector {
            _handler: VPRCLIC_7,
        },
        Vector {
            _handler: VPRCLIC_8,
        },
        Vector {
            _handler: VPRCLIC_9,
        },
        Vector {
            _handler: VPRCLIC_10,
        },
        Vector {
            _handler: VPRCLIC_11,
        },
        Vector {
            _handler: VPRCLIC_12,
        },
        Vector {
            _handler: VPRCLIC_13,
        },
        Vector {
            _handler: VPRCLIC_14,
        },
        Vector {
            _handler: VPRCLIC_15,
        },
        Vector {
            _handler: VPRCLIC_16,
        },
        Vector {
            _handler: VPRCLIC_17,
        },
        Vector {
            _handler: VPRCLIC_18,
        },
        Vector {
            _handler: VPRCLIC_19,
        },
        Vector {
            _handler: VPRCLIC_20,
        },
        Vector {
            _handler: VPRCLIC_21,
        },
        Vector {
            _handler: VPRCLIC_22,
        },
        Vector {
            _handler: VPRCLIC_23,
        },
        Vector {
            _handler: VPRCLIC_24,
        },
        Vector {
            _handler: VPRCLIC_25,
        },
        Vector {
            _handler: VPRCLIC_26,
        },
        Vector {
            _handler: VPRCLIC_27,
        },
        Vector {
            _handler: VPRCLIC_28,
        },
        Vector {
            _handler: VPRCLIC_29,
        },
        Vector {
            _handler: VPRCLIC_30,
        },
        Vector {
            _handler: VPRCLIC_31,
        },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU00 },
        Vector { _handler: MPC00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: AAR00_CCM00,
        },
        Vector { _handler: ECB00 },
        Vector { _handler: VPR00 },
        Vector { _handler: SERIAL00 },
        Vector { _handler: RRAMC },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: CTRLAP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: EGU00 },
        Vector { _handler: CRACEN },
        Vector { _handler: USBHS },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER10 },
        Vector { _reserved: 0 },
        Vector { _handler: EGU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: RADIO_0 },
        Vector { _handler: RADIO_1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU20 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL20 },
        Vector { _handler: SERIAL21 },
        Vector { _handler: SERIAL22 },
        Vector { _handler: EGU20 },
        Vector { _handler: TIMER20 },
        Vector { _handler: TIMER21 },
        Vector { _handler: TIMER22 },
        Vector { _handler: TIMER23 },
        Vector { _handler: TIMER24 },
        Vector { _reserved: 0 },
        Vector { _handler: PDM20 },
        Vector { _handler: PDM21 },
        Vector { _handler: PWM20 },
        Vector { _handler: PWM21 },
        Vector { _handler: PWM22 },
        Vector { _handler: SAADC },
        Vector { _handler: NFCT },
        Vector { _handler: TEMP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE20_0,
        },
        Vector {
            _handler: GPIOTE20_1,
        },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: QDEC20 },
        Vector { _handler: QDEC21 },
        Vector { _handler: GRTC_0 },
        Vector { _handler: GRTC_1 },
        Vector { _handler: GRTC_2 },
        Vector { _handler: GRTC_3 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TDM },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL23 },
        Vector { _handler: SERIAL24 },
        Vector { _handler: TAMPC },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU30 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL30 },
        Vector { _reserved: 0 },
        Vector {
            _handler: COMP_LPCOMP,
        },
        Vector { _reserved: 0 },
        Vector { _handler: WDT30 },
        Vector { _handler: WDT31 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE30_0,
        },
        Vector {
            _handler: GPIOTE30_1,
        },
        Vector {
            _handler: CLOCK_POWER,
        },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: VREGUSB },
    ];
}
#[doc = "Factory Information Configuration Registers"]
pub const FICR_NS: ficr::Ficr = unsafe { ficr::Ficr::from_ptr(0x00ff_c000usize as _) };
#[doc = "User Information Configuration Registers"]
pub const UICR_S: uicr::Uicr = unsafe { uicr::Uicr::from_ptr(0x00ff_d000usize as _) };
#[doc = "Factory Information Configuration Registers"]
pub const SICR_S: sicr::Sicr = unsafe { sicr::Sicr::from_ptr(0x00ff_e000usize as _) };
#[doc = "USBHSCORE 0"]
pub const USBHSCORE_NS: usbhscore::Usbhscore =
    unsafe { usbhscore::Usbhscore::from_ptr(0x4002_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub const DPPIC00_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4004_2000usize as _) };
#[doc = "PPIB APB registers 0"]
pub const PPIB00_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_4000usize as _) };
#[doc = "PPIB APB registers 2"]
pub const PPIB01_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_5000usize as _) };
#[doc = "Accelerated Address Resolver 0"]
pub const AAR00_NS: aar::Aar = unsafe { aar::Aar::from_ptr(0x4004_a000usize as _) };
#[doc = "AES CCM Mode Encryption 0"]
pub const CCM00_NS: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x4004_a000usize as _) };
#[doc = "AES ECB Mode Encryption 0"]
pub const ECB00_NS: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x4004_b000usize as _) };
#[doc = "VPR peripheral registers 0"]
pub const VPR00_NS: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x4004_c000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub const SPIM00_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4004_d000usize as _) };
#[doc = "SPI Slave 0"]
pub const SPIS00_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4004_d000usize as _) };
#[doc = "UART with EasyDMA 0"]
pub const UARTE00_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4004_d000usize as _) };
#[doc = "GPIO Port 0"]
pub const P2_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4005_0400usize as _) };
#[doc = "Control access port 0"]
pub const CTRLAP_NS: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x4005_2000usize as _) };
#[doc = "Trace and debug control 0"]
pub const TAD_NS: tad::Tad = unsafe { tad::Tad::from_ptr(0x4005_3000usize as _) };
#[doc = "Timer/Counter 0"]
pub const TIMER00_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4005_5000usize as _) };
#[doc = "Event generator unit 0"]
pub const EGU00_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4005_8000usize as _) };
#[doc = "USBHS 0"]
pub const USBHS_NS: usbhs::Usbhs = unsafe { usbhs::Usbhs::from_ptr(0x4005_a000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 2"]
pub const DPPIC10_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4008_2000usize as _) };
#[doc = "PPIB APB registers 4"]
pub const PPIB10_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_3000usize as _) };
#[doc = "PPIB APB registers 6"]
pub const PPIB11_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_4000usize as _) };
#[doc = "Timer/Counter 2"]
pub const TIMER10_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4008_5000usize as _) };
#[doc = "Event generator unit 2"]
pub const EGU10_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4008_7000usize as _) };
#[doc = "2.4 GHz radio 0"]
pub const RADIO_NS: radio::Radio = unsafe { radio::Radio::from_ptr(0x4008_a000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 4"]
pub const DPPIC20_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x400c_2000usize as _) };
#[doc = "PPIB APB registers 8"]
pub const PPIB20_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_3000usize as _) };
#[doc = "PPIB APB registers 10"]
pub const PPIB21_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_4000usize as _) };
#[doc = "PPIB APB registers 12"]
pub const PPIB22_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub const SPIM20_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_6000usize as _) };
#[doc = "SPI Slave 2"]
pub const SPIS20_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub const TWIM20_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub const TWIS20_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_6000usize as _) };
#[doc = "UART with EasyDMA 2"]
pub const UARTE20_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub const SPIM21_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_7000usize as _) };
#[doc = "SPI Slave 4"]
pub const SPIS21_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub const TWIM21_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub const TWIS21_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_7000usize as _) };
#[doc = "UART with EasyDMA 4"]
pub const UARTE21_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub const SPIM22_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_8000usize as _) };
#[doc = "SPI Slave 6"]
pub const SPIS22_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub const TWIM22_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub const TWIS22_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_8000usize as _) };
#[doc = "UART with EasyDMA 6"]
pub const UARTE22_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_8000usize as _) };
#[doc = "Event generator unit 4"]
pub const EGU20_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x400c_9000usize as _) };
#[doc = "Timer/Counter 4"]
pub const TIMER20_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_a000usize as _) };
#[doc = "Timer/Counter 6"]
pub const TIMER21_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_b000usize as _) };
#[doc = "Timer/Counter 8"]
pub const TIMER22_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_c000usize as _) };
#[doc = "Timer/Counter 10"]
pub const TIMER23_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_d000usize as _) };
#[doc = "Timer/Counter 12"]
pub const TIMER24_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_e000usize as _) };
#[doc = "Memory configuration 0"]
pub const MEMCONF_NS: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x400c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub const PDM20_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 2"]
pub const PDM21_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_1000usize as _) };
#[doc = "Pulse width modulation unit 0"]
pub const PWM20_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_2000usize as _) };
#[doc = "Pulse width modulation unit 2"]
pub const PWM21_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_3000usize as _) };
#[doc = "Pulse width modulation unit 4"]
pub const PWM22_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_4000usize as _) };
#[doc = "Analog to Digital Converter 0"]
pub const SAADC_NS: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x400d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
pub const NFCT_NS: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x400d_6000usize as _) };
#[doc = "Temperature Sensor 0"]
pub const TEMP_NS: temp::Temp = unsafe { temp::Temp::from_ptr(0x400d_7000usize as _) };
#[doc = "GPIO Port 2"]
pub const P1_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x400d_8200usize as _) };
#[doc = "GPIO Port 3"]
pub const P3_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x400d_8600usize as _) };
#[doc = "GPIO Tasks and Events 0"]
pub const GPIOTE20_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x400d_a000usize as _) };
#[doc = "Quadrature Decoder 0"]
pub const QDEC20_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_0000usize as _) };
#[doc = "Quadrature Decoder 2"]
pub const QDEC21_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_1000usize as _) };
#[doc = "Global Real-time counter 0"]
pub const GRTC_NS: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x400e_2000usize as _) };
#[doc = "Time division multiplexed audio interface 0"]
pub const TDM_NS: tdm::Tdm = unsafe { tdm::Tdm::from_ptr(0x400e_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 8"]
pub const SPIM23_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400e_d000usize as _) };
#[doc = "SPI Slave 8"]
pub const SPIS23_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400e_d000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub const TWIM23_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400e_d000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub const TWIS23_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400e_d000usize as _) };
#[doc = "UART with EasyDMA 8"]
pub const UARTE23_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400e_d000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 10"]
pub const SPIM24_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400e_e000usize as _) };
#[doc = "SPI Slave 10"]
pub const SPIS24_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400e_e000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 8"]
pub const TWIM24_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400e_e000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 8"]
pub const TWIS24_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400e_e000usize as _) };
#[doc = "UART with EasyDMA 10"]
pub const UARTE24_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400e_e000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 6"]
pub const DPPIC30_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4010_2000usize as _) };
#[doc = "PPIB APB registers 14"]
pub const PPIB30_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 12"]
pub const SPIM30_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4010_4000usize as _) };
#[doc = "SPI Slave 12"]
pub const SPIS30_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 10"]
pub const TWIM30_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 10"]
pub const TWIS30_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4010_4000usize as _) };
#[doc = "UART with EasyDMA 12"]
pub const UARTE30_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4010_4000usize as _) };
#[doc = "Comparator 0"]
pub const COMP_NS: comp::Comp = unsafe { comp::Comp::from_ptr(0x4010_6000usize as _) };
#[doc = "Low-power comparator 0"]
pub const LPCOMP_NS: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x4010_6000usize as _) };
#[doc = "Watchdog Timer 1"]
pub const WDT31_NS: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4010_9000usize as _) };
#[doc = "GPIO Port 6"]
pub const P0_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4010_a000usize as _) };
#[doc = "GPIO Tasks and Events 2"]
pub const GPIOTE30_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x4010_c000usize as _) };
#[doc = "Clock management 0"]
pub const CLOCK_NS: clock::Clock = unsafe { clock::Clock::from_ptr(0x4010_e000usize as _) };
#[doc = "Power control 0"]
pub const POWER_NS: power::Power = unsafe { power::Power::from_ptr(0x4010_e000usize as _) };
#[doc = "Reset control 0"]
pub const RESET_NS: reset::Reset = unsafe { reset::Reset::from_ptr(0x4010_e000usize as _) };
#[doc = "Oscillator control 0"]
pub const OSCILLATORS_NS: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x4012_0000usize as _) };
#[doc = "Voltage regulators 0"]
pub const REGULATORS_NS: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x4012_0000usize as _) };
#[doc = "VREGUSB peripheral 0"]
pub const VREGUSB_NS: vregusb::Vregusb =
    unsafe { vregusb::Vregusb::from_ptr(0x4012_1000usize as _) };
#[doc = "CRACENCORE"]
pub const CRACENCORE_S: cracencore::Cracencore =
    unsafe { cracencore::Cracencore::from_ptr(0x5001_0000usize as _) };
#[doc = "USBHSCORE 1"]
pub const USBHSCORE_S: usbhscore::Usbhscore =
    unsafe { usbhscore::Usbhscore::from_ptr(0x5002_0000usize as _) };
#[doc = "System protection unit 0"]
pub const SPU00_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5004_0000usize as _) };
#[doc = "Memory Privilege Controller"]
pub const MPC00_S: mpc::Mpc = unsafe { mpc::Mpc::from_ptr(0x5004_1000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub const DPPIC00_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5004_2000usize as _) };
#[doc = "PPIB APB registers 1"]
pub const PPIB00_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_4000usize as _) };
#[doc = "PPIB APB registers 3"]
pub const PPIB01_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_5000usize as _) };
#[doc = "Key management unit"]
pub const KMU_S: kmu::Kmu = unsafe { kmu::Kmu::from_ptr(0x5004_9000usize as _) };
#[doc = "Accelerated Address Resolver 1"]
pub const AAR00_S: aar::Aar = unsafe { aar::Aar::from_ptr(0x5004_a000usize as _) };
#[doc = "AES CCM Mode Encryption 1"]
pub const CCM00_S: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x5004_a000usize as _) };
#[doc = "AES ECB Mode Encryption 1"]
pub const ECB00_S: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x5004_b000usize as _) };
#[doc = "VPR peripheral registers 1"]
pub const VPR00_S: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x5004_c000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub const SPIM00_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5004_d000usize as _) };
#[doc = "SPI Slave 1"]
pub const SPIS00_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5004_d000usize as _) };
#[doc = "UART with EasyDMA 1"]
pub const UARTE00_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5004_d000usize as _) };
#[doc = "Voltage glitch detectors"]
pub const GLITCHDET_S: glitchdet::Glitchdet =
    unsafe { glitchdet::Glitchdet::from_ptr(0x5004_e000usize as _) };
#[doc = "RRAM controller GLITCH detector"]
pub const RRAMC_S: rramc::Rramc = unsafe { rramc::Rramc::from_ptr(0x5004_e000usize as _) };
#[doc = "GPIO high-speed pad control"]
pub const GPIOHSPADCTRL_S: gpiohspadctrl::Gpiohspadctrl =
    unsafe { gpiohspadctrl::Gpiohspadctrl::from_ptr(0x5005_0400usize as _) };
#[doc = "GPIO Port 1"]
pub const P2_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5005_0400usize as _) };
#[doc = "Control access port 1"]
pub const CTRLAP_S: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x5005_2000usize as _) };
#[doc = "Trace and debug control 1"]
pub const TAD_S: tad::Tad = unsafe { tad::Tad::from_ptr(0x5005_3000usize as _) };
#[doc = "Timer/Counter 1"]
pub const TIMER00_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5005_5000usize as _) };
#[doc = "Event generator unit 1"]
pub const EGU00_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5005_8000usize as _) };
#[doc = "CRACEN"]
pub const CRACEN_S: cracen::Cracen = unsafe { cracen::Cracen::from_ptr(0x5005_9000usize as _) };
#[doc = "USBHS 1"]
pub const USBHS_S: usbhs::Usbhs = unsafe { usbhs::Usbhs::from_ptr(0x5005_a000usize as _) };
#[doc = "System protection unit 1"]
pub const SPU10_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5008_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 3"]
pub const DPPIC10_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5008_2000usize as _) };
#[doc = "PPIB APB registers 5"]
pub const PPIB10_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_3000usize as _) };
#[doc = "PPIB APB registers 7"]
pub const PPIB11_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_4000usize as _) };
#[doc = "Timer/Counter 3"]
pub const TIMER10_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5008_5000usize as _) };
#[doc = "Event generator unit 3"]
pub const EGU10_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5008_7000usize as _) };
#[doc = "2.4 GHz radio 1"]
pub const RADIO_S: radio::Radio = unsafe { radio::Radio::from_ptr(0x5008_a000usize as _) };
#[doc = "System protection unit 2"]
pub const SPU20_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x500c_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 5"]
pub const DPPIC20_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x500c_2000usize as _) };
#[doc = "PPIB APB registers 9"]
pub const PPIB20_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_3000usize as _) };
#[doc = "PPIB APB registers 11"]
pub const PPIB21_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_4000usize as _) };
#[doc = "PPIB APB registers 13"]
pub const PPIB22_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub const SPIM20_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_6000usize as _) };
#[doc = "SPI Slave 3"]
pub const SPIS20_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub const TWIM20_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub const TWIS20_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_6000usize as _) };
#[doc = "UART with EasyDMA 3"]
pub const UARTE20_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub const SPIM21_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_7000usize as _) };
#[doc = "SPI Slave 5"]
pub const SPIS21_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub const TWIM21_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub const TWIS21_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_7000usize as _) };
#[doc = "UART with EasyDMA 5"]
pub const UARTE21_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub const SPIM22_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_8000usize as _) };
#[doc = "SPI Slave 7"]
pub const SPIS22_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub const TWIM22_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub const TWIS22_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_8000usize as _) };
#[doc = "UART with EasyDMA 7"]
pub const UARTE22_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_8000usize as _) };
#[doc = "Event generator unit 5"]
pub const EGU20_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x500c_9000usize as _) };
#[doc = "Timer/Counter 5"]
pub const TIMER20_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_a000usize as _) };
#[doc = "Timer/Counter 7"]
pub const TIMER21_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_b000usize as _) };
#[doc = "Timer/Counter 9"]
pub const TIMER22_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_c000usize as _) };
#[doc = "Timer/Counter 11"]
pub const TIMER23_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_d000usize as _) };
#[doc = "Timer/Counter 13"]
pub const TIMER24_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_e000usize as _) };
#[doc = "Memory configuration 1"]
pub const MEMCONF_S: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x500c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub const PDM20_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 3"]
pub const PDM21_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_1000usize as _) };
#[doc = "Pulse width modulation unit 1"]
pub const PWM20_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_2000usize as _) };
#[doc = "Pulse width modulation unit 3"]
pub const PWM21_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_3000usize as _) };
#[doc = "Pulse width modulation unit 5"]
pub const PWM22_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_4000usize as _) };
#[doc = "Analog to Digital Converter 1"]
pub const SAADC_S: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x500d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 1"]
pub const NFCT_S: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x500d_6000usize as _) };
#[doc = "Temperature Sensor 1"]
pub const TEMP_S: temp::Temp = unsafe { temp::Temp::from_ptr(0x500d_7000usize as _) };
#[doc = "GPIO Port 4"]
pub const P1_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x500d_8200usize as _) };
#[doc = "GPIO Port 5"]
pub const P3_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x500d_8600usize as _) };
#[doc = "GPIO Tasks and Events 1"]
pub const GPIOTE20_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x500d_a000usize as _) };
#[doc = "Quadrature Decoder 1"]
pub const QDEC20_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_0000usize as _) };
#[doc = "Quadrature Decoder 3"]
pub const QDEC21_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_1000usize as _) };
#[doc = "Global Real-time counter 1"]
pub const GRTC_S: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x500e_2000usize as _) };
#[doc = "Time division multiplexed audio interface 1"]
pub const TDM_S: tdm::Tdm = unsafe { tdm::Tdm::from_ptr(0x500e_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 9"]
pub const SPIM23_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500e_d000usize as _) };
#[doc = "SPI Slave 9"]
pub const SPIS23_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500e_d000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub const TWIM23_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500e_d000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub const TWIS23_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500e_d000usize as _) };
#[doc = "UART with EasyDMA 9"]
pub const UARTE23_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500e_d000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 11"]
pub const SPIM24_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500e_e000usize as _) };
#[doc = "SPI Slave 11"]
pub const SPIS24_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500e_e000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 9"]
pub const TWIM24_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500e_e000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 9"]
pub const TWIS24_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500e_e000usize as _) };
#[doc = "UART with EasyDMA 11"]
pub const UARTE24_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500e_e000usize as _) };
#[doc = "Tamper controller"]
pub const TAMPC_S: tampc::Tampc = unsafe { tampc::Tampc::from_ptr(0x500e_f000usize as _) };
#[doc = "System protection unit 3"]
pub const SPU30_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5010_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 7"]
pub const DPPIC30_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5010_2000usize as _) };
#[doc = "PPIB APB registers 15"]
pub const PPIB30_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 13"]
pub const SPIM30_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5010_4000usize as _) };
#[doc = "SPI Slave 13"]
pub const SPIS30_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 11"]
pub const TWIM30_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 11"]
pub const TWIS30_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5010_4000usize as _) };
#[doc = "UART with EasyDMA 13"]
pub const UARTE30_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5010_4000usize as _) };
#[doc = "Comparator 1"]
pub const COMP_S: comp::Comp = unsafe { comp::Comp::from_ptr(0x5010_6000usize as _) };
#[doc = "Low-power comparator 1"]
pub const LPCOMP_S: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x5010_6000usize as _) };
#[doc = "Watchdog Timer 0"]
pub const WDT30_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_8000usize as _) };
#[doc = "Watchdog Timer 2"]
pub const WDT31_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_9000usize as _) };
#[doc = "GPIO Port 7"]
pub const P0_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5010_a000usize as _) };
#[doc = "GPIO Tasks and Events 3"]
pub const GPIOTE30_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x5010_c000usize as _) };
#[doc = "Clock management 1"]
pub const CLOCK_S: clock::Clock = unsafe { clock::Clock::from_ptr(0x5010_e000usize as _) };
#[doc = "Power control 1"]
pub const POWER_S: power::Power = unsafe { power::Power::from_ptr(0x5010_e000usize as _) };
#[doc = "Reset control 1"]
pub const RESET_S: reset::Reset = unsafe { reset::Reset::from_ptr(0x5010_e000usize as _) };
#[doc = "Oscillator control 1"]
pub const OSCILLATORS_S: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x5012_0000usize as _) };
#[doc = "Voltage regulators 1"]
pub const REGULATORS_S: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x5012_0000usize as _) };
#[doc = "VREGUSB peripheral 1"]
pub const VREGUSB_S: vregusb::Vregusb =
    unsafe { vregusb::Vregusb::from_ptr(0x5012_1000usize as _) };
#[doc = "VPR CLIC registers"]
pub const VPRCLIC_NS: clic::Clic = unsafe { clic::Clic::from_ptr(0xf000_0000usize as _) };
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod aar {
    #[doc = "Accelerated Address Resolver 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Aar {
        ptr: *mut u8,
    }
    unsafe impl Send for Aar {}
    unsafe impl Sync for Aar {}
    impl Aar {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start resolving addresses based on IRKs specified in the IRK data structure"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop resolving addresses"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Address resolution procedure complete or ended due to an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Address resolved"]
        #[inline(always)]
        pub const fn events_resolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Address not resolved"]
        #[inline(always)]
        pub const fn events_notresolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Operation aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event RESOLVED"]
        #[inline(always)]
        pub const fn publish_resolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event NOTRESOLVED"]
        #[inline(always)]
        pub const fn publish_notresolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Enable AAR"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[inline(always)]
        pub const fn maxresolved(self) -> crate::common::Reg<regs::Maxresolved, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u8:?} }}", self.amount())
            }
        }
        #[doc = "Enable AAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable AAR"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable AAR"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[must_use]
            #[inline(always)]
            pub const fn resolved(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[inline(always)]
            pub const fn set_resolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[must_use]
            #[inline(always)]
            pub const fn notresolved(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[inline(always)]
            pub const fn set_notresolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("resolved", &self.resolved())
                    .field("notresolved", &self.notresolved())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ end: {=bool:?}, resolved: {=bool:?}, notresolved: {=bool:?}, error: {=bool:?} }}" , self . end () , self . resolved () , self . notresolved () , self . error ())
            }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxresolved(pub u32);
        impl Maxresolved {
            #[doc = "The maximum number of IRKs to resolve"]
            #[must_use]
            #[inline(always)]
            pub const fn maxresolved(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The maximum number of IRKs to resolve"]
            #[inline(always)]
            pub const fn set_maxresolved(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Maxresolved {
            #[inline(always)]
            fn default() -> Maxresolved {
                Maxresolved(0)
            }
        }
        impl core::fmt::Debug for Maxresolved {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxresolved")
                    .field("maxresolved", &self.maxresolved())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxresolved {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Maxresolved {{ maxresolved: {=u16:?} }}",
                    self.maxresolved()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Enable"]
            ENABLED = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod ccm {
    #[doc = "AES CCM Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccm {
        ptr: *mut u8,
    }
    unsafe impl Send for Ccm {}
    unsafe impl Sync for Ccm {}
    impl Ccm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start encryption/decryption. This operation will stop by itself when completed."]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_rateoverride(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task RATEOVERRIDE"]
        #[inline(always)]
        pub const fn subscribe_rateoverride(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Encrypt/decrypt complete or ended because of an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "CCM error event"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "MAC check result"]
        #[inline(always)]
        pub const fn macstatus(self) -> crate::common::Reg<regs::Macstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Operation mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nonce(self) -> Nonce {
            unsafe { Nonce::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Data rate override setting."]
        #[inline(always)]
        pub const fn rateoverride(
            self,
        ) -> crate::common::Reg<regs::Rateoverride, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0544usize) as _) }
        }
        #[doc = "CCM adata mask."]
        #[inline(always)]
        pub const fn adatamask(self) -> crate::common::Reg<regs::Adatamask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0548usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer Points to a job list containing unencrypted CCM data structure in Encryption mode Points to a job list containing encrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nonce {
        ptr: *mut u8,
    }
    unsafe impl Send for Nonce {}
    unsafe impl Sync for Nonce {}
    impl Nonce {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 13-byte NONCE vector Only the lower 13 bytes are used"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted CCM data structure in Encryption mode Points to a job list containing decrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CCM adata mask."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adatamask(pub u32);
        impl Adatamask {
            #[doc = "CCM adata mask."]
            #[must_use]
            #[inline(always)]
            pub const fn adatamask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CCM adata mask."]
            #[inline(always)]
            pub const fn set_adatamask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Adatamask {
            #[inline(always)]
            fn default() -> Adatamask {
                Adatamask(0)
            }
        }
        impl core::fmt::Debug for Adatamask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adatamask")
                    .field("adatamask", &self.adatamask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adatamask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adatamask {{ adatamask: {=u8:?} }}", self.adatamask())
            }
        }
        #[doc = "Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable CCM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable CCM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ end: {=bool:?}, error: {=bool:?} }}",
                    self.end(),
                    self.error()
                )
            }
        }
        #[doc = "MAC check result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Macstatus(pub u32);
        impl Macstatus {
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[must_use]
            #[inline(always)]
            pub const fn macstatus(&self) -> super::vals::Macstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Macstatus::from_bits(val as u8)
            }
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[inline(always)]
            pub const fn set_macstatus(&mut self, val: super::vals::Macstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Macstatus {
            #[inline(always)]
            fn default() -> Macstatus {
                Macstatus(0)
            }
        }
        impl core::fmt::Debug for Macstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Macstatus")
                    .field("macstatus", &self.macstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Macstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Macstatus {{ macstatus: {:?} }}", self.macstatus())
            }
        }
        #[doc = "Operation mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Protocol and packet format selection"]
            #[must_use]
            #[inline(always)]
            pub const fn protocol(&self) -> super::vals::Protocol {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Protocol::from_bits(val as u8)
            }
            #[doc = "Protocol and packet format selection"]
            #[inline(always)]
            pub const fn set_protocol(&mut self, val: super::vals::Protocol) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[must_use]
            #[inline(always)]
            pub const fn datarate(&self) -> super::vals::Datarate {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Datarate::from_bits(val as u8)
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[inline(always)]
            pub const fn set_datarate(&mut self, val: super::vals::Datarate) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "CCM MAC length (bytes)"]
            #[must_use]
            #[inline(always)]
            pub const fn maclen(&self) -> super::vals::Maclen {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Maclen::from_bits(val as u8)
            }
            #[doc = "CCM MAC length (bytes)"]
            #[inline(always)]
            pub const fn set_maclen(&mut self, val: super::vals::Maclen) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("mode", &self.mode())
                    .field("protocol", &self.protocol())
                    .field("datarate", &self.datarate())
                    .field("maclen", &self.maclen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ mode: {:?}, protocol: {:?}, datarate: {:?}, maclen: {:?} }}",
                    self.mode(),
                    self.protocol(),
                    self.datarate(),
                    self.maclen()
                )
            }
        }
        #[doc = "Data rate override setting."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rateoverride(pub u32);
        impl Rateoverride {
            #[doc = "Data rate override setting."]
            #[must_use]
            #[inline(always)]
            pub const fn rateoverride(&self) -> super::vals::Rateoverride {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Rateoverride::from_bits(val as u8)
            }
            #[doc = "Data rate override setting."]
            #[inline(always)]
            pub const fn set_rateoverride(&mut self, val: super::vals::Rateoverride) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rateoverride {
            #[inline(always)]
            fn default() -> Rateoverride {
                Rateoverride(0)
            }
        }
        impl core::fmt::Debug for Rateoverride {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rateoverride")
                    .field("rateoverride", &self.rateoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rateoverride {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rateoverride {{ rateoverride: {:?} }}",
                    self.rateoverride()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Datarate {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            #[doc = "250 Kbps"]
            _250KBIT = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Datarate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Datarate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Datarate {
            #[inline(always)]
            fn from(val: u8) -> Datarate {
                Datarate::from_bits(val)
            }
        }
        impl From<Datarate> for u8 {
            #[inline(always)]
            fn from(val: Datarate) -> u8 {
                Datarate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before CCM data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before CCM data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Encryption of the unencrypted CCM data structure did not complete in time."]
            ENCRYPTION_TOO_SLOW = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Maclen {
            #[doc = "M = 0 This is a special case for CCM* where encryption is required but not authentication"]
            M0 = 0x0,
            #[doc = "M = 4"]
            M4 = 0x01,
            #[doc = "M = 6"]
            M6 = 0x02,
            #[doc = "M = 8"]
            M8 = 0x03,
            #[doc = "M = 10"]
            M10 = 0x04,
            #[doc = "M = 12"]
            M12 = 0x05,
            #[doc = "M = 14"]
            M14 = 0x06,
            #[doc = "M = 16"]
            M16 = 0x07,
        }
        impl Maclen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Maclen {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Maclen {
            #[inline(always)]
            fn from(val: u8) -> Maclen {
                Maclen::from_bits(val)
            }
        }
        impl From<Maclen> for u8 {
            #[inline(always)]
            fn from(val: Maclen) -> u8 {
                Maclen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macstatus {
            #[doc = "MAC check failed"]
            CHECK_FAILED = 0x0,
            #[doc = "MAC check passed"]
            CHECK_PASSED = 0x01,
        }
        impl Macstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macstatus {
            #[inline(always)]
            fn from(val: u8) -> Macstatus {
                Macstatus::from_bits(val)
            }
        }
        impl From<Macstatus> for u8 {
            #[inline(always)]
            fn from(val: Macstatus) -> u8 {
                Macstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "AES CCM packet encryption mode"]
            ENCRYPTION = 0x0,
            #[doc = "Deprecated enumerator - This mode will run CCM decryption in the speed of the DATARATE field."]
            DECRYPTION = 0x01,
            #[doc = "AES CCM decryption mode."]
            FAST_DECRYPTION = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Protocol {
            #[doc = "Bluetooth Low Energy packet format"]
            BLE = 0x0,
            #[doc = "802.15.4 packet format"]
            IEEE802154 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Protocol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Protocol {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Protocol {
            #[inline(always)]
            fn from(val: u8) -> Protocol {
                Protocol::from_bits(val)
            }
        }
        impl From<Protocol> for u8 {
            #[inline(always)]
            fn from(val: Protocol) -> u8 {
                Protocol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rateoverride {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rateoverride {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rateoverride {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rateoverride {
            #[inline(always)]
            fn from(val: u8) -> Rateoverride {
                Rateoverride::from_bits(val)
            }
        }
        impl From<Rateoverride> for u8 {
            #[inline(always)]
            fn from(val: Rateoverride) -> u8 {
                Rateoverride::to_bits(val)
            }
        }
    }
}
pub mod clic {
    #[doc = "VPR CLIC registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clic {
        ptr: *mut u8,
    }
    unsafe impl Send for Clic {}
    unsafe impl Sync for Clic {}
    impl Clic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn clic(self) -> ClicClic {
            unsafe { ClicClic::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ClicClic {
        ptr: *mut u8,
    }
    unsafe impl Send for ClicClic {}
    unsafe impl Sync for ClicClic {}
    impl ClicClic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "CLIC configuration."]
        #[inline(always)]
        pub const fn cliccfg(self) -> crate::common::Reg<regs::Cliccfg, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "CLIC information."]
        #[inline(always)]
        pub const fn clicinfo(self) -> crate::common::Reg<regs::Clicinfo, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description collection: Interrupt control register for IRQ number \\[n\\]."]
        #[inline(always)]
        pub const fn clicint(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Clicint, crate::common::RW> {
            assert!(n < 271usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1000usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "CLIC configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cliccfg(pub u32);
        impl Cliccfg {
            #[doc = "Selective interrupt hardware vectoring."]
            #[must_use]
            #[inline(always)]
            pub const fn nvbits(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selective interrupt hardware vectoring."]
            #[inline(always)]
            pub const fn set_nvbits(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Interrupt level encoding."]
            #[must_use]
            #[inline(always)]
            pub const fn nlbits(&self) -> super::vals::Nlbits {
                let val = (self.0 >> 1usize) & 0x0f;
                super::vals::Nlbits::from_bits(val as u8)
            }
            #[doc = "Interrupt level encoding."]
            #[inline(always)]
            pub const fn set_nlbits(&mut self, val: super::vals::Nlbits) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val.to_bits() as u32) & 0x0f) << 1usize);
            }
            #[doc = "Interrupt privilege mode."]
            #[must_use]
            #[inline(always)]
            pub const fn nmbits(&self) -> super::vals::Nmbits {
                let val = (self.0 >> 5usize) & 0x03;
                super::vals::Nmbits::from_bits(val as u8)
            }
            #[doc = "Interrupt privilege mode."]
            #[inline(always)]
            pub const fn set_nmbits(&mut self, val: super::vals::Nmbits) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val.to_bits() as u32) & 0x03) << 5usize);
            }
        }
        impl Default for Cliccfg {
            #[inline(always)]
            fn default() -> Cliccfg {
                Cliccfg(0)
            }
        }
        impl core::fmt::Debug for Cliccfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cliccfg")
                    .field("nvbits", &self.nvbits())
                    .field("nlbits", &self.nlbits())
                    .field("nmbits", &self.nmbits())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cliccfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cliccfg {{ nvbits: {=bool:?}, nlbits: {:?}, nmbits: {:?} }}",
                    self.nvbits(),
                    self.nlbits(),
                    self.nmbits()
                )
            }
        }
        #[doc = "CLIC information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clicinfo(pub u32);
        impl Clicinfo {
            #[doc = "Maximum number of interrupts supported."]
            #[must_use]
            #[inline(always)]
            pub const fn numinterrupts(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of interrupts supported."]
            #[inline(always)]
            pub const fn set_numinterrupts(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
            #[doc = "Version"]
            #[must_use]
            #[inline(always)]
            pub const fn version(&self) -> u8 {
                let val = (self.0 >> 13usize) & 0xff;
                val as u8
            }
            #[doc = "Version"]
            #[inline(always)]
            pub const fn set_version(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 13usize)) | (((val as u32) & 0xff) << 13usize);
            }
            #[doc = "Number of maximum interrupt triggers supported"]
            #[must_use]
            #[inline(always)]
            pub const fn numtrigger(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x3f;
                val as u8
            }
            #[doc = "Number of maximum interrupt triggers supported"]
            #[inline(always)]
            pub const fn set_numtrigger(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 25usize)) | (((val as u32) & 0x3f) << 25usize);
            }
        }
        impl Default for Clicinfo {
            #[inline(always)]
            fn default() -> Clicinfo {
                Clicinfo(0)
            }
        }
        impl core::fmt::Debug for Clicinfo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clicinfo")
                    .field("numinterrupts", &self.numinterrupts())
                    .field("version", &self.version())
                    .field("numtrigger", &self.numtrigger())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clicinfo {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clicinfo {{ numinterrupts: {=u16:?}, version: {=u8:?}, numtrigger: {=u8:?} }}",
                    self.numinterrupts(),
                    self.version(),
                    self.numtrigger()
                )
            }
        }
        #[doc = "Description collection: Interrupt control register for IRQ number \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clicint(pub u32);
        impl Clicint {
            #[doc = "Interrupt Pending bit."]
            #[must_use]
            #[inline(always)]
            pub const fn ip(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt Pending bit."]
            #[inline(always)]
            pub const fn set_ip(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Read as 0, write ignored."]
            #[must_use]
            #[inline(always)]
            pub const fn read1(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x7f;
                val as u8
            }
            #[doc = "Read as 0, write ignored."]
            #[inline(always)]
            pub const fn set_read1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 1usize)) | (((val as u32) & 0x7f) << 1usize);
            }
            #[doc = "Interrupt enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn ie(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable bit."]
            #[inline(always)]
            pub const fn set_ie(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Read as 0, write ignored."]
            #[must_use]
            #[inline(always)]
            pub const fn read2(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x7f;
                val as u8
            }
            #[doc = "Read as 0, write ignored."]
            #[inline(always)]
            pub const fn set_read2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 9usize)) | (((val as u32) & 0x7f) << 9usize);
            }
            #[doc = "Selective Hardware Vectoring."]
            #[must_use]
            #[inline(always)]
            pub const fn shv(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selective Hardware Vectoring."]
            #[inline(always)]
            pub const fn set_shv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Trigger type and polarity for each interrupt input."]
            #[must_use]
            #[inline(always)]
            pub const fn trig(&self) -> super::vals::Trig {
                let val = (self.0 >> 17usize) & 0x03;
                super::vals::Trig::from_bits(val as u8)
            }
            #[doc = "Trigger type and polarity for each interrupt input."]
            #[inline(always)]
            pub const fn set_trig(&mut self, val: super::vals::Trig) {
                self.0 =
                    (self.0 & !(0x03 << 17usize)) | (((val.to_bits() as u32) & 0x03) << 17usize);
            }
            #[doc = "Privilege mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 22usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Privilege mode."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 =
                    (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
            }
            #[doc = "Interrupt priority level"]
            #[must_use]
            #[inline(always)]
            pub const fn priority(&self) -> super::vals::Priority {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::Priority::from_bits(val as u8)
            }
            #[doc = "Interrupt priority level"]
            #[inline(always)]
            pub const fn set_priority(&mut self, val: super::vals::Priority) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Clicint {
            #[inline(always)]
            fn default() -> Clicint {
                Clicint(0)
            }
        }
        impl core::fmt::Debug for Clicint {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clicint")
                    .field("ip", &self.ip())
                    .field("read1", &self.read1())
                    .field("ie", &self.ie())
                    .field("read2", &self.read2())
                    .field("shv", &self.shv())
                    .field("trig", &self.trig())
                    .field("mode", &self.mode())
                    .field("priority", &self.priority())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clicint {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Clicint {{ ip: {=bool:?}, read1: {=u8:?}, ie: {=bool:?}, read2: {=u8:?}, shv: {=bool:?}, trig: {:?}, mode: {:?}, priority: {:?} }}" , self . ip () , self . read1 () , self . ie () , self . read2 () , self . shv () , self . trig () , self . mode () , self . priority ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Machine mode"]
            MACHINE_MODE = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nlbits {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "8 bits = interrupt levels encoded in eight bits"]
            EIGHT = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Nlbits {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nlbits {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nlbits {
            #[inline(always)]
            fn from(val: u8) -> Nlbits {
                Nlbits::from_bits(val)
            }
        }
        impl From<Nlbits> for u8 {
            #[inline(always)]
            fn from(val: Nlbits) -> u8 {
                Nlbits::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nmbits {
            #[doc = "All interrupts are M-mode only"]
            MODE_M = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nmbits {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nmbits {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nmbits {
            #[inline(always)]
            fn from(val: u8) -> Nmbits {
                Nmbits::from_bits(val)
            }
        }
        impl From<Nmbits> for u8 {
            #[inline(always)]
            fn from(val: Nmbits) -> u8 {
                Nmbits::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Priority(u8);
        impl Priority {
            #[doc = "Priority level 0"]
            pub const PRIOLEVEL0: Self = Self(0x3f);
            #[doc = "Priority level 1"]
            pub const PRIOLEVEL1: Self = Self(0x7f);
            #[doc = "Priority level 2"]
            pub const PRIOLEVEL2: Self = Self(0xbf);
            #[doc = "Priority level 3"]
            pub const PRIOLEVEL3: Self = Self(0xff);
        }
        impl Priority {
            pub const fn from_bits(val: u8) -> Priority {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Priority {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x3f => f.write_str("PRIOLEVEL0"),
                    0x7f => f.write_str("PRIOLEVEL1"),
                    0xbf => f.write_str("PRIOLEVEL2"),
                    0xff => f.write_str("PRIOLEVEL3"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Priority {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x3f => defmt::write!(f, "PRIOLEVEL0"),
                    0x7f => defmt::write!(f, "PRIOLEVEL1"),
                    0xbf => defmt::write!(f, "PRIOLEVEL2"),
                    0xff => defmt::write!(f, "PRIOLEVEL3"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Priority {
            #[inline(always)]
            fn from(val: u8) -> Priority {
                Priority::from_bits(val)
            }
        }
        impl From<Priority> for u8 {
            #[inline(always)]
            fn from(val: Priority) -> u8 {
                Priority::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Trig {
            _RESERVED_0 = 0x0,
            #[doc = "Interrupts are edge-triggered"]
            EDGE_TRIGGERED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Trig {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Trig {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Trig {
            #[inline(always)]
            fn from(val: u8) -> Trig {
                Trig::from_bits(val)
            }
        }
        impl From<Trig> for u8 {
            #[inline(always)]
            fn from(val: Trig) -> u8 {
                Trig::to_bits(val)
            }
        }
    }
}
pub mod clock {
    #[doc = "Clock management 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clock {
        ptr: *mut u8,
    }
    unsafe impl Send for Clock {}
    unsafe impl Sync for Clock {}
    impl Clock {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Start PLL and keep it running, regardless of the automatic clock requests"]
        #[inline(always)]
        pub const fn tasks_pllstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Stop PLL"]
        #[inline(always)]
        pub const fn tasks_pllstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Start LFCLK source as selected in LFCLK.SRC"]
        #[inline(always)]
        pub const fn tasks_lfclkstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Stop LFCLK source"]
        #[inline(always)]
        pub const fn tasks_lfclkstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Start calibration of LFRC oscillator"]
        #[inline(always)]
        pub const fn tasks_cal(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Request tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotune(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Abort tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotuneabort(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Request HFXO to provide a crystal clock for PCLK24M"]
        #[inline(always)]
        pub const fn tasks_xo24mstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Stop request HFXO for PCLK24M. When all requests for HFXO are stopped, HFXO will also stop."]
        #[inline(always)]
        pub const fn tasks_xo24mstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTART"]
        #[inline(always)]
        pub const fn subscribe_xostart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTOP"]
        #[inline(always)]
        pub const fn subscribe_xostop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTART"]
        #[inline(always)]
        pub const fn subscribe_pllstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTOP"]
        #[inline(always)]
        pub const fn subscribe_pllstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTART"]
        #[inline(always)]
        pub const fn subscribe_lfclkstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTOP"]
        #[inline(always)]
        pub const fn subscribe_lfclkstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task CAL"]
        #[inline(always)]
        pub const fn subscribe_cal(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNE"]
        #[inline(always)]
        pub const fn subscribe_xotune(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNEABORT"]
        #[inline(always)]
        pub const fn subscribe_xotuneabort(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "Subscribe configuration for task XO24MSTART"]
        #[inline(always)]
        pub const fn subscribe_xo24mstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task XO24MSTOP"]
        #[inline(always)]
        pub const fn subscribe_xo24mstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "Crystal oscillator has started"]
        #[inline(always)]
        pub const fn events_xostarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "PLL started"]
        #[inline(always)]
        pub const fn events_pllstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "LFCLK source started"]
        #[inline(always)]
        pub const fn events_lfclkstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Calibration of LFRC oscillator complete event"]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "HFXO tuning is done. XOTUNED is generated after TASKS_XOSTART or after TASKS_XOTUNE has completed"]
        #[inline(always)]
        pub const fn events_xotuned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "HFXO quality issue detected, XOTUNE is needed"]
        #[inline(always)]
        pub const fn events_xotuneerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "HFXO tuning could not be completed"]
        #[inline(always)]
        pub const fn events_xotunefailed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "XO24M started"]
        #[inline(always)]
        pub const fn events_xo24mstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Publish configuration for event XOSTARTED"]
        #[inline(always)]
        pub const fn publish_xostarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event PLLSTARTED"]
        #[inline(always)]
        pub const fn publish_pllstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event LFCLKSTARTED"]
        #[inline(always)]
        pub const fn publish_lfclkstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNED"]
        #[inline(always)]
        pub const fn publish_xotuned(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEERROR"]
        #[inline(always)]
        pub const fn publish_xotuneerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEFAILED"]
        #[inline(always)]
        pub const fn publish_xotunefailed(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event XO24MSTARTED"]
        #[inline(always)]
        pub const fn publish_xo24mstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x019cusize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn xo(self) -> Xo {
            unsafe { Xo::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.wrapping_add(0x0420usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn lfclk(self) -> Lfclk {
            unsafe { Lfclk::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pll24m(self) -> Pll24m {
            unsafe { Pll24m::from_ptr(self.ptr.wrapping_add(0x0460usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lfclk {
        ptr: *mut u8,
    }
    unsafe impl Send for Lfclk {}
    unsafe impl Sync for Lfclk {}
    impl Lfclk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock source for LFCLK"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<regs::Src, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::LfclkRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::LfclkStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[inline(always)]
        pub const fn srccopy(self) -> crate::common::Reg<regs::Srccopy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::PllRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::PllStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll24m {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll24m {}
    unsafe impl Sync for Pll24m {}
    impl Pll24m {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that XO24MSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::Pll24mRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::Pll24mStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xo {
        ptr: *mut u8,
    }
    unsafe impl Send for Xo {}
    unsafe impl Sync for Xo {}
    impl Xo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::XoRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "XO status"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::XoStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn xostarted(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[inline(always)]
            pub const fn set_xostarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn pllstarted(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[inline(always)]
            pub const fn set_pllstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn lfclkstarted(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[inline(always)]
            pub const fn set_lfclkstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[must_use]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[must_use]
            #[inline(always)]
            pub const fn xotuned(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[inline(always)]
            pub const fn set_xotuned(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn xotuneerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[inline(always)]
            pub const fn set_xotuneerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[must_use]
            #[inline(always)]
            pub const fn xotunefailed(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[inline(always)]
            pub const fn set_xotunefailed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event XO24MSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn xo24mstarted(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XO24MSTARTED"]
            #[inline(always)]
            pub const fn set_xo24mstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("xostarted", &self.xostarted())
                    .field("pllstarted", &self.pllstarted())
                    .field("lfclkstarted", &self.lfclkstarted())
                    .field("done", &self.done())
                    .field("xotuned", &self.xotuned())
                    .field("xotuneerror", &self.xotuneerror())
                    .field("xotunefailed", &self.xotunefailed())
                    .field("xo24mstarted", &self.xo24mstarted())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ xostarted: {=bool:?}, pllstarted: {=bool:?}, lfclkstarted: {=bool:?}, done: {=bool:?}, xotuned: {=bool:?}, xotuneerror: {=bool:?}, xotunefailed: {=bool:?}, xo24mstarted: {=bool:?} }}" , self . xostarted () , self . pllstarted () , self . lfclkstarted () , self . done () , self . xotuned () , self . xotuneerror () , self . xotunefailed () , self . xo24mstarted ())
            }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkRun(pub u32);
        impl LfclkRun {
            #[doc = "LFCLKSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLKSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for LfclkRun {
            #[inline(always)]
            fn default() -> LfclkRun {
                LfclkRun(0)
            }
        }
        impl core::fmt::Debug for LfclkRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LfclkRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkStat(pub u32);
        impl LfclkStat {
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for LfclkStat {
            #[inline(always)]
            fn default() -> LfclkStat {
                LfclkStat(0)
            }
        }
        impl core::fmt::Debug for LfclkStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkStat")
                    .field("src", &self.src())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LfclkStat {{ src: {:?}, state: {=bool:?} }}",
                    self.src(),
                    self.state()
                )
            }
        }
        #[doc = "Indicates that XO24MSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pll24mRun(pub u32);
        impl Pll24mRun {
            #[doc = "XO24MSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "XO24MSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Pll24mRun {
            #[inline(always)]
            fn default() -> Pll24mRun {
                Pll24mRun(0)
            }
        }
        impl core::fmt::Debug for Pll24mRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pll24mRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pll24mRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pll24mRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pll24mStat(pub u32);
        impl Pll24mStat {
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Pll24mStat {
            #[inline(always)]
            fn default() -> Pll24mStat {
                Pll24mStat(0)
            }
        }
        impl core::fmt::Debug for Pll24mStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pll24mStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pll24mStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pll24mStat {{ state: {=bool:?} }}", self.state())
            }
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllRun(pub u32);
        impl PllRun {
            #[doc = "PLLSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PLLSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PllRun {
            #[inline(always)]
            fn default() -> PllRun {
                PllRun(0)
            }
        }
        impl core::fmt::Debug for PllRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PllRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllStat(pub u32);
        impl PllStat {
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PllStat {
            #[inline(always)]
            fn default() -> PllStat {
                PllStat(0)
            }
        }
        impl core::fmt::Debug for PllStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PllStat {{ state: {=bool:?} }}", self.state())
            }
        }
        #[doc = "Clock source for LFCLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src(pub u32);
        impl Src {
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Src {
            #[inline(always)]
            fn default() -> Src {
                Src(0)
            }
        }
        impl core::fmt::Debug for Src {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Src {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Srccopy(pub u32);
        impl Srccopy {
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Srccopy {
            #[inline(always)]
            fn default() -> Srccopy {
                Srccopy(0)
            }
        }
        impl core::fmt::Debug for Srccopy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Srccopy").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Srccopy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Srccopy {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoRun(pub u32);
        impl XoRun {
            #[doc = "XOSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "XOSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for XoRun {
            #[inline(always)]
            fn default() -> XoRun {
                XoRun(0)
            }
        }
        impl core::fmt::Debug for XoRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "XoRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "XO status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoStat(pub u32);
        impl XoStat {
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for XoStat {
            #[inline(always)]
            fn default() -> XoStat {
                XoStat(0)
            }
        }
        impl core::fmt::Debug for XoStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "XoStat {{ state: {=bool:?} }}", self.state())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lfclksrc {
            #[doc = "32.768 kHz RC oscillator"]
            LFRC = 0x0,
            #[doc = "32.768 kHz crystal oscillator"]
            LFXO = 0x01,
            #[doc = "32.768 kHz synthesized from HFCLK"]
            LFSYNT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lfclksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lfclksrc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lfclksrc {
            #[inline(always)]
            fn from(val: u8) -> Lfclksrc {
                Lfclksrc::from_bits(val)
            }
        }
        impl From<Lfclksrc> for u8 {
            #[inline(always)]
            fn from(val: Lfclksrc) -> u8 {
                Lfclksrc::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write(&self, f: impl FnOnce(&mut T)) {
            let mut val = Default::default();
            f(&mut val);
            self.write_value(val);
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify(&self, f: impl FnOnce(&mut T)) {
            let mut val = self.read();
            f(&mut val);
            self.write_value(val);
        }
    }
}
pub mod comp {
    #[doc = "Comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Comp {
        ptr: *mut u8,
    }
    unsafe impl Send for Comp {}
    unsafe impl Sync for Comp {}
    impl Comp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that COMP has been started by the START Task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "COMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "COMP enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[inline(always)]
        pub const fn th(self) -> crate::common::Reg<regs::Th, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "Mode configuration"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Current source select on analog input"]
        #[inline(always)]
        pub const fn isource(self) -> crate::common::Reg<regs::Isource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x053cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "COMP enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable COMP"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable COMP"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Extrefsel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis"]
            #[must_use]
            #[inline(always)]
            pub const fn hyst(&self) -> super::vals::Hyst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hyst::from_bits(val as u8)
            }
            #[doc = "Comparator hysteresis"]
            #[inline(always)]
            pub const fn set_hyst(&mut self, val: super::vals::Hyst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hyst {{ hyst: {:?} }}", self.hyst())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[must_use]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[must_use]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[must_use]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ ready: {=bool:?}, down: {=bool:?}, up: {=bool:?}, cross: {=bool:?} }}",
                    self.ready(),
                    self.down(),
                    self.up(),
                    self.cross()
                )
            }
        }
        #[doc = "Current source select on analog input"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Isource(pub u32);
        impl Isource {
            #[doc = "Current source select on analog input"]
            #[must_use]
            #[inline(always)]
            pub const fn isource(&self) -> super::vals::Isource {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Isource::from_bits(val as u8)
            }
            #[doc = "Current source select on analog input"]
            #[inline(always)]
            pub const fn set_isource(&mut self, val: super::vals::Isource) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Isource {
            #[inline(always)]
            fn default() -> Isource {
                Isource(0)
            }
        }
        impl core::fmt::Debug for Isource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Isource")
                    .field("isource", &self.isource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Isource {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Isource {{ isource: {:?} }}", self.isource())
            }
        }
        #[doc = "Mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Speed and power modes"]
            #[must_use]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Speed and power modes"]
            #[inline(always)]
            pub const fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Main operation modes"]
            #[must_use]
            #[inline(always)]
            pub const fn main(&self) -> super::vals::Main {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Main::from_bits(val as u8)
            }
            #[doc = "Main operation modes"]
            #[inline(always)]
            pub const fn set_main(&mut self, val: super::vals::Main) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("sp", &self.sp())
                    .field("main", &self.main())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ sp: {:?}, main: {:?} }}", self.sp(), self.main())
            }
        }
        #[doc = "Pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refsel {{ refsel: {:?} }}", self.refsel())
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[must_use]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Result {{ result: {:?} }}", self.result())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_sample: {=bool:?}, ready_stop: {=bool:?}, down_stop: {=bool:?}, up_stop: {=bool:?}, cross_stop: {=bool:?} }}" , self . ready_sample () , self . ready_stop () , self . down_stop () , self . up_stop () , self . cross_stop ())
            }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Th(pub u32);
        impl Th {
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[must_use]
            #[inline(always)]
            pub const fn thdown(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[inline(always)]
            pub const fn set_thdown(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[must_use]
            #[inline(always)]
            pub const fn thup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[inline(always)]
            pub const fn set_thup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for Th {
            #[inline(always)]
            fn default() -> Th {
                Th(0)
            }
        }
        impl core::fmt::Debug for Th {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Th")
                    .field("thdown", &self.thdown())
                    .field("thup", &self.thup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Th {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Th {{ thdown: {=u8:?}, thup: {=u8:?} }}",
                    self.thdown(),
                    self.thup()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hyst {
            #[doc = "Comparator hysteresis disabled"]
            NO_HYST = 0x0,
            #[doc = "Comparator hysteresis enabled"]
            HYST40M_V = 0x01,
        }
        impl Hyst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hyst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hyst {
            #[inline(always)]
            fn from(val: u8) -> Hyst {
                Hyst::from_bits(val)
            }
        }
        impl From<Hyst> for u8 {
            #[inline(always)]
            fn from(val: Hyst) -> u8 {
                Hyst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isource {
            #[doc = "Current source disabled"]
            OFF = 0x0,
            #[doc = "Current source enabled (+/- 2.5 uA)"]
            IEN2U_A5 = 0x01,
            #[doc = "Current source enabled (+/- 5 uA)"]
            IEN5U_A = 0x02,
            #[doc = "Current source enabled (+/- 10 uA)"]
            IEN10U_A = 0x03,
        }
        impl Isource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isource {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isource {
            #[inline(always)]
            fn from(val: u8) -> Isource {
                Isource::from_bits(val)
            }
        }
        impl From<Isource> for u8 {
            #[inline(always)]
            fn from(val: Isource) -> u8 {
                Isource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Main {
            #[doc = "Single-ended mode"]
            SE = 0x0,
            #[doc = "Differential mode"]
            DIFF = 0x01,
        }
        impl Main {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Main {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Main {
            #[inline(always)]
            fn from(val: u8) -> Main {
                Main::from_bits(val)
            }
        }
        impl From<Main> for u8 {
            #[inline(always)]
            fn from(val: Main) -> u8 {
                Main::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VREF = internal 1.2 V reference"]
            INT1V2 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "VREF = VDD"]
            VDD = 0x04,
            #[doc = "VREF = AREF"]
            AREF = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            #[doc = "Low-power mode"]
            LOW = 0x0,
            #[doc = "Normal mode"]
            NORMAL = 0x01,
            #[doc = "High-speed mode"]
            HIGH = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
    }
}
pub mod cracen {
    #[doc = "CRACEN"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracen {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracen {}
    unsafe impl Sync for Cracen {}
    impl Cracen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event indicating that interrupt triggered at Cryptomaster"]
        #[inline(always)]
        pub const fn events_cryptomaster(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at RNG"]
        #[inline(always)]
        pub const fn events_rng(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at PKE or IKG"]
        #[inline(always)]
        pub const fn events_pkeikg(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Enable CRACEN peripheral modules."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Indicates the SEED register is valid. Writing this register has no effect."]
        #[inline(always)]
        pub const fn seedvalid(self) -> crate::common::Reg<regs::Seedvalid, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Description collection: Seed word \\[n\\] for symmetric and asymmetric key generation. This register is only writable from KMU."]
        #[inline(always)]
        pub const fn seed(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0410usize + n * 4usize) as _)
            }
        }
        #[doc = "Indicates the access to the SEED register is locked. Writing this register has no effect."]
        #[inline(always)]
        pub const fn seedlock(self) -> crate::common::Reg<regs::Seedlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[inline(always)]
        pub const fn protectedramlock(
            self,
        ) -> crate::common::Reg<regs::Protectedramlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0444usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable CRACEN peripheral modules."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable cryptomaster"]
            #[must_use]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable cryptomaster"]
            #[inline(always)]
            pub const fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable RNG"]
            #[must_use]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RNG"]
            #[inline(always)]
            pub const fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable PKE and IKG"]
            #[must_use]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable PKE and IKG"]
            #[inline(always)]
            pub const fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Enable {{ cryptomaster: {=bool:?}, rng: {=bool:?}, pkeikg: {=bool:?} }}",
                    self.cryptomaster(),
                    self.rng(),
                    self.pkeikg()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[must_use]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[inline(always)]
            pub const fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[must_use]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[inline(always)]
            pub const fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[must_use]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[inline(always)]
            pub const fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ cryptomaster: {=bool:?}, rng: {=bool:?}, pkeikg: {=bool:?} }}",
                    self.cryptomaster(),
                    self.rng(),
                    self.pkeikg()
                )
            }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Protectedramlock(pub u32);
        impl Protectedramlock {
            #[doc = "Enable the lock"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Protectedramlock {
            #[inline(always)]
            fn default() -> Protectedramlock {
                Protectedramlock(0)
            }
        }
        impl core::fmt::Debug for Protectedramlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Protectedramlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Protectedramlock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Protectedramlock {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Indicates the access to the SEED register is locked. Writing this register has no effect."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedlock(pub u32);
        impl Seedlock {
            #[doc = "Enable the lock"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedlock {
            #[inline(always)]
            fn default() -> Seedlock {
                Seedlock(0)
            }
        }
        impl core::fmt::Debug for Seedlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedlock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Seedlock {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Indicates the SEED register is valid. Writing this register has no effect."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedvalid(pub u32);
        impl Seedvalid {
            #[doc = "Marks the SEED as valid"]
            #[must_use]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Marks the SEED as valid"]
            #[inline(always)]
            pub const fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedvalid {
            #[inline(always)]
            fn default() -> Seedvalid {
                Seedvalid(0)
            }
        }
        impl core::fmt::Debug for Seedvalid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedvalid")
                    .field("valid", &self.valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedvalid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Seedvalid {{ valid: {=bool:?} }}", self.valid())
            }
        }
    }
}
pub mod cracencore {
    #[doc = "CRACENCORE"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracencore {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracencore {}
    unsafe impl Sync for Cracencore {}
    impl Cracencore {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrdma(self) -> Cryptmstrdma {
            unsafe { Cryptmstrdma::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrhw(self) -> Cryptmstrhw {
            unsafe { Cryptmstrhw::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rngcontrol(self) -> Rngcontrol {
            unsafe { Rngcontrol::from_ptr(self.ptr.wrapping_add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pk(self) -> Pk {
            unsafe { Pk::from_ptr(self.ptr.wrapping_add(0x2000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ikg(self) -> Ikg {
            unsafe { Ikg::from_ptr(self.ptr.wrapping_add(0x3000usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrdma {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrdma {}
    unsafe impl Sync for Cryptmstrdma {}
    impl Cryptmstrdma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Fetch Address Least Significant Word"]
        #[inline(always)]
        pub const fn fetchaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Fetch Address Most Significant Word"]
        #[inline(always)]
        pub const fn fetchaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Fetch DMA Length (only used in direct mode)"]
        #[inline(always)]
        pub const fn fetchlen(self) -> crate::common::Reg<regs::Fetchlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Fetch User Tag (only used in direct mode)"]
        #[inline(always)]
        pub const fn fetchtag(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Push Address Least Significant Word"]
        #[inline(always)]
        pub const fn pushaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Push Address Most Significant Word"]
        #[inline(always)]
        pub const fn pushaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Push Length (only used in direct mode)"]
        #[inline(always)]
        pub const fn pushlen(self) -> crate::common::Reg<regs::Pushlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Interrupt Enable mask"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Interrupt Set"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Interrupt Clear"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Interrupt Status Raw"]
        #[inline(always)]
        pub const fn intstatraw(self) -> crate::common::Reg<regs::Intstatraw, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Interrupt Status"]
        #[inline(always)]
        pub const fn intstat(self) -> crate::common::Reg<regs::Intstat, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Interrupt Status Clear"]
        #[inline(always)]
        pub const fn intstatclr(self) -> crate::common::Reg<regs::Intstatclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Cryptomaster configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Start"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::CryptmstrdmaStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::CryptmstrdmaStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrhw {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrhw {}
    unsafe impl Sync for Cryptmstrhw {}
    impl Cryptmstrhw {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[inline(always)]
        pub const fn inclipshwcfg(
            self,
        ) -> crate::common::Reg<regs::Inclipshwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg1(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Generic g_CtrSize value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg2(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Generic g_Hash value"]
        #[inline(always)]
        pub const fn ba413hashhwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba413hashhwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[inline(always)]
        pub const fn ba418sha3hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba418sha3hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[inline(always)]
        pub const fn ba419sm4hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba419sm4hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[inline(always)]
        pub const fn ba424ariahwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba424ariahwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ikg {
        ptr: *mut u8,
    }
    unsafe impl Send for Ikg {}
    unsafe impl Sync for Ikg {}
    impl Ikg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start register."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::IkgStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IkgStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "InitData register."]
        #[inline(always)]
        pub const fn initdata(self) -> crate::common::Reg<regs::Initdata, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Nonce register."]
        #[inline(always)]
        pub const fn nonce(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Personalisation String register."]
        #[inline(always)]
        pub const fn personalisationstring(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Reseed Interval LSB register."]
        #[inline(always)]
        pub const fn reseedintervallsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Reseed Interval MSB register."]
        #[inline(always)]
        pub const fn reseedintervalmsb(
            self,
        ) -> crate::common::Reg<regs::Reseedintervalmsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "PKE Control register."]
        #[inline(always)]
        pub const fn pkecontrol(self) -> crate::common::Reg<regs::Pkecontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "PKE Command register."]
        #[inline(always)]
        pub const fn pkecommand(self) -> crate::common::Reg<regs::Pkecommand, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "PKE Status register."]
        #[inline(always)]
        pub const fn pkestatus(self) -> crate::common::Reg<regs::Pkestatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "SoftRst register."]
        #[inline(always)]
        pub const fn softrst(self) -> crate::common::Reg<regs::Softrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "HwConfig register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::IkgHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pk {
        ptr: *mut u8,
    }
    unsafe impl Send for Pk {}
    unsafe impl Sync for Pk {}
    impl Pk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pointers register."]
        #[inline(always)]
        pub const fn pointers(self) -> crate::common::Reg<regs::Pointers, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn command(self) -> crate::common::Reg<regs::Command, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::PkControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::PkStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Timer register."]
        #[inline(always)]
        pub const fn timer(self) -> crate::common::Reg<regs::Timer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::PkHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Operand size register."]
        #[inline(always)]
        pub const fn opsize(self) -> crate::common::Reg<regs::Opsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "ECC Error bit position register."]
        #[inline(always)]
        pub const fn eccerrorbitpos(
            self,
        ) -> crate::common::Reg<regs::Eccerrorbitpos, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize) as _) }
        }
        #[doc = "ECC Control and Status register."]
        #[inline(always)]
        pub const fn ecccontrolstatusreg(
            self,
        ) -> crate::common::Reg<regs::Ecccontrolstatusreg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
        #[doc = "Microcode Format register."]
        #[inline(always)]
        pub const fn microcodeformat(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x78usize) as _) }
        }
        #[doc = "Hardware Version register."]
        #[inline(always)]
        pub const fn hwversion(self) -> crate::common::Reg<regs::PkHwversion, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x7cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rngcontrol {
        ptr: *mut u8,
    }
    unsafe impl Send for Rngcontrol {}
    unsafe impl Sync for Rngcontrol {}
    impl Rngcontrol {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register"]
        #[inline(always)]
        pub const fn control(
            self,
        ) -> crate::common::Reg<regs::RngcontrolControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "FIFO level register."]
        #[inline(always)]
        pub const fn fifolevel(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "FIFO threshold register."]
        #[inline(always)]
        pub const fn fifothreshold(
            self,
        ) -> crate::common::Reg<regs::Fifothreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "FIFO depth register."]
        #[inline(always)]
        pub const fn fifodepth(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Key register."]
        #[inline(always)]
        pub const fn key(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
        #[doc = "Test data register."]
        #[inline(always)]
        pub const fn testdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Repetition test cut-off register."]
        #[inline(always)]
        pub const fn repeatthreshold(
            self,
        ) -> crate::common::Reg<regs::Repeatthreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Proportion test cut-off register."]
        #[inline(always)]
        pub const fn proptestcutoff(
            self,
        ) -> crate::common::Reg<regs::Proptestcutoff, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "LFSR seed register."]
        #[inline(always)]
        pub const fn lfsrseed(self) -> crate::common::Reg<regs::Lfsrseed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::RngcontrolStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Number of clock cycles in warm-up sequence."]
        #[inline(always)]
        pub const fn warmupperiod(
            self,
        ) -> crate::common::Reg<regs::Warmupperiod, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "DisableOsc register."]
        #[inline(always)]
        pub const fn disableosc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "Number of clock cycles between sampling moments."]
        #[inline(always)]
        pub const fn samplingperiod(
            self,
        ) -> crate::common::Reg<regs::Samplingperiod, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(
            self,
        ) -> crate::common::Reg<regs::RngcontrolHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x58usize) as _) }
        }
        #[doc = "Number of clock cycles in cool-down sequence."]
        #[inline(always)]
        pub const fn cooldownperiod(
            self,
        ) -> crate::common::Reg<regs::Cooldownperiod, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x5cusize) as _) }
        }
        #[doc = "AutoCorrTestCutoff register 0"]
        #[inline(always)]
        pub const fn autocorrtestcutoff0(
            self,
        ) -> crate::common::Reg<regs::Autocorrtestcutoff0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize) as _) }
        }
        #[doc = "AutoCorrTestCutoff register 1"]
        #[inline(always)]
        pub const fn autocorrtestcutoff1(
            self,
        ) -> crate::common::Reg<regs::Autocorrtestcutoff1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x64usize) as _) }
        }
        #[doc = "CorrTestCutoff register 0"]
        #[inline(always)]
        pub const fn corrtestcutoff0(
            self,
        ) -> crate::common::Reg<regs::Corrtestcutoff0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x68usize) as _) }
        }
        #[doc = "CorrTestCutoff register 1"]
        #[inline(always)]
        pub const fn corrtestcutoff1(
            self,
        ) -> crate::common::Reg<regs::Corrtestcutoff1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x6cusize) as _) }
        }
        #[doc = "Auto-correlation test failing ring(s)."]
        #[inline(always)]
        pub const fn autocorrtestfailed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x70usize) as _) }
        }
        #[doc = "Correlation test failing ring."]
        #[inline(always)]
        pub const fn corrtestfailed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x74usize) as _) }
        }
        #[doc = "Fixed to 1 for this version."]
        #[inline(always)]
        pub const fn hwversion(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x7cusize) as _) }
        }
        #[doc = "Description collection: FIFO data"]
        #[inline(always)]
        pub const fn fifo(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "AutoCorrTestCutoff register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Autocorrtestcutoff0(pub u32);
        impl Autocorrtestcutoff0 {
            #[doc = "Auto-correlation test cut-off value for delay of 0 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlyzerocutoff(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Auto-correlation test cut-off value for delay of 0 samples."]
            #[inline(always)]
            pub const fn set_dlyzerocutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Auto-correlation test cut-off value for delay of +1 sample."]
            #[must_use]
            #[inline(always)]
            pub const fn dlyonecutoff(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Auto-correlation test cut-off value for delay of +1 sample."]
            #[inline(always)]
            pub const fn set_dlyonecutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for Autocorrtestcutoff0 {
            #[inline(always)]
            fn default() -> Autocorrtestcutoff0 {
                Autocorrtestcutoff0(0)
            }
        }
        impl core::fmt::Debug for Autocorrtestcutoff0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Autocorrtestcutoff0")
                    .field("dlyzerocutoff", &self.dlyzerocutoff())
                    .field("dlyonecutoff", &self.dlyonecutoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Autocorrtestcutoff0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Autocorrtestcutoff0 {{ dlyzerocutoff: {=u8:?}, dlyonecutoff: {=u8:?} }}",
                    self.dlyzerocutoff(),
                    self.dlyonecutoff()
                )
            }
        }
        #[doc = "AutoCorrTestCutoff register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Autocorrtestcutoff1(pub u32);
        impl Autocorrtestcutoff1 {
            #[doc = "Auto-correlation test cut-off value for delay of +2 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlytwocutoff(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Auto-correlation test cut-off value for delay of +2 samples."]
            #[inline(always)]
            pub const fn set_dlytwocutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Auto-correlation test cut-off value for delay of +3 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlythreecutoff(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Auto-correlation test cut-off value for delay of +3 samples."]
            #[inline(always)]
            pub const fn set_dlythreecutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for Autocorrtestcutoff1 {
            #[inline(always)]
            fn default() -> Autocorrtestcutoff1 {
                Autocorrtestcutoff1(0)
            }
        }
        impl core::fmt::Debug for Autocorrtestcutoff1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Autocorrtestcutoff1")
                    .field("dlytwocutoff", &self.dlytwocutoff())
                    .field("dlythreecutoff", &self.dlythreecutoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Autocorrtestcutoff1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Autocorrtestcutoff1 {{ dlytwocutoff: {=u8:?}, dlythreecutoff: {=u8:?} }}",
                    self.dlytwocutoff(),
                    self.dlythreecutoff()
                )
            }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg1(pub u32);
        impl Ba411eaeshwcfg1 {
            #[doc = "Generic g_AesModesPoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmode(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_AesModesPoss value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgmode(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Generic g_CS value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgcs(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_CS value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgcs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_UseMasking value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_UseMasking value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgmasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_Keysize value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgkeysize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "Generic g_Keysize value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgkeysize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
            #[doc = "Generic g_CxSwitch value."]
            #[must_use]
            #[inline(always)]
            pub const fn contexten(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_CxSwitch value."]
            #[inline(always)]
            pub const fn set_contexten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Generic g_GlitchProtection value."]
            #[must_use]
            #[inline(always)]
            pub const fn glitchprot(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_GlitchProtection value."]
            #[inline(always)]
            pub const fn set_glitchprot(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Ba411eaeshwcfg1 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg1 {
                Ba411eaeshwcfg1(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg1")
                    .field("ba411eaeshwcfgmode", &self.ba411eaeshwcfgmode())
                    .field("ba411eaeshwcfgcs", &self.ba411eaeshwcfgcs())
                    .field("ba411eaeshwcfgmasking", &self.ba411eaeshwcfgmasking())
                    .field("ba411eaeshwcfgkeysize", &self.ba411eaeshwcfgkeysize())
                    .field("contexten", &self.contexten())
                    .field("glitchprot", &self.glitchprot())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba411eaeshwcfg1 {{ ba411eaeshwcfgmode: {=u16:?}, ba411eaeshwcfgcs: {=bool:?}, ba411eaeshwcfgmasking: {=bool:?}, ba411eaeshwcfgkeysize: {=u8:?}, contexten: {=bool:?}, glitchprot: {=bool:?} }}" , self . ba411eaeshwcfgmode () , self . ba411eaeshwcfgcs () , self . ba411eaeshwcfgmasking () , self . ba411eaeshwcfgkeysize () , self . contexten () , self . glitchprot ())
            }
        }
        #[doc = "Generic g_CtrSize value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg2(pub u32);
        impl Ba411eaeshwcfg2 {
            #[doc = "Generic g_CtrSize value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfg2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Generic g_CtrSize value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfg2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Generic g_Ext_nb_AES_keys value."]
            #[must_use]
            #[inline(always)]
            pub const fn nbextaeskeys(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_Ext_nb_AES_keys value."]
            #[inline(always)]
            pub const fn set_nbextaeskeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Generic g_IKG_nb_AES_keys value."]
            #[must_use]
            #[inline(always)]
            pub const fn nbikgaeskeys(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_IKG_nb_AES_keys value."]
            #[inline(always)]
            pub const fn set_nbikgaeskeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Ba411eaeshwcfg2 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg2 {
                Ba411eaeshwcfg2(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg2")
                    .field("ba411eaeshwcfg2", &self.ba411eaeshwcfg2())
                    .field("nbextaeskeys", &self.nbextaeskeys())
                    .field("nbikgaeskeys", &self.nbikgaeskeys())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba411eaeshwcfg2 {{ ba411eaeshwcfg2: {=u16:?}, nbextaeskeys: {=u8:?}, nbikgaeskeys: {=u8:?} }}" , self . ba411eaeshwcfg2 () , self . nbextaeskeys () , self . nbikgaeskeys ())
            }
        }
        #[doc = "Generic g_Hash value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba413hashhwcfg(pub u32);
        impl Ba413hashhwcfg {
            #[doc = "Generic g_HashMaskFunc value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgmask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Generic g_HashMaskFunc value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgmask(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Generic g_HashPadding value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgpadding(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashPadding value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfghmac(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfghmac(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgverifydigest(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgverifydigest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Generic g_Ext_nb_Hash_keys value."]
            #[must_use]
            #[inline(always)]
            pub const fn nbexthashkeys(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_Ext_nb_Hash_keys value."]
            #[inline(always)]
            pub const fn set_nbexthashkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Generic g_IKG_nb_Hash_keys value."]
            #[must_use]
            #[inline(always)]
            pub const fn nbikghashkeys(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_IKG_nb_Hash_keys value."]
            #[inline(always)]
            pub const fn set_nbikghashkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Ba413hashhwcfg {
            #[inline(always)]
            fn default() -> Ba413hashhwcfg {
                Ba413hashhwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba413hashhwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba413hashhwcfg")
                    .field("ba413hashhwcfgmask", &self.ba413hashhwcfgmask())
                    .field("ba413hashhwcfgpadding", &self.ba413hashhwcfgpadding())
                    .field("ba413hashhwcfghmac", &self.ba413hashhwcfghmac())
                    .field(
                        "ba413hashhwcfgverifydigest",
                        &self.ba413hashhwcfgverifydigest(),
                    )
                    .field("nbexthashkeys", &self.nbexthashkeys())
                    .field("nbikghashkeys", &self.nbikghashkeys())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba413hashhwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba413hashhwcfg {{ ba413hashhwcfgmask: {=u8:?}, ba413hashhwcfgpadding: {=bool:?}, ba413hashhwcfghmac: {=bool:?}, ba413hashhwcfgverifydigest: {=bool:?}, nbexthashkeys: {=u8:?}, nbikghashkeys: {=u8:?} }}" , self . ba413hashhwcfgmask () , self . ba413hashhwcfgpadding () , self . ba413hashhwcfghmac () , self . ba413hashhwcfgverifydigest () , self . nbexthashkeys () , self . nbikghashkeys ())
            }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba418sha3hwcfg(pub u32);
        impl Ba418sha3hwcfg {
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba418sha3hwcfg(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[inline(always)]
            pub const fn set_ba418sha3hwcfg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "HMAC enabled."]
            #[must_use]
            #[inline(always)]
            pub const fn hmac(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "HMAC enabled."]
            #[inline(always)]
            pub const fn set_hmac(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Support to digest verification."]
            #[must_use]
            #[inline(always)]
            pub const fn verifydigest(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Support to digest verification."]
            #[inline(always)]
            pub const fn set_verifydigest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Number of SHA3 HW keys."]
            #[must_use]
            #[inline(always)]
            pub const fn nbexthashkeys(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of SHA3 HW keys."]
            #[inline(always)]
            pub const fn set_nbexthashkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Number of SHA3 IKG keys."]
            #[must_use]
            #[inline(always)]
            pub const fn nbikghashkeys(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of SHA3 IKG keys."]
            #[inline(always)]
            pub const fn set_nbikghashkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Ba418sha3hwcfg {
            #[inline(always)]
            fn default() -> Ba418sha3hwcfg {
                Ba418sha3hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba418sha3hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba418sha3hwcfg")
                    .field("ba418sha3hwcfg", &self.ba418sha3hwcfg())
                    .field("hmac", &self.hmac())
                    .field("verifydigest", &self.verifydigest())
                    .field("nbexthashkeys", &self.nbexthashkeys())
                    .field("nbikghashkeys", &self.nbikghashkeys())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba418sha3hwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba418sha3hwcfg {{ ba418sha3hwcfg: {=bool:?}, hmac: {=bool:?}, verifydigest: {=bool:?}, nbexthashkeys: {=u8:?}, nbikghashkeys: {=u8:?} }}" , self . ba418sha3hwcfg () , self . hmac () , self . verifydigest () , self . nbexthashkeys () , self . nbikghashkeys ())
            }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba419sm4hwcfg(pub u32);
        impl Ba419sm4hwcfg {
            #[doc = "Generic g_SM4ModesPoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba419sm4hwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_SM4ModesPoss value."]
            #[inline(always)]
            pub const fn set_ba419sm4hwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[must_use]
            #[inline(always)]
            pub const fn usemasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[inline(always)]
            pub const fn set_usemasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Ba419sm4hwcfg {
            #[inline(always)]
            fn default() -> Ba419sm4hwcfg {
                Ba419sm4hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba419sm4hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba419sm4hwcfg")
                    .field("ba419sm4hwcfg", &self.ba419sm4hwcfg())
                    .field("usemasking", &self.usemasking())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba419sm4hwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba419sm4hwcfg {{ ba419sm4hwcfg: {=u16:?}, usemasking: {=bool:?} }}",
                    self.ba419sm4hwcfg(),
                    self.usemasking()
                )
            }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba424ariahwcfg(pub u32);
        impl Ba424ariahwcfg {
            #[doc = "Generic g_aria_modePoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba424ariahwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_aria_modePoss value."]
            #[inline(always)]
            pub const fn set_ba424ariahwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ba424ariahwcfg {
            #[inline(always)]
            fn default() -> Ba424ariahwcfg {
                Ba424ariahwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba424ariahwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba424ariahwcfg")
                    .field("ba424ariahwcfg", &self.ba424ariahwcfg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba424ariahwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba424ariahwcfg {{ ba424ariahwcfg: {=u16:?} }}",
                    self.ba424ariahwcfg()
                )
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Command(pub u32);
        impl Command {
            #[doc = "This field defines the operation to be performed."]
            #[must_use]
            #[inline(always)]
            pub const fn opeaddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "This field defines the operation to be performed."]
            #[inline(always)]
            pub const fn set_opeaddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldf(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[inline(always)]
            pub const fn set_fieldf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[must_use]
            #[inline(always)]
            pub const fn opbytesm1(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x03ff;
                val as u16
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[inline(always)]
            pub const fn set_opbytesm1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 8usize)) | (((val as u32) & 0x03ff) << 8usize);
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randmod(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[inline(always)]
            pub const fn set_randmod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[must_use]
            #[inline(always)]
            pub const fn selcurve(&self) -> super::vals::Selcurve {
                let val = (self.0 >> 20usize) & 0x07;
                super::vals::Selcurve::from_bits(val as u8)
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[inline(always)]
            pub const fn set_selcurve(&mut self, val: super::vals::Selcurve) {
                self.0 =
                    (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randke(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[inline(always)]
            pub const fn set_randke(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randproj(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[inline(always)]
            pub const fn set_randproj(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable Edwards curve."]
            #[must_use]
            #[inline(always)]
            pub const fn edwards(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Edwards curve."]
            #[inline(always)]
            pub const fn set_edwards(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[must_use]
            #[inline(always)]
            pub const fn swapbytes(&self) -> super::vals::Swapbytes {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Swapbytes::from_bits(val as u8)
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[inline(always)]
            pub const fn set_swapbytes(&mut self, val: super::vals::Swapbytes) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Flag A."]
            #[must_use]
            #[inline(always)]
            pub const fn flaga(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Flag A."]
            #[inline(always)]
            pub const fn set_flaga(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Flag B."]
            #[must_use]
            #[inline(always)]
            pub const fn flagb(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Flag B."]
            #[inline(always)]
            pub const fn set_flagb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[must_use]
            #[inline(always)]
            pub const fn calcr2(&self) -> super::vals::Calcr2 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Calcr2::from_bits(val as u8)
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[inline(always)]
            pub const fn set_calcr2(&mut self, val: super::vals::Calcr2) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Command {
            #[inline(always)]
            fn default() -> Command {
                Command(0)
            }
        }
        impl core::fmt::Debug for Command {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Command")
                    .field("opeaddr", &self.opeaddr())
                    .field("fieldf", &self.fieldf())
                    .field("opbytesm1", &self.opbytesm1())
                    .field("randmod", &self.randmod())
                    .field("selcurve", &self.selcurve())
                    .field("randke", &self.randke())
                    .field("randproj", &self.randproj())
                    .field("edwards", &self.edwards())
                    .field("swapbytes", &self.swapbytes())
                    .field("flaga", &self.flaga())
                    .field("flagb", &self.flagb())
                    .field("calcr2", &self.calcr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Command {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Command {{ opeaddr: {=u8:?}, fieldf: {=bool:?}, opbytesm1: {=u16:?}, randmod: {=bool:?}, selcurve: {:?}, randke: {=bool:?}, randproj: {=bool:?}, edwards: {=bool:?}, swapbytes: {:?}, flaga: {=bool:?}, flagb: {=bool:?}, calcr2: {:?} }}" , self . opeaddr () , self . fieldf () , self . opbytesm1 () , self . randmod () , self . selcurve () , self . randke () , self . randproj () , self . edwards () , self . swapbytes () , self . flaga () , self . flagb () , self . calcr2 ())
            }
        }
        #[doc = "Cryptomaster configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Fetcher scatter/gather."]
            #[must_use]
            #[inline(always)]
            pub const fn fetchctrlindirect(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher scatter/gather."]
            #[inline(always)]
            pub const fn set_fetchctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Pusher scatter/gather."]
            #[must_use]
            #[inline(always)]
            pub const fn pushctrlindirect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher scatter/gather."]
            #[inline(always)]
            pub const fn set_pushctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Stop fetcher."]
            #[must_use]
            #[inline(always)]
            pub const fn fetchstop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Stop fetcher."]
            #[inline(always)]
            pub const fn set_fetchstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Stop pusher DMA."]
            #[must_use]
            #[inline(always)]
            pub const fn pushstop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Stop pusher DMA."]
            #[inline(always)]
            pub const fn set_pushstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Soft reset the cryptomaster."]
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset the cryptomaster."]
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("fetchctrlindirect", &self.fetchctrlindirect())
                    .field("pushctrlindirect", &self.pushctrlindirect())
                    .field("fetchstop", &self.fetchstop())
                    .field("pushstop", &self.pushstop())
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ fetchctrlindirect: {=bool:?}, pushctrlindirect: {=bool:?}, fetchstop: {=bool:?}, pushstop: {=bool:?}, softrst: {=bool:?} }}" , self . fetchctrlindirect () , self . pushctrlindirect () , self . fetchstop () , self . pushstop () , self . softrst ())
            }
        }
        #[doc = "Number of clock cycles in cool-down sequence."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cooldownperiod(pub u32);
        impl Cooldownperiod {
            #[doc = "Number of clock cycles in cool-down sequence."]
            #[must_use]
            #[inline(always)]
            pub const fn cooldownperiod(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Number of clock cycles in cool-down sequence."]
            #[inline(always)]
            pub const fn set_cooldownperiod(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Cooldownperiod {
            #[inline(always)]
            fn default() -> Cooldownperiod {
                Cooldownperiod(0)
            }
        }
        impl core::fmt::Debug for Cooldownperiod {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cooldownperiod")
                    .field("cooldownperiod", &self.cooldownperiod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cooldownperiod {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cooldownperiod {{ cooldownperiod: {=u16:?} }}",
                    self.cooldownperiod()
                )
            }
        }
        #[doc = "CorrTestCutoff register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Corrtestcutoff0(pub u32);
        impl Corrtestcutoff0 {
            #[doc = "Correlation test cut-off value for delay of 0 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlyzerocutoff(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Correlation test cut-off value for delay of 0 samples."]
            #[inline(always)]
            pub const fn set_dlyzerocutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Correlation test cut-off value for delay of +/-1 sample."]
            #[must_use]
            #[inline(always)]
            pub const fn dlyonecutoff(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Correlation test cut-off value for delay of +/-1 sample."]
            #[inline(always)]
            pub const fn set_dlyonecutoff(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for Corrtestcutoff0 {
            #[inline(always)]
            fn default() -> Corrtestcutoff0 {
                Corrtestcutoff0(0)
            }
        }
        impl core::fmt::Debug for Corrtestcutoff0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Corrtestcutoff0")
                    .field("dlyzerocutoff", &self.dlyzerocutoff())
                    .field("dlyonecutoff", &self.dlyonecutoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Corrtestcutoff0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Corrtestcutoff0 {{ dlyzerocutoff: {=u8:?}, dlyonecutoff: {=u8:?} }}",
                    self.dlyzerocutoff(),
                    self.dlyonecutoff()
                )
            }
        }
        #[doc = "CorrTestCutoff register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Corrtestcutoff1(pub u32);
        impl Corrtestcutoff1 {
            #[doc = "Correlation test cut-off value for delay of +/- 2 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlytwocutoff(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Correlation test cut-off value for delay of +/- 2 samples."]
            #[inline(always)]
            pub const fn set_dlytwocutoff(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Correlation test cut-off value for delay of +/- 3 samples."]
            #[must_use]
            #[inline(always)]
            pub const fn dlythreecutoff(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Correlation test cut-off value for delay of +/- 3 samples."]
            #[inline(always)]
            pub const fn set_dlythreecutoff(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Corrtestcutoff1 {
            #[inline(always)]
            fn default() -> Corrtestcutoff1 {
                Corrtestcutoff1(0)
            }
        }
        impl core::fmt::Debug for Corrtestcutoff1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Corrtestcutoff1")
                    .field("dlytwocutoff", &self.dlytwocutoff())
                    .field("dlythreecutoff", &self.dlythreecutoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Corrtestcutoff1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Corrtestcutoff1 {{ dlytwocutoff: {=u16:?}, dlythreecutoff: {=u16:?} }}",
                    self.dlytwocutoff(),
                    self.dlythreecutoff()
                )
            }
        }
        #[doc = "Start"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStart(pub u32);
        impl CryptmstrdmaStart {
            #[doc = "Writing a '1' starts the fetcher DMA. Writing a '0' has no effect."]
            #[must_use]
            #[inline(always)]
            pub const fn startfetch(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a '1' starts the fetcher DMA. Writing a '0' has no effect."]
            #[inline(always)]
            pub const fn set_startfetch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a '1' starts the pusher DMA. Writing a '0' has no effect."]
            #[must_use]
            #[inline(always)]
            pub const fn startpush(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a '1' starts the pusher DMA. Writing a '0' has no effect."]
            #[inline(always)]
            pub const fn set_startpush(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CryptmstrdmaStart {
            #[inline(always)]
            fn default() -> CryptmstrdmaStart {
                CryptmstrdmaStart(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStart")
                    .field("startfetch", &self.startfetch())
                    .field("startpush", &self.startpush())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CryptmstrdmaStart {{ startfetch: {=bool:?}, startpush: {=bool:?} }}",
                    self.startfetch(),
                    self.startpush()
                )
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStatus(pub u32);
        impl CryptmstrdmaStatus {
            #[doc = "This bit is high as long as the fetcher DMA is busy."]
            #[must_use]
            #[inline(always)]
            pub const fn fetchbusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is high as long as the fetcher DMA is busy."]
            #[inline(always)]
            pub const fn set_fetchbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit is high as long as the pusher DMA is busy."]
            #[must_use]
            #[inline(always)]
            pub const fn pushbusy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is high as long as the pusher DMA is busy."]
            #[inline(always)]
            pub const fn set_pushbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Not empty flag for fetcher DMA input FIFO"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchnotempty(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Not empty flag for fetcher DMA input FIFO"]
            #[inline(always)]
            pub const fn set_fetchnotempty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Pusher DMA Waiting FIFO. This bit is high when the pusher is waiting for more data in output FIFO."]
            #[must_use]
            #[inline(always)]
            pub const fn pushwaitingfifo(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA Waiting FIFO. This bit is high when the pusher is waiting for more data in output FIFO."]
            #[inline(always)]
            pub const fn set_pushwaitingfifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "This bit is high when the soft reset is on going"]
            #[must_use]
            #[inline(always)]
            pub const fn softrstbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "This bit is high when the soft reset is on going"]
            #[inline(always)]
            pub const fn set_softrstbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Amount of data in the pusher DMA output FIFO"]
            #[must_use]
            #[inline(always)]
            pub const fn pushnbdata(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Amount of data in the pusher DMA output FIFO"]
            #[inline(always)]
            pub const fn set_pushnbdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CryptmstrdmaStatus {
            #[inline(always)]
            fn default() -> CryptmstrdmaStatus {
                CryptmstrdmaStatus(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStatus")
                    .field("fetchbusy", &self.fetchbusy())
                    .field("pushbusy", &self.pushbusy())
                    .field("fetchnotempty", &self.fetchnotempty())
                    .field("pushwaitingfifo", &self.pushwaitingfifo())
                    .field("softrstbusy", &self.softrstbusy())
                    .field("pushnbdata", &self.pushnbdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CryptmstrdmaStatus {{ fetchbusy: {=bool:?}, pushbusy: {=bool:?}, fetchnotempty: {=bool:?}, pushwaitingfifo: {=bool:?}, softrstbusy: {=bool:?}, pushnbdata: {=u16:?} }}" , self . fetchbusy () , self . pushbusy () , self . fetchnotempty () , self . pushwaitingfifo () , self . softrstbusy () , self . pushnbdata ())
            }
        }
        #[doc = "ECC Control and Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ecccontrolstatusreg(pub u32);
        impl Ecccontrolstatusreg {
            #[doc = "Data Memory Correction flag, clear on write"]
            #[must_use]
            #[inline(always)]
            pub const fn datamemcorrection(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Data Memory Correction flag, clear on write"]
            #[inline(always)]
            pub const fn set_datamemcorrection(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Data Memory Failure flag, clear on write"]
            #[must_use]
            #[inline(always)]
            pub const fn datamemfailure(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Data Memory Failure flag, clear on write"]
            #[inline(always)]
            pub const fn set_datamemfailure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Code Memory Correction flag, clear on write"]
            #[must_use]
            #[inline(always)]
            pub const fn codememcorrection(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Code Memory Correction flag, clear on write"]
            #[inline(always)]
            pub const fn set_codememcorrection(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Code Memory Failure flag, clear on write"]
            #[must_use]
            #[inline(always)]
            pub const fn codememfailure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Code Memory Failure flag, clear on write"]
            #[inline(always)]
            pub const fn set_codememfailure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Ecccontrolstatusreg {
            #[inline(always)]
            fn default() -> Ecccontrolstatusreg {
                Ecccontrolstatusreg(0)
            }
        }
        impl core::fmt::Debug for Ecccontrolstatusreg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ecccontrolstatusreg")
                    .field("datamemcorrection", &self.datamemcorrection())
                    .field("datamemfailure", &self.datamemfailure())
                    .field("codememcorrection", &self.codememcorrection())
                    .field("codememfailure", &self.codememfailure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ecccontrolstatusreg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ecccontrolstatusreg {{ datamemcorrection: {=bool:?}, datamemfailure: {=bool:?}, codememcorrection: {=bool:?}, codememfailure: {=bool:?} }}" , self . datamemcorrection () , self . datamemfailure () , self . codememcorrection () , self . codememfailure ())
            }
        }
        #[doc = "ECC Error bit position register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eccerrorbitpos(pub u32);
        impl Eccerrorbitpos {
            #[doc = "Position of error bit 1"]
            #[must_use]
            #[inline(always)]
            pub const fn errorbitpos1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Position of error bit 1"]
            #[inline(always)]
            pub const fn set_errorbitpos1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Position of error bit 2"]
            #[must_use]
            #[inline(always)]
            pub const fn errorbitpos2(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Position of error bit 2"]
            #[inline(always)]
            pub const fn set_errorbitpos2(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Eccerrorbitpos {
            #[inline(always)]
            fn default() -> Eccerrorbitpos {
                Eccerrorbitpos(0)
            }
        }
        impl core::fmt::Debug for Eccerrorbitpos {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eccerrorbitpos")
                    .field("errorbitpos1", &self.errorbitpos1())
                    .field("errorbitpos2", &self.errorbitpos2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eccerrorbitpos {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Eccerrorbitpos {{ errorbitpos1: {=u16:?}, errorbitpos2: {=u16:?} }}",
                    self.errorbitpos1(),
                    self.errorbitpos2()
                )
            }
        }
        #[doc = "Fetch DMA Length (only used in direct mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fetchlen(pub u32);
        impl Fetchlen {
            #[doc = "Length of data block"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "Length of data block"]
            #[inline(always)]
            pub const fn set_fetchlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[doc = "Constant address"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Constant address"]
            #[inline(always)]
            pub const fn set_fetchcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Realign length"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Realign length"]
            #[inline(always)]
            pub const fn set_fetchrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchzpadding(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchzpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Fetchlen {
            #[inline(always)]
            fn default() -> Fetchlen {
                Fetchlen(0)
            }
        }
        impl core::fmt::Debug for Fetchlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fetchlen")
                    .field("fetchlen", &self.fetchlen())
                    .field("fetchcstaddr", &self.fetchcstaddr())
                    .field("fetchrealign", &self.fetchrealign())
                    .field("fetchzpadding", &self.fetchzpadding())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fetchlen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fetchlen {{ fetchlen: {=u32:?}, fetchcstaddr: {=bool:?}, fetchrealign: {=bool:?}, fetchzpadding: {=bool:?} }}" , self . fetchlen () , self . fetchcstaddr () , self . fetchrealign () , self . fetchzpadding ())
            }
        }
        #[doc = "FIFO threshold register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fifothreshold(pub u32);
        impl Fifothreshold {
            #[doc = "FIFO level threshold below which the module leaves the idle state to refill the FIFO. Expressed in number of 128bit blocks."]
            #[must_use]
            #[inline(always)]
            pub const fn fifothreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "FIFO level threshold below which the module leaves the idle state to refill the FIFO. Expressed in number of 128bit blocks."]
            #[inline(always)]
            pub const fn set_fifothreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Fifothreshold {
            #[inline(always)]
            fn default() -> Fifothreshold {
                Fifothreshold(0)
            }
        }
        impl core::fmt::Debug for Fifothreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fifothreshold")
                    .field("fifothreshold", &self.fifothreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fifothreshold {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fifothreshold {{ fifothreshold: {=u8:?} }}",
                    self.fifothreshold()
                )
            }
        }
        #[doc = "HwConfig register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgHwconfig(pub u32);
        impl IkgHwconfig {
            #[doc = "Number of Symmetric Keys generated."]
            #[must_use]
            #[inline(always)]
            pub const fn nbsymkeys(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Symmetric Keys generated."]
            #[inline(always)]
            pub const fn set_nbsymkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Number of Private Keys generated."]
            #[must_use]
            #[inline(always)]
            pub const fn nbprivkeys(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Private Keys generated."]
            #[inline(always)]
            pub const fn set_nbprivkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn ikgcm(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[inline(always)]
            pub const fn set_ikgcm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn hwhealthtest(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[inline(always)]
            pub const fn set_hwhealthtest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "ECC curve for IKG (input)."]
            #[must_use]
            #[inline(always)]
            pub const fn curve(&self) -> super::vals::Curve {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Curve::from_bits(val as u8)
            }
            #[doc = "ECC curve for IKG (input)."]
            #[inline(always)]
            pub const fn set_curve(&mut self, val: super::vals::Curve) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn df(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[inline(always)]
            pub const fn set_df(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[must_use]
            #[inline(always)]
            pub const fn keysize(&self) -> super::vals::Keysize {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Keysize::from_bits(val as u8)
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[inline(always)]
            pub const fn set_keysize(&mut self, val: super::vals::Keysize) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn entropyinputlength(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[inline(always)]
            pub const fn set_entropyinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Value of g_nonce_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn noncelength(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_nonce_length/32."]
            #[inline(always)]
            pub const fn set_noncelength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn personalizationstringlength(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[inline(always)]
            pub const fn set_personalizationstringlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn additionalinputlength(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[inline(always)]
            pub const fn set_additionalinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for IkgHwconfig {
            #[inline(always)]
            fn default() -> IkgHwconfig {
                IkgHwconfig(0)
            }
        }
        impl core::fmt::Debug for IkgHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgHwconfig")
                    .field("nbsymkeys", &self.nbsymkeys())
                    .field("nbprivkeys", &self.nbprivkeys())
                    .field("ikgcm", &self.ikgcm())
                    .field("hwhealthtest", &self.hwhealthtest())
                    .field("curve", &self.curve())
                    .field("df", &self.df())
                    .field("keysize", &self.keysize())
                    .field("entropyinputlength", &self.entropyinputlength())
                    .field("noncelength", &self.noncelength())
                    .field(
                        "personalizationstringlength",
                        &self.personalizationstringlength(),
                    )
                    .field("additionalinputlength", &self.additionalinputlength())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IkgHwconfig {{ nbsymkeys: {=u8:?}, nbprivkeys: {=u8:?}, ikgcm: {=bool:?}, hwhealthtest: {=bool:?}, curve: {:?}, df: {=bool:?}, keysize: {:?}, entropyinputlength: {=u8:?}, noncelength: {=u8:?}, personalizationstringlength: {=u8:?}, additionalinputlength: {=u8:?} }}" , self . nbsymkeys () , self . nbprivkeys () , self . ikgcm () , self . hwhealthtest () , self . curve () , self . df () , self . keysize () , self . entropyinputlength () , self . noncelength () , self . personalizationstringlength () , self . additionalinputlength ())
            }
        }
        #[doc = "Start register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStart(pub u32);
        impl IkgStart {
            #[doc = "Start the Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IkgStart {
            #[inline(always)]
            fn default() -> IkgStart {
                IkgStart(0)
            }
        }
        impl core::fmt::Debug for IkgStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStart")
                    .field("start", &self.start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IkgStart {{ start: {=bool:?} }}", self.start())
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStatus(pub u32);
        impl IkgStatus {
            #[doc = "Seed Error during Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn seederror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Seed Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_seederror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn entropyerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_entropyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Isolated Key Generation is okay."]
            #[must_use]
            #[inline(always)]
            pub const fn okay(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Isolated Key Generation is okay."]
            #[inline(always)]
            pub const fn set_okay(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[must_use]
            #[inline(always)]
            pub const fn ctrdrbgbusy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn set_ctrdrbgbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[must_use]
            #[inline(always)]
            pub const fn catastrophicerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn set_catastrophicerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Symmetric Keys are stored."]
            #[must_use]
            #[inline(always)]
            pub const fn symkeystored(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Symmetric Keys are stored."]
            #[inline(always)]
            pub const fn set_symkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Private Keys are stored."]
            #[must_use]
            #[inline(always)]
            pub const fn privkeystored(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Private Keys are stored."]
            #[inline(always)]
            pub const fn set_privkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for IkgStatus {
            #[inline(always)]
            fn default() -> IkgStatus {
                IkgStatus(0)
            }
        }
        impl core::fmt::Debug for IkgStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStatus")
                    .field("seederror", &self.seederror())
                    .field("entropyerror", &self.entropyerror())
                    .field("okay", &self.okay())
                    .field("ctrdrbgbusy", &self.ctrdrbgbusy())
                    .field("catastrophicerror", &self.catastrophicerror())
                    .field("symkeystored", &self.symkeystored())
                    .field("privkeystored", &self.privkeystored())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IkgStatus {{ seederror: {=bool:?}, entropyerror: {=bool:?}, okay: {=bool:?}, ctrdrbgbusy: {=bool:?}, catastrophicerror: {=bool:?}, symkeystored: {=bool:?}, privkeystored: {=bool:?} }}" , self . seederror () , self . entropyerror () , self . okay () , self . ctrdrbgbusy () , self . catastrophicerror () , self . symkeystored () , self . privkeystored ())
            }
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inclipshwcfg(pub u32);
        impl Inclipshwcfg {
            #[doc = "Generic g_IncludeAES value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411aesincluded(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAES value."]
            #[inline(always)]
            pub const fn set_ba411aesincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba415hpaesgcmincluded(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[inline(always)]
            pub const fn set_ba415hpaesgcmincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba416hpaesxtsincluded(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[inline(always)]
            pub const fn set_ba416hpaesxtsincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Generic g_IncludeDES value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba412desincluded(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeDES value."]
            #[inline(always)]
            pub const fn set_ba412desincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashincluded(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[inline(always)]
            pub const fn set_ba413hashincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba417chachapolyincluded(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[inline(always)]
            pub const fn set_ba417chachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba418sha3included(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[inline(always)]
            pub const fn set_ba418sha3included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba421zucincluded(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[inline(always)]
            pub const fn set_ba421zucincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba419sm4included(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[inline(always)]
            pub const fn set_ba419sm4included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Generic g_IncludePKE value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba414eppkeincluded(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludePKE value."]
            #[inline(always)]
            pub const fn set_ba414eppkeincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba431ndrngincluded(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[inline(always)]
            pub const fn set_ba431ndrngincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba420hpchachapolyincluded(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[inline(always)]
            pub const fn set_ba420hpchachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba423snow3gincluded(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[inline(always)]
            pub const fn set_ba423snow3gincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba422kasumiincluded(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[inline(always)]
            pub const fn set_ba422kasumiincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Generic g_IncludeAria value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba422ariaincluded(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAria value."]
            #[inline(always)]
            pub const fn set_ba422ariaincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Inclipshwcfg {
            #[inline(always)]
            fn default() -> Inclipshwcfg {
                Inclipshwcfg(0)
            }
        }
        impl core::fmt::Debug for Inclipshwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inclipshwcfg")
                    .field("ba411aesincluded", &self.ba411aesincluded())
                    .field("ba415hpaesgcmincluded", &self.ba415hpaesgcmincluded())
                    .field("ba416hpaesxtsincluded", &self.ba416hpaesxtsincluded())
                    .field("ba412desincluded", &self.ba412desincluded())
                    .field("ba413hashincluded", &self.ba413hashincluded())
                    .field("ba417chachapolyincluded", &self.ba417chachapolyincluded())
                    .field("ba418sha3included", &self.ba418sha3included())
                    .field("ba421zucincluded", &self.ba421zucincluded())
                    .field("ba419sm4included", &self.ba419sm4included())
                    .field("ba414eppkeincluded", &self.ba414eppkeincluded())
                    .field("ba431ndrngincluded", &self.ba431ndrngincluded())
                    .field(
                        "ba420hpchachapolyincluded",
                        &self.ba420hpchachapolyincluded(),
                    )
                    .field("ba423snow3gincluded", &self.ba423snow3gincluded())
                    .field("ba422kasumiincluded", &self.ba422kasumiincluded())
                    .field("ba422ariaincluded", &self.ba422ariaincluded())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inclipshwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Inclipshwcfg {{ ba411aesincluded: {=bool:?}, ba415hpaesgcmincluded: {=bool:?}, ba416hpaesxtsincluded: {=bool:?}, ba412desincluded: {=bool:?}, ba413hashincluded: {=bool:?}, ba417chachapolyincluded: {=bool:?}, ba418sha3included: {=bool:?}, ba421zucincluded: {=bool:?}, ba419sm4included: {=bool:?}, ba414eppkeincluded: {=bool:?}, ba431ndrngincluded: {=bool:?}, ba420hpchachapolyincluded: {=bool:?}, ba423snow3gincluded: {=bool:?}, ba422kasumiincluded: {=bool:?}, ba422ariaincluded: {=bool:?} }}" , self . ba411aesincluded () , self . ba415hpaesgcmincluded () , self . ba416hpaesxtsincluded () , self . ba412desincluded () , self . ba413hashincluded () , self . ba417chachapolyincluded () , self . ba418sha3included () , self . ba421zucincluded () , self . ba419sm4included () , self . ba414eppkeincluded () , self . ba431ndrngincluded () , self . ba420hpchachapolyincluded () , self . ba423snow3gincluded () , self . ba422kasumiincluded () , self . ba422ariaincluded ())
            }
        }
        #[doc = "InitData register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Initdata(pub u32);
        impl Initdata {
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[must_use]
            #[inline(always)]
            pub const fn initdata(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[inline(always)]
            pub const fn set_initdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Initdata {
            #[inline(always)]
            fn default() -> Initdata {
                Initdata(0)
            }
        }
        impl core::fmt::Debug for Initdata {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Initdata")
                    .field("initdata", &self.initdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Initdata {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Initdata {{ initdata: {=bool:?} }}", self.initdata())
            }
        }
        #[doc = "Interrupt Enable mask"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherblockend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_fetcherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherstopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_fetcherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchererror(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[inline(always)]
            pub const fn set_fetchererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherblockend(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_pusherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherstopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_pusherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bus error during pusher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn pushererror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during pusher DMA access"]
            #[inline(always)]
            pub const fn set_pushererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("fetcherblockend", &self.fetcherblockend())
                    .field("fetcherstopped", &self.fetcherstopped())
                    .field("fetchererror", &self.fetchererror())
                    .field("pusherblockend", &self.pusherblockend())
                    .field("pusherstopped", &self.pusherstopped())
                    .field("pushererror", &self.pushererror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ fetcherblockend: {=bool:?}, fetcherstopped: {=bool:?}, fetchererror: {=bool:?}, pusherblockend: {=bool:?}, pusherstopped: {=bool:?}, pushererror: {=bool:?} }}" , self . fetcherblockend () , self . fetcherstopped () , self . fetchererror () , self . pusherblockend () , self . pusherstopped () , self . pushererror ())
            }
        }
        #[doc = "Interrupt Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intstat(pub u32);
        impl Intstat {
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherblockend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_fetcherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherstopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_fetcherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchererror(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[inline(always)]
            pub const fn set_fetchererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherblockend(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_pusherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherstopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_pusherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bus error during pusher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn pushererror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during pusher DMA access"]
            #[inline(always)]
            pub const fn set_pushererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Intstat {
            #[inline(always)]
            fn default() -> Intstat {
                Intstat(0)
            }
        }
        impl core::fmt::Debug for Intstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intstat")
                    .field("fetcherblockend", &self.fetcherblockend())
                    .field("fetcherstopped", &self.fetcherstopped())
                    .field("fetchererror", &self.fetchererror())
                    .field("pusherblockend", &self.pusherblockend())
                    .field("pusherstopped", &self.pusherstopped())
                    .field("pushererror", &self.pushererror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intstat {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intstat {{ fetcherblockend: {=bool:?}, fetcherstopped: {=bool:?}, fetchererror: {=bool:?}, pusherblockend: {=bool:?}, pusherstopped: {=bool:?}, pushererror: {=bool:?} }}" , self . fetcherblockend () , self . fetcherstopped () , self . fetchererror () , self . pusherblockend () , self . pusherstopped () , self . pushererror ())
            }
        }
        #[doc = "Interrupt Status Clear"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intstatclr(pub u32);
        impl Intstatclr {
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherblockend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_fetcherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherstopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_fetcherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchererror(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[inline(always)]
            pub const fn set_fetchererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherblockend(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_pusherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherstopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_pusherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bus error during pusher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn pushererror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during pusher DMA access"]
            #[inline(always)]
            pub const fn set_pushererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Intstatclr {
            #[inline(always)]
            fn default() -> Intstatclr {
                Intstatclr(0)
            }
        }
        impl core::fmt::Debug for Intstatclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intstatclr")
                    .field("fetcherblockend", &self.fetcherblockend())
                    .field("fetcherstopped", &self.fetcherstopped())
                    .field("fetchererror", &self.fetchererror())
                    .field("pusherblockend", &self.pusherblockend())
                    .field("pusherstopped", &self.pusherstopped())
                    .field("pushererror", &self.pushererror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intstatclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intstatclr {{ fetcherblockend: {=bool:?}, fetcherstopped: {=bool:?}, fetchererror: {=bool:?}, pusherblockend: {=bool:?}, pusherstopped: {=bool:?}, pushererror: {=bool:?} }}" , self . fetcherblockend () , self . fetcherstopped () , self . fetchererror () , self . pusherblockend () , self . pusherstopped () , self . pushererror ())
            }
        }
        #[doc = "Interrupt Status Raw"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intstatraw(pub u32);
        impl Intstatraw {
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherblockend(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_fetcherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn fetcherstopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Fetcher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_fetcherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn fetchererror(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during fetcher DMA access"]
            #[inline(always)]
            pub const fn set_fetchererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherblockend(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block (if enabled in the descriptor; scatter-gather only)"]
            #[inline(always)]
            pub const fn set_pusherblockend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn pusherstopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Pusher DMA reached the end of a block with Stop=1, or end of direct transfer"]
            #[inline(always)]
            pub const fn set_pusherstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Bus error during pusher DMA access"]
            #[must_use]
            #[inline(always)]
            pub const fn pushererror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Bus error during pusher DMA access"]
            #[inline(always)]
            pub const fn set_pushererror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Intstatraw {
            #[inline(always)]
            fn default() -> Intstatraw {
                Intstatraw(0)
            }
        }
        impl core::fmt::Debug for Intstatraw {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intstatraw")
                    .field("fetcherblockend", &self.fetcherblockend())
                    .field("fetcherstopped", &self.fetcherstopped())
                    .field("fetchererror", &self.fetchererror())
                    .field("pusherblockend", &self.pusherblockend())
                    .field("pusherstopped", &self.pusherstopped())
                    .field("pushererror", &self.pushererror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intstatraw {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intstatraw {{ fetcherblockend: {=bool:?}, fetcherstopped: {=bool:?}, fetchererror: {=bool:?}, pusherblockend: {=bool:?}, pusherstopped: {=bool:?}, pushererror: {=bool:?} }}" , self . fetcherblockend () , self . fetcherstopped () , self . fetchererror () , self . pusherblockend () , self . pusherstopped () , self . pushererror ())
            }
        }
        #[doc = "LFSR seed register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfsrseed(pub u32);
        impl Lfsrseed {
            #[doc = "LFSR initialization value."]
            #[must_use]
            #[inline(always)]
            pub const fn lfsrseed(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "LFSR initialization value."]
            #[inline(always)]
            pub const fn set_lfsrseed(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Share index for which initialization value should be used."]
            #[must_use]
            #[inline(always)]
            pub const fn lfsrsselection(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "Share index for which initialization value should be used."]
            #[inline(always)]
            pub const fn set_lfsrsselection(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
        }
        impl Default for Lfsrseed {
            #[inline(always)]
            fn default() -> Lfsrseed {
                Lfsrseed(0)
            }
        }
        impl core::fmt::Debug for Lfsrseed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfsrseed")
                    .field("lfsrseed", &self.lfsrseed())
                    .field("lfsrsselection", &self.lfsrsselection())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfsrseed {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lfsrseed {{ lfsrseed: {=u32:?}, lfsrsselection: {=u8:?} }}",
                    self.lfsrseed(),
                    self.lfsrsselection()
                )
            }
        }
        #[doc = "Operand size register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opsize(pub u32);
        impl Opsize {
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[must_use]
            #[inline(always)]
            pub const fn opsize(&self) -> super::vals::Opsize {
                let val = (self.0 >> 0usize) & 0x1fff;
                super::vals::Opsize::from_bits(val as u16)
            }
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[inline(always)]
            pub const fn set_opsize(&mut self, val: super::vals::Opsize) {
                self.0 =
                    (self.0 & !(0x1fff << 0usize)) | (((val.to_bits() as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Opsize {
            #[inline(always)]
            fn default() -> Opsize {
                Opsize(0)
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opsize")
                    .field("opsize", &self.opsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Opsize {{ opsize: {:?} }}", self.opsize())
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkControl(pub u32);
        impl PkControl {
            #[doc = "Writing a 1 starts the processing."]
            #[must_use]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 starts the processing."]
            #[inline(always)]
            pub const fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[must_use]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[inline(always)]
            pub const fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for PkControl {
            #[inline(always)]
            fn default() -> PkControl {
                PkControl(0)
            }
        }
        impl core::fmt::Debug for PkControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkControl")
                    .field("start", &self.start())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkControl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PkControl {{ start: {=bool:?}, clearirq: {=bool:?} }}",
                    self.start(),
                    self.clearirq()
                )
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkHwconfig(pub u32);
        impl PkHwconfig {
            #[doc = "Maximum operand size (number of bytes)."]
            #[must_use]
            #[inline(always)]
            pub const fn maxopsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Maximum operand size (number of bytes)."]
            #[inline(always)]
            pub const fn set_maxopsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Number of multipliers:"]
            #[must_use]
            #[inline(always)]
            pub const fn nbmult(&self) -> super::vals::Nbmult {
                let val = (self.0 >> 12usize) & 0x0f;
                super::vals::Nbmult::from_bits(val as u8)
            }
            #[doc = "Number of multipliers:"]
            #[inline(always)]
            pub const fn set_nbmult(&mut self, val: super::vals::Nbmult) {
                self.0 =
                    (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u32) & 0x0f) << 12usize);
            }
            #[doc = "Support prime field."]
            #[must_use]
            #[inline(always)]
            pub const fn primefield(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Support prime field."]
            #[inline(always)]
            pub const fn set_primefield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Support binary field."]
            #[must_use]
            #[inline(always)]
            pub const fn binaryfield(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Support binary field."]
            #[inline(always)]
            pub const fn set_binaryfield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Support data memory error correction."]
            #[must_use]
            #[inline(always)]
            pub const fn datamemecc(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Support data memory error correction."]
            #[inline(always)]
            pub const fn set_datamemecc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Support code memory error correction."]
            #[must_use]
            #[inline(always)]
            pub const fn codememecc(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Support code memory error correction."]
            #[inline(always)]
            pub const fn set_codememecc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Support ECC P256 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p256(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P256 acceleration."]
            #[inline(always)]
            pub const fn set_p256(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Support ECC P384 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p384(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P384 acceleration."]
            #[inline(always)]
            pub const fn set_p384(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Support ECC P521 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p521(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P521 acceleration."]
            #[inline(always)]
            pub const fn set_p521(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Support ECC P192 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p192(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P192 acceleration."]
            #[inline(always)]
            pub const fn set_p192(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn x25519(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[inline(always)]
            pub const fn set_x25519(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Memory access"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbmaster(&self) -> super::vals::Ahbmaster {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Ahbmaster::from_bits(val as u8)
            }
            #[doc = "Memory access"]
            #[inline(always)]
            pub const fn set_ahbmaster(&mut self, val: super::vals::Ahbmaster) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Code memory"]
            #[must_use]
            #[inline(always)]
            pub const fn coderam(&self) -> super::vals::Coderam {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Coderam::from_bits(val as u8)
            }
            #[doc = "Code memory"]
            #[inline(always)]
            pub const fn set_coderam(&mut self, val: super::vals::Coderam) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disablesmx(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[inline(always)]
            pub const fn set_disablesmx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disableclrmem(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[inline(always)]
            pub const fn set_disableclrmem(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disablecm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[inline(always)]
            pub const fn set_disablecm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for PkHwconfig {
            #[inline(always)]
            fn default() -> PkHwconfig {
                PkHwconfig(0)
            }
        }
        impl core::fmt::Debug for PkHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkHwconfig")
                    .field("maxopsize", &self.maxopsize())
                    .field("nbmult", &self.nbmult())
                    .field("primefield", &self.primefield())
                    .field("binaryfield", &self.binaryfield())
                    .field("datamemecc", &self.datamemecc())
                    .field("codememecc", &self.codememecc())
                    .field("p256", &self.p256())
                    .field("p384", &self.p384())
                    .field("p521", &self.p521())
                    .field("p192", &self.p192())
                    .field("x25519", &self.x25519())
                    .field("ahbmaster", &self.ahbmaster())
                    .field("coderam", &self.coderam())
                    .field("disablesmx", &self.disablesmx())
                    .field("disableclrmem", &self.disableclrmem())
                    .field("disablecm", &self.disablecm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PkHwconfig {{ maxopsize: {=u16:?}, nbmult: {:?}, primefield: {=bool:?}, binaryfield: {=bool:?}, datamemecc: {=bool:?}, codememecc: {=bool:?}, p256: {=bool:?}, p384: {=bool:?}, p521: {=bool:?}, p192: {=bool:?}, x25519: {=bool:?}, ahbmaster: {:?}, coderam: {:?}, disablesmx: {=bool:?}, disableclrmem: {=bool:?}, disablecm: {=bool:?} }}" , self . maxopsize () , self . nbmult () , self . primefield () , self . binaryfield () , self . datamemecc () , self . codememecc () , self . p256 () , self . p384 () , self . p521 () , self . p192 () , self . x25519 () , self . ahbmaster () , self . coderam () , self . disablesmx () , self . disableclrmem () , self . disablecm ())
            }
        }
        #[doc = "Hardware Version register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkHwversion(pub u32);
        impl PkHwversion {
            #[doc = "Minor version number."]
            #[must_use]
            #[inline(always)]
            pub const fn minor(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Minor version number."]
            #[inline(always)]
            pub const fn set_minor(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Major version number."]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Major version number."]
            #[inline(always)]
            pub const fn set_major(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for PkHwversion {
            #[inline(always)]
            fn default() -> PkHwversion {
                PkHwversion(0)
            }
        }
        impl core::fmt::Debug for PkHwversion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkHwversion")
                    .field("minor", &self.minor())
                    .field("major", &self.major())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkHwversion {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PkHwversion {{ minor: {=u16:?}, major: {=u16:?} }}",
                    self.minor(),
                    self.major()
                )
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkStatus(pub u32);
        impl PkStatus {
            #[doc = "These bits indicate an error condition."]
            #[must_use]
            #[inline(always)]
            pub const fn errorflags(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits indicate an error condition."]
            #[inline(always)]
            pub const fn set_errorflags(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u32) & 0x0fff) << 4usize);
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[must_use]
            #[inline(always)]
            pub const fn pkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[inline(always)]
            pub const fn set_pkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[must_use]
            #[inline(always)]
            pub const fn intrptstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[inline(always)]
            pub const fn set_intrptstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[must_use]
            #[inline(always)]
            pub const fn failptr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[inline(always)]
            pub const fn set_failptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for PkStatus {
            #[inline(always)]
            fn default() -> PkStatus {
                PkStatus(0)
            }
        }
        impl core::fmt::Debug for PkStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkStatus")
                    .field("errorflags", &self.errorflags())
                    .field("pkbusy", &self.pkbusy())
                    .field("intrptstatus", &self.intrptstatus())
                    .field("failptr", &self.failptr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PkStatus {{ errorflags: {=u16:?}, pkbusy: {=bool:?}, intrptstatus: {=bool:?}, failptr: {=u8:?} }}" , self . errorflags () , self . pkbusy () , self . intrptstatus () , self . failptr ())
            }
        }
        #[doc = "PKE Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecommand(pub u32);
        impl Pkecommand {
            #[doc = "Secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn securemode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Secure mode."]
            #[inline(always)]
            pub const fn set_securemode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[must_use]
            #[inline(always)]
            pub const fn selectedkey(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[inline(always)]
            pub const fn set_selectedkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[must_use]
            #[inline(always)]
            pub const fn opsel(&self) -> super::vals::Opsel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Opsel::from_bits(val as u8)
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[inline(always)]
            pub const fn set_opsel(&mut self, val: super::vals::Opsel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Pkecommand {
            #[inline(always)]
            fn default() -> Pkecommand {
                Pkecommand(0)
            }
        }
        impl core::fmt::Debug for Pkecommand {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecommand")
                    .field("securemode", &self.securemode())
                    .field("selectedkey", &self.selectedkey())
                    .field("opsel", &self.opsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecommand {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pkecommand {{ securemode: {=bool:?}, selectedkey: {=u8:?}, opsel: {:?} }}",
                    self.securemode(),
                    self.selectedkey(),
                    self.opsel()
                )
            }
        }
        #[doc = "PKE Control register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecontrol(pub u32);
        impl Pkecontrol {
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[must_use]
            #[inline(always)]
            pub const fn pkestart(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[inline(always)]
            pub const fn set_pkestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Clear the IRQ output."]
            #[must_use]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the IRQ output."]
            #[inline(always)]
            pub const fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Pkecontrol {
            #[inline(always)]
            fn default() -> Pkecontrol {
                Pkecontrol(0)
            }
        }
        impl core::fmt::Debug for Pkecontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecontrol")
                    .field("pkestart", &self.pkestart())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecontrol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pkecontrol {{ pkestart: {=bool:?}, clearirq: {=bool:?} }}",
                    self.pkestart(),
                    self.clearirq()
                )
            }
        }
        #[doc = "PKE Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkestatus(pub u32);
        impl Pkestatus {
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[must_use]
            #[inline(always)]
            pub const fn starterror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[inline(always)]
            pub const fn set_starterror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[must_use]
            #[inline(always)]
            pub const fn ikgpkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[inline(always)]
            pub const fn set_ikgpkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[must_use]
            #[inline(always)]
            pub const fn irqstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[inline(always)]
            pub const fn set_irqstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[must_use]
            #[inline(always)]
            pub const fn erasebusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[inline(always)]
            pub const fn set_erasebusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Pkestatus {
            #[inline(always)]
            fn default() -> Pkestatus {
                Pkestatus(0)
            }
        }
        impl core::fmt::Debug for Pkestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkestatus")
                    .field("error", &self.error())
                    .field("starterror", &self.starterror())
                    .field("ikgpkbusy", &self.ikgpkbusy())
                    .field("irqstatus", &self.irqstatus())
                    .field("erasebusy", &self.erasebusy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pkestatus {{ error: {=bool:?}, starterror: {=bool:?}, ikgpkbusy: {=bool:?}, irqstatus: {=bool:?}, erasebusy: {=bool:?} }}" , self . error () , self . starterror () , self . ikgpkbusy () , self . irqstatus () , self . erasebusy ())
            }
        }
        #[doc = "Pointers register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pointers(pub u32);
        impl Pointers {
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptra(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptra(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrb(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptrb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrc(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[inline(always)]
            pub const fn set_opptrc(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrn(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptrn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Pointers {
            #[inline(always)]
            fn default() -> Pointers {
                Pointers(0)
            }
        }
        impl core::fmt::Debug for Pointers {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pointers")
                    .field("opptra", &self.opptra())
                    .field("opptrb", &self.opptrb())
                    .field("opptrc", &self.opptrc())
                    .field("opptrn", &self.opptrn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pointers {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pointers {{ opptra: {=u8:?}, opptrb: {=u8:?}, opptrc: {=u8:?}, opptrn: {=u8:?} }}" , self . opptra () , self . opptrb () , self . opptrc () , self . opptrn ())
            }
        }
        #[doc = "Proportion test cut-off register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Proptestcutoff(pub u32);
        impl Proptestcutoff {
            #[doc = "Proportion test cut-off value."]
            #[must_use]
            #[inline(always)]
            pub const fn proptestcutoff(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Proportion test cut-off value."]
            #[inline(always)]
            pub const fn set_proptestcutoff(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Proptestcutoff {
            #[inline(always)]
            fn default() -> Proptestcutoff {
                Proptestcutoff(0)
            }
        }
        impl core::fmt::Debug for Proptestcutoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Proptestcutoff")
                    .field("proptestcutoff", &self.proptestcutoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Proptestcutoff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Proptestcutoff {{ proptestcutoff: {=u16:?} }}",
                    self.proptestcutoff()
                )
            }
        }
        #[doc = "Push Length (only used in direct mode)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pushlen(pub u32);
        impl Pushlen {
            #[doc = "Length of data block"]
            #[must_use]
            #[inline(always)]
            pub const fn pushlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[doc = "Length of data block"]
            #[inline(always)]
            pub const fn set_pushlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[doc = "Constant address"]
            #[must_use]
            #[inline(always)]
            pub const fn pushcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Constant address"]
            #[inline(always)]
            pub const fn set_pushcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Realign length"]
            #[must_use]
            #[inline(always)]
            pub const fn pushrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Realign length"]
            #[inline(always)]
            pub const fn set_pushrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Discard data"]
            #[must_use]
            #[inline(always)]
            pub const fn pushdiscard(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Discard data"]
            #[inline(always)]
            pub const fn set_pushdiscard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Pushlen {
            #[inline(always)]
            fn default() -> Pushlen {
                Pushlen(0)
            }
        }
        impl core::fmt::Debug for Pushlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pushlen")
                    .field("pushlen", &self.pushlen())
                    .field("pushcstaddr", &self.pushcstaddr())
                    .field("pushrealign", &self.pushrealign())
                    .field("pushdiscard", &self.pushdiscard())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pushlen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pushlen {{ pushlen: {=u32:?}, pushcstaddr: {=bool:?}, pushrealign: {=bool:?}, pushdiscard: {=bool:?} }}" , self . pushlen () , self . pushcstaddr () , self . pushrealign () , self . pushdiscard ())
            }
        }
        #[doc = "Repetition test cut-off register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Repeatthreshold(pub u32);
        impl Repeatthreshold {
            #[doc = "Repetition Test cut-off value."]
            #[must_use]
            #[inline(always)]
            pub const fn repeatthreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Repetition Test cut-off value."]
            #[inline(always)]
            pub const fn set_repeatthreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Repeatthreshold {
            #[inline(always)]
            fn default() -> Repeatthreshold {
                Repeatthreshold(0)
            }
        }
        impl core::fmt::Debug for Repeatthreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Repeatthreshold")
                    .field("repeatthreshold", &self.repeatthreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Repeatthreshold {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Repeatthreshold {{ repeatthreshold: {=u8:?} }}",
                    self.repeatthreshold()
                )
            }
        }
        #[doc = "Reseed Interval MSB register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reseedintervalmsb(pub u32);
        impl Reseedintervalmsb {
            #[doc = "Reseed Interval MSB."]
            #[must_use]
            #[inline(always)]
            pub const fn reseedintervalmsb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Reseed Interval MSB."]
            #[inline(always)]
            pub const fn set_reseedintervalmsb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Reseedintervalmsb {
            #[inline(always)]
            fn default() -> Reseedintervalmsb {
                Reseedintervalmsb(0)
            }
        }
        impl core::fmt::Debug for Reseedintervalmsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reseedintervalmsb")
                    .field("reseedintervalmsb", &self.reseedintervalmsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reseedintervalmsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Reseedintervalmsb {{ reseedintervalmsb: {=u16:?} }}",
                    self.reseedintervalmsb()
                )
            }
        }
        #[doc = "Control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolControl(pub u32);
        impl RngcontrolControl {
            #[doc = "Start the NDRNG. Self-clearing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the NDRNG. Self-clearing bit."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[must_use]
            #[inline(always)]
            pub const fn lfsren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[inline(always)]
            pub const fn set_lfsren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[must_use]
            #[inline(always)]
            pub const fn testen(&self) -> super::vals::Testen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Testen::from_bits(val as u8)
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[inline(always)]
            pub const fn set_testen(&mut self, val: super::vals::Testen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Conditioning function bypass."]
            #[must_use]
            #[inline(always)]
            pub const fn condbypass(&self) -> super::vals::Condbypass {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Condbypass::from_bits(val as u8)
            }
            #[doc = "Conditioning function bypass."]
            #[inline(always)]
            pub const fn set_condbypass(&mut self, val: super::vals::Condbypass) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable interrupt if any of the health test fails."]
            #[must_use]
            #[inline(always)]
            pub const fn intenrep(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable interrupt if any of the health test fails."]
            #[inline(always)]
            pub const fn set_intenrep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable interrupt if FIFO is full."]
            #[must_use]
            #[inline(always)]
            pub const fn intenfull(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable interrupt if FIFO is full."]
            #[inline(always)]
            pub const fn set_intenfull(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Datapath content flush and control FSM"]
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Datapath content flush and control FSM"]
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[must_use]
            #[inline(always)]
            pub const fn forceactiveros(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[inline(always)]
            pub const fn set_forceactiveros(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Results of the health tests during start-up and online test do not affect the control FSM state."]
            #[must_use]
            #[inline(always)]
            pub const fn ignorehealthtestsfailforfsm(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Results of the health tests during start-up and online test do not affect the control FSM state."]
            #[inline(always)]
            pub const fn set_ignorehealthtestsfailforfsm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Number of 128 bit blocks used in conditioning (AES-CBC-MAC) post-processing."]
            #[must_use]
            #[inline(always)]
            pub const fn nb128bitblocks(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 128 bit blocks used in conditioning (AES-CBC-MAC) post-processing."]
            #[inline(always)]
            pub const fn set_nb128bitblocks(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[must_use]
            #[inline(always)]
            pub const fn fifowritestartup(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[inline(always)]
            pub const fn set_fifowritestartup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "All repetition tests (each share) are disabled via this single bit."]
            #[must_use]
            #[inline(always)]
            pub const fn disrepettests(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "All repetition tests (each share) are disabled via this single bit."]
            #[inline(always)]
            pub const fn set_disrepettests(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "All proportion tests (each share) are disabled via this single bit."]
            #[must_use]
            #[inline(always)]
            pub const fn disproptests(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "All proportion tests (each share) are disabled via this single bit."]
            #[inline(always)]
            pub const fn set_disproptests(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Disable specific delay(s) check in auto-correlation test - same RO:"]
            #[must_use]
            #[inline(always)]
            pub const fn disautocorrtests(&self) -> u8 {
                let val = (self.0 >> 23usize) & 0x03;
                val as u8
            }
            #[doc = "Disable specific delay(s) check in auto-correlation test - same RO:"]
            #[inline(always)]
            pub const fn set_disautocorrtests(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 23usize)) | (((val as u32) & 0x03) << 23usize);
            }
            #[doc = "Disable specific delay(s) check in correlation test - different ROs:"]
            #[must_use]
            #[inline(always)]
            pub const fn discorrtests(&self) -> u8 {
                let val = (self.0 >> 27usize) & 0x07;
                val as u8
            }
            #[doc = "Disable specific delay(s) check in correlation test - different ROs:"]
            #[inline(always)]
            pub const fn set_discorrtests(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 27usize)) | (((val as u32) & 0x07) << 27usize);
            }
            #[doc = "Select blending method"]
            #[must_use]
            #[inline(always)]
            pub const fn blendingmethod(&self) -> super::vals::Blendingmethod {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::Blendingmethod::from_bits(val as u8)
            }
            #[doc = "Select blending method"]
            #[inline(always)]
            pub const fn set_blendingmethod(&mut self, val: super::vals::Blendingmethod) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for RngcontrolControl {
            #[inline(always)]
            fn default() -> RngcontrolControl {
                RngcontrolControl(0)
            }
        }
        impl core::fmt::Debug for RngcontrolControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolControl")
                    .field("enable", &self.enable())
                    .field("lfsren", &self.lfsren())
                    .field("testen", &self.testen())
                    .field("condbypass", &self.condbypass())
                    .field("intenrep", &self.intenrep())
                    .field("intenfull", &self.intenfull())
                    .field("softrst", &self.softrst())
                    .field("forceactiveros", &self.forceactiveros())
                    .field(
                        "ignorehealthtestsfailforfsm",
                        &self.ignorehealthtestsfailforfsm(),
                    )
                    .field("nb128bitblocks", &self.nb128bitblocks())
                    .field("fifowritestartup", &self.fifowritestartup())
                    .field("disrepettests", &self.disrepettests())
                    .field("disproptests", &self.disproptests())
                    .field("disautocorrtests", &self.disautocorrtests())
                    .field("discorrtests", &self.discorrtests())
                    .field("blendingmethod", &self.blendingmethod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolControl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolControl {{ enable: {=bool:?}, lfsren: {=bool:?}, testen: {:?}, condbypass: {:?}, intenrep: {=bool:?}, intenfull: {=bool:?}, softrst: {=bool:?}, forceactiveros: {=bool:?}, ignorehealthtestsfailforfsm: {=bool:?}, nb128bitblocks: {=u8:?}, fifowritestartup: {=bool:?}, disrepettests: {=bool:?}, disproptests: {=bool:?}, disautocorrtests: {=u8:?}, discorrtests: {=u8:?}, blendingmethod: {:?} }}" , self . enable () , self . lfsren () , self . testen () , self . condbypass () , self . intenrep () , self . intenfull () , self . softrst () , self . forceactiveros () , self . ignorehealthtestsfailforfsm () , self . nb128bitblocks () , self . fifowritestartup () , self . disrepettests () , self . disproptests () , self . disautocorrtests () , self . discorrtests () , self . blendingmethod ())
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolHwconfig(pub u32);
        impl RngcontrolHwconfig {
            #[doc = "Generic g_NbOfInverters value."]
            #[must_use]
            #[inline(always)]
            pub const fn nbofinv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Generic g_NbOfInverters value."]
            #[inline(always)]
            pub const fn set_nbofinv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Generic g_Log2NbOfAutoCorrTestsPerShare value."]
            #[must_use]
            #[inline(always)]
            pub const fn log2nbofautocorrtestspershare(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_Log2NbOfAutoCorrTestsPerShare value."]
            #[inline(always)]
            pub const fn set_log2nbofautocorrtestspershare(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Generic g_Log2FifoDepth value."]
            #[must_use]
            #[inline(always)]
            pub const fn log2fifodepth(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Generic g_Log2FifoDepth value."]
            #[inline(always)]
            pub const fn set_log2fifodepth(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Generic g_Log2NbOfShares value."]
            #[must_use]
            #[inline(always)]
            pub const fn log2nbofshares(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x03;
                val as u8
            }
            #[doc = "Generic g_Log2NbOfShares value."]
            #[inline(always)]
            pub const fn set_log2nbofshares(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize);
            }
        }
        impl Default for RngcontrolHwconfig {
            #[inline(always)]
            fn default() -> RngcontrolHwconfig {
                RngcontrolHwconfig(0)
            }
        }
        impl core::fmt::Debug for RngcontrolHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolHwconfig")
                    .field("nbofinv", &self.nbofinv())
                    .field(
                        "log2nbofautocorrtestspershare",
                        &self.log2nbofautocorrtestspershare(),
                    )
                    .field("log2fifodepth", &self.log2fifodepth())
                    .field("log2nbofshares", &self.log2nbofshares())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolHwconfig {{ nbofinv: {=u8:?}, log2nbofautocorrtestspershare: {=u8:?}, log2fifodepth: {=u8:?}, log2nbofshares: {=u8:?} }}" , self . nbofinv () , self . log2nbofautocorrtestspershare () , self . log2fifodepth () , self . log2nbofshares ())
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolStatus(pub u32);
        impl RngcontrolStatus {
            #[doc = "High when data written to TestData register is being processed."]
            #[must_use]
            #[inline(always)]
            pub const fn testdatabusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "High when data written to TestData register is being processed."]
            #[inline(always)]
            pub const fn set_testdatabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "State of the control FSM:"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "State of the control FSM:"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "NIST repetition test(s) failure."]
            #[must_use]
            #[inline(always)]
            pub const fn repfail(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "NIST repetition test(s) failure."]
            #[inline(always)]
            pub const fn set_repfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "NIST proportion test(s) failure."]
            #[must_use]
            #[inline(always)]
            pub const fn propfail(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "NIST proportion test(s) failure."]
            #[inline(always)]
            pub const fn set_propfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Any of the enabled health tests is failing."]
            #[must_use]
            #[inline(always)]
            pub const fn anyhealthtestfail(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Any of the enabled health tests is failing."]
            #[inline(always)]
            pub const fn set_anyhealthtestfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "FIFO full status."]
            #[must_use]
            #[inline(always)]
            pub const fn fullint(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO full status."]
            #[inline(always)]
            pub const fn set_fullint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Start-up test(s) failure."]
            #[must_use]
            #[inline(always)]
            pub const fn startupfail(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Start-up test(s) failure."]
            #[inline(always)]
            pub const fn set_startupfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "NIST Repetition test failure per share."]
            #[must_use]
            #[inline(always)]
            pub const fn reptestfailpershare(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "NIST Repetition test failure per share."]
            #[inline(always)]
            pub const fn set_reptestfailpershare(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "NIST Proportion test failure per share."]
            #[must_use]
            #[inline(always)]
            pub const fn proptestfailpershare(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "NIST Proportion test failure per share."]
            #[inline(always)]
            pub const fn set_proptestfailpershare(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Conditioning consumes data slower than they are provided to it."]
            #[must_use]
            #[inline(always)]
            pub const fn conditioningistooslow(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Conditioning consumes data slower than they are provided to it."]
            #[inline(always)]
            pub const fn set_conditioningistooslow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for RngcontrolStatus {
            #[inline(always)]
            fn default() -> RngcontrolStatus {
                RngcontrolStatus(0)
            }
        }
        impl core::fmt::Debug for RngcontrolStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolStatus")
                    .field("testdatabusy", &self.testdatabusy())
                    .field("state", &self.state())
                    .field("repfail", &self.repfail())
                    .field("propfail", &self.propfail())
                    .field("anyhealthtestfail", &self.anyhealthtestfail())
                    .field("fullint", &self.fullint())
                    .field("startupfail", &self.startupfail())
                    .field("reptestfailpershare", &self.reptestfailpershare())
                    .field("proptestfailpershare", &self.proptestfailpershare())
                    .field("conditioningistooslow", &self.conditioningistooslow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolStatus {{ testdatabusy: {=bool:?}, state: {:?}, repfail: {=bool:?}, propfail: {=bool:?}, anyhealthtestfail: {=bool:?}, fullint: {=bool:?}, startupfail: {=bool:?}, reptestfailpershare: {=u8:?}, proptestfailpershare: {=u8:?}, conditioningistooslow: {=bool:?} }}" , self . testdatabusy () , self . state () , self . repfail () , self . propfail () , self . anyhealthtestfail () , self . fullint () , self . startupfail () , self . reptestfailpershare () , self . proptestfailpershare () , self . conditioningistooslow ())
            }
        }
        #[doc = "Number of clock cycles between sampling moments."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Samplingperiod(pub u32);
        impl Samplingperiod {
            #[doc = "Number of clock cycles between sampling moments."]
            #[must_use]
            #[inline(always)]
            pub const fn samplingperiod(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Number of clock cycles between sampling moments."]
            #[inline(always)]
            pub const fn set_samplingperiod(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Samplingperiod {
            #[inline(always)]
            fn default() -> Samplingperiod {
                Samplingperiod(0)
            }
        }
        impl core::fmt::Debug for Samplingperiod {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Samplingperiod")
                    .field("samplingperiod", &self.samplingperiod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Samplingperiod {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Samplingperiod {{ samplingperiod: {=u16:?} }}",
                    self.samplingperiod()
                )
            }
        }
        #[doc = "SoftRst register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softrst(pub u32);
        impl Softrst {
            #[doc = "Software reset:"]
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> super::vals::Softrst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Softrst::from_bits(val as u8)
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: super::vals::Softrst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Softrst {
            #[inline(always)]
            fn default() -> Softrst {
                Softrst(0)
            }
        }
        impl core::fmt::Debug for Softrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softrst")
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Softrst {{ softrst: {:?} }}", self.softrst())
            }
        }
        #[doc = "Timer register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timer(pub u32);
        impl Timer {
            #[doc = "Number of clock cycles (as the number of core cycles is always even, register bit 0 is tied to zero)."]
            #[must_use]
            #[inline(always)]
            pub const fn timer(&self) -> u32 {
                let val = (self.0 >> 1usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Number of clock cycles (as the number of core cycles is always even, register bit 0 is tied to zero)."]
            #[inline(always)]
            pub const fn set_timer(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 1usize)) | (((val as u32) & 0x7fff_ffff) << 1usize);
            }
        }
        impl Default for Timer {
            #[inline(always)]
            fn default() -> Timer {
                Timer(0)
            }
        }
        impl core::fmt::Debug for Timer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timer")
                    .field("timer", &self.timer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Timer {{ timer: {=u32:?} }}", self.timer())
            }
        }
        #[doc = "Number of clock cycles in warm-up sequence."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Warmupperiod(pub u32);
        impl Warmupperiod {
            #[doc = "Number of clock cycles in warm-up sequence."]
            #[must_use]
            #[inline(always)]
            pub const fn warmupperiod(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Number of clock cycles in warm-up sequence."]
            #[inline(always)]
            pub const fn set_warmupperiod(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Warmupperiod {
            #[inline(always)]
            fn default() -> Warmupperiod {
                Warmupperiod(0)
            }
        }
        impl core::fmt::Debug for Warmupperiod {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Warmupperiod")
                    .field("warmupperiod", &self.warmupperiod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Warmupperiod {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Warmupperiod {{ warmupperiod: {=u16:?} }}",
                    self.warmupperiod()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ahbmaster {
            #[doc = "Memory access through AHB Slave and internally in the PKE."]
            SLAVE = 0x0,
            #[doc = "Memory access through AHB Master, outside the PKE."]
            MASTER = 0x01,
        }
        impl Ahbmaster {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ahbmaster {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ahbmaster {
            #[inline(always)]
            fn from(val: u8) -> Ahbmaster {
                Ahbmaster::from_bits(val)
            }
        }
        impl From<Ahbmaster> for u8 {
            #[inline(always)]
            fn from(val: Ahbmaster) -> u8 {
                Ahbmaster::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Blendingmethod {
            #[doc = "Concatenation"]
            CONCATENATION = 0x0,
            #[doc = "XOR level 1"]
            XORLEVEL1 = 0x01,
            #[doc = "XOR level 2"]
            XORLEVEL2 = 0x02,
            #[doc = "VON-NEUMANN debiasing"]
            VONNEUMANN = 0x03,
        }
        impl Blendingmethod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Blendingmethod {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Blendingmethod {
            #[inline(always)]
            fn from(val: u8) -> Blendingmethod {
                Blendingmethod::from_bits(val)
            }
        }
        impl From<Blendingmethod> for u8 {
            #[inline(always)]
            fn from(val: Blendingmethod) -> u8 {
                Blendingmethod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Calcr2 {
            #[doc = "don't recalculate R mod N"]
            NRECALCULATE = 0x0,
            #[doc = "re-calculate R mod N"]
            RECALCULATE = 0x01,
        }
        impl Calcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Calcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Calcr2 {
            #[inline(always)]
            fn from(val: u8) -> Calcr2 {
                Calcr2::from_bits(val)
            }
        }
        impl From<Calcr2> for u8 {
            #[inline(always)]
            fn from(val: Calcr2) -> u8 {
                Calcr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Coderam {
            #[doc = "Code memory is a ROM."]
            ROM = 0x0,
            #[doc = "Code memory is a RAM."]
            RAM = 0x01,
        }
        impl Coderam {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Coderam {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Coderam {
            #[inline(always)]
            fn from(val: u8) -> Coderam {
                Coderam::from_bits(val)
            }
        }
        impl From<Coderam> for u8 {
            #[inline(always)]
            fn from(val: Coderam) -> u8 {
                Coderam::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Condbypass {
            #[doc = "the conditioning function is used (normal mode)."]
            NORMAL = 0x0,
            #[doc = "the conditioning function is bypassed (to observe entropy source directly)."]
            BYPASS = 0x01,
        }
        impl Condbypass {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Condbypass {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Condbypass {
            #[inline(always)]
            fn from(val: u8) -> Condbypass {
                Condbypass::from_bits(val)
            }
        }
        impl From<Condbypass> for u8 {
            #[inline(always)]
            fn from(val: Condbypass) -> u8 {
                Condbypass::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Curve {
            #[doc = "P256."]
            P256 = 0x0,
            #[doc = "P384."]
            P384 = 0x01,
            #[doc = "P521."]
            P521 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Curve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Curve {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Curve {
            #[inline(always)]
            fn from(val: u8) -> Curve {
                Curve::from_bits(val)
            }
        }
        impl From<Curve> for u8 {
            #[inline(always)]
            fn from(val: Curve) -> u8 {
                Curve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Keysize {
            _RESERVED_0 = 0x0,
            #[doc = "supports AES128"]
            AES128 = 0x01,
            #[doc = "supports AES192"]
            AES192 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "supports AES256"]
            AES256 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Keysize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Keysize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Keysize {
            #[inline(always)]
            fn from(val: u8) -> Keysize {
                Keysize::from_bits(val)
            }
        }
        impl From<Keysize> for u8 {
            #[inline(always)]
            fn from(val: Keysize) -> u8 {
                Keysize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nbmult {
            #[doc = "1 multiplier"]
            MULT1 = 0x0,
            #[doc = "4 multipliers"]
            MULT4 = 0x01,
            #[doc = "16 multipliers"]
            MULT16 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "64 multipliers"]
            MULT64 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "256 multipliers"]
            MULT256 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Nbmult {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nbmult {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nbmult {
            #[inline(always)]
            fn from(val: u8) -> Nbmult {
                Nbmult::from_bits(val)
            }
        }
        impl From<Nbmult> for u8 {
            #[inline(always)]
            fn from(val: Nbmult) -> u8 {
                Nbmult::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opsel {
            #[doc = "Public Key Generation"]
            PUBKEY = 0x0,
            #[doc = "ECDSA Signature"]
            ECDSA = 0x01,
            #[doc = "Point Multiplication"]
            PTMUL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opsel {
            #[inline(always)]
            fn from(val: u8) -> Opsel {
                Opsel::from_bits(val)
            }
        }
        impl From<Opsel> for u8 {
            #[inline(always)]
            fn from(val: Opsel) -> u8 {
                Opsel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Opsize(u16);
        impl Opsize {
            #[doc = "256 bytes."]
            pub const OPSIZE256: Self = Self(0x0100);
            #[doc = "521 bytes."]
            pub const OPSIZE521: Self = Self(0x0209);
            #[doc = "2048 bytes."]
            pub const OPSIZE2048: Self = Self(0x0800);
            #[doc = "4096 bytes."]
            pub const OPSIZE4096: Self = Self(0x1000);
        }
        impl Opsize {
            pub const fn from_bits(val: u16) -> Opsize {
                Self(val & 0x1fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("OPSIZE256"),
                    0x0209 => f.write_str("OPSIZE521"),
                    0x0800 => f.write_str("OPSIZE2048"),
                    0x1000 => f.write_str("OPSIZE4096"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "OPSIZE256"),
                    0x0209 => defmt::write!(f, "OPSIZE521"),
                    0x0800 => defmt::write!(f, "OPSIZE2048"),
                    0x1000 => defmt::write!(f, "OPSIZE4096"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Opsize {
            #[inline(always)]
            fn from(val: u16) -> Opsize {
                Opsize::from_bits(val)
            }
        }
        impl From<Opsize> for u16 {
            #[inline(always)]
            fn from(val: Opsize) -> u16 {
                Opsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Selcurve {
            #[doc = "Unspecified"]
            NOACCEL = 0x0,
            #[doc = "Unspecified"]
            P256 = 0x01,
            #[doc = "Unspecified"]
            P384 = 0x02,
            #[doc = "Unspecified"]
            P521 = 0x03,
            #[doc = "Unspecified"]
            P192 = 0x04,
            #[doc = "Unspecified"]
            CURVE25519 = 0x05,
            #[doc = "Unspecified"]
            ED25519 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Selcurve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Selcurve {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Selcurve {
            #[inline(always)]
            fn from(val: u8) -> Selcurve {
                Selcurve::from_bits(val)
            }
        }
        impl From<Selcurve> for u8 {
            #[inline(always)]
            fn from(val: Selcurve) -> u8 {
                Selcurve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Softrst {
            #[doc = "Normal mode."]
            NORMAL = 0x0,
            #[doc = "The Isolated Key Generation logic and the keys are reset."]
            KEY = 0x01,
        }
        impl Softrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Softrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Softrst {
            #[inline(always)]
            fn from(val: u8) -> Softrst {
                Softrst::from_bits(val)
            }
        }
        impl From<Softrst> for u8 {
            #[inline(always)]
            fn from(val: Softrst) -> u8 {
                Softrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "Reset"]
            RESET = 0x0,
            #[doc = "Startup"]
            STARTUP = 0x01,
            #[doc = "Idle / FIFO full"]
            IDLERON = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Fill FIFO"]
            FILLFIFO = 0x04,
            #[doc = "Error"]
            ERROR = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swapbytes {
            #[doc = "Native format (little endian)."]
            NATIVE = 0x0,
            #[doc = "Byte swapped (big endian)."]
            SWAPPED = 0x01,
        }
        impl Swapbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swapbytes {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swapbytes {
            #[inline(always)]
            fn from(val: u8) -> Swapbytes {
                Swapbytes::from_bits(val)
            }
        }
        impl From<Swapbytes> for u8 {
            #[inline(always)]
            fn from(val: Swapbytes) -> u8 {
                Swapbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Testen {
            #[doc = "Noise source (normal mode)."]
            NORMAL = 0x0,
            #[doc = "Test data register (test mode)."]
            TEST = 0x01,
        }
        impl Testen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Testen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Testen {
            #[inline(always)]
            fn from(val: u8) -> Testen {
                Testen::from_bits(val)
            }
        }
        impl From<Testen> for u8 {
            #[inline(always)]
            fn from(val: Testen) -> u8 {
                Testen::to_bits(val)
            }
        }
    }
}
pub mod ctrlapperi {
    #[doc = "Control access port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctrlapperi {
        ptr: *mut u8,
    }
    unsafe impl Send for Ctrlapperi {}
    unsafe impl Sync for Ctrlapperi {}
    impl Ctrlapperi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXSTATUS is changed to DataPending."]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "TXSTATUS is changed to NoDataPending."]
        #[inline(always)]
        pub const fn events_txdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn mailbox(self) -> Mailbox {
            unsafe { Mailbox::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "System reset request."]
        #[inline(always)]
        pub const fn reset(self) -> crate::common::Reg<regs::Reset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "This register disables the ERASEPROTECT register and performs an ERASEALL operation."]
        #[inline(always)]
        pub const fn disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mailbox {
        ptr: *mut u8,
    }
    unsafe impl Send for Mailbox {}
    unsafe impl Sync for Mailbox {}
    impl Mailbox {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data sent from the debugger to the CPU."]
        #[inline(always)]
        pub const fn rxdata(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[inline(always)]
        pub const fn rxstatus(self) -> crate::common::Reg<regs::Rxstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Data sent from the CPU to the debugger."]
        #[inline(always)]
        pub const fn txdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[inline(always)]
        pub const fn txstatus(self) -> crate::common::Reg<regs::Txstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn txdone(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[inline(always)]
            pub const fn set_txdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxready", &self.rxready())
                    .field("txdone", &self.txdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ rxready: {=bool:?}, txdone: {=bool:?} }}",
                    self.rxready(),
                    self.txdone()
                )
            }
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Writing any value will lock the ERASEPROTECT.DISABLE register from being written until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value will lock the ERASEPROTECT.DISABLE register from being written until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "System reset request."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reset(pub u32);
        impl Reset {
            #[doc = "Reset request"]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Reset {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Reset::from_bits(val as u8)
            }
            #[doc = "Reset request"]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: super::vals::Reset) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Reset {
            #[inline(always)]
            fn default() -> Reset {
                Reset(0)
            }
        }
        impl core::fmt::Debug for Reset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Reset {{ reset: {:?} }}", self.reset())
            }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxstatus(pub u32);
        impl Rxstatus {
            #[doc = "Status of data in register RXDATA."]
            #[must_use]
            #[inline(always)]
            pub const fn rxstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register RXDATA."]
            #[inline(always)]
            pub const fn set_rxstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxstatus {
            #[inline(always)]
            fn default() -> Rxstatus {
                Rxstatus(0)
            }
        }
        impl core::fmt::Debug for Rxstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxstatus")
                    .field("rxstatus", &self.rxstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxstatus {{ rxstatus: {=bool:?} }}", self.rxstatus())
            }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txstatus(pub u32);
        impl Txstatus {
            #[doc = "Status of data in register TXDATA."]
            #[must_use]
            #[inline(always)]
            pub const fn txstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register TXDATA."]
            #[inline(always)]
            pub const fn set_txstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txstatus {
            #[inline(always)]
            fn default() -> Txstatus {
                Txstatus(0)
            }
        }
        impl core::fmt::Debug for Txstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txstatus")
                    .field("txstatus", &self.txstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txstatus {{ txstatus: {=bool:?} }}", self.txstatus())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reset {
            #[doc = "No reset is generated"]
            NO_RESET = 0x0,
            #[doc = "Perform a device soft reset"]
            SOFT_RESET = 0x01,
            #[doc = "Perform a device hard reset"]
            HARD_RESET = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Perform a device pin reset"]
            PIN_RESET = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Reset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reset {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reset {
            #[inline(always)]
            fn from(val: u8) -> Reset {
                Reset::from_bits(val)
            }
        }
        impl From<Reset> for u8 {
            #[inline(always)]
            fn from(val: Reset) -> u8 {
                Reset::to_bits(val)
            }
        }
    }
}
pub mod dppic {
    #[doc = "Distributed programmable peripheral interconnect controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Channel group tasks"]
        #[inline(always)]
        pub const fn tasks_chg(self, n: usize) -> TasksChg {
            assert!(n < 6usize);
            unsafe { TasksChg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_chg(self, n: usize) -> SubscribeChg {
            assert!(n < 6usize);
            unsafe { SubscribeChg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 8usize) as _) }
        }
        #[doc = "Channel enable register"]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Channel enable set register"]
        #[inline(always)]
        pub const fn chenset(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Channel enable clear register"]
        #[inline(always)]
        pub const fn chenclr(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0800usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeChg {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeChg {}
    unsafe impl Sync for SubscribeChg {}
    impl SubscribeChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].EN"]
        #[inline(always)]
        pub const fn en(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].DIS"]
        #[inline(always)]
        pub const fn dis(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Channel group tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksChg {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksChg {}
    unsafe impl Sync for TasksChg {}
    impl TasksChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Enable channel group n"]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Disable channel group n"]
        #[inline(always)]
        pub const fn dis(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Channel enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .field("ch[16]", &self.ch(16usize))
                    .field("ch[17]", &self.ch(17usize))
                    .field("ch[18]", &self.ch(18usize))
                    .field("ch[19]", &self.ch(19usize))
                    .field("ch[20]", &self.ch(20usize))
                    .field("ch[21]", &self.ch(21usize))
                    .field("ch[22]", &self.ch(22usize))
                    .field("ch[23]", &self.ch(23usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chen {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?}, ch[16]: {=bool:?}, ch[17]: {=bool:?}, ch[18]: {=bool:?}, ch[19]: {=bool:?}, ch[20]: {=bool:?}, ch[21]: {=bool:?}, ch[22]: {=bool:?}, ch[23]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize) , self . ch (16usize) , self . ch (17usize) , self . ch (18usize) , self . ch (19usize) , self . ch (20usize) , self . ch (21usize) , self . ch (22usize) , self . ch (23usize))
            }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "Include or exclude channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Include or exclude channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .field("ch[16]", &self.ch(16usize))
                    .field("ch[17]", &self.ch(17usize))
                    .field("ch[18]", &self.ch(18usize))
                    .field("ch[19]", &self.ch(19usize))
                    .field("ch[20]", &self.ch(20usize))
                    .field("ch[21]", &self.ch(21usize))
                    .field("ch[22]", &self.ch(22usize))
                    .field("ch[23]", &self.ch(23usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chg {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?}, ch[16]: {=bool:?}, ch[17]: {=bool:?}, ch[18]: {=bool:?}, ch[19]: {=bool:?}, ch[20]: {=bool:?}, ch[21]: {=bool:?}, ch[22]: {=bool:?}, ch[23]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize) , self . ch (16usize) , self . ch (17usize) , self . ch (18usize) , self . ch (19usize) , self . ch (20usize) , self . ch (21usize) , self . ch (22usize) , self . ch (23usize))
            }
        }
    }
}
pub mod ecb {
    #[doc = "Channel sounding access address scoring algorithm"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Csaa {
        ptr: *mut u8,
    }
    unsafe impl Send for Csaa {}
    unsafe impl Sync for Csaa {}
    impl Csaa {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Selected Channel Sounding Access Address used in the CS SYNC from Reflector to Initiator"]
        #[inline(always)]
        pub const fn reflector(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Selected Channel Sounding Access Address used in the CS SYNC from Initiator to Reflector"]
        #[inline(always)]
        pub const fn initiator(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Operation modes"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "AES ECB Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecb {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecb {}
    unsafe impl Sync for Ecb {}
    impl Ecb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start ECB block encrypt"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Abort a possible executing ECB operation"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "ECB block encrypt complete"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "ECB block encrypt aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Channel sounding access address scoring algorithm"]
        #[inline(always)]
        pub const fn csaa(self) -> Csaa {
            unsafe { Csaa::from_ptr(self.ptr.wrapping_add(0x053cusize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted ECB data structure"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ end: {=bool:?}, error: {=bool:?} }}",
                    self.end(),
                    self.error()
                )
            }
        }
        #[doc = "Operation modes"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Reverse the endianness on bit level for the ECB output, INITIATOR, and REFLECTOR registers"]
            #[must_use]
            #[inline(always)]
            pub const fn bitreverse(&self) -> super::vals::Bitreverse {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Bitreverse::from_bits(val as u8)
            }
            #[doc = "Reverse the endianness on bit level for the ECB output, INITIATOR, and REFLECTOR registers"]
            #[inline(always)]
            pub const fn set_bitreverse(&mut self, val: super::vals::Bitreverse) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("bitreverse", &self.bitreverse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ bitreverse: {:?} }}", self.bitreverse())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitreverse {
            #[doc = "Default endianness"]
            DEFAULT = 0x0,
            #[doc = "Reversed endianness"]
            REVERSED = 0x01,
        }
        impl Bitreverse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitreverse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitreverse {
            #[inline(always)]
            fn from(val: u8) -> Bitreverse {
                Bitreverse::from_bits(val)
            }
        }
        impl From<Bitreverse> for u8 {
            #[inline(always)]
            fn from(val: Bitreverse) -> u8 {
                Bitreverse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Encryption aborted due to higher priority peripheral requesting or using the AES module."]
            ABORTED = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod egu {
    #[doc = "Event generator unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Egu {
        ptr: *mut u8,
    }
    unsafe impl Send for Egu {}
    unsafe impl Sync for Egu {}
    impl Egu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Trigger n for triggering the corresponding TRIGGERED\\[n\\] event"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Event number n generated by triggering the corresponding TRIGGER\\[n\\] task"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[inline(always)]
            pub const fn set_triggered(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered[0]", &self.triggered(0usize))
                    .field("triggered[1]", &self.triggered(1usize))
                    .field("triggered[2]", &self.triggered(2usize))
                    .field("triggered[3]", &self.triggered(3usize))
                    .field("triggered[4]", &self.triggered(4usize))
                    .field("triggered[5]", &self.triggered(5usize))
                    .field("triggered[6]", &self.triggered(6usize))
                    .field("triggered[7]", &self.triggered(7usize))
                    .field("triggered[8]", &self.triggered(8usize))
                    .field("triggered[9]", &self.triggered(9usize))
                    .field("triggered[10]", &self.triggered(10usize))
                    .field("triggered[11]", &self.triggered(11usize))
                    .field("triggered[12]", &self.triggered(12usize))
                    .field("triggered[13]", &self.triggered(13usize))
                    .field("triggered[14]", &self.triggered(14usize))
                    .field("triggered[15]", &self.triggered(15usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ triggered[0]: {=bool:?}, triggered[1]: {=bool:?}, triggered[2]: {=bool:?}, triggered[3]: {=bool:?}, triggered[4]: {=bool:?}, triggered[5]: {=bool:?}, triggered[6]: {=bool:?}, triggered[7]: {=bool:?}, triggered[8]: {=bool:?}, triggered[9]: {=bool:?}, triggered[10]: {=bool:?}, triggered[11]: {=bool:?}, triggered[12]: {=bool:?}, triggered[13]: {=bool:?}, triggered[14]: {=bool:?}, triggered[15]: {=bool:?} }}" , self . triggered (0usize) , self . triggered (1usize) , self . triggered (2usize) , self . triggered (3usize) , self . triggered (4usize) , self . triggered (5usize) , self . triggered (6usize) , self . triggered (7usize) , self . triggered (8usize) , self . triggered (9usize) , self . triggered (10usize) , self . triggered (11usize) , self . triggered (12usize) , self . triggered (13usize) , self . triggered (14usize) , self . triggered (15usize))
            }
        }
    }
}
pub mod ficr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ficr {
        ptr: *mut u8,
    }
    unsafe impl Send for Ficr {}
    unsafe impl Sync for Ficr {}
    impl Ficr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Device info"]
        #[inline(always)]
        pub const fn info(self) -> Info {
            unsafe { Info::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Description collection: Common encryption root key, word n"]
        #[inline(always)]
        pub const fn er(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0380usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Common identity root key, word n"]
        #[inline(always)]
        pub const fn ir(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0390usize + n * 4usize) as _)
            }
        }
        #[doc = "Device address type"]
        #[inline(always)]
        pub const fn deviceaddrtype(
            self,
        ) -> crate::common::Reg<regs::Deviceaddrtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03a0usize) as _) }
        }
        #[doc = "Description collection: Device address n"]
        #[inline(always)]
        pub const fn deviceaddr(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03a4usize + n * 4usize) as _)
            }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trimcnf(self, n: usize) -> Trimcnf {
            assert!(n < 64usize);
            unsafe { Trimcnf::from_ptr(self.ptr.wrapping_add(0x0400usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfc(self) -> Nfc {
            unsafe { Nfc::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32mtrim(self) -> crate::common::Reg<regs::Xosc32mtrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0620usize) as _) }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32ktrim(self) -> crate::common::Reg<regs::Xosc32ktrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0624usize) as _) }
        }
    }
    #[doc = "Device info"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Info {
        ptr: *mut u8,
    }
    unsafe impl Send for Info {}
    unsafe impl Sync for Info {}
    impl Info {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration identifier"]
        #[inline(always)]
        pub const fn configid(self) -> crate::common::Reg<regs::Configid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: Device identifier"]
        #[inline(always)]
        pub const fn deviceid(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: 128-bit Universally Unique IDentifier (UUID)."]
        #[inline(always)]
        pub const fn uuid(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
        #[doc = "Part code"]
        #[inline(always)]
        pub const fn part(self) -> crate::common::Reg<regs::Part, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[inline(always)]
        pub const fn variant(self) -> crate::common::Reg<regs::Variant, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Package option"]
        #[inline(always)]
        pub const fn package(self) -> crate::common::Reg<regs::Package, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "RAM size (KB)"]
        #[inline(always)]
        pub const fn ram(self) -> crate::common::Reg<regs::Ram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "RRAM size (KB)"]
        #[inline(always)]
        pub const fn rram(self) -> crate::common::Reg<regs::Rram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfc {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfc {}
    unsafe impl Sync for Nfc {}
    impl Nfc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader0(self) -> crate::common::Reg<regs::Tagheader0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader1(self) -> crate::common::Reg<regs::Tagheader1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader2(self) -> crate::common::Reg<regs::Tagheader2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader3(self) -> crate::common::Reg<regs::Tagheader3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trimcnf {
        ptr: *mut u8,
    }
    unsafe impl Send for Trimcnf {}
    unsafe impl Sync for Trimcnf {}
    impl Trimcnf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Address of the register which will be written"]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Data to be written into the register"]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration identifier"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Configid(pub u32);
        impl Configid {
            #[doc = "Identification number for the HW"]
            #[must_use]
            #[inline(always)]
            pub const fn hwid(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Identification number for the HW"]
            #[inline(always)]
            pub const fn set_hwid(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Configid {
            #[inline(always)]
            fn default() -> Configid {
                Configid(0)
            }
        }
        impl core::fmt::Debug for Configid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Configid")
                    .field("hwid", &self.hwid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Configid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Configid {{ hwid: {=u16:?} }}", self.hwid())
            }
        }
        #[doc = "Device address type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Deviceaddrtype(pub u32);
        impl Deviceaddrtype {
            #[doc = "Device address type"]
            #[must_use]
            #[inline(always)]
            pub const fn deviceaddrtype(&self) -> super::vals::Deviceaddrtype {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Deviceaddrtype::from_bits(val as u8)
            }
            #[doc = "Device address type"]
            #[inline(always)]
            pub const fn set_deviceaddrtype(&mut self, val: super::vals::Deviceaddrtype) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Deviceaddrtype {
            #[inline(always)]
            fn default() -> Deviceaddrtype {
                Deviceaddrtype(0)
            }
        }
        impl core::fmt::Debug for Deviceaddrtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Deviceaddrtype")
                    .field("deviceaddrtype", &self.deviceaddrtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Deviceaddrtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Deviceaddrtype {{ deviceaddrtype: {:?} }}",
                    self.deviceaddrtype()
                )
            }
        }
        #[doc = "Package option"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Package(pub u32);
        impl Package {
            #[doc = "Package option"]
            #[must_use]
            #[inline(always)]
            pub const fn package(&self) -> super::vals::Package {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Package::from_bits(val as u32)
            }
            #[doc = "Package option"]
            #[inline(always)]
            pub const fn set_package(&mut self, val: super::vals::Package) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Package {
            #[inline(always)]
            fn default() -> Package {
                Package(0)
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Package")
                    .field("package", &self.package())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Package {{ package: {:?} }}", self.package())
            }
        }
        #[doc = "Part code"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Part(pub u32);
        impl Part {
            #[doc = "Part code"]
            #[must_use]
            #[inline(always)]
            pub const fn part(&self) -> super::vals::Part {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Part::from_bits(val as u32)
            }
            #[doc = "Part code"]
            #[inline(always)]
            pub const fn set_part(&mut self, val: super::vals::Part) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Part {
            #[inline(always)]
            fn default() -> Part {
                Part(0)
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Part").field("part", &self.part()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Part {{ part: {:?} }}", self.part())
            }
        }
        #[doc = "RAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ram(pub u32);
        impl Ram {
            #[doc = "RAM size (KB)"]
            #[must_use]
            #[inline(always)]
            pub const fn ram(&self) -> super::vals::Ram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Ram::from_bits(val as u32)
            }
            #[doc = "RAM size (KB)"]
            #[inline(always)]
            pub const fn set_ram(&mut self, val: super::vals::Ram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ram {
            #[inline(always)]
            fn default() -> Ram {
                Ram(0)
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ram").field("ram", &self.ram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ram {{ ram: {:?} }}", self.ram())
            }
        }
        #[doc = "RRAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rram(pub u32);
        impl Rram {
            #[doc = "RRAM size (KB)"]
            #[must_use]
            #[inline(always)]
            pub const fn rram(&self) -> super::vals::Rram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rram::from_bits(val as u32)
            }
            #[doc = "RRAM size (KB)"]
            #[inline(always)]
            pub const fn set_rram(&mut self, val: super::vals::Rram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rram {
            #[inline(always)]
            fn default() -> Rram {
                Rram(0)
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rram").field("rram", &self.rram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rram {{ rram: {:?} }}", self.rram())
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader0(pub u32);
        impl Tagheader0 {
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[must_use]
            #[inline(always)]
            pub const fn mfgid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[inline(always)]
            pub const fn set_mfgid(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ud1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 1"]
            #[inline(always)]
            pub const fn set_ud1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ud2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 2"]
            #[inline(always)]
            pub const fn set_ud2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ud3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 3"]
            #[inline(always)]
            pub const fn set_ud3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader0 {
            #[inline(always)]
            fn default() -> Tagheader0 {
                Tagheader0(0)
            }
        }
        impl core::fmt::Debug for Tagheader0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader0")
                    .field("mfgid", &self.mfgid())
                    .field("ud1", &self.ud1())
                    .field("ud2", &self.ud2())
                    .field("ud3", &self.ud3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader0 {{ mfgid: {=u8:?}, ud1: {=u8:?}, ud2: {=u8:?}, ud3: {=u8:?} }}",
                    self.mfgid(),
                    self.ud1(),
                    self.ud2(),
                    self.ud3()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader1(pub u32);
        impl Tagheader1 {
            #[doc = "Unique identifier byte 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ud4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 4"]
            #[inline(always)]
            pub const fn set_ud4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ud5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 5"]
            #[inline(always)]
            pub const fn set_ud5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ud6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 6"]
            #[inline(always)]
            pub const fn set_ud6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ud7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 7"]
            #[inline(always)]
            pub const fn set_ud7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader1 {
            #[inline(always)]
            fn default() -> Tagheader1 {
                Tagheader1(0)
            }
        }
        impl core::fmt::Debug for Tagheader1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader1")
                    .field("ud4", &self.ud4())
                    .field("ud5", &self.ud5())
                    .field("ud6", &self.ud6())
                    .field("ud7", &self.ud7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader1 {{ ud4: {=u8:?}, ud5: {=u8:?}, ud6: {=u8:?}, ud7: {=u8:?} }}",
                    self.ud4(),
                    self.ud5(),
                    self.ud6(),
                    self.ud7()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader2(pub u32);
        impl Tagheader2 {
            #[doc = "Unique identifier byte 8"]
            #[must_use]
            #[inline(always)]
            pub const fn ud8(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 8"]
            #[inline(always)]
            pub const fn set_ud8(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 9"]
            #[must_use]
            #[inline(always)]
            pub const fn ud9(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 9"]
            #[inline(always)]
            pub const fn set_ud9(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 10"]
            #[must_use]
            #[inline(always)]
            pub const fn ud10(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 10"]
            #[inline(always)]
            pub const fn set_ud10(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 11"]
            #[must_use]
            #[inline(always)]
            pub const fn ud11(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 11"]
            #[inline(always)]
            pub const fn set_ud11(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader2 {
            #[inline(always)]
            fn default() -> Tagheader2 {
                Tagheader2(0)
            }
        }
        impl core::fmt::Debug for Tagheader2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader2")
                    .field("ud8", &self.ud8())
                    .field("ud9", &self.ud9())
                    .field("ud10", &self.ud10())
                    .field("ud11", &self.ud11())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader2 {{ ud8: {=u8:?}, ud9: {=u8:?}, ud10: {=u8:?}, ud11: {=u8:?} }}",
                    self.ud8(),
                    self.ud9(),
                    self.ud10(),
                    self.ud11()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader3(pub u32);
        impl Tagheader3 {
            #[doc = "Unique identifier byte 12"]
            #[must_use]
            #[inline(always)]
            pub const fn ud12(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 12"]
            #[inline(always)]
            pub const fn set_ud12(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 13"]
            #[must_use]
            #[inline(always)]
            pub const fn ud13(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 13"]
            #[inline(always)]
            pub const fn set_ud13(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 14"]
            #[must_use]
            #[inline(always)]
            pub const fn ud14(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 14"]
            #[inline(always)]
            pub const fn set_ud14(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 15"]
            #[must_use]
            #[inline(always)]
            pub const fn ud15(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 15"]
            #[inline(always)]
            pub const fn set_ud15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader3 {
            #[inline(always)]
            fn default() -> Tagheader3 {
                Tagheader3(0)
            }
        }
        impl core::fmt::Debug for Tagheader3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader3")
                    .field("ud12", &self.ud12())
                    .field("ud13", &self.ud13())
                    .field("ud14", &self.ud14())
                    .field("ud15", &self.ud15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader3 {{ ud12: {=u8:?}, ud13: {=u8:?}, ud14: {=u8:?}, ud15: {=u8:?} }}",
                    self.ud12(),
                    self.ud13(),
                    self.ud14(),
                    self.ud15()
                )
            }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Variant(pub u32);
        impl Variant {
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[must_use]
            #[inline(always)]
            pub const fn variant(&self) -> super::vals::Variant {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Variant::from_bits(val as u32)
            }
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[inline(always)]
            pub const fn set_variant(&mut self, val: super::vals::Variant) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Variant {
            #[inline(always)]
            fn default() -> Variant {
                Variant(0)
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Variant")
                    .field("variant", &self.variant())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Variant {{ variant: {:?} }}", self.variant())
            }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32ktrim(pub u32);
        impl Xosc32ktrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[must_use]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[must_use]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32ktrim {
            #[inline(always)]
            fn default() -> Xosc32ktrim {
                Xosc32ktrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32ktrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32ktrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32ktrim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Xosc32ktrim {{ slope: {=u16:?}, offset: {=u16:?} }}",
                    self.slope(),
                    self.offset()
                )
            }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32mtrim(pub u32);
        impl Xosc32mtrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[must_use]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[must_use]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32mtrim {
            #[inline(always)]
            fn default() -> Xosc32mtrim {
                Xosc32mtrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32mtrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32mtrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32mtrim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Xosc32mtrim {{ slope: {=u16:?}, offset: {=u16:?} }}",
                    self.slope(),
                    self.offset()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Deviceaddrtype {
            #[doc = "Public address"]
            PUBLIC = 0x0,
            #[doc = "Random address"]
            RANDOM = 0x01,
        }
        impl Deviceaddrtype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Deviceaddrtype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Deviceaddrtype {
            #[inline(always)]
            fn from(val: u8) -> Deviceaddrtype {
                Deviceaddrtype::from_bits(val)
            }
        }
        impl From<Deviceaddrtype> for u8 {
            #[inline(always)]
            fn from(val: Deviceaddrtype) -> u8 {
                Deviceaddrtype::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Package(u32);
        impl Package {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Package {
            pub const fn from_bits(val: u32) -> Package {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Package {
            #[inline(always)]
            fn from(val: u32) -> Package {
                Package::from_bits(val)
            }
        }
        impl From<Package> for u32 {
            #[inline(always)]
            fn from(val: Package) -> u32 {
                Package::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Part(u32);
        impl Part {
            #[doc = "nRF54LM20A"]
            pub const N54LM20A: Self = Self(0x054b_c20a);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Part {
            pub const fn from_bits(val: u32) -> Part {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x054b_c20a => f.write_str("N54LM20A"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x054b_c20a => defmt::write!(f, "N54LM20A"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Part {
            #[inline(always)]
            fn from(val: u32) -> Part {
                Part::from_bits(val)
            }
        }
        impl From<Part> for u32 {
            #[inline(always)]
            fn from(val: Part) -> u32 {
                Part::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ram(u32);
        impl Ram {
            #[doc = "512 kByte RAM"]
            pub const K512: Self = Self(0x0200);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Ram {
            pub const fn from_bits(val: u32) -> Ram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0200 => f.write_str("K512"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0200 => defmt::write!(f, "K512"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Ram {
            #[inline(always)]
            fn from(val: u32) -> Ram {
                Ram::from_bits(val)
            }
        }
        impl From<Ram> for u32 {
            #[inline(always)]
            fn from(val: Ram) -> u32 {
                Ram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rram(u32);
        impl Rram {
            #[doc = "2036 KByte RRAM"]
            pub const K2036: Self = Self(0x07f4);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Rram {
            pub const fn from_bits(val: u32) -> Rram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x07f4 => f.write_str("K2036"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x07f4 => defmt::write!(f, "K2036"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rram {
            #[inline(always)]
            fn from(val: u32) -> Rram {
                Rram::from_bits(val)
            }
        }
        impl From<Rram> for u32 {
            #[inline(always)]
            fn from(val: Rram) -> u32 {
                Rram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Variant(u32);
        impl Variant {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Variant {
            pub const fn from_bits(val: u32) -> Variant {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Variant {
            #[inline(always)]
            fn from(val: u32) -> Variant {
                Variant::from_bits(val)
            }
        }
        impl From<Variant> for u32 {
            #[inline(always)]
            fn from(val: Variant) -> u32 {
                Variant::to_bits(val)
            }
        }
    }
}
pub mod glitchdet {
    #[doc = "Voltage glitch detectors"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchdet {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchdet {}
    unsafe impl Sync for Glitchdet {}
    impl Glitchdet {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration for glitch detector"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05a0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration for glitch detector"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable glitch detector"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable glitch detector"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Glitch detector mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Glitch detector mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable", &self.enable())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ enable: {=bool:?}, mode: {:?} }}",
                    self.enable(),
                    self.mode()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "High pass filter mode"]
            HIGH_PASS_FILTER = 0x0,
            #[doc = "Cap divider mode"]
            CAP_DIV = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Write GPIO port"]
        #[inline(always)]
        pub const fn out(self) -> crate::common::Reg<regs::Out, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outset(self) -> crate::common::Reg<regs::Outset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outclr(self) -> crate::common::Reg<regs::Outclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Read GPIO port"]
        #[inline(always)]
        pub const fn in_(self) -> crate::common::Reg<regs::In, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Direction of GPIO pins"]
        #[inline(always)]
        pub const fn dir(self) -> crate::common::Reg<regs::Dir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "DIR set register"]
        #[inline(always)]
        pub const fn dirset(self) -> crate::common::Reg<regs::Dirset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "DIR clear register"]
        #[inline(always)]
        pub const fn dirclr(self) -> crate::common::Reg<regs::Dirclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[inline(always)]
        pub const fn latch(self) -> crate::common::Reg<regs::Latch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[inline(always)]
        pub const fn detectmode(self) -> crate::common::Reg<regs::Detectmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[inline(always)]
        pub const fn pin_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PinCnf, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Detectmode(pub u32);
        impl Detectmode {
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[must_use]
            #[inline(always)]
            pub const fn detectmode(&self) -> super::vals::Detectmode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detectmode::from_bits(val as u8)
            }
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub const fn set_detectmode(&mut self, val: super::vals::Detectmode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Detectmode {
            #[inline(always)]
            fn default() -> Detectmode {
                Detectmode(0)
            }
        }
        impl core::fmt::Debug for Detectmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Detectmode")
                    .field("detectmode", &self.detectmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Detectmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Detectmode {{ detectmode: {:?} }}", self.detectmode())
            }
        }
        #[doc = "Direction of GPIO pins"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dir(pub u32);
        impl Dir {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> super::vals::Dir {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: super::vals::Dir) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
            }
        }
        impl Default for Dir {
            #[inline(always)]
            fn default() -> Dir {
                Dir(0)
            }
        }
        impl core::fmt::Debug for Dir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dir")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dir {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dir {{ pin[0]: {:?}, pin[1]: {:?}, pin[2]: {:?}, pin[3]: {:?}, pin[4]: {:?}, pin[5]: {:?}, pin[6]: {:?}, pin[7]: {:?}, pin[8]: {:?}, pin[9]: {:?}, pin[10]: {:?}, pin[11]: {:?}, pin[12]: {:?}, pin[13]: {:?}, pin[14]: {:?}, pin[15]: {:?}, pin[16]: {:?}, pin[17]: {:?}, pin[18]: {:?}, pin[19]: {:?}, pin[20]: {:?}, pin[21]: {:?}, pin[22]: {:?}, pin[23]: {:?}, pin[24]: {:?}, pin[25]: {:?}, pin[26]: {:?}, pin[27]: {:?}, pin[28]: {:?}, pin[29]: {:?}, pin[30]: {:?}, pin[31]: {:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR clear register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirclr(pub u32);
        impl Dirclr {
            #[doc = "Set as input pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as input pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirclr {
            #[inline(always)]
            fn default() -> Dirclr {
                Dirclr(0)
            }
        }
        impl core::fmt::Debug for Dirclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR set register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirset(pub u32);
        impl Dirset {
            #[doc = "Set as output pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as output pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirset {
            #[inline(always)]
            fn default() -> Dirset {
                Dirset(0)
            }
        }
        impl core::fmt::Debug for Dirset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Read GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct In(pub u32);
        impl In {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for In {
            #[inline(always)]
            fn default() -> In {
                In(0)
            }
        }
        impl core::fmt::Debug for In {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("In")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for In {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "In {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Latch(pub u32);
        impl Latch {
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Latch {
            #[inline(always)]
            fn default() -> Latch {
                Latch(0)
            }
        }
        impl core::fmt::Debug for Latch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Latch")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Latch {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Latch {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Write GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Out(pub u32);
        impl Out {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Out {
            #[inline(always)]
            fn default() -> Out {
                Out(0)
            }
        }
        impl core::fmt::Debug for Out {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Out")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Out {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Out {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outclr(pub u32);
        impl Outclr {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outclr {
            #[inline(always)]
            fn default() -> Outclr {
                Outclr(0)
            }
        }
        impl core::fmt::Debug for Outclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outset(pub u32);
        impl Outset {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outset {
            #[inline(always)]
            fn default() -> Outset {
                Outset(0)
            }
        }
        impl core::fmt::Debug for Outset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PinCnf(pub u32);
        impl PinCnf {
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[must_use]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[inline(always)]
            pub const fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Connect or disconnect input buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn input(&self) -> super::vals::Input {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Input::from_bits(val as u8)
            }
            #[doc = "Connect or disconnect input buffer"]
            #[inline(always)]
            pub const fn set_input(&mut self, val: super::vals::Input) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pull configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn pull(&self) -> super::vals::Pull {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Pull::from_bits(val as u8)
            }
            #[doc = "Pull configuration"]
            #[inline(always)]
            pub const fn set_pull(&mut self, val: super::vals::Pull) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Drive configuration for '0'"]
            #[must_use]
            #[inline(always)]
            pub const fn drive0(&self) -> super::vals::Drive {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '0'"]
            #[inline(always)]
            pub const fn set_drive0(&mut self, val: super::vals::Drive) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Drive configuration for '1'"]
            #[must_use]
            #[inline(always)]
            pub const fn drive1(&self) -> super::vals::Drive {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '1'"]
            #[inline(always)]
            pub const fn set_drive1(&mut self, val: super::vals::Drive) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Pin sensing mechanism"]
            #[must_use]
            #[inline(always)]
            pub const fn sense(&self) -> super::vals::Sense {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Sense::from_bits(val as u8)
            }
            #[doc = "Pin sensing mechanism"]
            #[inline(always)]
            pub const fn set_sense(&mut self, val: super::vals::Sense) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Select which module has direct control over this pin"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlsel(&self) -> super::vals::Ctrlsel {
                let val = (self.0 >> 28usize) & 0x07;
                super::vals::Ctrlsel::from_bits(val as u8)
            }
            #[doc = "Select which module has direct control over this pin"]
            #[inline(always)]
            pub const fn set_ctrlsel(&mut self, val: super::vals::Ctrlsel) {
                self.0 =
                    (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
            }
        }
        impl Default for PinCnf {
            #[inline(always)]
            fn default() -> PinCnf {
                PinCnf(0)
            }
        }
        impl core::fmt::Debug for PinCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PinCnf")
                    .field("dir", &self.dir())
                    .field("input", &self.input())
                    .field("pull", &self.pull())
                    .field("drive0", &self.drive0())
                    .field("drive1", &self.drive1())
                    .field("sense", &self.sense())
                    .field("ctrlsel", &self.ctrlsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PinCnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PinCnf {{ dir: {:?}, input: {:?}, pull: {:?}, drive0: {:?}, drive1: {:?}, sense: {:?}, ctrlsel: {:?} }}" , self . dir () , self . input () , self . pull () , self . drive0 () , self . drive1 () , self . sense () , self . ctrlsel ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrlsel {
            #[doc = "GPIO or peripherals with PSEL registers"]
            GPIO = 0x0,
            #[doc = "VPR processor"]
            VPR = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "GRTC peripheral"]
            GRTC = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrlsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrlsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrlsel {
            #[inline(always)]
            fn from(val: u8) -> Ctrlsel {
                Ctrlsel::from_bits(val)
            }
        }
        impl From<Ctrlsel> for u8 {
            #[inline(always)]
            fn from(val: Ctrlsel) -> u8 {
                Ctrlsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detectmode {
            #[doc = "DETECT directly connected to PIN DETECT signals"]
            DEFAULT = 0x0,
            #[doc = "Use the latched LDETECT behavior"]
            LDETECT = 0x01,
        }
        impl Detectmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detectmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detectmode {
            #[inline(always)]
            fn from(val: u8) -> Detectmode {
                Detectmode::from_bits(val)
            }
        }
        impl From<Detectmode> for u8 {
            #[inline(always)]
            fn from(val: Detectmode) -> u8 {
                Detectmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            #[doc = "Configure pin as an input pin"]
            INPUT = 0x0,
            #[doc = "Configure pin as an output pin"]
            OUTPUT = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drive {
            #[doc = "Standard '0'"]
            S = 0x0,
            #[doc = "High drive '0'"]
            H = 0x01,
            #[doc = "Disconnect '0'(normally used for wired-or connections)"]
            D = 0x02,
            #[doc = "Extra high drive '0'"]
            E = 0x03,
        }
        impl Drive {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drive {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drive {
            #[inline(always)]
            fn from(val: u8) -> Drive {
                Drive::from_bits(val)
            }
        }
        impl From<Drive> for u8 {
            #[inline(always)]
            fn from(val: Drive) -> u8 {
                Drive::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Input {
            #[doc = "Connect input buffer"]
            CONNECT = 0x0,
            #[doc = "Disconnect input buffer"]
            DISCONNECT = 0x01,
        }
        impl Input {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Input {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Input {
            #[inline(always)]
            fn from(val: u8) -> Input {
                Input::from_bits(val)
            }
        }
        impl From<Input> for u8 {
            #[inline(always)]
            fn from(val: Input) -> u8 {
                Input::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pull {
            #[doc = "No pull"]
            DISABLED = 0x0,
            #[doc = "Pull down on pin"]
            PULLDOWN = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Pull up on pin"]
            PULLUP = 0x03,
        }
        impl Pull {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pull {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pull {
            #[inline(always)]
            fn from(val: u8) -> Pull {
                Pull::from_bits(val)
            }
        }
        impl From<Pull> for u8 {
            #[inline(always)]
            fn from(val: Pull) -> u8 {
                Pull::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sense {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Sense for high level"]
            HIGH = 0x02,
            #[doc = "Sense for low level"]
            LOW = 0x03,
        }
        impl Sense {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sense {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sense {
            #[inline(always)]
            fn from(val: u8) -> Sense {
                Sense::from_bits(val)
            }
        }
        impl From<Sense> for u8 {
            #[inline(always)]
            fn from(val: Sense) -> u8 {
                Sense::to_bits(val)
            }
        }
    }
}
pub mod gpiohspadctrl {
    #[doc = "GPIO high-speed pad control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiohspadctrl {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiohspadctrl {}
    unsafe impl Sync for Gpiohspadctrl {}
    impl Gpiohspadctrl {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Bias control"]
        #[inline(always)]
        pub const fn bias(self) -> crate::common::Reg<regs::Bias, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Input sampling and buffering control (used by the VPR coprocessor for emulating a QSPI peripheral)"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Bias control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bias(pub u32);
        impl Bias {
            #[doc = "Slew setting for high-speed pad (higher value is faster)"]
            #[must_use]
            #[inline(always)]
            pub const fn hsbias(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Slew setting for high-speed pad (higher value is faster)"]
            #[inline(always)]
            pub const fn set_hsbias(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Slew setting for replica clock (used by the VPR coprocessor for emulating a QSPI peripheral)"]
            #[must_use]
            #[inline(always)]
            pub const fn replicabias(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Slew setting for replica clock (used by the VPR coprocessor for emulating a QSPI peripheral)"]
            #[inline(always)]
            pub const fn set_replicabias(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Bias {
            #[inline(always)]
            fn default() -> Bias {
                Bias(0)
            }
        }
        impl core::fmt::Debug for Bias {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bias")
                    .field("hsbias", &self.hsbias())
                    .field("replicabias", &self.replicabias())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bias {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Bias {{ hsbias: {=u8:?}, replicabias: {=bool:?} }}",
                    self.hsbias(),
                    self.replicabias()
                )
            }
        }
        #[doc = "Input sampling and buffering control (used by the VPR coprocessor for emulating a QSPI peripheral)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "Delay selection"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdelay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Delay selection"]
            #[inline(always)]
            pub const fn set_rxdelay(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Enable SCK"]
            #[must_use]
            #[inline(always)]
            pub const fn scken(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable SCK"]
            #[inline(always)]
            pub const fn set_scken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "SCK phase"]
            #[must_use]
            #[inline(always)]
            pub const fn sckphase(&self) -> super::vals::Sckphase {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Sckphase::from_bits(val as u8)
            }
            #[doc = "SCK phase"]
            #[inline(always)]
            pub const fn set_sckphase(&mut self, val: super::vals::Sckphase) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable CSN synchronization of sampling"]
            #[must_use]
            #[inline(always)]
            pub const fn csnen(&self) -> super::vals::Csnen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Csnen::from_bits(val as u8)
            }
            #[doc = "Enable CSN synchronization of sampling"]
            #[inline(always)]
            pub const fn set_csnen(&mut self, val: super::vals::Csnen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable delayed sampling"]
            #[must_use]
            #[inline(always)]
            pub const fn dataenable(&self) -> super::vals::Dataenable {
                let val = (self.0 >> 6usize) & 0x0f;
                super::vals::Dataenable::from_bits(val as u8)
            }
            #[doc = "Enable delayed sampling"]
            #[inline(always)]
            pub const fn set_dataenable(&mut self, val: super::vals::Dataenable) {
                self.0 = (self.0 & !(0x0f << 6usize)) | (((val.to_bits() as u32) & 0x0f) << 6usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("rxdelay", &self.rxdelay())
                    .field("scken", &self.scken())
                    .field("sckphase", &self.sckphase())
                    .field("csnen", &self.csnen())
                    .field("dataenable", &self.dataenable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ rxdelay: {=u8:?}, scken: {=bool:?}, sckphase: {:?}, csnen: {:?}, dataenable: {:?} }}" , self . rxdelay () , self . scken () , self . sckphase () , self . csnen () , self . dataenable ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csnen {
            #[doc = "Delay chain is reset on active edge of CSN"]
            ENABLED = 0x0,
            #[doc = "Delay chain is not reset on active edge of CSN"]
            DISABLED = 0x01,
        }
        impl Csnen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csnen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csnen {
            #[inline(always)]
            fn from(val: u8) -> Csnen {
                Csnen::from_bits(val)
            }
        }
        impl From<Csnen> for u8 {
            #[inline(always)]
            fn from(val: Csnen) -> u8 {
                Csnen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dataenable {
            #[doc = "Delayed sampling is disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Delayed sampling is enabled"]
            ENABLED = 0x0f,
        }
        impl Dataenable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dataenable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dataenable {
            #[inline(always)]
            fn from(val: u8) -> Dataenable {
                Dataenable::from_bits(val)
            }
        }
        impl From<Dataenable> for u8 {
            #[inline(always)]
            fn from(val: Dataenable) -> u8 {
                Dataenable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckphase {
            #[doc = "Invert SCK phase"]
            INVERTED = 0x0,
            #[doc = "Non-inverted SCK phase"]
            NON_INVERTED = 0x01,
        }
        impl Sckphase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckphase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckphase {
            #[inline(always)]
            fn from(val: u8) -> Sckphase {
                Sckphase::from_bits(val)
            }
        }
        impl From<Sckphase> for u8 {
            #[inline(always)]
            fn from(val: Sckphase) -> u8 {
                Sckphase::to_bits(val)
            }
        }
    }
}
pub mod gpiote {
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsPort {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsPort {}
    unsafe impl Sync for EventsPort {}
    impl EventsPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Non-secure port event"]
        #[inline(always)]
        pub const fn nonsecure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Secure port event"]
        #[inline(always)]
        pub const fn secure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "GPIO Tasks and Events 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is configured in CONFIG\\[n\\].POLARITY."]
        #[inline(always)]
        pub const fn tasks_out(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it high."]
        #[inline(always)]
        pub const fn tasks_set(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it low."]
        #[inline(always)]
        pub const fn tasks_clr(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task OUT\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task SET\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_set(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task CLR\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_clr(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Event from pin specified in CONFIG\\[n\\].PSEL"]
        #[inline(always)]
        pub const fn events_in(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_port(self, n: usize) -> EventsPort {
            assert!(n < 1usize);
            unsafe { EventsPort::from_ptr(self.ptr.wrapping_add(0x0140usize + n * 8usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event IN\\[n\\]"]
        #[inline(always)]
        pub const fn publish_in(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_port(self, n: usize) -> PublishPort {
            assert!(n < 1usize);
            unsafe { PublishPort::from_ptr(self.ptr.wrapping_add(0x01c0usize + n * 8usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize + n * 16usize) as _)
            }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize + n * 16usize) as _)
            }
        }
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[inline(always)]
        pub const fn config(self, n: usize) -> crate::common::Reg<regs::Config, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishPort {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishPort {}
    unsafe impl Sync for PublishPort {}
    impl PublishPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].NONSECURE"]
        #[inline(always)]
        pub const fn nonsecure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].SECURE"]
        #[inline(always)]
        pub const fn secure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[must_use]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[inline(always)]
            pub const fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 4usize)) | (((val as u32) & 0x1f) << 4usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x0f;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val as u32) & 0x0f) << 9usize);
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[must_use]
            #[inline(always)]
            pub const fn polarity(&self) -> super::vals::Polarity {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Polarity::from_bits(val as u8)
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[inline(always)]
            pub const fn set_polarity(&mut self, val: super::vals::Polarity) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[must_use]
            #[inline(always)]
            pub const fn outinit(&self) -> super::vals::Outinit {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Outinit::from_bits(val as u8)
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[inline(always)]
            pub const fn set_outinit(&mut self, val: super::vals::Outinit) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("mode", &self.mode())
                    .field("psel", &self.psel())
                    .field("port", &self.port())
                    .field("polarity", &self.polarity())
                    .field("outinit", &self.outinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ mode: {:?}, psel: {=u8:?}, port: {=u8:?}, polarity: {:?}, outinit: {:?} }}" , self . mode () , self . psel () , self . port () , self . polarity () , self . outinit ())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn in_(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[inline(always)]
            pub const fn set_in_(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[must_use]
            #[inline(always)]
            pub const fn port0nonsecure(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[inline(always)]
            pub const fn set_port0nonsecure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[must_use]
            #[inline(always)]
            pub const fn port0secure(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[inline(always)]
            pub const fn set_port0secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("in_[0]", &self.in_(0usize))
                    .field("in_[1]", &self.in_(1usize))
                    .field("in_[2]", &self.in_(2usize))
                    .field("in_[3]", &self.in_(3usize))
                    .field("in_[4]", &self.in_(4usize))
                    .field("in_[5]", &self.in_(5usize))
                    .field("in_[6]", &self.in_(6usize))
                    .field("in_[7]", &self.in_(7usize))
                    .field("port0nonsecure", &self.port0nonsecure())
                    .field("port0secure", &self.port0secure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ in_[0]: {=bool:?}, in_[1]: {=bool:?}, in_[2]: {=bool:?}, in_[3]: {=bool:?}, in_[4]: {=bool:?}, in_[5]: {=bool:?}, in_[6]: {=bool:?}, in_[7]: {=bool:?}, port0nonsecure: {=bool:?}, port0secure: {=bool:?} }}" , self . in_ (0usize) , self . in_ (1usize) , self . in_ (2usize) , self . in_ (3usize) , self . in_ (4usize) , self . in_ (5usize) , self . in_ (6usize) , self . in_ (7usize) , self . port0nonsecure () , self . port0secure ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module."]
            DISABLED = 0x0,
            #[doc = "Event mode"]
            EVENT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Task mode"]
            TASK = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outinit {
            #[doc = "Task mode: Initial value of pin before task triggering is low"]
            LOW = 0x0,
            #[doc = "Task mode: Initial value of pin before task triggering is high"]
            HIGH = 0x01,
        }
        impl Outinit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outinit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outinit {
            #[inline(always)]
            fn from(val: u8) -> Outinit {
                Outinit::from_bits(val)
            }
        }
        impl From<Outinit> for u8 {
            #[inline(always)]
            fn from(val: Outinit) -> u8 {
                Outinit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Polarity {
            #[doc = "Task mode: No effect on pin from OUT\\[n\\] task. Event mode: no IN\\[n\\] event generated on pin activity."]
            NONE = 0x0,
            #[doc = "Task mode: Set pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when rising edge on pin."]
            LO_TO_HI = 0x01,
            #[doc = "Task mode: Clear pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when falling edge on pin."]
            HI_TO_LO = 0x02,
            #[doc = "Task mode: Toggle pin from OUT\\[n\\]. Event mode: Generate IN\\[n\\] when any change on pin."]
            TOGGLE = 0x03,
        }
        impl Polarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Polarity {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Polarity {
            #[inline(always)]
            fn from(val: u8) -> Polarity {
                Polarity::from_bits(val)
            }
        }
        impl From<Polarity> for u8 {
            #[inline(always)]
            fn from(val: Polarity) -> u8 {
                Polarity::to_bits(val)
            }
        }
    }
}
pub mod grtc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cc {
        ptr: *mut u8,
    }
    unsafe impl Send for Cc {}
    unsafe impl Sync for Cc {}
    impl Cc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn cch(self) -> crate::common::Reg<regs::Cch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[inline(always)]
        pub const fn ccadd(self) -> crate::common::Reg<regs::Ccadd, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccen(self) -> crate::common::Reg<regs::Ccen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Global Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Capture the counter value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Start the counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize) as _) }
        }
        #[doc = "Stop the counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x64usize) as _) }
        }
        #[doc = "Clear the counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x68usize) as _) }
        }
        #[doc = "Start the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x6cusize) as _) }
        }
        #[doc = "Stop the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x70usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 12usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 12usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "The GRTC low frequency timer is synchronized with the SYSCOUNTER"]
        #[inline(always)]
        pub const fn events_rtcomparesync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0164usize) as _) }
        }
        #[doc = "Event on end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x016cusize) as _) }
        }
        #[doc = "Event on STATUS.PWM.READY status changed to ready"]
        #[inline(always)]
        pub const fn events_pwmready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0174usize) as _) }
        }
        #[doc = "Event on STATUS.CLKOUT.READY status changed to ready"]
        #[inline(always)]
        pub const fn events_clkoutready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0178usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 12usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event PWMREADY"]
        #[inline(always)]
        pub const fn publish_pwmready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01f4usize) as _) }
        }
        #[doc = "Publish configuration for event CLKOUTREADY"]
        #[inline(always)]
        pub const fn publish_clkoutready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01f8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize + n * 16usize) as _)
            }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize + n * 16usize) as _)
            }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize + n * 16usize) as _)
            }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize + n * 16usize) as _)
            }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0408usize) as _) }
        }
        #[doc = "Counter mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> Cc {
            assert!(n < 12usize);
            unsafe { Cc::from_ptr(self.ptr.wrapping_add(0x0520usize + n * 16usize) as _) }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[inline(always)]
        pub const fn timeout(self) -> crate::common::Reg<regs::Timeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x06a4usize) as _) }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[inline(always)]
        pub const fn interval(self) -> crate::common::Reg<regs::Interval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x06a8usize) as _) }
        }
        #[doc = "GRTC wake up time."]
        #[inline(always)]
        pub const fn waketime(self) -> crate::common::Reg<regs::Waketime, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x06acusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn status(self) -> Status {
            unsafe { Status::from_ptr(self.ptr.wrapping_add(0x06b0usize) as _) }
        }
        #[doc = "PWM configuration."]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0710usize) as _) }
        }
        #[doc = "Configuration of clock output"]
        #[inline(always)]
        pub const fn clkout(self) -> crate::common::Reg<regs::GrtcClkout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0714usize) as _) }
        }
        #[doc = "Clock Configuration"]
        #[inline(always)]
        pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0718usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn syscounter(self, n: usize) -> Syscounter {
            assert!(n < 4usize);
            unsafe { Syscounter::from_ptr(self.ptr.wrapping_add(0x0720usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Status {
        ptr: *mut u8,
    }
    unsafe impl Send for Status {}
    unsafe impl Sync for Status {}
    impl Status {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Low frequency timer status."]
        #[inline(always)]
        pub const fn lftimer(self) -> crate::common::Reg<regs::Lftimer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "PWM status."]
        #[inline(always)]
        pub const fn pwm(self) -> crate::common::Reg<regs::Pwm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "CLKOUT configuration status."]
        #[inline(always)]
        pub const fn clkout(self) -> crate::common::Reg<regs::StatusClkout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Syscounter {
        ptr: *mut u8,
    }
    unsafe impl Send for Syscounter {}
    unsafe impl Sync for Syscounter {}
    impl Syscounter {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterl(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterh(self) -> crate::common::Reg<regs::Syscounterh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[inline(always)]
        pub const fn active(self) -> crate::common::Reg<regs::Active, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Active(pub u32);
        impl Active {
            #[doc = "Keep SYSCOUNTER in active state"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep SYSCOUNTER in active state"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Active {
            #[inline(always)]
            fn default() -> Active {
                Active(0)
            }
        }
        impl core::fmt::Debug for Active {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Active")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Active {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Active {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccadd(pub u32);
        impl Ccadd {
            #[doc = "Count to add to CC\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Count to add to CC\\[n\\]"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
            #[doc = "Configure the Capture/Compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn reference(&self) -> super::vals::Reference {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Reference::from_bits(val as u8)
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn set_reference(&mut self, val: super::vals::Reference) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ccadd {
            #[inline(always)]
            fn default() -> Ccadd {
                Ccadd(0)
            }
        }
        impl core::fmt::Debug for Ccadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccadd")
                    .field("value", &self.value())
                    .field("reference", &self.reference())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccadd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ccadd {{ value: {=u32:?}, reference: {:?} }}",
                    self.value(),
                    self.reference()
                )
            }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccen(pub u32);
        impl Ccen {
            #[doc = "Configure the Capture/Compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Status of event EVENTS_COMPARE\\[n\\] caused by the configured CC value is in past"]
            #[must_use]
            #[inline(always)]
            pub const fn pastcc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Status of event EVENTS_COMPARE\\[n\\] caused by the configured CC value is in past"]
            #[inline(always)]
            pub const fn set_pastcc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ccen {
            #[inline(always)]
            fn default() -> Ccen {
                Ccen(0)
            }
        }
        impl core::fmt::Debug for Ccen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccen")
                    .field("active", &self.active())
                    .field("pastcc", &self.pastcc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ccen {{ active: {=bool:?}, pastcc: {=bool:?} }}",
                    self.active(),
                    self.pastcc()
                )
            }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cch(pub u32);
        impl Cch {
            #[doc = "Capture/Compare high value in 1 us"]
            #[must_use]
            #[inline(always)]
            pub const fn cch(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Capture/Compare high value in 1 us"]
            #[inline(always)]
            pub const fn set_cch(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Cch {
            #[inline(always)]
            fn default() -> Cch {
                Cch(0)
            }
        }
        impl core::fmt::Debug for Cch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cch").field("cch", &self.cch()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cch {{ cch: {=u32:?} }}", self.cch())
            }
        }
        #[doc = "Clock Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkcfg(pub u32);
        impl Clkcfg {
            #[doc = "Fast clock divisor value of clock output"]
            #[must_use]
            #[inline(always)]
            pub const fn clkfastdiv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fast clock divisor value of clock output"]
            #[inline(always)]
            pub const fn set_clkfastdiv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn clksel(&self) -> super::vals::Clksel {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Clksel::from_bits(val as u8)
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[inline(always)]
            pub const fn set_clksel(&mut self, val: super::vals::Clksel) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
        }
        impl Default for Clkcfg {
            #[inline(always)]
            fn default() -> Clkcfg {
                Clkcfg(0)
            }
        }
        impl core::fmt::Debug for Clkcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkcfg")
                    .field("clkfastdiv", &self.clkfastdiv())
                    .field("clksel", &self.clksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clkcfg {{ clkfastdiv: {=u8:?}, clksel: {:?} }}",
                    self.clkfastdiv(),
                    self.clksel()
                )
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("pwmperiodend", &self.pwmperiodend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Evt {{ pwmperiodend: {=bool:?} }}", self.pwmperiodend())
            }
        }
        #[doc = "Configuration of clock output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GrtcClkout(pub u32);
        impl GrtcClkout {
            #[doc = "Enable 32Ki clock output on pin"]
            #[must_use]
            #[inline(always)]
            pub const fn clkout32k(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32Ki clock output on pin"]
            #[inline(always)]
            pub const fn set_clkout32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable fast clock output on pin"]
            #[must_use]
            #[inline(always)]
            pub const fn clkoutfast(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable fast clock output on pin"]
            #[inline(always)]
            pub const fn set_clkoutfast(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for GrtcClkout {
            #[inline(always)]
            fn default() -> GrtcClkout {
                GrtcClkout(0)
            }
        }
        impl core::fmt::Debug for GrtcClkout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GrtcClkout")
                    .field("clkout32k", &self.clkout32k())
                    .field("clkoutfast", &self.clkoutfast())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GrtcClkout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GrtcClkout {{ clkout32k: {=bool:?}, clkoutfast: {=bool:?} }}",
                    self.clkout32k(),
                    self.clkoutfast()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[inline(always)]
            pub const fn set_compare1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[inline(always)]
            pub const fn set_compare2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[inline(always)]
            pub const fn set_compare3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[inline(always)]
            pub const fn set_compare4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[inline(always)]
            pub const fn set_compare5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[inline(always)]
            pub const fn set_compare6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[inline(always)]
            pub const fn set_compare7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[inline(always)]
            pub const fn set_compare8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[inline(always)]
            pub const fn set_compare9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[inline(always)]
            pub const fn set_compare10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[inline(always)]
            pub const fn set_compare11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[must_use]
            #[inline(always)]
            pub const fn rtcomparesync(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[inline(always)]
            pub const fn set_rtcomparesync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event PWMREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmready(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMREADY"]
            #[inline(always)]
            pub const fn set_pwmready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Enable or disable interrupt for event CLKOUTREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn clkoutready(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CLKOUTREADY"]
            #[inline(always)]
            pub const fn set_clkoutready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare0", &self.compare0())
                    .field("compare1", &self.compare1())
                    .field("compare2", &self.compare2())
                    .field("compare3", &self.compare3())
                    .field("compare4", &self.compare4())
                    .field("compare5", &self.compare5())
                    .field("compare6", &self.compare6())
                    .field("compare7", &self.compare7())
                    .field("compare8", &self.compare8())
                    .field("compare9", &self.compare9())
                    .field("compare10", &self.compare10())
                    .field("compare11", &self.compare11())
                    .field("rtcomparesync", &self.rtcomparesync())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .field("pwmready", &self.pwmready())
                    .field("clkoutready", &self.clkoutready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ compare0: {=bool:?}, compare1: {=bool:?}, compare2: {=bool:?}, compare3: {=bool:?}, compare4: {=bool:?}, compare5: {=bool:?}, compare6: {=bool:?}, compare7: {=bool:?}, compare8: {=bool:?}, compare9: {=bool:?}, compare10: {=bool:?}, compare11: {=bool:?}, rtcomparesync: {=bool:?}, pwmperiodend: {=bool:?}, pwmready: {=bool:?}, clkoutready: {=bool:?} }}" , self . compare0 () , self . compare1 () , self . compare2 () , self . compare3 () , self . compare4 () , self . compare5 () , self . compare6 () , self . compare7 () , self . compare8 () , self . compare9 () , self . compare10 () , self . compare11 () , self . rtcomparesync () , self . pwmperiodend () , self . pwmready () , self . clkoutready ())
            }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Interval(pub u32);
        impl Interval {
            #[doc = "Count to add to CC\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Count to add to CC\\[0\\]"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Interval {
            #[inline(always)]
            fn default() -> Interval {
                Interval(0)
            }
        }
        impl core::fmt::Debug for Interval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Interval")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Interval {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Interval {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Low frequency timer status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lftimer(pub u32);
        impl Lftimer {
            #[doc = "Low frequency timer is ready or busy."]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Low frequency timer is ready or busy."]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lftimer {
            #[inline(always)]
            fn default() -> Lftimer {
                Lftimer(0)
            }
        }
        impl core::fmt::Debug for Lftimer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lftimer")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lftimer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lftimer {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Counter mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[must_use]
            #[inline(always)]
            pub const fn autoen(&self) -> super::vals::Autoen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Autoen::from_bits(val as u8)
            }
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[inline(always)]
            pub const fn set_autoen(&mut self, val: super::vals::Autoen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[must_use]
            #[inline(always)]
            pub const fn syscounteren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[inline(always)]
            pub const fn set_syscounteren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("autoen", &self.autoen())
                    .field("syscounteren", &self.syscounteren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ autoen: {:?}, syscounteren: {=bool:?} }}",
                    self.autoen(),
                    self.syscounteren()
                )
            }
        }
        #[doc = "PWM status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwm(pub u32);
        impl Pwm {
            #[doc = "PWM is ready or busy."]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PWM is ready or busy."]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Pwm {
            #[inline(always)]
            fn default() -> Pwm {
                Pwm(0)
            }
        }
        impl core::fmt::Debug for Pwm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwm").field("ready", &self.ready()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pwm {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "PWM configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "The PWM compare value"]
            #[must_use]
            #[inline(always)]
            pub const fn comparevalue(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The PWM compare value"]
            #[inline(always)]
            pub const fn set_comparevalue(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("comparevalue", &self.comparevalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwmconfig {{ comparevalue: {=u8:?} }}",
                    self.comparevalue()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn rtcompare_clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[inline(always)]
            pub const fn set_rtcompare_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("rtcompare_clear", &self.rtcompare_clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Shorts {{ rtcompare_clear: {=bool:?} }}",
                    self.rtcompare_clear()
                )
            }
        }
        #[doc = "CLKOUT configuration status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct StatusClkout(pub u32);
        impl StatusClkout {
            #[doc = "CLKOUT is ready or busy."]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "CLKOUT is ready or busy."]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for StatusClkout {
            #[inline(always)]
            fn default() -> StatusClkout {
                StatusClkout(0)
            }
        }
        impl core::fmt::Debug for StatusClkout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("StatusClkout")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for StatusClkout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "StatusClkout {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounterh(pub u32);
        impl Syscounterh {
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "SYSCOUNTER loaded status"]
            #[must_use]
            #[inline(always)]
            pub const fn loaded(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "SYSCOUNTER loaded status"]
            #[inline(always)]
            pub const fn set_loaded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "SYSCOUNTER busy status"]
            #[must_use]
            #[inline(always)]
            pub const fn busy(&self) -> super::vals::Busy {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Busy::from_bits(val as u8)
            }
            #[doc = "SYSCOUNTER busy status"]
            #[inline(always)]
            pub const fn set_busy(&mut self, val: super::vals::Busy) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Syscounterh {
            #[inline(always)]
            fn default() -> Syscounterh {
                Syscounterh(0)
            }
        }
        impl core::fmt::Debug for Syscounterh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounterh")
                    .field("value", &self.value())
                    .field("loaded", &self.loaded())
                    .field("busy", &self.busy())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounterh {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Syscounterh {{ value: {=u32:?}, loaded: {=bool:?}, busy: {:?}, overflow: {=bool:?} }}" , self . value () , self . loaded () , self . busy () , self . overflow ())
            }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timeout(pub u32);
        impl Timeout {
            #[doc = "Number of 32Ki cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of 32Ki cycles"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Timeout {
            #[inline(always)]
            fn default() -> Timeout {
                Timeout(0)
            }
        }
        impl core::fmt::Debug for Timeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timeout")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Timeout {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "GRTC wake up time."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Waketime(pub u32);
        impl Waketime {
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Waketime {
            #[inline(always)]
            fn default() -> Waketime {
                Waketime(0)
            }
        }
        impl core::fmt::Debug for Waketime {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Waketime")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Waketime {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Waketime {{ value: {=u8:?} }}", self.value())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Autoen {
            #[doc = "Default configuration to keep the SYSCOUNTER active."]
            DEFAULT = 0x0,
            #[doc = "In addition to the above mode, any local CPU that is not sleeping keep the SYSCOUNTER active."]
            CPU_ACTIVE = 0x01,
        }
        impl Autoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Autoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Autoen {
            #[inline(always)]
            fn from(val: u8) -> Autoen {
                Autoen::from_bits(val)
            }
        }
        impl From<Autoen> for u8 {
            #[inline(always)]
            fn from(val: Autoen) -> u8 {
                Autoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busy {
            #[doc = "SYSCOUNTER is ready for read"]
            READY = 0x0,
            #[doc = "SYSCOUNTER is busy, so not ready for read (value returned in the VALUE field of this register is not valid)"]
            BUSY = 0x01,
        }
        impl Busy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busy {
            #[inline(always)]
            fn from(val: u8) -> Busy {
                Busy::from_bits(val)
            }
        }
        impl From<Busy> for u8 {
            #[inline(always)]
            fn from(val: Busy) -> u8 {
                Busy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clksel {
            #[doc = "GRTC LFCLK clock source is LFXO"]
            LFXO = 0x0,
            #[doc = "GRTC LFCLK clock source is system LFCLK"]
            SYSTEM_LFCLK = 0x01,
            #[doc = "GRTC LFCLK clock source is LFLPRC"]
            LFLPRC = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Clksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clksel {
            #[inline(always)]
            fn from(val: u8) -> Clksel {
                Clksel::from_bits(val)
            }
        }
        impl From<Clksel> for u8 {
            #[inline(always)]
            fn from(val: Clksel) -> u8 {
                Clksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reference {
            #[doc = "Adds SYSCOUNTER value."]
            SYSCOUNTER = 0x0,
            #[doc = "Adds CC value."]
            CC = 0x01,
        }
        impl Reference {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reference {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reference {
            #[inline(always)]
            fn from(val: u8) -> Reference {
                Reference::from_bits(val)
            }
        }
        impl From<Reference> for u8 {
            #[inline(always)]
            fn from(val: Reference) -> u8 {
                Reference::to_bits(val)
            }
        }
    }
}
pub mod kmu {
    #[doc = "Key management unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kmu {
        ptr: *mut u8,
    }
    unsafe impl Send for Kmu {}
    unsafe impl Sync for Kmu {}
    impl Kmu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Provision key slot"]
        #[inline(always)]
        pub const fn tasks_provision(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Push key slot"]
        #[inline(always)]
        pub const fn tasks_push(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Revoke key slot"]
        #[inline(always)]
        pub const fn tasks_revoke(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Read key slot metadata into METADATA register"]
        #[inline(always)]
        pub const fn tasks_readmetadata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Block only the PUSH operation of a key slot, preventing the key slot from being PUSHED until next reset. The task is kept for backwards compatibility."]
        #[inline(always)]
        pub const fn tasks_pushblock(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Block the PROVISION, PUSH, and REVOKE operations of a key slot, preventing the key slot from being PROVISIONED, PUSHED, or REVOKED until next reset"]
        #[inline(always)]
        pub const fn tasks_block(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Key slot successfully provisioned"]
        #[inline(always)]
        pub const fn events_provisioned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Key slot successfully pushed"]
        #[inline(always)]
        pub const fn events_pushed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Key slot has been revoked and can no longer be used"]
        #[inline(always)]
        pub const fn events_revoked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Error generated during PROVISION, PUSH, READMETADATA or REVOKE operations. Triggering the PROVISION, PUSH and REVOKE tasks on a BLOCKED keyslot will also generate this event."]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Key slot metadata has been read into METADATA register"]
        #[inline(always)]
        pub const fn events_metadataread(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "The PUSHBLOCK operation was successful. The event is kept for backwards compatibility."]
        #[inline(always)]
        pub const fn events_pushblocked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "The BLOCK operation was successful"]
        #[inline(always)]
        pub const fn events_blocked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "KMU status register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Select key slot to operate on"]
        #[inline(always)]
        pub const fn keyslot(self) -> crate::common::Reg<regs::Keyslot, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Source address for provisioning"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Key slot metadata as read by TASKS_READMETADATA."]
        #[inline(always)]
        pub const fn metadata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Select key slot to operate on"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Keyslot(pub u32);
        impl Keyslot {
            #[doc = "Select key slot ID to provision, push, read METADATA, revoke or block when the corresponding task is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select key slot ID to provision, push, read METADATA, revoke or block when the corresponding task is triggered."]
            #[inline(always)]
            pub const fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Keyslot {
            #[inline(always)]
            fn default() -> Keyslot {
                Keyslot(0)
            }
        }
        impl core::fmt::Debug for Keyslot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Keyslot").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Keyslot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Keyslot {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "KMU status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "KMU status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "KMU status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "KMU is ready for new operation"]
            READY = 0x0,
            #[doc = "KMU is busy, an operation is in progress"]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
    }
}
pub mod lpcomp {
    #[doc = "Low-power comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lpcomp {
        ptr: *mut u8,
    }
    unsafe impl Send for Lpcomp {}
    unsafe impl Sync for Lpcomp {}
    impl Lpcomp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that LPCOMP has been started by the START task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "LPCOMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Enable LPCOMP"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Input pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Reference select"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Analog detect configuration"]
        #[inline(always)]
        pub const fn anadetect(self) -> crate::common::Reg<regs::Anadetect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Analog detect configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Anadetect(pub u32);
        impl Anadetect {
            #[doc = "Analog detect configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn anadetect(&self) -> super::vals::Anadetect {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Anadetect::from_bits(val as u8)
            }
            #[doc = "Analog detect configuration"]
            #[inline(always)]
            pub const fn set_anadetect(&mut self, val: super::vals::Anadetect) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Anadetect {
            #[inline(always)]
            fn default() -> Anadetect {
                Anadetect(0)
            }
        }
        impl core::fmt::Debug for Anadetect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Anadetect")
                    .field("anadetect", &self.anadetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Anadetect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Anadetect {{ anadetect: {:?} }}", self.anadetect())
            }
        }
        #[doc = "Enable LPCOMP"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable LPCOMP"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable LPCOMP"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Extrefsel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis enable"]
            #[must_use]
            #[inline(always)]
            pub const fn hyst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator hysteresis enable"]
            #[inline(always)]
            pub const fn set_hyst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hyst {{ hyst: {=bool:?} }}", self.hyst())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[must_use]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[must_use]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[must_use]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ ready: {=bool:?}, down: {=bool:?}, up: {=bool:?}, cross: {=bool:?} }}",
                    self.ready(),
                    self.down(),
                    self.up(),
                    self.cross()
                )
            }
        }
        #[doc = "Input pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refsel {{ refsel: {:?} }}", self.refsel())
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[must_use]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Result {{ result: {:?} }}", self.result())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_sample: {=bool:?}, ready_stop: {=bool:?}, down_stop: {=bool:?}, up_stop: {=bool:?}, cross_stop: {=bool:?} }}" , self . ready_sample () , self . ready_stop () , self . down_stop () , self . up_stop () , self . cross_stop ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Anadetect {
            #[doc = "Generate ANADETECT on crossing, both upward crossing and downward crossing"]
            CROSS = 0x0,
            #[doc = "Generate ANADETECT on upward crossing only"]
            UP = 0x01,
            #[doc = "Generate ANADETECT on downward crossing only"]
            DOWN = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Anadetect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Anadetect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Anadetect {
            #[inline(always)]
            fn from(val: u8) -> Anadetect {
                Anadetect::from_bits(val)
            }
        }
        impl From<Anadetect> for u8 {
            #[inline(always)]
            fn from(val: Anadetect) -> u8 {
                Anadetect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            #[doc = "Enable"]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VDD * 1/8 selected as reference"]
            REF1_8VDD = 0x0,
            #[doc = "VDD * 2/8 selected as reference"]
            REF2_8VDD = 0x01,
            #[doc = "VDD * 3/8 selected as reference"]
            REF3_8VDD = 0x02,
            #[doc = "VDD * 4/8 selected as reference"]
            REF4_8VDD = 0x03,
            #[doc = "VDD * 5/8 selected as reference"]
            REF5_8VDD = 0x04,
            #[doc = "VDD * 6/8 selected as reference"]
            REF6_8VDD = 0x05,
            #[doc = "VDD * 7/8 selected as reference"]
            REF7_8VDD = 0x06,
            #[doc = "External analog reference selected"]
            AREF = 0x07,
            #[doc = "VDD * 1/16 selected as reference"]
            REF1_16VDD = 0x08,
            #[doc = "VDD * 3/16 selected as reference"]
            REF3_16VDD = 0x09,
            #[doc = "VDD * 5/16 selected as reference"]
            REF5_16VDD = 0x0a,
            #[doc = "VDD * 7/16 selected as reference"]
            REF7_16VDD = 0x0b,
            #[doc = "VDD * 9/16 selected as reference"]
            REF9_16VDD = 0x0c,
            #[doc = "VDD * 11/16 selected as reference"]
            REF11_16VDD = 0x0d,
            #[doc = "VDD * 13/16 selected as reference"]
            REF13_16VDD = 0x0e,
            #[doc = "VDD * 15/16 selected as reference"]
            REF15_16VDD = 0x0f,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the reference threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the reference threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
    }
}
pub mod memconf {
    #[doc = "Memory configuration 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memconf {
        ptr: *mut u8,
    }
    unsafe impl Send for Memconf {}
    unsafe impl Sync for Memconf {}
    impl Memconf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self, n: usize) -> Power {
            assert!(n < 2usize);
            unsafe { Power::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control memory block power."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::Control, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[inline(always)]
        pub const fn ret(self) -> crate::common::Reg<regs::Ret, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Control memory block power."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Control(pub u32);
        impl Control {
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Control {
            #[inline(always)]
            fn default() -> Control {
                Control(0)
            }
        }
        impl core::fmt::Debug for Control {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Control")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Control {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Control {{ mem0: {=bool:?}, mem1: {=bool:?}, mem2: {=bool:?}, mem3: {=bool:?}, mem4: {=bool:?}, mem5: {=bool:?}, mem6: {=bool:?}, mem7: {=bool:?}, mem8: {=bool:?}, mem9: {=bool:?}, mem10: {=bool:?}, mem11: {=bool:?}, mem12: {=bool:?}, mem13: {=bool:?}, mem14: {=bool:?}, mem15: {=bool:?}, mem16: {=bool:?}, mem17: {=bool:?}, mem18: {=bool:?}, mem19: {=bool:?}, mem20: {=bool:?}, mem21: {=bool:?}, mem22: {=bool:?}, mem23: {=bool:?}, mem24: {=bool:?}, mem25: {=bool:?}, mem26: {=bool:?}, mem27: {=bool:?}, mem28: {=bool:?}, mem29: {=bool:?}, mem30: {=bool:?}, mem31: {=bool:?} }}" , self . mem0 () , self . mem1 () , self . mem2 () , self . mem3 () , self . mem4 () , self . mem5 () , self . mem6 () , self . mem7 () , self . mem8 () , self . mem9 () , self . mem10 () , self . mem11 () , self . mem12 () , self . mem13 () , self . mem14 () , self . mem15 () , self . mem16 () , self . mem17 () , self . mem18 () , self . mem19 () , self . mem20 () , self . mem21 () , self . mem22 () , self . mem23 () , self . mem24 () , self . mem25 () , self . mem26 () , self . mem27 () , self . mem28 () , self . mem29 () , self . mem30 () , self . mem31 ())
            }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ret(pub u32);
        impl Ret {
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ret {
            #[inline(always)]
            fn default() -> Ret {
                Ret(0)
            }
        }
        impl core::fmt::Debug for Ret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ret")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ret {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ret {{ mem0: {=bool:?}, mem1: {=bool:?}, mem2: {=bool:?}, mem3: {=bool:?}, mem4: {=bool:?}, mem5: {=bool:?}, mem6: {=bool:?}, mem7: {=bool:?}, mem8: {=bool:?}, mem9: {=bool:?}, mem10: {=bool:?}, mem11: {=bool:?}, mem12: {=bool:?}, mem13: {=bool:?}, mem14: {=bool:?}, mem15: {=bool:?}, mem16: {=bool:?}, mem17: {=bool:?}, mem18: {=bool:?}, mem19: {=bool:?}, mem20: {=bool:?}, mem21: {=bool:?}, mem22: {=bool:?}, mem23: {=bool:?}, mem24: {=bool:?}, mem25: {=bool:?}, mem26: {=bool:?}, mem27: {=bool:?}, mem28: {=bool:?}, mem29: {=bool:?}, mem30: {=bool:?}, mem31: {=bool:?} }}" , self . mem0 () , self . mem1 () , self . mem2 () , self . mem3 () , self . mem4 () , self . mem5 () , self . mem6 () , self . mem7 () , self . mem8 () , self . mem9 () , self . mem10 () , self . mem11 () , self . mem12 () , self . mem13 () , self . mem14 () , self . mem15 () , self . mem16 () , self . mem17 () , self . mem18 () , self . mem19 () , self . mem20 () , self . mem21 () , self . mem22 () , self . mem23 () , self . mem24 () , self . mem25 () , self . mem26 () , self . mem27 () , self . mem28 () , self . mem29 () , self . mem30 () , self . mem31 ())
            }
        }
    }
}
pub mod mpc {
    #[doc = "Memory Access Error status registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Memaccerr {}
    unsafe impl Sync for Memaccerr {}
    impl Memaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Target Address of Memory Access Error. Register content will not be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content will not be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn info(self) -> crate::common::Reg<regs::Info, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Memory Privilege Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mpc {
        ptr: *mut u8,
    }
    unsafe impl Send for Mpc {}
    unsafe impl Sync for Mpc {}
    impl Mpc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Memory Access Error event"]
        #[inline(always)]
        pub const fn events_memaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Memory Access Error status registers"]
        #[inline(always)]
        pub const fn memaccerr(self) -> Memaccerr {
            unsafe { Memaccerr::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Special privilege tables"]
        #[inline(always)]
        pub const fn override_(self, n: usize) -> Override {
            assert!(n < 12usize);
            unsafe { Override::from_ptr(self.ptr.wrapping_add(0x0800usize + n * 32usize) as _) }
        }
    }
    #[doc = "Special privilege tables"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Override {
        ptr: *mut u8,
    }
    unsafe impl Send for Override {}
    unsafe impl Sync for Override {}
    impl Override {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Override region n Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Override region n Start Address"]
        #[inline(always)]
        pub const fn startaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Override region n End Address"]
        #[inline(always)]
        pub const fn endaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[inline(always)]
        pub const fn permmask(self) -> crate::common::Reg<regs::Permmask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Override region n Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Lock Override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Override region n"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Override region n"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("lock", &self.lock())
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ lock: {=bool:?}, enable: {=bool:?} }}",
                    self.lock(),
                    self.enable()
                )
            }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content will not be changed as long as MEMACCERR event is active."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Info(pub u32);
        impl Info {
            #[doc = "Read bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Read bit of bus access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Write bit of bus access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Execute bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Execute bit of bus access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Secure bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Secure bit of bus access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Source of memory access error"]
            #[must_use]
            #[inline(always)]
            pub const fn errorsource(&self) -> super::vals::Errorsource {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Errorsource::from_bits(val as u8)
            }
            #[doc = "Source of memory access error"]
            #[inline(always)]
            pub const fn set_errorsource(&mut self, val: super::vals::Errorsource) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Info {
            #[inline(always)]
            fn default() -> Info {
                Info(0)
            }
        }
        impl core::fmt::Debug for Info {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Info")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("errorsource", &self.errorsource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Info {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Info {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, errorsource: {:?} }}" , self . read () , self . write () , self . execute () , self . secure () , self . errorsource ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn memaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[inline(always)]
            pub const fn set_memaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("memaccerr", &self.memaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ memaccerr: {=bool:?} }}", self.memaccerr())
            }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software execute"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Perm {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secattr: {=bool:?} }}" , self . read () , self . write () , self . execute () , self . secattr ())
            }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Permmask(pub u32);
        impl Permmask {
            #[doc = "Read mask"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> super::vals::PermmaskRead {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PermmaskRead::from_bits(val as u8)
            }
            #[doc = "Read mask"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: super::vals::PermmaskRead) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Write mask"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> super::vals::PermmaskWrite {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PermmaskWrite::from_bits(val as u8)
            }
            #[doc = "Write mask"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: super::vals::PermmaskWrite) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute mask"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> super::vals::PermmaskExecute {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PermmaskExecute::from_bits(val as u8)
            }
            #[doc = "Execute mask"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: super::vals::PermmaskExecute) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping mask"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> super::vals::PermmaskSecattr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PermmaskSecattr::from_bits(val as u8)
            }
            #[doc = "Security mapping mask"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: super::vals::PermmaskSecattr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Permmask {
            #[inline(always)]
            fn default() -> Permmask {
                Permmask(0)
            }
        }
        impl core::fmt::Debug for Permmask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Permmask")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Permmask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Permmask {{ read: {:?}, write: {:?}, execute: {:?}, secattr: {:?} }}",
                    self.read(),
                    self.write(),
                    self.execute(),
                    self.secattr()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorsource {
            #[doc = "Error was triggered by a Subordinate"]
            SLAVE = 0x0,
            #[doc = "Error was triggered by MPC module"]
            MPC = 0x01,
        }
        impl Errorsource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorsource {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorsource {
            #[inline(always)]
            fn from(val: u8) -> Errorsource {
                Errorsource::from_bits(val)
            }
        }
        impl From<Errorsource> for u8 {
            #[inline(always)]
            fn from(val: Errorsource) -> u8 {
                Errorsource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskExecute {
            #[doc = "Permission setting EXECUTE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting EXECUTE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskExecute {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskExecute {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskExecute {
            #[inline(always)]
            fn from(val: u8) -> PermmaskExecute {
                PermmaskExecute::from_bits(val)
            }
        }
        impl From<PermmaskExecute> for u8 {
            #[inline(always)]
            fn from(val: PermmaskExecute) -> u8 {
                PermmaskExecute::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskRead {
            #[doc = "Permission setting READ in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting READ in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskRead {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskRead {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskRead {
            #[inline(always)]
            fn from(val: u8) -> PermmaskRead {
                PermmaskRead::from_bits(val)
            }
        }
        impl From<PermmaskRead> for u8 {
            #[inline(always)]
            fn from(val: PermmaskRead) -> u8 {
                PermmaskRead::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskSecattr {
            #[doc = "Permission setting SECATTR in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting SECATTR in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskSecattr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskSecattr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskSecattr {
            #[inline(always)]
            fn from(val: u8) -> PermmaskSecattr {
                PermmaskSecattr::from_bits(val)
            }
        }
        impl From<PermmaskSecattr> for u8 {
            #[inline(always)]
            fn from(val: PermmaskSecattr) -> u8 {
                PermmaskSecattr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskWrite {
            #[doc = "Permission setting WRITE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting WRITE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskWrite {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskWrite {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskWrite {
            #[inline(always)]
            fn from(val: u8) -> PermmaskWrite {
                PermmaskWrite::from_bits(val)
            }
        }
        impl From<PermmaskWrite> for u8 {
            #[inline(always)]
            fn from(val: PermmaskWrite) -> u8 {
                PermmaskWrite::to_bits(val)
            }
        }
    }
}
pub mod nfct {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Framestatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Framestatus {}
    unsafe impl Sync for Framestatus {}
    impl Framestatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Result of last incoming frame"]
        #[inline(always)]
        pub const fn rx(self) -> crate::common::Reg<regs::Rx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfcid1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfcid1 {}
    unsafe impl Sync for Nfcid1 {}
    impl Nfcid1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn last(self) -> crate::common::Reg<regs::Last, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn secondlast(self) -> crate::common::Reg<regs::Secondlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[inline(always)]
        pub const fn thirdlast(self) -> crate::common::Reg<regs::Thirdlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfct {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfct {}
    unsafe impl Sync for Nfct {}
    impl Nfct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Activate NFCT peripheral for incoming and outgoing frames, change state to activated"]
        #[inline(always)]
        pub const fn tasks_activate(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Disable NFCT peripheral"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Enable NFC sense field mode, change state to sense mode"]
        #[inline(always)]
        pub const fn tasks_sense(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Start transmission of an outgoing frame, change state to transmit"]
        #[inline(always)]
        pub const fn tasks_starttx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Stops an issued transmission of a frame"]
        #[inline(always)]
        pub const fn tasks_stoptx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Initializes the EasyDMA for receive."]
        #[inline(always)]
        pub const fn tasks_enablerxdata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Force state machine to IDLE state"]
        #[inline(always)]
        pub const fn tasks_goidle(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Force state machine to SLEEP_A state"]
        #[inline(always)]
        pub const fn tasks_gosleep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACTIVATE"]
        #[inline(always)]
        pub const fn subscribe_activate(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SENSE"]
        #[inline(always)]
        pub const fn subscribe_sense(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTTX"]
        #[inline(always)]
        pub const fn subscribe_starttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task STOPTX"]
        #[inline(always)]
        pub const fn subscribe_stoptx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task ENABLERXDATA"]
        #[inline(always)]
        pub const fn subscribe_enablerxdata(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task GOIDLE"]
        #[inline(always)]
        pub const fn subscribe_goidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task GOSLEEP"]
        #[inline(always)]
        pub const fn subscribe_gosleep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "The NFCT peripheral is ready to receive and send frames"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Remote NFC field detected"]
        #[inline(always)]
        pub const fn events_fielddetected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Remote NFC field lost"]
        #[inline(always)]
        pub const fn events_fieldlost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Marks the start of the first symbol of a transmitted frame"]
        #[inline(always)]
        pub const fn events_txframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Marks the end of the last transmitted on-air symbol of a frame"]
        #[inline(always)]
        pub const fn events_txframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Marks the end of the first symbol of a received frame"]
        #[inline(always)]
        pub const fn events_rxframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer"]
        #[inline(always)]
        pub const fn events_rxframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "NFC error reported. The ERRORSTATUS register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_rxerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0128usize) as _) }
        }
        #[doc = "RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full."]
        #[inline(always)]
        pub const fn events_endrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x012cusize) as _) }
        }
        #[doc = "Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer"]
        #[inline(always)]
        pub const fn events_endtx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0130usize) as _) }
        }
        #[doc = "Auto collision resolution process has started"]
        #[inline(always)]
        pub const fn events_autocolresstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0138usize) as _) }
        }
        #[doc = "NFC auto collision resolution error reported."]
        #[inline(always)]
        pub const fn events_collision(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0148usize) as _) }
        }
        #[doc = "NFC auto collision resolution successfully completed"]
        #[inline(always)]
        pub const fn events_selected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "EasyDMA is ready to receive or send frames."]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0150usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDDETECTED"]
        #[inline(always)]
        pub const fn publish_fielddetected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDLOST"]
        #[inline(always)]
        pub const fn publish_fieldlost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_txframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_txframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_rxframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_rxframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RXERROR"]
        #[inline(always)]
        pub const fn publish_rxerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01acusize) as _) }
        }
        #[doc = "Publish configuration for event ENDTX"]
        #[inline(always)]
        pub const fn publish_endtx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event AUTOCOLRESSTARTED"]
        #[inline(always)]
        pub const fn publish_autocolresstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for event COLLISION"]
        #[inline(always)]
        pub const fn publish_collision(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c8usize) as _) }
        }
        #[doc = "Publish configuration for event SELECTED"]
        #[inline(always)]
        pub const fn publish_selected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d0usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "NFC Error Status register"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn framestatus(self) -> Framestatus {
            unsafe { Framestatus::from_ptr(self.ptr.wrapping_add(0x040cusize) as _) }
        }
        #[doc = "Current operating state of NFC tag"]
        #[inline(always)]
        pub const fn nfctagstate(self) -> crate::common::Reg<regs::Nfctagstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0410usize) as _) }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[inline(always)]
        pub const fn sleepstate(self) -> crate::common::Reg<regs::Sleepstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0420usize) as _) }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[inline(always)]
        pub const fn fieldpresent(
            self,
        ) -> crate::common::Reg<regs::Fieldpresent, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x043cusize) as _) }
        }
        #[doc = "Minimum frame delay"]
        #[inline(always)]
        pub const fn framedelaymin(
            self,
        ) -> crate::common::Reg<regs::Framedelaymin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Maximum frame delay"]
        #[inline(always)]
        pub const fn framedelaymax(
            self,
        ) -> crate::common::Reg<regs::Framedelaymax, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[inline(always)]
        pub const fn framedelaymode(
            self,
        ) -> crate::common::Reg<regs::Framedelaymode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Packet pointer for TXD and RXD data storage in Data RAM"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[inline(always)]
        pub const fn maxlen(self) -> crate::common::Reg<regs::Maxlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[inline(always)]
        pub const fn modulationctrl(
            self,
        ) -> crate::common::Reg<regs::Modulationctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x052cusize) as _) }
        }
        #[doc = "Pin select for Modulation control"]
        #[inline(always)]
        pub const fn modulationpsel(
            self,
        ) -> crate::common::Reg<regs::Modulationpsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Configure EasyDMA mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfcid1(self) -> Nfcid1 {
            unsafe { Nfcid1::from_ptr(self.ptr.wrapping_add(0x0590usize) as _) }
        }
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[inline(always)]
        pub const fn autocolresconfig(
            self,
        ) -> crate::common::Reg<regs::Autocolresconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x059cusize) as _) }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[inline(always)]
        pub const fn sensres(self) -> crate::common::Reg<regs::Sensres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05a0usize) as _) }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[inline(always)]
        pub const fn selres(self) -> crate::common::Reg<regs::Selres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05a4usize) as _) }
        }
        #[doc = "NFC pad configuration"]
        #[inline(always)]
        pub const fn padconfig(self) -> crate::common::Reg<regs::Padconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x06d4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of incoming frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::RxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Size of last incoming frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of outgoing frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::TxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Size of outgoing frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Autocolresconfig(pub u32);
        impl Autocolresconfig {
            #[doc = "Enables/disables auto collision resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Enables/disables auto collision resolution"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Autocolresconfig {
            #[inline(always)]
            fn default() -> Autocolresconfig {
                Autocolresconfig(0)
            }
        }
        impl core::fmt::Debug for Autocolresconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Autocolresconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Autocolresconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Autocolresconfig {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "NFC Error Status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaytimeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[inline(always)]
            pub const fn set_framedelaytimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("framedelaytimeout", &self.framedelaytimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorstatus {{ framedelaytimeout: {=bool:?} }}",
                    self.framedelaytimeout()
                )
            }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fieldpresent(pub u32);
        impl Fieldpresent {
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[must_use]
            #[inline(always)]
            pub const fn fieldpresent(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[inline(always)]
            pub const fn set_fieldpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[must_use]
            #[inline(always)]
            pub const fn lockdetect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[inline(always)]
            pub const fn set_lockdetect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Fieldpresent {
            #[inline(always)]
            fn default() -> Fieldpresent {
                Fieldpresent(0)
            }
        }
        impl core::fmt::Debug for Fieldpresent {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fieldpresent")
                    .field("fieldpresent", &self.fieldpresent())
                    .field("lockdetect", &self.lockdetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fieldpresent {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fieldpresent {{ fieldpresent: {=bool:?}, lockdetect: {=bool:?} }}",
                    self.fieldpresent(),
                    self.lockdetect()
                )
            }
        }
        #[doc = "Maximum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymax(pub u32);
        impl Framedelaymax {
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymax(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn set_framedelaymax(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Framedelaymax {
            #[inline(always)]
            fn default() -> Framedelaymax {
                Framedelaymax(0)
            }
        }
        impl core::fmt::Debug for Framedelaymax {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymax")
                    .field("framedelaymax", &self.framedelaymax())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymax {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymax {{ framedelaymax: {=u32:?} }}",
                    self.framedelaymax()
                )
            }
        }
        #[doc = "Minimum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymin(pub u32);
        impl Framedelaymin {
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn set_framedelaymin(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Framedelaymin {
            #[inline(always)]
            fn default() -> Framedelaymin {
                Framedelaymin(0)
            }
        }
        impl core::fmt::Debug for Framedelaymin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymin")
                    .field("framedelaymin", &self.framedelaymin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymin {{ framedelaymin: {=u16:?} }}",
                    self.framedelaymin()
                )
            }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymode(pub u32);
        impl Framedelaymode {
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymode(&self) -> super::vals::Framedelaymode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Framedelaymode::from_bits(val as u8)
            }
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[inline(always)]
            pub const fn set_framedelaymode(&mut self, val: super::vals::Framedelaymode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Framedelaymode {
            #[inline(always)]
            fn default() -> Framedelaymode {
                Framedelaymode(0)
            }
        }
        impl core::fmt::Debug for Framedelaymode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymode")
                    .field("framedelaymode", &self.framedelaymode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymode {{ framedelaymode: {:?} }}",
                    self.framedelaymode()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[must_use]
            #[inline(always)]
            pub const fn fielddetected(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[inline(always)]
            pub const fn set_fielddetected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldlost(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[inline(always)]
            pub const fn set_fieldlost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn txframestart(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[inline(always)]
            pub const fn set_txframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[must_use]
            #[inline(always)]
            pub const fn txframeend(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[inline(always)]
            pub const fn set_txframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn rxframestart(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[inline(always)]
            pub const fn set_rxframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[must_use]
            #[inline(always)]
            pub const fn rxframeend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[inline(always)]
            pub const fn set_rxframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn rxerror(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[inline(always)]
            pub const fn set_rxerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn set_endrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[must_use]
            #[inline(always)]
            pub const fn endtx(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[inline(always)]
            pub const fn set_endtx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn autocolresstarted(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[inline(always)]
            pub const fn set_autocolresstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[must_use]
            #[inline(always)]
            pub const fn collision(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[inline(always)]
            pub const fn set_collision(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[must_use]
            #[inline(always)]
            pub const fn selected(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[inline(always)]
            pub const fn set_selected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("fielddetected", &self.fielddetected())
                    .field("fieldlost", &self.fieldlost())
                    .field("txframestart", &self.txframestart())
                    .field("txframeend", &self.txframeend())
                    .field("rxframestart", &self.rxframestart())
                    .field("rxframeend", &self.rxframeend())
                    .field("error", &self.error())
                    .field("rxerror", &self.rxerror())
                    .field("endrx", &self.endrx())
                    .field("endtx", &self.endtx())
                    .field("autocolresstarted", &self.autocolresstarted())
                    .field("collision", &self.collision())
                    .field("selected", &self.selected())
                    .field("started", &self.started())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ ready: {=bool:?}, fielddetected: {=bool:?}, fieldlost: {=bool:?}, txframestart: {=bool:?}, txframeend: {=bool:?}, rxframestart: {=bool:?}, rxframeend: {=bool:?}, error: {=bool:?}, rxerror: {=bool:?}, endrx: {=bool:?}, endtx: {=bool:?}, autocolresstarted: {=bool:?}, collision: {=bool:?}, selected: {=bool:?}, started: {=bool:?} }}" , self . ready () , self . fielddetected () , self . fieldlost () , self . txframestart () , self . txframeend () , self . rxframestart () , self . rxframeend () , self . error () , self . rxerror () , self . endrx () , self . endtx () , self . autocolresstarted () , self . collision () , self . selected () , self . started ())
            }
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Last(pub u32);
        impl Last {
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[must_use]
            #[inline(always)]
            pub const fn z(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[inline(always)]
            pub const fn set_z(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte Y"]
            #[must_use]
            #[inline(always)]
            pub const fn y(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Y"]
            #[inline(always)]
            pub const fn set_y(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte X"]
            #[must_use]
            #[inline(always)]
            pub const fn x(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte X"]
            #[inline(always)]
            pub const fn set_x(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "NFCID1 byte W"]
            #[must_use]
            #[inline(always)]
            pub const fn w(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte W"]
            #[inline(always)]
            pub const fn set_w(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Last {
            #[inline(always)]
            fn default() -> Last {
                Last(0)
            }
        }
        impl core::fmt::Debug for Last {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Last")
                    .field("z", &self.z())
                    .field("y", &self.y())
                    .field("x", &self.x())
                    .field("w", &self.w())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Last {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Last {{ z: {=u8:?}, y: {=u8:?}, x: {=u8:?}, w: {=u8:?} }}",
                    self.z(),
                    self.y(),
                    self.x(),
                    self.w()
                )
            }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxlen(pub u32);
        impl Maxlen {
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[must_use]
            #[inline(always)]
            pub const fn maxlen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[inline(always)]
            pub const fn set_maxlen(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Maxlen {
            #[inline(always)]
            fn default() -> Maxlen {
                Maxlen(0)
            }
        }
        impl core::fmt::Debug for Maxlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxlen")
                    .field("maxlen", &self.maxlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxlen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxlen {{ maxlen: {=u16:?} }}", self.maxlen())
            }
        }
        #[doc = "Configure EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Enable low-power operation, or use low-latency"]
            #[must_use]
            #[inline(always)]
            pub const fn lpop(&self) -> super::vals::Lpop {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lpop::from_bits(val as u8)
            }
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub const fn set_lpop(&mut self, val: super::vals::Lpop) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("lpop", &self.lpop()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ lpop: {:?} }}", self.lpop())
            }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationctrl(pub u32);
        impl Modulationctrl {
            #[doc = "Configuration of modulation control."]
            #[must_use]
            #[inline(always)]
            pub const fn modulationctrl(&self) -> super::vals::Modulationctrl {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Modulationctrl::from_bits(val as u8)
            }
            #[doc = "Configuration of modulation control."]
            #[inline(always)]
            pub const fn set_modulationctrl(&mut self, val: super::vals::Modulationctrl) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Modulationctrl {
            #[inline(always)]
            fn default() -> Modulationctrl {
                Modulationctrl(0)
            }
        }
        impl core::fmt::Debug for Modulationctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationctrl")
                    .field("modulationctrl", &self.modulationctrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Modulationctrl {{ modulationctrl: {:?} }}",
                    self.modulationctrl()
                )
            }
        }
        #[doc = "Pin select for Modulation control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationpsel(pub u32);
        impl Modulationpsel {
            #[doc = "Pin number"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::super::shared::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::super::shared::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::super::shared::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Modulationpsel {
            #[inline(always)]
            fn default() -> Modulationpsel {
                Modulationpsel(0)
            }
        }
        impl core::fmt::Debug for Modulationpsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationpsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationpsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Modulationpsel {{ pin: {=u8:?}, port: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.connect()
                )
            }
        }
        #[doc = "Current operating state of NFC tag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nfctagstate(pub u32);
        impl Nfctagstate {
            #[doc = "NfcTag state"]
            #[must_use]
            #[inline(always)]
            pub const fn nfctagstate(&self) -> super::vals::Nfctagstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfctagstate::from_bits(val as u8)
            }
            #[doc = "NfcTag state"]
            #[inline(always)]
            pub const fn set_nfctagstate(&mut self, val: super::vals::Nfctagstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Nfctagstate {
            #[inline(always)]
            fn default() -> Nfctagstate {
                Nfctagstate(0)
            }
        }
        impl core::fmt::Debug for Nfctagstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nfctagstate")
                    .field("nfctagstate", &self.nfctagstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nfctagstate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Nfctagstate {{ nfctagstate: {:?} }}", self.nfctagstate())
            }
        }
        #[doc = "NFC pad configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Padconfig(pub u32);
        impl Padconfig {
            #[doc = "Enable NFC pads"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable NFC pads"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Padconfig {
            #[inline(always)]
            fn default() -> Padconfig {
                Padconfig(0)
            }
        }
        impl core::fmt::Debug for Padconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Padconfig")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Padconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Padconfig {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Result of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rx(pub u32);
        impl Rx {
            #[doc = "No valid end of frame (EoF) detected"]
            #[must_use]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No valid end of frame (EoF) detected"]
            #[inline(always)]
            pub const fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity status of received frame"]
            #[must_use]
            #[inline(always)]
            pub const fn paritystatus(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Parity status of received frame"]
            #[inline(always)]
            pub const fn set_paritystatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Overrun detected"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun detected"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Rx {
            #[inline(always)]
            fn default() -> Rx {
                Rx(0)
            }
        }
        impl core::fmt::Debug for Rx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rx")
                    .field("crcerror", &self.crcerror())
                    .field("paritystatus", &self.paritystatus())
                    .field("overrun", &self.overrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rx {{ crcerror: {=bool:?}, paritystatus: {=bool:?}, overrun: {=bool:?} }}",
                    self.crcerror(),
                    self.paritystatus(),
                    self.overrun()
                )
            }
        }
        #[doc = "Size of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[must_use]
            #[inline(always)]
            pub const fn rxdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[inline(always)]
            pub const fn set_rxdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[inline(always)]
            pub const fn set_rxdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("rxdatabits", &self.rxdatabits())
                    .field("rxdatabytes", &self.rxdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxdAmount {{ rxdatabits: {=u8:?}, rxdatabytes: {=u16:?} }}",
                    self.rxdatabits(),
                    self.rxdatabytes()
                )
            }
        }
        #[doc = "Configuration of incoming frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdFrameconfig(pub u32);
        impl RxdFrameconfig {
            #[doc = "Indicates if parity expected in RX frame"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity expected in RX frame"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SoF expected or not in RX frames"]
            #[must_use]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SoF expected or not in RX frames"]
            #[inline(always)]
            pub const fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for incoming frames"]
            #[must_use]
            #[inline(always)]
            pub const fn crcmoderx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for incoming frames"]
            #[inline(always)]
            pub const fn set_crcmoderx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for RxdFrameconfig {
            #[inline(always)]
            fn default() -> RxdFrameconfig {
                RxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for RxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("sof", &self.sof())
                    .field("crcmoderx", &self.crcmoderx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxdFrameconfig {{ parity: {=bool:?}, sof: {=bool:?}, crcmoderx: {=bool:?} }}",
                    self.parity(),
                    self.sof(),
                    self.crcmoderx()
                )
            }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Secondlast(pub u32);
        impl Secondlast {
            #[doc = "NFCID1 byte V"]
            #[must_use]
            #[inline(always)]
            pub const fn v(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte V"]
            #[inline(always)]
            pub const fn set_v(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte U"]
            #[must_use]
            #[inline(always)]
            pub const fn u(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte U"]
            #[inline(always)]
            pub const fn set_u(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte T"]
            #[must_use]
            #[inline(always)]
            pub const fn t(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte T"]
            #[inline(always)]
            pub const fn set_t(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Secondlast {
            #[inline(always)]
            fn default() -> Secondlast {
                Secondlast(0)
            }
        }
        impl core::fmt::Debug for Secondlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Secondlast")
                    .field("v", &self.v())
                    .field("u", &self.u())
                    .field("t", &self.t())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Secondlast {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Secondlast {{ v: {=u8:?}, u: {=u8:?}, t: {=u8:?} }}",
                    self.v(),
                    self.u(),
                    self.t()
                )
            }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Selres(pub u32);
        impl Selres {
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu10(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[must_use]
            #[inline(always)]
            pub const fn cascade(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[inline(always)]
            pub const fn set_cascade(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu43(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu43(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u32) & 0x03) << 3usize);
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn protocol(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_protocol(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Selres {
            #[inline(always)]
            fn default() -> Selres {
                Selres(0)
            }
        }
        impl core::fmt::Debug for Selres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Selres")
                    .field("rfu10", &self.rfu10())
                    .field("cascade", &self.cascade())
                    .field("rfu43", &self.rfu43())
                    .field("protocol", &self.protocol())
                    .field("rfu7", &self.rfu7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Selres {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Selres {{ rfu10: {=u8:?}, cascade: {=bool:?}, rfu43: {=u8:?}, protocol: {=u8:?}, rfu7: {=bool:?} }}" , self . rfu10 () , self . cascade () , self . rfu43 () , self . protocol () , self . rfu7 ())
            }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sensres(pub u32);
        impl Sensres {
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn bitframesdd(&self) -> super::vals::Bitframesdd {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Bitframesdd::from_bits(val as u8)
            }
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_bitframesdd(&mut self, val: super::vals::Bitframesdd) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[must_use]
            #[inline(always)]
            pub const fn nfcidsize(&self) -> super::vals::Nfcidsize {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Nfcidsize::from_bits(val as u8)
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[inline(always)]
            pub const fn set_nfcidsize(&mut self, val: super::vals::Nfcidsize) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn platfconfig(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_platfconfig(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu74(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu74(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Sensres {
            #[inline(always)]
            fn default() -> Sensres {
                Sensres(0)
            }
        }
        impl core::fmt::Debug for Sensres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sensres")
                    .field("bitframesdd", &self.bitframesdd())
                    .field("rfu5", &self.rfu5())
                    .field("nfcidsize", &self.nfcidsize())
                    .field("platfconfig", &self.platfconfig())
                    .field("rfu74", &self.rfu74())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sensres {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sensres {{ bitframesdd: {:?}, rfu5: {=bool:?}, nfcidsize: {:?}, platfconfig: {=u8:?}, rfu74: {=u8:?} }}" , self . bitframesdd () , self . rfu5 () , self . nfcidsize () , self . platfconfig () , self . rfu74 ())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[must_use]
            #[inline(always)]
            pub const fn fielddetected_activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[inline(always)]
            pub const fn set_fielddetected_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldlost_sense(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[inline(always)]
            pub const fn set_fieldlost_sense(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[must_use]
            #[inline(always)]
            pub const fn txframeend_enablerxdata(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[inline(always)]
            pub const fn set_txframeend_enablerxdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("fielddetected_activate", &self.fielddetected_activate())
                    .field("fieldlost_sense", &self.fieldlost_sense())
                    .field("txframeend_enablerxdata", &self.txframeend_enablerxdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ fielddetected_activate: {=bool:?}, fieldlost_sense: {=bool:?}, txframeend_enablerxdata: {=bool:?} }}" , self . fielddetected_activate () , self . fieldlost_sense () , self . txframeend_enablerxdata ())
            }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sleepstate(pub u32);
        impl Sleepstate {
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[must_use]
            #[inline(always)]
            pub const fn sleepstate(&self) -> super::vals::Sleepstate {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleepstate::from_bits(val as u8)
            }
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[inline(always)]
            pub const fn set_sleepstate(&mut self, val: super::vals::Sleepstate) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sleepstate {
            #[inline(always)]
            fn default() -> Sleepstate {
                Sleepstate(0)
            }
        }
        impl core::fmt::Debug for Sleepstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sleepstate")
                    .field("sleepstate", &self.sleepstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sleepstate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sleepstate {{ sleepstate: {:?} }}", self.sleepstate())
            }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Thirdlast(pub u32);
        impl Thirdlast {
            #[doc = "NFCID1 byte S"]
            #[must_use]
            #[inline(always)]
            pub const fn s(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte S"]
            #[inline(always)]
            pub const fn set_s(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte R"]
            #[must_use]
            #[inline(always)]
            pub const fn r(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte R"]
            #[inline(always)]
            pub const fn set_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte Q"]
            #[must_use]
            #[inline(always)]
            pub const fn q(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Q"]
            #[inline(always)]
            pub const fn set_q(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Thirdlast {
            #[inline(always)]
            fn default() -> Thirdlast {
                Thirdlast(0)
            }
        }
        impl core::fmt::Debug for Thirdlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Thirdlast")
                    .field("s", &self.s())
                    .field("r", &self.r())
                    .field("q", &self.q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Thirdlast {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Thirdlast {{ s: {=u8:?}, r: {=u8:?}, q: {=u8:?} }}",
                    self.s(),
                    self.r(),
                    self.q()
                )
            }
        }
        #[doc = "Size of outgoing frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[must_use]
            #[inline(always)]
            pub const fn txdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[inline(always)]
            pub const fn set_txdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[must_use]
            #[inline(always)]
            pub const fn txdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[inline(always)]
            pub const fn set_txdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("txdatabits", &self.txdatabits())
                    .field("txdatabytes", &self.txdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxdAmount {{ txdatabits: {=u8:?}, txdatabytes: {=u16:?} }}",
                    self.txdatabits(),
                    self.txdatabytes()
                )
            }
        }
        #[doc = "Configuration of outgoing frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdFrameconfig(pub u32);
        impl TxdFrameconfig {
            #[doc = "Indicates if parity is added to the frame"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity is added to the frame"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[must_use]
            #[inline(always)]
            pub const fn discardmode(&self) -> super::vals::Discardmode {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Discardmode::from_bits(val as u8)
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[inline(always)]
            pub const fn set_discardmode(&mut self, val: super::vals::Discardmode) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[must_use]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[inline(always)]
            pub const fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for outgoing frames"]
            #[must_use]
            #[inline(always)]
            pub const fn crcmodetx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for outgoing frames"]
            #[inline(always)]
            pub const fn set_crcmodetx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for TxdFrameconfig {
            #[inline(always)]
            fn default() -> TxdFrameconfig {
                TxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for TxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("discardmode", &self.discardmode())
                    .field("sof", &self.sof())
                    .field("crcmodetx", &self.crcmodetx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TxdFrameconfig {{ parity: {=bool:?}, discardmode: {:?}, sof: {=bool:?}, crcmodetx: {=bool:?} }}" , self . parity () , self . discardmode () , self . sof () , self . crcmodetx ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitframesdd {
            #[doc = "SDD pattern 00000"]
            SDD00000 = 0x0,
            #[doc = "SDD pattern 00001"]
            SDD00001 = 0x01,
            #[doc = "SDD pattern 00010"]
            SDD00010 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "SDD pattern 00100"]
            SDD00100 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "SDD pattern 01000"]
            SDD01000 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "SDD pattern 10000"]
            SDD10000 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Bitframesdd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitframesdd {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitframesdd {
            #[inline(always)]
            fn from(val: u8) -> Bitframesdd {
                Bitframesdd::from_bits(val)
            }
        }
        impl From<Bitframesdd> for u8 {
            #[inline(always)]
            fn from(val: Bitframesdd) -> u8 {
                Bitframesdd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Discardmode {
            #[doc = "Unused bits are discarded at end of frame (EoF)"]
            DISCARD_END = 0x0,
            #[doc = "Unused bits are discarded at start of frame (SoF)"]
            DISCARD_START = 0x01,
        }
        impl Discardmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Discardmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Discardmode {
            #[inline(always)]
            fn from(val: u8) -> Discardmode {
                Discardmode::from_bits(val)
            }
        }
        impl From<Discardmode> for u8 {
            #[inline(always)]
            fn from(val: Discardmode) -> u8 {
                Discardmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framedelaymode {
            #[doc = "Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout."]
            FREE_RUN = 0x0,
            #[doc = "Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW = 0x01,
            #[doc = "Frame is transmitted exactly at FRAMEDELAYMAX"]
            EXACT_VAL = 0x02,
            #[doc = "Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW_GRID = 0x03,
        }
        impl Framedelaymode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framedelaymode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framedelaymode {
            #[inline(always)]
            fn from(val: u8) -> Framedelaymode {
                Framedelaymode::from_bits(val)
            }
        }
        impl From<Framedelaymode> for u8 {
            #[inline(always)]
            fn from(val: Framedelaymode) -> u8 {
                Framedelaymode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpop {
            #[doc = "Low-latency operation"]
            LOW_LAT = 0x0,
            #[doc = "Low-power operation"]
            LOW_POWER = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Full Low-power operation"]
            FULL_LOW_POWER = 0x03,
        }
        impl Lpop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpop {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpop {
            #[inline(always)]
            fn from(val: u8) -> Lpop {
                Lpop::from_bits(val)
            }
        }
        impl From<Lpop> for u8 {
            #[inline(always)]
            fn from(val: Lpop) -> u8 {
                Lpop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Auto collision resolution enabled"]
            ENABLED = 0x0,
            #[doc = "Auto collision resolution disabled"]
            DISABLED = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modulationctrl {
            #[doc = "Invalid, defaults to same behaviour as for Internal"]
            INVALID = 0x0,
            #[doc = "Use internal modulator only"]
            INTERNAL = 0x01,
            #[doc = "Output digital modulation signal to a GPIO pin."]
            MOD_TO_GPIO = 0x02,
            #[doc = "Use internal modulator and output digital modulation signal to a GPIO pin."]
            INTERNAL_AND_MOD_TO_GPIO = 0x03,
        }
        impl Modulationctrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modulationctrl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modulationctrl {
            #[inline(always)]
            fn from(val: u8) -> Modulationctrl {
                Modulationctrl::from_bits(val)
            }
        }
        impl From<Modulationctrl> for u8 {
            #[inline(always)]
            fn from(val: Modulationctrl) -> u8 {
                Modulationctrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcidsize {
            #[doc = "NFCID1 size: single (4 bytes)"]
            NFCID1SINGLE = 0x0,
            #[doc = "NFCID1 size: double (7 bytes)"]
            NFCID1DOUBLE = 0x01,
            #[doc = "NFCID1 size: triple (10 bytes)"]
            NFCID1TRIPLE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcidsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcidsize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcidsize {
            #[inline(always)]
            fn from(val: u8) -> Nfcidsize {
                Nfcidsize::from_bits(val)
            }
        }
        impl From<Nfcidsize> for u8 {
            #[inline(always)]
            fn from(val: Nfcidsize) -> u8 {
                Nfcidsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfctagstate {
            #[doc = "Disabled or sense"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "RampUp"]
            RAMP_UP = 0x02,
            #[doc = "Idle"]
            IDLE = 0x03,
            #[doc = "Receive"]
            RECEIVE = 0x04,
            #[doc = "FrameDelay"]
            FRAME_DELAY = 0x05,
            #[doc = "Transmit"]
            TRANSMIT = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfctagstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfctagstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfctagstate {
            #[inline(always)]
            fn from(val: u8) -> Nfctagstate {
                Nfctagstate::from_bits(val)
            }
        }
        impl From<Nfctagstate> for u8 {
            #[inline(always)]
            fn from(val: Nfctagstate) -> u8 {
                Nfctagstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleepstate {
            #[doc = "State is IDLE."]
            IDLE = 0x0,
            #[doc = "State is SLEEP_A."]
            SLEEP_A = 0x01,
        }
        impl Sleepstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleepstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleepstate {
            #[inline(always)]
            fn from(val: u8) -> Sleepstate {
                Sleepstate::from_bits(val)
            }
        }
        impl From<Sleepstate> for u8 {
            #[inline(always)]
            fn from(val: Sleepstate) -> u8 {
                Sleepstate::to_bits(val)
            }
        }
    }
}
pub mod oscillators {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::ConfigIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Oscillator control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Oscillators {
        ptr: *mut u8,
    }
    unsafe impl Send for Oscillators {}
    unsafe impl Sync for Oscillators {}
    impl Oscillators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "32 MHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32m(self) -> Xosc32m {
            unsafe { Xosc32m::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
        #[doc = "Oscillator control"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.wrapping_add(0x0800usize) as _) }
        }
        #[doc = "32.768 kHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32ki(self) -> Xosc32ki {
            unsafe { Xosc32ki::from_ptr(self.ptr.wrapping_add(0x0900usize) as _) }
        }
    }
    #[doc = "Oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn freq(self) -> crate::common::Reg<regs::Freq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn currentfreq(self) -> crate::common::Reg<regs::Currentfreq, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "32.768 kHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32ki {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32ki {}
    unsafe impl Sync for Xosc32ki {}
    impl Xosc32ki {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
        #[inline(always)]
        pub const fn bypass(self) -> crate::common::Reg<regs::Bypass, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::Xosc32kiIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "32 MHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32m {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32m {}
    unsafe impl Sync for Xosc32m {}
    impl Xosc32m {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bypass(pub u32);
        impl Bypass {
            #[doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
            #[must_use]
            #[inline(always)]
            pub const fn bypass(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable bypass of LFCLK crystal oscillator with external clock source"]
            #[inline(always)]
            pub const fn set_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Bypass {
            #[inline(always)]
            fn default() -> Bypass {
                Bypass(0)
            }
        }
        impl core::fmt::Debug for Bypass {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bypass")
                    .field("bypass", &self.bypass())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bypass {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bypass {{ bypass: {=bool:?} }}", self.bypass())
            }
        }
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConfigIntcap(pub u32);
        impl ConfigIntcap {
            #[doc = "Crystal load capacitor value"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Crystal load capacitor value"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for ConfigIntcap {
            #[inline(always)]
            fn default() -> ConfigIntcap {
                ConfigIntcap(0)
            }
        }
        impl core::fmt::Debug for ConfigIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConfigIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConfigIntcap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConfigIntcap {{ val: {=u8:?} }}", self.val())
            }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentfreq(pub u32);
        impl Currentfreq {
            #[doc = "Active CPU speed"]
            #[must_use]
            #[inline(always)]
            pub const fn currentfreq(&self) -> super::vals::Currentfreq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Currentfreq::from_bits(val as u8)
            }
            #[doc = "Active CPU speed"]
            #[inline(always)]
            pub const fn set_currentfreq(&mut self, val: super::vals::Currentfreq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Currentfreq {
            #[inline(always)]
            fn default() -> Currentfreq {
                Currentfreq(0)
            }
        }
        impl core::fmt::Debug for Currentfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentfreq")
                    .field("currentfreq", &self.currentfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentfreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentfreq {{ currentfreq: {:?} }}", self.currentfreq())
            }
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freq(pub u32);
        impl Freq {
            #[doc = "Select CPU speed"]
            #[must_use]
            #[inline(always)]
            pub const fn freq(&self) -> super::vals::Freq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Freq::from_bits(val as u8)
            }
            #[doc = "Select CPU speed"]
            #[inline(always)]
            pub const fn set_freq(&mut self, val: super::vals::Freq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Freq {
            #[inline(always)]
            fn default() -> Freq {
                Freq(0)
            }
        }
        impl core::fmt::Debug for Freq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freq").field("freq", &self.freq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Freq {{ freq: {:?} }}", self.freq())
            }
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32kiIntcap(pub u32);
        impl Xosc32kiIntcap {
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Xosc32kiIntcap {
            #[inline(always)]
            fn default() -> Xosc32kiIntcap {
                Xosc32kiIntcap(0)
            }
        }
        impl core::fmt::Debug for Xosc32kiIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32kiIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32kiIntcap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Xosc32kiIntcap {{ val: {=u8:?} }}", self.val())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Currentfreq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Currentfreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Currentfreq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Currentfreq {
            #[inline(always)]
            fn from(val: u8) -> Currentfreq {
                Currentfreq::from_bits(val)
            }
        }
        impl From<Currentfreq> for u8 {
            #[inline(always)]
            fn from(val: Currentfreq) -> u8 {
                Currentfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Freq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freq {
            #[inline(always)]
            fn from(val: u8) -> Freq {
                Freq::from_bits(val)
            }
        }
        impl From<Freq> for u8 {
            #[inline(always)]
            fn from(val: Freq) -> u8 {
                Freq::to_bits(val)
            }
        }
    }
}
pub mod pdm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This event is generated if an error occurs during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Filter {
        ptr: *mut u8,
    }
    unsafe impl Send for Filter {}
    unsafe impl Sync for Filter {}
    impl Filter {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Aditional PDM configurability"]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::Ctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Settings for the high-pass filter"]
        #[inline(always)]
        pub const fn hppole(self) -> crate::common::Reg<regs::Hppole, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "High pass filter disable"]
        #[inline(always)]
        pub const fn hpdisable(self) -> crate::common::Reg<regs::Hpdisable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Soft mute function"]
        #[inline(always)]
        pub const fn softmute(self) -> crate::common::Reg<regs::Softmute, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Soft mute settings"]
        #[inline(always)]
        pub const fn softcycles(self) -> crate::common::Reg<regs::Softcycles, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Input Data Sampling with Number of ckFilterL (double frequency of PDM_CLK) Clock Cycle Delay. Optionally,input sample point can be delayed independently on left and right channels using FILTER:CTRL\\[20:19\\] bits"]
        #[inline(always)]
        pub const fn sampledelay(self) -> crate::common::Reg<regs::Sampledelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
    }
    #[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pdm {}
    unsafe impl Sync for Pdm {}
    impl Pdm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous PDM transfer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops PDM transfer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "PDM transfer has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "PDM transfer has finished"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "PDM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Left output gain adjustment"]
        #[inline(always)]
        pub const fn gainl(self) -> crate::common::Reg<regs::Gainl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Right output gain adjustment"]
        #[inline(always)]
        pub const fn gainr(self) -> crate::common::Reg<regs::Gainr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x051cusize) as _) }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. When RATIO is selected to be 'custom', the decimation rate should be set using the FILTER.CTRL field before setting the RATIO to 7 Change PRESCALER.DIVISOR accordingly."]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn filter(self) -> Filter {
            unsafe { Filter::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "Master clock generator configuration"]
        #[inline(always)]
        pub const fn clkselect(self) -> crate::common::Reg<regs::Clkselect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x054cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn sample(self) -> Sample {
            unsafe { Sample::from_ptr(self.ptr.wrapping_add(0x0560usize) as _) }
        }
        #[doc = "The prescaler is used to set the PDM frequency"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0580usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin number configuration for PDM CLK signal"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin number configuration for PDM DIN signal"]
        #[inline(always)]
        pub const fn din(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event DMA.BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sample {
        ptr: *mut u8,
    }
    unsafe impl Send for Sample {}
    unsafe impl Sync for Sample {}
    impl Sample {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM address pointer to write samples to with EasyDMA"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Number of bytes to allocate memory for in EasyDMA mode"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Master clock generator configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkselect(pub u32);
        impl Clkselect {
            #[doc = "Master clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Src {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Src::from_bits(val as u8)
            }
            #[doc = "Master clock source selection"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Src) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clkselect {
            #[inline(always)]
            fn default() -> Clkselect {
                Clkselect(0)
            }
        }
        impl core::fmt::Debug for Clkselect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkselect")
                    .field("src", &self.src())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkselect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Clkselect {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Aditional PDM configurability"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrl(pub u32);
        impl Ctrl {
            #[doc = "Override soft mute enable for right channel"]
            #[must_use]
            #[inline(always)]
            pub const fn overriderightsoftmute(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Override soft mute enable for right channel"]
            #[inline(always)]
            pub const fn set_overriderightsoftmute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Override soft mute enable for left channel"]
            #[must_use]
            #[inline(always)]
            pub const fn overrideleftsoftmute(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Override soft mute enable for left channel"]
            #[inline(always)]
            pub const fn set_overrideleftsoftmute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Add +0.25dB to the gain stage"]
            #[must_use]
            #[inline(always)]
            pub const fn gainadd0p25(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Add +0.25dB to the gain stage"]
            #[inline(always)]
            pub const fn set_gainadd0p25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Compensates Gain with +0.25dB"]
            #[must_use]
            #[inline(always)]
            pub const fn minorstep025custom(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Compensates Gain with +0.25dB"]
            #[inline(always)]
            pub const fn set_minorstep025custom(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Compensates Gain with +0.5dB steps"]
            #[must_use]
            #[inline(always)]
            pub const fn minorstep050custom(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x0f;
                val as u8
            }
            #[doc = "Compensates Gain with +0.5dB steps"]
            #[inline(always)]
            pub const fn set_minorstep050custom(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 10usize)) | (((val as u32) & 0x0f) << 10usize);
            }
            #[doc = "Custom number of cycles for soft gain/mute function 32*(Multiplication+1) steps"]
            #[must_use]
            #[inline(always)]
            pub const fn softcycles(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x0f;
                val as u8
            }
            #[doc = "Custom number of cycles for soft gain/mute function 32*(Multiplication+1) steps"]
            #[inline(always)]
            pub const fn set_softcycles(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 14usize)) | (((val as u32) & 0x0f) << 14usize);
            }
            #[doc = "Input data sampling point delay in PDM_CLK cycels"]
            #[must_use]
            #[inline(always)]
            pub const fn datasampledelay(&self) -> super::vals::Datasampledelay {
                let val = (self.0 >> 19usize) & 0x03;
                super::vals::Datasampledelay::from_bits(val as u8)
            }
            #[doc = "Input data sampling point delay in PDM_CLK cycels"]
            #[inline(always)]
            pub const fn set_datasampledelay(&mut self, val: super::vals::Datasampledelay) {
                self.0 =
                    (self.0 & !(0x03 << 19usize)) | (((val.to_bits() as u32) & 0x03) << 19usize);
            }
            #[doc = "Defines MSB for CIC fliter when RATIO is set to 'custom'"]
            #[must_use]
            #[inline(always)]
            pub const fn cicfiltermsbcustom(&self) -> super::vals::Cicfiltermsbcustom {
                let val = (self.0 >> 21usize) & 0x0f;
                super::vals::Cicfiltermsbcustom::from_bits(val as u8)
            }
            #[doc = "Defines MSB for CIC fliter when RATIO is set to 'custom'"]
            #[inline(always)]
            pub const fn set_cicfiltermsbcustom(&mut self, val: super::vals::Cicfiltermsbcustom) {
                self.0 =
                    (self.0 & !(0x0f << 21usize)) | (((val.to_bits() as u32) & 0x0f) << 21usize);
            }
            #[doc = "Configures decimation ratio to any even number between 6 and 256"]
            #[must_use]
            #[inline(always)]
            pub const fn decratio(&self) -> u8 {
                let val = (self.0 >> 25usize) & 0x7f;
                val as u8
            }
            #[doc = "Configures decimation ratio to any even number between 6 and 256"]
            #[inline(always)]
            pub const fn set_decratio(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 25usize)) | (((val as u32) & 0x7f) << 25usize);
            }
        }
        impl Default for Ctrl {
            #[inline(always)]
            fn default() -> Ctrl {
                Ctrl(0)
            }
        }
        impl core::fmt::Debug for Ctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrl")
                    .field("overriderightsoftmute", &self.overriderightsoftmute())
                    .field("overrideleftsoftmute", &self.overrideleftsoftmute())
                    .field("gainadd0p25", &self.gainadd0p25())
                    .field("minorstep025custom", &self.minorstep025custom())
                    .field("minorstep050custom", &self.minorstep050custom())
                    .field("softcycles", &self.softcycles())
                    .field("datasampledelay", &self.datasampledelay())
                    .field("cicfiltermsbcustom", &self.cicfiltermsbcustom())
                    .field("decratio", &self.decratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrl {{ overriderightsoftmute: {=bool:?}, overrideleftsoftmute: {=bool:?}, gainadd0p25: {=bool:?}, minorstep025custom: {=bool:?}, minorstep050custom: {=u8:?}, softcycles: {=u8:?}, datasampledelay: {:?}, cicfiltermsbcustom: {:?}, decratio: {=u8:?} }}" , self . overriderightsoftmute () , self . overrideleftsoftmute () , self . gainadd0p25 () , self . minorstep025custom () , self . minorstep050custom () , self . softcycles () , self . datasampledelay () , self . cicfiltermsbcustom () , self . decratio ())
            }
        }
        #[doc = "PDM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PDM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PDM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Left output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainl(pub u32);
        impl Gainl {
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[must_use]
            #[inline(always)]
            pub const fn gainl(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[inline(always)]
            pub const fn set_gainl(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainl {
            #[inline(always)]
            fn default() -> Gainl {
                Gainl(0)
            }
        }
        impl core::fmt::Debug for Gainl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainl")
                    .field("gainl", &self.gainl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainl {{ gainl: {:?} }}", self.gainl())
            }
        }
        #[doc = "Right output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainr(pub u32);
        impl Gainr {
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[must_use]
            #[inline(always)]
            pub const fn gainr(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[inline(always)]
            pub const fn set_gainr(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainr {
            #[inline(always)]
            fn default() -> Gainr {
                Gainr(0)
            }
        }
        impl core::fmt::Debug for Gainr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainr")
                    .field("gainr", &self.gainr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainr {{ gainr: {:?} }}", self.gainr())
            }
        }
        #[doc = "High pass filter disable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hpdisable(pub u32);
        impl Hpdisable {
            #[doc = "High pass filter disable"]
            #[must_use]
            #[inline(always)]
            pub const fn disable(&self) -> super::vals::HpdisableDisable {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::HpdisableDisable::from_bits(val as u8)
            }
            #[doc = "High pass filter disable"]
            #[inline(always)]
            pub const fn set_disable(&mut self, val: super::vals::HpdisableDisable) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hpdisable {
            #[inline(always)]
            fn default() -> Hpdisable {
                Hpdisable(0)
            }
        }
        impl core::fmt::Debug for Hpdisable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hpdisable")
                    .field("disable", &self.disable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hpdisable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hpdisable {{ disable: {:?} }}", self.disable())
            }
        }
        #[doc = "Settings for the high-pass filter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hppole(pub u32);
        impl Hppole {
            #[doc = "Settings for the high-pass filter -3dB gain pole, assuming filter source clock of 16KHz"]
            #[must_use]
            #[inline(always)]
            pub const fn hppole(&self) -> super::vals::Hppole {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Hppole::from_bits(val as u8)
            }
            #[doc = "Settings for the high-pass filter -3dB gain pole, assuming filter source clock of 16KHz"]
            #[inline(always)]
            pub const fn set_hppole(&mut self, val: super::vals::Hppole) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Hppole {
            #[inline(always)]
            fn default() -> Hppole {
                Hppole(0)
            }
        }
        impl core::fmt::Debug for Hppole {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hppole")
                    .field("hppole", &self.hppole())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hppole {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hppole {{ hppole: {:?} }}", self.hppole())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmabuserror(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[inline(always)]
            pub const fn set_dmabuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmabuserror", &self.dmabuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, stopped: {=bool:?}, end: {=bool:?}, dmabuserror: {=bool:?} }}" , self . started () , self . stopped () , self . end () , self . dmabuserror ())
            }
        }
        #[doc = "Number of bytes to allocate memory for in EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Length of DMA RAM allocation in number of bytes"]
            #[must_use]
            #[inline(always)]
            pub const fn buffsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Length of DMA RAM allocation in number of bytes"]
            #[inline(always)]
            pub const fn set_buffsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("buffsize", &self.buffsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ buffsize: {=u16:?} }}", self.buffsize())
            }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Mono or stereo operation"]
            #[must_use]
            #[inline(always)]
            pub const fn operation(&self) -> super::vals::Operation {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Operation::from_bits(val as u8)
            }
            #[doc = "Mono or stereo operation"]
            #[inline(always)]
            pub const fn set_operation(&mut self, val: super::vals::Operation) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[must_use]
            #[inline(always)]
            pub const fn edge(&self) -> super::vals::Edge {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Edge::from_bits(val as u8)
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[inline(always)]
            pub const fn set_edge(&mut self, val: super::vals::Edge) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("operation", &self.operation())
                    .field("edge", &self.edge())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ operation: {:?}, edge: {:?} }}",
                    self.operation(),
                    self.edge()
                )
            }
        }
        #[doc = "The prescaler is used to set the PDM frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Core clock to PDM divisor"]
            #[must_use]
            #[inline(always)]
            pub const fn divisor(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Core clock to PDM divisor"]
            #[inline(always)]
            pub const fn set_divisor(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("divisor", &self.divisor())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ divisor: {=u8:?} }}", self.divisor())
            }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. When RATIO is selected to be 'custom', the decimation rate should be set using the FILTER.CTRL field before setting the RATIO to 7 Change PRESCALER.DIVISOR accordingly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[must_use]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[inline(always)]
            pub const fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ratio {{ ratio: {:?} }}", self.ratio())
            }
        }
        #[doc = "Input Data Sampling with Number of ckFilterL (double frequency of PDM_CLK) Clock Cycle Delay. Optionally,input sample point can be delayed independently on left and right channels using FILTER:CTRL\\[20:19\\] bits"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sampledelay(pub u32);
        impl Sampledelay {
            #[doc = "Input Data Sampling with Number of ckFilterL (double frequency of PDM_CLK) Clock Cycle Delay"]
            #[must_use]
            #[inline(always)]
            pub const fn delay(&self) -> super::vals::Delay {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Delay::from_bits(val as u8)
            }
            #[doc = "Input Data Sampling with Number of ckFilterL (double frequency of PDM_CLK) Clock Cycle Delay"]
            #[inline(always)]
            pub const fn set_delay(&mut self, val: super::vals::Delay) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sampledelay {
            #[inline(always)]
            fn default() -> Sampledelay {
                Sampledelay(0)
            }
        }
        impl core::fmt::Debug for Sampledelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sampledelay")
                    .field("delay", &self.delay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sampledelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sampledelay {{ delay: {:?} }}", self.delay())
            }
        }
        #[doc = "Soft mute settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softcycles(pub u32);
        impl Softcycles {
            #[doc = "Soft mute settings: amount of cycles for transition"]
            #[must_use]
            #[inline(always)]
            pub const fn disable(&self) -> super::vals::SoftcyclesDisable {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::SoftcyclesDisable::from_bits(val as u8)
            }
            #[doc = "Soft mute settings: amount of cycles for transition"]
            #[inline(always)]
            pub const fn set_disable(&mut self, val: super::vals::SoftcyclesDisable) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Softcycles {
            #[inline(always)]
            fn default() -> Softcycles {
                Softcycles(0)
            }
        }
        impl core::fmt::Debug for Softcycles {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softcycles")
                    .field("disable", &self.disable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softcycles {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Softcycles {{ disable: {:?} }}", self.disable())
            }
        }
        #[doc = "Soft mute function"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softmute(pub u32);
        impl Softmute {
            #[doc = "Soft mute function"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Soft mute function"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Softmute {
            #[inline(always)]
            fn default() -> Softmute {
                Softmute(0)
            }
        }
        impl core::fmt::Debug for Softmute {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softmute")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softmute {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Softmute {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Terminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cicfiltermsbcustom {
            #[doc = "OSR range low 4 OSR range high 32"]
            RANGE0 = 0x0,
            #[doc = "OSR range low 34 OSR range high 36"]
            RANGE1 = 0x01,
            #[doc = "OSR range low 38 OSR range high 42"]
            RANGE2 = 0x02,
            #[doc = "OSR range low 44 OSR range high 48"]
            RANGE3 = 0x03,
            #[doc = "OSR range low 50 OSR range high 54"]
            RANGE4 = 0x04,
            #[doc = "OSR range low 56 OSR range high 64"]
            RANGE5 = 0x05,
            #[doc = "OSR range low 66 OSR range high 72"]
            RANGE6 = 0x06,
            #[doc = "OSR range low 74 OSR range high 84"]
            RANGE7 = 0x07,
            #[doc = "OSR range low 86 OSR range high 96"]
            RANGE8 = 0x08,
            #[doc = "OSR range low 98 OSR range high 110"]
            RANGE9 = 0x09,
            #[doc = "OSR range low 112 OSR range high 128"]
            RANGE10 = 0x0a,
            #[doc = "OSR range low 130 OSR range high 146"]
            RANGE11 = 0x0b,
            #[doc = "OSR range low 148 OSR range high 168"]
            RANGE12 = 0x0c,
            #[doc = "OSR range low 170 OSR range high 194"]
            RANGE13 = 0x0d,
            #[doc = "OSR range low 196 OSR range high 222"]
            RANGE14 = 0x0e,
            #[doc = "OSR range low 224 OSR range high 256"]
            RANGE15 = 0x0f,
        }
        impl Cicfiltermsbcustom {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cicfiltermsbcustom {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cicfiltermsbcustom {
            #[inline(always)]
            fn from(val: u8) -> Cicfiltermsbcustom {
                Cicfiltermsbcustom::from_bits(val)
            }
        }
        impl From<Cicfiltermsbcustom> for u8 {
            #[inline(always)]
            fn from(val: Cicfiltermsbcustom) -> u8 {
                Cicfiltermsbcustom::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Datasampledelay {
            #[doc = "No added delay"]
            NO_DELAY = 0x0,
            #[doc = "1 clock cycle delay on left channel"]
            DELAY_ON_LEFT = 0x01,
            #[doc = "1 clock cycle delay on right channel"]
            DELAY_ON_RIGHT = 0x02,
            #[doc = "1 clock cycle delay on both channels"]
            DELAY_ON_BOTH = 0x03,
        }
        impl Datasampledelay {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Datasampledelay {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Datasampledelay {
            #[inline(always)]
            fn from(val: u8) -> Datasampledelay {
                Datasampledelay::from_bits(val)
            }
        }
        impl From<Datasampledelay> for u8 {
            #[inline(always)]
            fn from(val: Datasampledelay) -> u8 {
                Datasampledelay::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Delay {
            #[doc = "No delay"]
            NO_DELAY = 0x0,
            #[doc = "1 cycle"]
            X1 = 0x01,
        }
        impl Delay {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Delay {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Delay {
            #[inline(always)]
            fn from(val: u8) -> Delay {
                Delay::from_bits(val)
            }
        }
        impl From<Delay> for u8 {
            #[inline(always)]
            fn from(val: Delay) -> u8 {
                Delay::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edge {
            #[doc = "Left (or mono) is sampled on falling edge of PDM_CLK"]
            LEFT_FALLING = 0x0,
            #[doc = "Left (or mono) is sampled on rising edge of PDM_CLK"]
            LEFT_RISING = 0x01,
        }
        impl Edge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edge {
            #[inline(always)]
            fn from(val: u8) -> Edge {
                Edge::from_bits(val)
            }
        }
        impl From<Edge> for u8 {
            #[inline(always)]
            fn from(val: Edge) -> u8 {
                Edge::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Gain(u8);
        impl Gain {
            #[doc = "-20 dB gain adjustment (minimum)"]
            pub const MIN_GAIN: Self = Self(0x0);
            #[doc = "0 dB gain adjustment"]
            pub const DEFAULT_GAIN: Self = Self(0x28);
            #[doc = "+20 dB gain adjustment (maximum)"]
            pub const MAX_GAIN: Self = Self(0x50);
        }
        impl Gain {
            pub const fn from_bits(val: u8) -> Gain {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_GAIN"),
                    0x28 => f.write_str("DEFAULT_GAIN"),
                    0x50 => f.write_str("MAX_GAIN"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_GAIN"),
                    0x28 => defmt::write!(f, "DEFAULT_GAIN"),
                    0x50 => defmt::write!(f, "MAX_GAIN"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HpdisableDisable {
            #[doc = "High pass filter enabled"]
            ENABLE = 0x0,
            #[doc = "High pass filter disabled"]
            DISABLE = 0x01,
        }
        impl HpdisableDisable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> HpdisableDisable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for HpdisableDisable {
            #[inline(always)]
            fn from(val: u8) -> HpdisableDisable {
                HpdisableDisable::from_bits(val)
            }
        }
        impl From<HpdisableDisable> for u8 {
            #[inline(always)]
            fn from(val: HpdisableDisable) -> u8 {
                HpdisableDisable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hppole {
            _RESERVED_0 = 0x0,
            #[doc = "2110 Hz"]
            P2110 = 0x01,
            #[doc = "1152 Hz"]
            P1152 = 0x02,
            #[doc = "603 Hz"]
            P603 = 0x03,
            #[doc = "310 Hz"]
            P310 = 0x04,
            #[doc = "157 Hz"]
            P157 = 0x05,
            #[doc = "79 Hz"]
            P79 = 0x06,
            #[doc = "40 Hz"]
            P40 = 0x07,
            #[doc = "20 Hz"]
            P20 = 0x08,
            #[doc = "10 Hz"]
            P10 = 0x09,
            #[doc = "5 Hz"]
            P5 = 0x0a,
            #[doc = "2.5 Hz"]
            P2P5 = 0x0b,
            #[doc = "1.25 Hz"]
            P1P25 = 0x0c,
            #[doc = "0.64 Hz"]
            P0P64 = 0x0d,
            #[doc = "0.32 Hz"]
            P0P32 = 0x0e,
            #[doc = "0.16 Hz"]
            P0P16 = 0x0f,
        }
        impl Hppole {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hppole {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hppole {
            #[inline(always)]
            fn from(val: u8) -> Hppole {
                Hppole::from_bits(val)
            }
        }
        impl From<Hppole> for u8 {
            #[inline(always)]
            fn from(val: Hppole) -> u8 {
                Hppole::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Operation {
            #[doc = "Sample and store one pair (left + right) of 16-bit samples per RAM word R=\\[31:16\\]; L=\\[15:0\\]"]
            STEREO = 0x0,
            #[doc = "Sample and store two successive left samples (16 bits each) per RAM word L1=\\[31:16\\]; L0=\\[15:0\\]"]
            MONO = 0x01,
        }
        impl Operation {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Operation {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Operation {
            #[inline(always)]
            fn from(val: u8) -> Operation {
                Operation::from_bits(val)
            }
        }
        impl From<Operation> for u8 {
            #[inline(always)]
            fn from(val: Operation) -> u8 {
                Operation::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "Ratio of 48"]
            RATIO48 = 0x0,
            #[doc = "Ratio of 50"]
            RATIO50 = 0x01,
            #[doc = "Ratio of 64"]
            RATIO64 = 0x02,
            #[doc = "Ratio of 80"]
            RATIO80 = 0x03,
            #[doc = "Ratio of 96"]
            RATIO96 = 0x04,
            #[doc = "Ratio of 150"]
            RATIO150 = 0x05,
            #[doc = "Ratio of 192"]
            RATIO192 = 0x06,
            #[doc = "Custom. The decimation rate can be changed using the FILTER.CTRL\\[31:25\\] bits"]
            CUSTOM = 0x07,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SoftcyclesDisable {
            #[doc = "2 filter source clock cycles"]
            S2 = 0x0,
            #[doc = "8 filter source clock cycles"]
            S8 = 0x01,
            #[doc = "32 filter source clock cycles"]
            S32 = 0x02,
            #[doc = "64 filter source clock cycles"]
            S64 = 0x03,
            #[doc = "128 filter source clock cycles"]
            S128 = 0x04,
            #[doc = "256 filter source clock cycles"]
            S256 = 0x05,
            #[doc = "512 filter source clock cycles"]
            S512 = 0x06,
            #[doc = "The number of cycles can be set using FILTER.CTRL\\[17:14\\] bits"]
            CUSTOM = 0x07,
        }
        impl SoftcyclesDisable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SoftcyclesDisable {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SoftcyclesDisable {
            #[inline(always)]
            fn from(val: u8) -> SoftcyclesDisable {
                SoftcyclesDisable::from_bits(val)
            }
        }
        impl From<SoftcyclesDisable> for u8 {
            #[inline(always)]
            fn from(val: SoftcyclesDisable) -> u8 {
                SoftcyclesDisable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Src {
            #[doc = "32 MHz peripheral clock"]
            PCLK32M = 0x0,
            #[doc = "24 MHz peripheral clock"]
            ACLK = 0x01,
        }
        impl Src {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Src {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Src {
            #[inline(always)]
            fn from(val: u8) -> Src {
                Src::from_bits(val)
            }
        }
        impl From<Src> for u8 {
            #[inline(always)]
            fn from(val: Src) -> u8 {
                Src::to_bits(val)
            }
        }
    }
}
pub mod power {
    #[doc = "Power control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable Constant Latency mode"]
        #[inline(always)]
        pub const fn tasks_constlat(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Enable Low-power mode (variable latency)"]
        #[inline(always)]
        pub const fn tasks_lowpwr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Subscribe configuration for task CONSTLAT"]
        #[inline(always)]
        pub const fn subscribe_constlat(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb0usize) as _) }
        }
        #[doc = "Subscribe configuration for task LOWPWR"]
        #[inline(always)]
        pub const fn subscribe_lowpwr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb4usize) as _) }
        }
        #[doc = "Power failure warning"]
        #[inline(always)]
        pub const fn events_pofwarn(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0130usize) as _) }
        }
        #[doc = "CPU entered WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepenter(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0134usize) as _) }
        }
        #[doc = "CPU exited WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepexit(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0138usize) as _) }
        }
        #[doc = "Publish configuration for event POFWARN"]
        #[inline(always)]
        pub const fn publish_pofwarn(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPENTER"]
        #[inline(always)]
        pub const fn publish_sleepenter(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPEXIT"]
        #[inline(always)]
        pub const fn publish_sleepexit(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[inline(always)]
        pub const fn gpregret(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Gpregret, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 4usize) as _)
            }
        }
        #[doc = "Status of constant latency"]
        #[inline(always)]
        pub const fn constlatstat(
            self,
        ) -> crate::common::Reg<regs::Constlatstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status of constant latency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Constlatstat(pub u32);
        impl Constlatstat {
            #[doc = "Status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Constlatstat {
            #[inline(always)]
            fn default() -> Constlatstat {
                Constlatstat(0)
            }
        }
        impl core::fmt::Debug for Constlatstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Constlatstat")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Constlatstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Constlatstat {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gpregret(pub u32);
        impl Gpregret {
            #[doc = "General purpose retention register"]
            #[must_use]
            #[inline(always)]
            pub const fn gpregret(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "General purpose retention register"]
            #[inline(always)]
            pub const fn set_gpregret(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Gpregret {
            #[inline(always)]
            fn default() -> Gpregret {
                Gpregret(0)
            }
        }
        impl core::fmt::Debug for Gpregret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gpregret")
                    .field("gpregret", &self.gpregret())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gpregret {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gpregret {{ gpregret: {=u8:?} }}", self.gpregret())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[must_use]
            #[inline(always)]
            pub const fn pofwarn(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[inline(always)]
            pub const fn set_pofwarn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepenter(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[inline(always)]
            pub const fn set_sleepenter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepexit(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[inline(always)]
            pub const fn set_sleepexit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("pofwarn", &self.pofwarn())
                    .field("sleepenter", &self.sleepenter())
                    .field("sleepexit", &self.sleepexit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ pofwarn: {=bool:?}, sleepenter: {=bool:?}, sleepexit: {=bool:?} }}",
                    self.pofwarn(),
                    self.sleepenter(),
                    self.sleepexit()
                )
            }
        }
    }
}
pub mod ppib {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Overflow {
        ptr: *mut u8,
    }
    unsafe impl Send for Overflow {}
    unsafe impl Sync for Overflow {}
    impl Overflow {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[inline(always)]
        pub const fn send(self) -> crate::common::Reg<regs::Send, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "PPIB APB registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ppib {
        ptr: *mut u8,
    }
    unsafe impl Send for Ppib {}
    unsafe impl Sync for Ppib {}
    impl Ppib {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: This task is unused, but the PPIB provides the SUBSCRIBE task to connect SEND \\[n\\] task."]
        #[inline(always)]
        pub const fn tasks_send(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task SEND\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_send(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: This event is unused, but the PPIB provides the PUBLISH event to connect RECEIVE \\[n\\] event."]
        #[inline(always)]
        pub const fn events_receive(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event RECEIVE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_receive(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn overflow(self) -> Overflow {
            unsafe { Overflow::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Send(pub u32);
        impl Send {
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[inline(always)]
            pub const fn set_send_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[inline(always)]
            pub const fn set_send_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[inline(always)]
            pub const fn set_send_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[inline(always)]
            pub const fn set_send_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[inline(always)]
            pub const fn set_send_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[inline(always)]
            pub const fn set_send_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[inline(always)]
            pub const fn set_send_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[inline(always)]
            pub const fn set_send_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[inline(always)]
            pub const fn set_send_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[inline(always)]
            pub const fn set_send_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[inline(always)]
            pub const fn set_send_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[inline(always)]
            pub const fn set_send_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[inline(always)]
            pub const fn set_send_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[inline(always)]
            pub const fn set_send_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[inline(always)]
            pub const fn set_send_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[inline(always)]
            pub const fn set_send_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[inline(always)]
            pub const fn set_send_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[inline(always)]
            pub const fn set_send_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[inline(always)]
            pub const fn set_send_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[inline(always)]
            pub const fn set_send_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[inline(always)]
            pub const fn set_send_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[inline(always)]
            pub const fn set_send_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[inline(always)]
            pub const fn set_send_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[inline(always)]
            pub const fn set_send_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[inline(always)]
            pub const fn set_send_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[inline(always)]
            pub const fn set_send_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[inline(always)]
            pub const fn set_send_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[inline(always)]
            pub const fn set_send_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[inline(always)]
            pub const fn set_send_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[inline(always)]
            pub const fn set_send_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[inline(always)]
            pub const fn set_send_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[inline(always)]
            pub const fn set_send_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Send {
            #[inline(always)]
            fn default() -> Send {
                Send(0)
            }
        }
        impl core::fmt::Debug for Send {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Send")
                    .field("send_0", &self.send_0())
                    .field("send_1", &self.send_1())
                    .field("send_2", &self.send_2())
                    .field("send_3", &self.send_3())
                    .field("send_4", &self.send_4())
                    .field("send_5", &self.send_5())
                    .field("send_6", &self.send_6())
                    .field("send_7", &self.send_7())
                    .field("send_8", &self.send_8())
                    .field("send_9", &self.send_9())
                    .field("send_10", &self.send_10())
                    .field("send_11", &self.send_11())
                    .field("send_12", &self.send_12())
                    .field("send_13", &self.send_13())
                    .field("send_14", &self.send_14())
                    .field("send_15", &self.send_15())
                    .field("send_16", &self.send_16())
                    .field("send_17", &self.send_17())
                    .field("send_18", &self.send_18())
                    .field("send_19", &self.send_19())
                    .field("send_20", &self.send_20())
                    .field("send_21", &self.send_21())
                    .field("send_22", &self.send_22())
                    .field("send_23", &self.send_23())
                    .field("send_24", &self.send_24())
                    .field("send_25", &self.send_25())
                    .field("send_26", &self.send_26())
                    .field("send_27", &self.send_27())
                    .field("send_28", &self.send_28())
                    .field("send_29", &self.send_29())
                    .field("send_30", &self.send_30())
                    .field("send_31", &self.send_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Send {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Send {{ send_0: {=bool:?}, send_1: {=bool:?}, send_2: {=bool:?}, send_3: {=bool:?}, send_4: {=bool:?}, send_5: {=bool:?}, send_6: {=bool:?}, send_7: {=bool:?}, send_8: {=bool:?}, send_9: {=bool:?}, send_10: {=bool:?}, send_11: {=bool:?}, send_12: {=bool:?}, send_13: {=bool:?}, send_14: {=bool:?}, send_15: {=bool:?}, send_16: {=bool:?}, send_17: {=bool:?}, send_18: {=bool:?}, send_19: {=bool:?}, send_20: {=bool:?}, send_21: {=bool:?}, send_22: {=bool:?}, send_23: {=bool:?}, send_24: {=bool:?}, send_25: {=bool:?}, send_26: {=bool:?}, send_27: {=bool:?}, send_28: {=bool:?}, send_29: {=bool:?}, send_30: {=bool:?}, send_31: {=bool:?} }}" , self . send_0 () , self . send_1 () , self . send_2 () , self . send_3 () , self . send_4 () , self . send_5 () , self . send_6 () , self . send_7 () , self . send_8 () , self . send_9 () , self . send_10 () , self . send_11 () , self . send_12 () , self . send_13 () , self . send_14 () , self . send_15 () , self . send_16 () , self . send_17 () , self . send_18 () , self . send_19 () , self . send_20 () , self . send_21 () , self . send_22 () , self . send_23 () , self . send_24 () , self . send_25 () , self . send_26 () , self . send_27 () , self . send_28 () , self . send_29 () , self . send_30 () , self . send_31 ())
            }
        }
    }
}
pub mod pwm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> DmaSeq {
            assert!(n < 2usize);
            unsafe { DmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 36usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaSeq {}
    unsafe impl Sync for DmaSeq {}
    impl DmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Description cluster: Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> EventsDmaSeq {
            assert!(n < 2usize);
            unsafe { EventsDmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaSeq {}
    unsafe impl Sync for EventsDmaSeq {}
    impl EventsDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Output pin select for PWM channel n"]
        #[inline(always)]
        pub const fn out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PublishDmaSeq {
            assert!(n < 2usize);
            unsafe { PublishDmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaSeq {}
    unsafe impl Sync for PublishDmaSeq {}
    impl PublishDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Pulse width modulation unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm {}
    unsafe impl Sync for Pwm {}
    impl Pwm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running."]
        #[inline(always)]
        pub const fn tasks_nextstep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task NEXTSTEP"]
        #[inline(always)]
        pub const fn subscribe_nextstep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Response to STOP task, emitted when PWM pulses are no longer generated"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Description collection: First PWM period started on sequence n"]
        #[inline(always)]
        pub const fn events_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter"]
        #[inline(always)]
        pub const fn events_seqend(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize + n * 4usize) as _)
            }
        }
        #[doc = "Emitted at the end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"]
        #[inline(always)]
        pub const fn events_loopsdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Emitted when retrieving from RAM does not complete in time for the PWM module"]
        #[inline(always)]
        pub const fn events_ramunderflow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0120usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "Description collection: This event is generated when the compare matches for the compare channel \\[n\\]."]
        #[inline(always)]
        pub const fn events_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x013cusize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQSTARTED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event SEQEND\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqend(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event PWMPERIODEND"]
        #[inline(always)]
        pub const fn publish_pwmperiodend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event LOOPSDONE"]
        #[inline(always)]
        pub const fn publish_loopsdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RAMUNDERFLOW"]
        #[inline(always)]
        pub const fn publish_ramunderflow(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPAREMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn publish_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01bcusize + n * 4usize) as _)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "PWM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[inline(always)]
        pub const fn countertop(self) -> crate::common::Reg<regs::Countertop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Configuration of the decoder"]
        #[inline(always)]
        pub const fn decoder(self) -> crate::common::Reg<regs::Decoder, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Number of playbacks of a loop"]
        #[inline(always)]
        pub const fn loop_(self) -> crate::common::Reg<regs::Loop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize) as _) }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[inline(always)]
        pub const fn idleout(self) -> crate::common::Reg<regs::Idleout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PwmSeq {
            assert!(n < 2usize);
            unsafe { PwmSeq::from_ptr(self.ptr.wrapping_add(0x0520usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0560usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PwmSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PwmSeq {}
    unsafe impl Sync for PwmSeq {}
    impl PwmSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[inline(always)]
        pub const fn refresh(self) -> crate::common::Reg<regs::Refresh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[inline(always)]
        pub const fn enddelay(self) -> crate::common::Reg<regs::Enddelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> SubscribeDmaSeq {
            assert!(n < 2usize);
            unsafe { SubscribeDmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaSeq {}
    unsafe impl Sync for SubscribeDmaSeq {}
    impl SubscribeDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> TasksDmaSeq {
            assert!(n < 2usize);
            unsafe { TasksDmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaSeq {}
    unsafe impl Sync for TasksDmaSeq {}
    impl TasksDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Countertop(pub u32);
        impl Countertop {
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[must_use]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[inline(always)]
            pub const fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Countertop {
            #[inline(always)]
            fn default() -> Countertop {
                Countertop(0)
            }
        }
        impl core::fmt::Debug for Countertop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Countertop")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Countertop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Countertop {{ countertop: {=u16:?} }}",
                    self.countertop()
                )
            }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Configuration of the decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Decoder(pub u32);
        impl Decoder {
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn load(&self) -> super::vals::Load {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Load::from_bits(val as u8)
            }
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[inline(always)]
            pub const fn set_load(&mut self, val: super::vals::Load) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Decoder {
            #[inline(always)]
            fn default() -> Decoder {
                Decoder(0)
            }
        }
        impl core::fmt::Debug for Decoder {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Decoder")
                    .field("load", &self.load())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Decoder {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Decoder {{ load: {:?}, mode: {:?} }}",
                    self.load(),
                    self.mode()
                )
            }
        }
        #[doc = "PWM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PWM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PWM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enddelay(pub u32);
        impl Enddelay {
            #[doc = "Time added after the sequence in PWM periods"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Time added after the sequence in PWM periods"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Enddelay {
            #[inline(always)]
            fn default() -> Enddelay {
                Enddelay(0)
            }
        }
        impl core::fmt::Debug for Enddelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enddelay")
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enddelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enddelay {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idleout(pub u32);
        impl Idleout {
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[inline(always)]
            pub const fn set_val_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[inline(always)]
            pub const fn set_val_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[inline(always)]
            pub const fn set_val_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[inline(always)]
            pub const fn set_val_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Idleout {
            #[inline(always)]
            fn default() -> Idleout {
                Idleout(0)
            }
        }
        impl core::fmt::Debug for Idleout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idleout")
                    .field("val_0", &self.val_0())
                    .field("val_1", &self.val_1())
                    .field("val_2", &self.val_2())
                    .field("val_3", &self.val_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idleout {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Idleout {{ val_0: {=bool:?}, val_1: {=bool:?}, val_2: {=bool:?}, val_3: {=bool:?} }}" , self . val_0 () , self . val_1 () , self . val_2 () , self . val_3 ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqstarted0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqstarted1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqend0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqend1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[inline(always)]
            pub const fn set_loopsdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[must_use]
            #[inline(always)]
            pub const fn ramunderflow(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[inline(always)]
            pub const fn set_ramunderflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0end(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[inline(always)]
            pub const fn set_dmaseq0end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0ready(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[inline(always)]
            pub const fn set_dmaseq0ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0buserror(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[inline(always)]
            pub const fn set_dmaseq0buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1end(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[inline(always)]
            pub const fn set_dmaseq1end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1ready(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[inline(always)]
            pub const fn set_dmaseq1ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1buserror(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[inline(always)]
            pub const fn set_dmaseq1buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn comparematch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_comparematch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("seqstarted0", &self.seqstarted0())
                    .field("seqstarted1", &self.seqstarted1())
                    .field("seqend0", &self.seqend0())
                    .field("seqend1", &self.seqend1())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .field("loopsdone", &self.loopsdone())
                    .field("ramunderflow", &self.ramunderflow())
                    .field("dmaseq0end", &self.dmaseq0end())
                    .field("dmaseq0ready", &self.dmaseq0ready())
                    .field("dmaseq0buserror", &self.dmaseq0buserror())
                    .field("dmaseq1end", &self.dmaseq1end())
                    .field("dmaseq1ready", &self.dmaseq1ready())
                    .field("dmaseq1buserror", &self.dmaseq1buserror())
                    .field("comparematch[0]", &self.comparematch(0usize))
                    .field("comparematch[1]", &self.comparematch(1usize))
                    .field("comparematch[2]", &self.comparematch(2usize))
                    .field("comparematch[3]", &self.comparematch(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, seqstarted0: {=bool:?}, seqstarted1: {=bool:?}, seqend0: {=bool:?}, seqend1: {=bool:?}, pwmperiodend: {=bool:?}, loopsdone: {=bool:?}, ramunderflow: {=bool:?}, dmaseq0end: {=bool:?}, dmaseq0ready: {=bool:?}, dmaseq0buserror: {=bool:?}, dmaseq1end: {=bool:?}, dmaseq1ready: {=bool:?}, dmaseq1buserror: {=bool:?}, comparematch[0]: {=bool:?}, comparematch[1]: {=bool:?}, comparematch[2]: {=bool:?}, comparematch[3]: {=bool:?} }}" , self . stopped () , self . seqstarted0 () , self . seqstarted1 () , self . seqend0 () , self . seqend1 () , self . pwmperiodend () , self . loopsdone () , self . ramunderflow () , self . dmaseq0end () , self . dmaseq0ready () , self . dmaseq0buserror () , self . dmaseq1end () , self . dmaseq1ready () , self . dmaseq1buserror () , self . comparematch (0usize) , self . comparematch (1usize) , self . comparematch (2usize) , self . comparematch (3usize))
            }
        }
        #[doc = "Number of playbacks of a loop"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Loop(pub u32);
        impl Loop {
            #[doc = "Number of playbacks of pattern cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::LoopCnt {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::LoopCnt::from_bits(val as u16)
            }
            #[doc = "Number of playbacks of pattern cycles"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::LoopCnt) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Loop {
            #[inline(always)]
            fn default() -> Loop {
                Loop(0)
            }
        }
        impl core::fmt::Debug for Loop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Loop").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Loop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Loop {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[must_use]
            #[inline(always)]
            pub const fn updown(&self) -> super::vals::Updown {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Updown::from_bits(val as u8)
            }
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[inline(always)]
            pub const fn set_updown(&mut self, val: super::vals::Updown) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("updown", &self.updown())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ updown: {:?} }}", self.updown())
            }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler of PWM_CLK"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> super::vals::Prescaler {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Prescaler::from_bits(val as u8)
            }
            #[doc = "Prescaler of PWM_CLK"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: super::vals::Prescaler) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {:?} }}", self.prescaler())
            }
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refresh(pub u32);
        impl Refresh {
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::RefreshCnt {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                super::vals::RefreshCnt::from_bits(val as u32)
            }
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::RefreshCnt) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Refresh {
            #[inline(always)]
            fn default() -> Refresh {
                Refresh(0)
            }
        }
        impl core::fmt::Debug for Refresh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refresh").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refresh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refresh {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0_stop(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend0_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend1_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_dma_seq0_start(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn set_loopsdone_dma_seq0_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_dma_seq1_start(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn set_loopsdone_dma_seq1_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[inline(always)]
            pub const fn set_loopsdone_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ramunderflow_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[inline(always)]
            pub const fn set_ramunderflow_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_seq0_buserror_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn set_dma_seq0_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_seq1_buserror_stop(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn set_dma_seq1_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("seqend0_stop", &self.seqend0_stop())
                    .field("seqend1_stop", &self.seqend1_stop())
                    .field("loopsdone_dma_seq0_start", &self.loopsdone_dma_seq0_start())
                    .field("loopsdone_dma_seq1_start", &self.loopsdone_dma_seq1_start())
                    .field("loopsdone_stop", &self.loopsdone_stop())
                    .field("ramunderflow_stop", &self.ramunderflow_stop())
                    .field("dma_seq0_buserror_stop", &self.dma_seq0_buserror_stop())
                    .field("dma_seq1_buserror_stop", &self.dma_seq1_buserror_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ seqend0_stop: {=bool:?}, seqend1_stop: {=bool:?}, loopsdone_dma_seq0_start: {=bool:?}, loopsdone_dma_seq1_start: {=bool:?}, loopsdone_stop: {=bool:?}, ramunderflow_stop: {=bool:?}, dma_seq0_buserror_stop: {=bool:?}, dma_seq1_buserror_stop: {=bool:?} }}" , self . seqend0_stop () , self . seqend1_stop () , self . loopsdone_dma_seq0_start () , self . loopsdone_dma_seq1_start () , self . loopsdone_stop () , self . ramunderflow_stop () , self . dma_seq0_buserror_stop () , self . dma_seq1_buserror_stop ())
            }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Terminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Load {
            #[doc = "1st half word (16-bit) used in all PWM channels 0..3"]
            COMMON = 0x0,
            #[doc = "1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3"]
            GROUPED = 0x01,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3"]
            INDIVIDUAL = 0x02,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP"]
            WAVE_FORM = 0x03,
        }
        impl Load {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Load {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Load {
            #[inline(always)]
            fn from(val: u8) -> Load {
                Load::from_bits(val)
            }
        }
        impl From<Load> for u8 {
            #[inline(always)]
            fn from(val: Load) -> u8 {
                Load::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct LoopCnt(u16);
        impl LoopCnt {
            #[doc = "Looping disabled (stop at the end of the sequence)"]
            pub const DISABLED: Self = Self(0x0);
        }
        impl LoopCnt {
            pub const fn from_bits(val: u16) -> LoopCnt {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for LoopCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LoopCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for LoopCnt {
            #[inline(always)]
            fn from(val: u16) -> LoopCnt {
                LoopCnt::from_bits(val)
            }
        }
        impl From<LoopCnt> for u16 {
            #[inline(always)]
            fn from(val: LoopCnt) -> u16 {
                LoopCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "SEQ\\[n\\].REFRESH is used to determine loading internal compare registers"]
            REFRESH_COUNT = 0x0,
            #[doc = "NEXTSTEP task causes a new value to be loaded to internal compare registers"]
            NEXT_STEP = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prescaler {
            #[doc = "Divide by 1 (16 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (8 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (4 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (2 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (1 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (500 kHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (250 kHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (125 kHz)"]
            DIV_128 = 0x07,
        }
        impl Prescaler {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prescaler {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prescaler {
            #[inline(always)]
            fn from(val: u8) -> Prescaler {
                Prescaler::from_bits(val)
            }
        }
        impl From<Prescaler> for u8 {
            #[inline(always)]
            fn from(val: Prescaler) -> u8 {
                Prescaler::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct RefreshCnt(u32);
        impl RefreshCnt {
            #[doc = "Update every PWM period"]
            pub const CONTINUOUS: Self = Self(0x0);
        }
        impl RefreshCnt {
            pub const fn from_bits(val: u32) -> RefreshCnt {
                Self(val & 0x00ff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for RefreshCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("CONTINUOUS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RefreshCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "CONTINUOUS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for RefreshCnt {
            #[inline(always)]
            fn from(val: u32) -> RefreshCnt {
                RefreshCnt::from_bits(val)
            }
        }
        impl From<RefreshCnt> for u32 {
            #[inline(always)]
            fn from(val: RefreshCnt) -> u32 {
                RefreshCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Updown {
            #[doc = "Up counter, edge-aligned PWM duty cycle"]
            UP = 0x0,
            #[doc = "Up and down counter, center-aligned PWM duty cycle"]
            UP_AND_DOWN = 0x01,
        }
        impl Updown {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Updown {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Updown {
            #[inline(always)]
            fn from(val: u8) -> Updown {
                Updown::from_bits(val)
            }
        }
        impl From<Updown> for u8 {
            #[inline(always)]
            fn from(val: Updown) -> u8 {
                Updown::to_bits(val)
            }
        }
    }
}
pub mod qdec {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for LED signal"]
        #[inline(always)]
        pub const fn led(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for A signal"]
        #[inline(always)]
        pub const fn a(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for B signal"]
        #[inline(always)]
        pub const fn b(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Quadrature Decoder 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qdec {
        ptr: *mut u8,
    }
    unsafe impl Send for Qdec {}
    unsafe impl Sync for Qdec {}
    impl Qdec {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Task starting the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Task stopping the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Read and clear ACC and ACCDBL"]
        #[inline(always)]
        pub const fn tasks_readclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Read and clear ACC"]
        #[inline(always)]
        pub const fn tasks_rdclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Read and clear ACCDBL"]
        #[inline(always)]
        pub const fn tasks_rdclrdbl(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task READCLRACC"]
        #[inline(always)]
        pub const fn subscribe_readclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRACC"]
        #[inline(always)]
        pub const fn subscribe_rdclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRDBL"]
        #[inline(always)]
        pub const fn subscribe_rdclrdbl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Event being generated for every new sample value written to the SAMPLE register"]
        #[inline(always)]
        pub const fn events_samplerdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Non-null report ready"]
        #[inline(always)]
        pub const fn events_reportrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "ACC or ACCDBL register overflow"]
        #[inline(always)]
        pub const fn events_accof(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Double displacement(s) detected"]
        #[inline(always)]
        pub const fn events_dblrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "QDEC has been stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event SAMPLERDY"]
        #[inline(always)]
        pub const fn publish_samplerdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event REPORTRDY"]
        #[inline(always)]
        pub const fn publish_reportrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACCOF"]
        #[inline(always)]
        pub const fn publish_accof(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DBLRDY"]
        #[inline(always)]
        pub const fn publish_dblrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable the quadrature decoder"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "LED output pin polarity"]
        #[inline(always)]
        pub const fn ledpol(self) -> crate::common::Reg<regs::Ledpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Sample period"]
        #[inline(always)]
        pub const fn sampleper(self) -> crate::common::Reg<regs::Sampleper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Motion sample value"]
        #[inline(always)]
        pub const fn sample(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[inline(always)]
        pub const fn reportper(self) -> crate::common::Reg<regs::Reportper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Register accumulating the valid transitions"]
        #[inline(always)]
        pub const fn acc(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize) as _) }
        }
        #[doc = "Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task"]
        #[inline(always)]
        pub const fn accread(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x051cusize) as _) }
        }
        #[doc = "Enable input debounce filters"]
        #[inline(always)]
        pub const fn dbfen(self) -> crate::common::Reg<regs::Dbfen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0528usize) as _) }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[inline(always)]
        pub const fn ledpre(self) -> crate::common::Reg<regs::Ledpre, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "Register accumulating the number of detected double transitions"]
        #[inline(always)]
        pub const fn accdbl(self) -> crate::common::Reg<regs::Accdbl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0544usize) as _) }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[inline(always)]
        pub const fn accdblread(self) -> crate::common::Reg<regs::Accdblread, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0548usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Register accumulating the number of detected double transitions"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdbl(pub u32);
        impl Accdbl {
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[must_use]
            #[inline(always)]
            pub const fn accdbl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[inline(always)]
            pub const fn set_accdbl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdbl {
            #[inline(always)]
            fn default() -> Accdbl {
                Accdbl(0)
            }
        }
        impl core::fmt::Debug for Accdbl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdbl")
                    .field("accdbl", &self.accdbl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdbl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Accdbl {{ accdbl: {=u8:?} }}", self.accdbl())
            }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdblread(pub u32);
        impl Accdblread {
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn accdblread(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[inline(always)]
            pub const fn set_accdblread(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdblread {
            #[inline(always)]
            fn default() -> Accdblread {
                Accdblread(0)
            }
        }
        impl core::fmt::Debug for Accdblread {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdblread")
                    .field("accdblread", &self.accdblread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdblread {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Accdblread {{ accdblread: {=u8:?} }}", self.accdblread())
            }
        }
        #[doc = "Enable input debounce filters"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbfen(pub u32);
        impl Dbfen {
            #[doc = "Enable input debounce filters"]
            #[must_use]
            #[inline(always)]
            pub const fn dbfen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable input debounce filters"]
            #[inline(always)]
            pub const fn set_dbfen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbfen {
            #[inline(always)]
            fn default() -> Dbfen {
                Dbfen(0)
            }
        }
        impl core::fmt::Debug for Dbfen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbfen")
                    .field("dbfen", &self.dbfen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbfen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dbfen {{ dbfen: {=bool:?} }}", self.dbfen())
            }
        }
        #[doc = "Enable the quadrature decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable the quadrature decoder"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable the quadrature decoder"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[inline(always)]
            pub const fn set_samplerdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[inline(always)]
            pub const fn set_reportrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[must_use]
            #[inline(always)]
            pub const fn accof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[inline(always)]
            pub const fn set_accof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[inline(always)]
            pub const fn set_dblrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("samplerdy", &self.samplerdy())
                    .field("reportrdy", &self.reportrdy())
                    .field("accof", &self.accof())
                    .field("dblrdy", &self.dblrdy())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ samplerdy: {=bool:?}, reportrdy: {=bool:?}, accof: {=bool:?}, dblrdy: {=bool:?}, stopped: {=bool:?} }}" , self . samplerdy () , self . reportrdy () , self . accof () , self . dblrdy () , self . stopped ())
            }
        }
        #[doc = "LED output pin polarity"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpol(pub u32);
        impl Ledpol {
            #[doc = "LED output pin polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn ledpol(&self) -> super::vals::Ledpol {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ledpol::from_bits(val as u8)
            }
            #[doc = "LED output pin polarity"]
            #[inline(always)]
            pub const fn set_ledpol(&mut self, val: super::vals::Ledpol) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ledpol {
            #[inline(always)]
            fn default() -> Ledpol {
                Ledpol(0)
            }
        }
        impl core::fmt::Debug for Ledpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpol")
                    .field("ledpol", &self.ledpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ledpol {{ ledpol: {:?} }}", self.ledpol())
            }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpre(pub u32);
        impl Ledpre {
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[must_use]
            #[inline(always)]
            pub const fn ledpre(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[inline(always)]
            pub const fn set_ledpre(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ledpre {
            #[inline(always)]
            fn default() -> Ledpre {
                Ledpre(0)
            }
        }
        impl core::fmt::Debug for Ledpre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpre")
                    .field("ledpre", &self.ledpre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpre {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ledpre {{ ledpre: {=u16:?} }}", self.ledpre())
            }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reportper(pub u32);
        impl Reportper {
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[must_use]
            #[inline(always)]
            pub const fn reportper(&self) -> super::vals::Reportper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Reportper::from_bits(val as u8)
            }
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[inline(always)]
            pub const fn set_reportper(&mut self, val: super::vals::Reportper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Reportper {
            #[inline(always)]
            fn default() -> Reportper {
                Reportper(0)
            }
        }
        impl core::fmt::Debug for Reportper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reportper")
                    .field("reportper", &self.reportper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reportper {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Reportper {{ reportper: {:?} }}", self.reportper())
            }
        }
        #[doc = "Sample period"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sampleper(pub u32);
        impl Sampleper {
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[must_use]
            #[inline(always)]
            pub const fn sampleper(&self) -> super::vals::Sampleper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Sampleper::from_bits(val as u8)
            }
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[inline(always)]
            pub const fn set_sampleper(&mut self, val: super::vals::Sampleper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Sampleper {
            #[inline(always)]
            fn default() -> Sampleper {
                Sampleper(0)
            }
        }
        impl core::fmt::Debug for Sampleper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sampleper")
                    .field("sampleper", &self.sampleper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sampleper {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sampleper {{ sampleper: {:?} }}", self.sampleper())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_readclracc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[inline(always)]
            pub const fn set_reportrdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[inline(always)]
            pub const fn set_samplerdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_rdclracc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[inline(always)]
            pub const fn set_reportrdy_rdclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[inline(always)]
            pub const fn set_reportrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy_rdclrdbl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[inline(always)]
            pub const fn set_dblrdy_rdclrdbl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[inline(always)]
            pub const fn set_dblrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy_readclracc(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[inline(always)]
            pub const fn set_samplerdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("reportrdy_readclracc", &self.reportrdy_readclracc())
                    .field("samplerdy_stop", &self.samplerdy_stop())
                    .field("reportrdy_rdclracc", &self.reportrdy_rdclracc())
                    .field("reportrdy_stop", &self.reportrdy_stop())
                    .field("dblrdy_rdclrdbl", &self.dblrdy_rdclrdbl())
                    .field("dblrdy_stop", &self.dblrdy_stop())
                    .field("samplerdy_readclracc", &self.samplerdy_readclracc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ reportrdy_readclracc: {=bool:?}, samplerdy_stop: {=bool:?}, reportrdy_rdclracc: {=bool:?}, reportrdy_stop: {=bool:?}, dblrdy_rdclrdbl: {=bool:?}, dblrdy_stop: {=bool:?}, samplerdy_readclracc: {=bool:?} }}" , self . reportrdy_readclracc () , self . samplerdy_stop () , self . reportrdy_rdclracc () , self . reportrdy_stop () , self . dblrdy_rdclrdbl () , self . dblrdy_stop () , self . samplerdy_readclracc ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ledpol {
            #[doc = "Led active on output pin low"]
            ACTIVE_LOW = 0x0,
            #[doc = "Led active on output pin high"]
            ACTIVE_HIGH = 0x01,
        }
        impl Ledpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ledpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ledpol {
            #[inline(always)]
            fn from(val: u8) -> Ledpol {
                Ledpol::from_bits(val)
            }
        }
        impl From<Ledpol> for u8 {
            #[inline(always)]
            fn from(val: Ledpol) -> u8 {
                Ledpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reportper {
            #[doc = "10 samples/report"]
            _10SMPL = 0x0,
            #[doc = "40 samples/report"]
            _40SMPL = 0x01,
            #[doc = "80 samples/report"]
            _80SMPL = 0x02,
            #[doc = "120 samples/report"]
            _120SMPL = 0x03,
            #[doc = "160 samples/report"]
            _160SMPL = 0x04,
            #[doc = "200 samples/report"]
            _200SMPL = 0x05,
            #[doc = "240 samples/report"]
            _240SMPL = 0x06,
            #[doc = "280 samples/report"]
            _280SMPL = 0x07,
            #[doc = "1 sample/report"]
            _1SMPL = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Reportper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reportper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reportper {
            #[inline(always)]
            fn from(val: u8) -> Reportper {
                Reportper::from_bits(val)
            }
        }
        impl From<Reportper> for u8 {
            #[inline(always)]
            fn from(val: Reportper) -> u8 {
                Reportper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampleper {
            #[doc = "128 us"]
            _128US = 0x0,
            #[doc = "256 us"]
            _256US = 0x01,
            #[doc = "512 us"]
            _512US = 0x02,
            #[doc = "1024 us"]
            _1024US = 0x03,
            #[doc = "2048 us"]
            _2048US = 0x04,
            #[doc = "4096 us"]
            _4096US = 0x05,
            #[doc = "8192 us"]
            _8192US = 0x06,
            #[doc = "16384 us"]
            _16384US = 0x07,
            #[doc = "32768 us"]
            _32MS = 0x08,
            #[doc = "65536 us"]
            _65MS = 0x09,
            #[doc = "131072 us"]
            _131MS = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sampleper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampleper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampleper {
            #[inline(always)]
            fn from(val: u8) -> Sampleper {
                Sampleper::from_bits(val)
            }
        }
        impl From<Sampleper> for u8 {
            #[inline(always)]
            fn from(val: Sampleper) -> u8 {
                Sampleper::to_bits(val)
            }
        }
    }
}
pub mod radio {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Auxdata {
        ptr: *mut u8,
    }
    unsafe impl Send for Auxdata {}
    unsafe impl Sync for Auxdata {}
    impl Auxdata {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: AUXDATA configuration"]
        #[inline(always)]
        pub const fn cnf(self, n: usize) -> crate::common::Reg<regs::Cnf, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Auxdatadma {
        ptr: *mut u8,
    }
    unsafe impl Send for Auxdatadma {}
    unsafe impl Sync for Auxdatadma {}
    impl Auxdatadma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Enable or disable data acquisition"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: DMA pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Maximum number of 32-bit words to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::AuxdatadmaMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Number of 32-bit words transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::AuxdatadmaAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cstones {
        ptr: *mut u8,
    }
    unsafe impl Send for Cstones {}
    unsafe impl Sync for Cstones {}
    impl Cstones {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::CstonesMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[inline(always)]
        pub const fn numsamples(self) -> crate::common::Reg<regs::Numsamples, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[inline(always)]
        pub const fn nextfrequency(
            self,
        ) -> crate::common::Reg<regs::Nextfrequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[inline(always)]
        pub const fn faepeer(self) -> crate::common::Reg<regs::Faepeer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn phaseshift(self) -> crate::common::Reg<regs::Phaseshift, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn numsamplescoeff(
            self,
        ) -> crate::common::Reg<regs::Numsamplescoeff, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[inline(always)]
        pub const fn pct16(self) -> crate::common::Reg<regs::Pct16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[inline(always)]
        pub const fn magphasemean(
            self,
        ) -> crate::common::Reg<regs::Magphasemean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Mean of IQ values"]
        #[inline(always)]
        pub const fn iqrawmean(self) -> crate::common::Reg<regs::Iqrawmean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[inline(always)]
        pub const fn magstd(self) -> crate::common::Reg<regs::Magstd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "FFO estimate"]
        #[inline(always)]
        pub const fn ffoest(self) -> crate::common::Reg<regs::Ffoest, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[inline(always)]
        pub const fn downsample(self) -> crate::common::Reg<regs::Downsample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "Frequency offset estimate"]
        #[inline(always)]
        pub const fn freqoffset(self) -> crate::common::Reg<regs::Freqoffset, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
    }
    #[doc = "DFE packet EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dfepacket {
        ptr: *mut u8,
    }
    unsafe impl Send for Dfepacket {}
    unsafe impl Sync for Dfepacket {}
    impl Dfepacket {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::DfepacketMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::DfepacketAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Pin select for DFE pin n"]
        #[inline(always)]
        pub const fn dfegpio(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "2.4 GHz radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Radio {
        ptr: *mut u8,
    }
    unsafe impl Send for Radio {}
    unsafe impl Sync for Radio {}
    impl Radio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable RADIO in TX mode"]
        #[inline(always)]
        pub const fn tasks_txen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Enable RADIO in RX mode"]
        #[inline(always)]
        pub const fn tasks_rxen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Start RADIO"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Stop RADIO"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Disable RADIO"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
        #[inline(always)]
        pub const fn tasks_rssistart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Start the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Stop the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_edstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Stop the energy detect measurement"]
        #[inline(always)]
        pub const fn tasks_edstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_ccastart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Stop the clear channel assessment"]
        #[inline(always)]
        pub const fn tasks_ccastop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Start DMA transaction of acquisition"]
        #[inline(always)]
        pub const fn tasks_auxdatadmastart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "Stop ongoing DMA transaction of acquisition"]
        #[inline(always)]
        pub const fn tasks_auxdatadmastop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
        #[doc = "Enable RADIO in PLL mode (standby for either TX or RX)"]
        #[inline(always)]
        pub const fn tasks_pllen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x6cusize) as _) }
        }
        #[doc = "Start tone processing for channel sounding"]
        #[inline(always)]
        pub const fn tasks_cstonesstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "Reset all public registers, but with these exceptions: DMA registers and EVENT/INTEN/SUBSCRIBE/PUBLISH registers. Only to be used in DISABLED state."]
        #[inline(always)]
        pub const fn tasks_softreset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task TXEN"]
        #[inline(always)]
        pub const fn subscribe_txen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Subscribe configuration for task RXEN"]
        #[inline(always)]
        pub const fn subscribe_rxen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Subscribe configuration for task RSSISTART"]
        #[inline(always)]
        pub const fn subscribe_rssistart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTART"]
        #[inline(always)]
        pub const fn subscribe_bcstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTOP"]
        #[inline(always)]
        pub const fn subscribe_bcstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTART"]
        #[inline(always)]
        pub const fn subscribe_edstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0120usize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTOP"]
        #[inline(always)]
        pub const fn subscribe_edstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTART"]
        #[inline(always)]
        pub const fn subscribe_ccastart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0128usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTOP"]
        #[inline(always)]
        pub const fn subscribe_ccastop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x012cusize) as _) }
        }
        #[doc = "Subscribe configuration for task AUXDATADMASTART"]
        #[inline(always)]
        pub const fn subscribe_auxdatadmastart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0138usize) as _) }
        }
        #[doc = "Subscribe configuration for task AUXDATADMASTOP"]
        #[inline(always)]
        pub const fn subscribe_auxdatadmastop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x013cusize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLEN"]
        #[inline(always)]
        pub const fn subscribe_pllen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x016cusize) as _) }
        }
        #[doc = "Subscribe configuration for task CSTONESSTART"]
        #[inline(always)]
        pub const fn subscribe_cstonesstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a0usize) as _) }
        }
        #[doc = "Subscribe configuration for task SOFTRESET"]
        #[inline(always)]
        pub const fn subscribe_softreset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started TX path"]
        #[inline(always)]
        pub const fn events_txready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0204usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started RX path"]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0208usize) as _) }
        }
        #[doc = "Address sent or received"]
        #[inline(always)]
        pub const fn events_address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x020cusize) as _) }
        }
        #[doc = "IEEE 802.15.4 length field received"]
        #[inline(always)]
        pub const fn events_framestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0210usize) as _) }
        }
        #[doc = "Packet payload sent or received"]
        #[inline(always)]
        pub const fn events_payload(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0214usize) as _) }
        }
        #[doc = "Memory access for packet data has been completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0218usize) as _) }
        }
        #[doc = "The last bit is sent on air or last bit is received"]
        #[inline(always)]
        pub const fn events_phyend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x021cusize) as _) }
        }
        #[doc = "RADIO has been disabled"]
        #[inline(always)]
        pub const fn events_disabled(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0220usize) as _) }
        }
        #[doc = "A device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0224usize) as _) }
        }
        #[doc = "No device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmiss(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0228usize) as _) }
        }
        #[doc = "Packet received with CRC ok"]
        #[inline(always)]
        pub const fn events_crcok(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x022cusize) as _) }
        }
        #[doc = "Packet received with CRC error"]
        #[inline(always)]
        pub const fn events_crcerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0230usize) as _) }
        }
        #[doc = "Bit counter reached bit count value"]
        #[inline(always)]
        pub const fn events_bcmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0238usize) as _) }
        }
        #[doc = "Sampling of energy detection complete (a new ED sample is ready for readout from the RADIO.EDSAMPLE register)"]
        #[inline(always)]
        pub const fn events_edend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x023cusize) as _) }
        }
        #[doc = "The sampling of energy detection has stopped"]
        #[inline(always)]
        pub const fn events_edstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0240usize) as _) }
        }
        #[doc = "Wireless medium in idle - clear to send"]
        #[inline(always)]
        pub const fn events_ccaidle(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0244usize) as _) }
        }
        #[doc = "Wireless medium busy - do not send"]
        #[inline(always)]
        pub const fn events_ccabusy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0248usize) as _) }
        }
        #[doc = "The CCA has stopped"]
        #[inline(always)]
        pub const fn events_ccastopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x024cusize) as _) }
        }
        #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit"]
        #[inline(always)]
        pub const fn events_rateboost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0250usize) as _) }
        }
        #[doc = "MAC header match found"]
        #[inline(always)]
        pub const fn events_mhrmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0254usize) as _) }
        }
        #[doc = "Initial sync detected"]
        #[inline(always)]
        pub const fn events_sync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0258usize) as _) }
        }
        #[doc = "CTEInfo byte is received"]
        #[inline(always)]
        pub const fn events_ctepresent(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x025cusize) as _) }
        }
        #[doc = "PLL has settled and RADIO is ready to be enabled in either TX or RX mode"]
        #[inline(always)]
        pub const fn events_pllready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02b0usize) as _) }
        }
        #[doc = "Address received"]
        #[inline(always)]
        pub const fn events_rxaddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02bcusize) as _) }
        }
        #[doc = "AUXDATA DMA end"]
        #[inline(always)]
        pub const fn events_auxdatadmaend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02c0usize) as _) }
        }
        #[doc = "The channel sounding tone processing is complete"]
        #[inline(always)]
        pub const fn events_cstonesend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02c8usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Publish configuration for event TXREADY"]
        #[inline(always)]
        pub const fn publish_txready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Publish configuration for event RXREADY"]
        #[inline(always)]
        pub const fn publish_rxready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Publish configuration for event ADDRESS"]
        #[inline(always)]
        pub const fn publish_address(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMESTART"]
        #[inline(always)]
        pub const fn publish_framestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0310usize) as _) }
        }
        #[doc = "Publish configuration for event PAYLOAD"]
        #[inline(always)]
        pub const fn publish_payload(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0314usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0318usize) as _) }
        }
        #[doc = "Publish configuration for event PHYEND"]
        #[inline(always)]
        pub const fn publish_phyend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x031cusize) as _) }
        }
        #[doc = "Publish configuration for event DISABLED"]
        #[inline(always)]
        pub const fn publish_disabled(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0320usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMATCH"]
        #[inline(always)]
        pub const fn publish_devmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0324usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMISS"]
        #[inline(always)]
        pub const fn publish_devmiss(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0328usize) as _) }
        }
        #[doc = "Publish configuration for event CRCOK"]
        #[inline(always)]
        pub const fn publish_crcok(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x032cusize) as _) }
        }
        #[doc = "Publish configuration for event CRCERROR"]
        #[inline(always)]
        pub const fn publish_crcerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0330usize) as _) }
        }
        #[doc = "Publish configuration for event BCMATCH"]
        #[inline(always)]
        pub const fn publish_bcmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0338usize) as _) }
        }
        #[doc = "Publish configuration for event EDEND"]
        #[inline(always)]
        pub const fn publish_edend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x033cusize) as _) }
        }
        #[doc = "Publish configuration for event EDSTOPPED"]
        #[inline(always)]
        pub const fn publish_edstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0340usize) as _) }
        }
        #[doc = "Publish configuration for event CCAIDLE"]
        #[inline(always)]
        pub const fn publish_ccaidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0344usize) as _) }
        }
        #[doc = "Publish configuration for event CCABUSY"]
        #[inline(always)]
        pub const fn publish_ccabusy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0348usize) as _) }
        }
        #[doc = "Publish configuration for event CCASTOPPED"]
        #[inline(always)]
        pub const fn publish_ccastopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x034cusize) as _) }
        }
        #[doc = "Publish configuration for event RATEBOOST"]
        #[inline(always)]
        pub const fn publish_rateboost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0350usize) as _) }
        }
        #[doc = "Publish configuration for event MHRMATCH"]
        #[inline(always)]
        pub const fn publish_mhrmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0354usize) as _) }
        }
        #[doc = "Publish configuration for event SYNC"]
        #[inline(always)]
        pub const fn publish_sync(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0358usize) as _) }
        }
        #[doc = "Publish configuration for event CTEPRESENT"]
        #[inline(always)]
        pub const fn publish_ctepresent(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x035cusize) as _) }
        }
        #[doc = "Publish configuration for event PLLREADY"]
        #[inline(always)]
        pub const fn publish_pllready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03b0usize) as _) }
        }
        #[doc = "Publish configuration for event RXADDRESS"]
        #[inline(always)]
        pub const fn publish_rxaddress(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03bcusize) as _) }
        }
        #[doc = "Publish configuration for event AUXDATADMAEND"]
        #[inline(always)]
        pub const fn publish_auxdatadmaend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03c0usize) as _) }
        }
        #[doc = "Publish configuration for event CSTONESEND"]
        #[inline(always)]
        pub const fn publish_cstonesend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03c8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset0(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Int0, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0488usize + n * 32usize) as _)
            }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Int1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x048cusize + n * 32usize) as _)
            }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr0(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Int0, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0490usize + n * 32usize) as _)
            }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr1(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Int1, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0494usize + n * 32usize) as _)
            }
        }
        #[doc = "Data rate and modulation"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::RadioMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Configurable delay of PHYEND event for TX"]
        #[inline(always)]
        pub const fn phyendtxdelay(
            self,
        ) -> crate::common::Reg<regs::Phyendtxdelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Current radio state"]
        #[inline(always)]
        pub const fn state(self) -> crate::common::Reg<regs::State, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[inline(always)]
        pub const fn edctrl(self) -> crate::common::Reg<regs::Edctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[inline(always)]
        pub const fn edsample(self) -> crate::common::Reg<regs::Edsample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[inline(always)]
        pub const fn ccactrl(self) -> crate::common::Reg<regs::Ccactrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Data whitening configuration"]
        #[inline(always)]
        pub const fn datawhite(self) -> crate::common::Reg<regs::Datawhite, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn auxdata(self) -> Auxdata {
            unsafe { Auxdata::from_ptr(self.ptr.wrapping_add(0x0548usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn auxdatadma(self, n: usize) -> Auxdatadma {
            assert!(n < 2usize);
            unsafe { Auxdatadma::from_ptr(self.ptr.wrapping_add(0x0550usize + n * 16usize) as _) }
        }
        #[doc = "Timing"]
        #[inline(always)]
        pub const fn timing(self) -> crate::common::Reg<regs::Timing, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0704usize) as _) }
        }
        #[doc = "Frequency"]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0708usize) as _) }
        }
        #[doc = "Output power"]
        #[inline(always)]
        pub const fn txpower(self) -> crate::common::Reg<regs::Txpower, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0710usize) as _) }
        }
        #[doc = "Interframe spacing in us"]
        #[inline(always)]
        pub const fn tifs(self) -> crate::common::Reg<regs::Tifs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0714usize) as _) }
        }
        #[doc = "RSSI sample"]
        #[inline(always)]
        pub const fn rssisample(self) -> crate::common::Reg<regs::Rssisample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0718usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxgain(self) -> Rxgain {
            unsafe { Rxgain::from_ptr(self.ptr.wrapping_add(0x07d0usize) as _) }
        }
        #[doc = "Fine tuning of the RF frequency"]
        #[inline(always)]
        pub const fn freqfinetune(
            self,
        ) -> crate::common::Reg<regs::Freqfinetune, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0804usize) as _) }
        }
        #[doc = "Config register"]
        #[inline(always)]
        pub const fn feconfig(self) -> crate::common::Reg<regs::Feconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0908usize) as _) }
        }
        #[doc = "Carrier freq. offset estimate"]
        #[inline(always)]
        pub const fn cfo_stat(self) -> crate::common::Reg<regs::CfoStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b00usize) as _) }
        }
        #[doc = "Correlator thresholds"]
        #[inline(always)]
        pub const fn dbccorr(self) -> crate::common::Reg<regs::Dbccorr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b40usize) as _) }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[inline(always)]
        pub const fn dfemode(self) -> crate::common::Reg<regs::Dfemode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d00usize) as _) }
        }
        #[doc = "DFE status information"]
        #[inline(always)]
        pub const fn dfestatus(self) -> crate::common::Reg<regs::Dfestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d04usize) as _) }
        }
        #[doc = "Various configuration for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl1(self) -> crate::common::Reg<regs::Dfectrl1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d10usize) as _) }
        }
        #[doc = "Start offset for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl2(self) -> crate::common::Reg<regs::Dfectrl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d14usize) as _) }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[inline(always)]
        pub const fn switchpattern(
            self,
        ) -> crate::common::Reg<regs::Switchpattern, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d28usize) as _) }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[inline(always)]
        pub const fn clearpattern(
            self,
        ) -> crate::common::Reg<regs::Clearpattern, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d2cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0d30usize) as _) }
        }
        #[doc = "DFE packet EasyDMA channel"]
        #[inline(always)]
        pub const fn dfepacket(self) -> Dfepacket {
            unsafe { Dfepacket::from_ptr(self.ptr.wrapping_add(0x0d50usize) as _) }
        }
        #[doc = "CRC status"]
        #[inline(always)]
        pub const fn crcstatus(self) -> crate::common::Reg<regs::Crcstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e0cusize) as _) }
        }
        #[doc = "Received address"]
        #[inline(always)]
        pub const fn rxmatch(self) -> crate::common::Reg<regs::Rxmatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e10usize) as _) }
        }
        #[doc = "CRC field of previously received packet"]
        #[inline(always)]
        pub const fn rxcrc(self) -> crate::common::Reg<regs::Rxcrc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e14usize) as _) }
        }
        #[doc = "Device address match index"]
        #[inline(always)]
        pub const fn dai(self) -> crate::common::Reg<regs::Dai, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e18usize) as _) }
        }
        #[doc = "Payload status"]
        #[inline(always)]
        pub const fn pdustat(self) -> crate::common::Reg<regs::Pdustat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e1cusize) as _) }
        }
        #[doc = "Packet configuration register 0"]
        #[inline(always)]
        pub const fn pcnf0(self) -> crate::common::Reg<regs::Pcnf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e20usize) as _) }
        }
        #[doc = "Packet configuration register 1"]
        #[inline(always)]
        pub const fn pcnf1(self) -> crate::common::Reg<regs::Pcnf1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e28usize) as _) }
        }
        #[doc = "Base address 0"]
        #[inline(always)]
        pub const fn base0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e2cusize) as _) }
        }
        #[doc = "Base address 1"]
        #[inline(always)]
        pub const fn base1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e30usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[inline(always)]
        pub const fn prefix0(self) -> crate::common::Reg<regs::Prefix0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e34usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[inline(always)]
        pub const fn prefix1(self) -> crate::common::Reg<regs::Prefix1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e38usize) as _) }
        }
        #[doc = "Transmit address select"]
        #[inline(always)]
        pub const fn txaddress(self) -> crate::common::Reg<regs::Txaddress, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e3cusize) as _) }
        }
        #[doc = "Receive address select"]
        #[inline(always)]
        pub const fn rxaddresses(self) -> crate::common::Reg<regs::Rxaddresses, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e40usize) as _) }
        }
        #[doc = "CRC configuration"]
        #[inline(always)]
        pub const fn crccnf(self) -> crate::common::Reg<regs::Crccnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e44usize) as _) }
        }
        #[doc = "CRC polynomial"]
        #[inline(always)]
        pub const fn crcpoly(self) -> crate::common::Reg<regs::Crcpoly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e48usize) as _) }
        }
        #[doc = "CRC initial value"]
        #[inline(always)]
        pub const fn crcinit(self) -> crate::common::Reg<regs::Crcinit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e4cusize) as _) }
        }
        #[doc = "Description collection: Device address base segment n"]
        #[inline(always)]
        pub const fn dab(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e50usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[inline(always)]
        pub const fn dap(self, n: usize) -> crate::common::Reg<regs::Dap, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e70usize + n * 4usize) as _)
            }
        }
        #[doc = "Device address match configuration"]
        #[inline(always)]
        pub const fn dacnf(self) -> crate::common::Reg<regs::Dacnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e90usize) as _) }
        }
        #[doc = "Bit counter compare"]
        #[inline(always)]
        pub const fn bcc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e94usize) as _) }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[inline(always)]
        pub const fn ctestatus(self) -> crate::common::Reg<regs::Ctestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ea4usize) as _) }
        }
        #[doc = "Search pattern configuration"]
        #[inline(always)]
        pub const fn mhrmatchconf(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0eb4usize) as _) }
        }
        #[doc = "Pattern mask"]
        #[inline(always)]
        pub const fn mhrmatchmask(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0eb8usize) as _) }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[inline(always)]
        pub const fn sfd(self) -> crate::common::Reg<regs::Sfd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ebcusize) as _) }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[inline(always)]
        pub const fn cteinlineconf(
            self,
        ) -> crate::common::Reg<regs::Cteinlineconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ec0usize) as _) }
        }
        #[doc = "Packet pointer"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ed0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cstones(self) -> Cstones {
            unsafe { Cstones::from_ptr(self.ptr.wrapping_add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rtt(self) -> Rtt {
            unsafe { Rtt::from_ptr(self.ptr.wrapping_add(0x1050usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtt {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtt {}
    unsafe impl Sync for Rtt {}
    impl Rtt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTT Config."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RttConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "RTT segments 0 and 1"]
        #[inline(always)]
        pub const fn segment01(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "RTT segments 2 and 3"]
        #[inline(always)]
        pub const fn segment23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "RTT segments 4 and 5"]
        #[inline(always)]
        pub const fn segment45(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "RTT segments 6 and 7"]
        #[inline(always)]
        pub const fn segment67(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxgain {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxgain {}
    unsafe impl Sync for Rxgain {}
    impl Rxgain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Override configuration of receiver gain control loop"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RxgainConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Number of 32-bit words transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxdatadmaAmount(pub u32);
        impl AuxdatadmaAmount {
            #[doc = "Number of 32-bit words transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Number of 32-bit words transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for AuxdatadmaAmount {
            #[inline(always)]
            fn default() -> AuxdatadmaAmount {
                AuxdatadmaAmount(0)
            }
        }
        impl core::fmt::Debug for AuxdatadmaAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxdatadmaAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxdatadmaAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxdatadmaAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Description cluster: Maximum number of 32-bit words to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxdatadmaMaxcnt(pub u32);
        impl AuxdatadmaMaxcnt {
            #[doc = "Maximum number of 32-bit words to transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Maximum number of 32-bit words to transfer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for AuxdatadmaMaxcnt {
            #[inline(always)]
            fn default() -> AuxdatadmaMaxcnt {
                AuxdatadmaMaxcnt(0)
            }
        }
        impl core::fmt::Debug for AuxdatadmaMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxdatadmaMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxdatadmaMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxdatadmaMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccactrl(pub u32);
        impl Ccactrl {
            #[doc = "CCA mode of operation"]
            #[must_use]
            #[inline(always)]
            pub const fn ccamode(&self) -> super::vals::Ccamode {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ccamode::from_bits(val as u8)
            }
            #[doc = "CCA mode of operation"]
            #[inline(always)]
            pub const fn set_ccamode(&mut self, val: super::vals::Ccamode) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[must_use]
            #[inline(always)]
            pub const fn ccaedthres(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[inline(always)]
            pub const fn set_ccaedthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[must_use]
            #[inline(always)]
            pub const fn ccacorrthres(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[inline(always)]
            pub const fn set_ccacorrthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[must_use]
            #[inline(always)]
            pub const fn ccacorrcnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[inline(always)]
            pub const fn set_ccacorrcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Ccactrl {
            #[inline(always)]
            fn default() -> Ccactrl {
                Ccactrl(0)
            }
        }
        impl core::fmt::Debug for Ccactrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccactrl")
                    .field("ccamode", &self.ccamode())
                    .field("ccaedthres", &self.ccaedthres())
                    .field("ccacorrthres", &self.ccacorrthres())
                    .field("ccacorrcnt", &self.ccacorrcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccactrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ccactrl {{ ccamode: {:?}, ccaedthres: {=u8:?}, ccacorrthres: {=u8:?}, ccacorrcnt: {=u8:?} }}" , self . ccamode () , self . ccaedthres () , self . ccacorrthres () , self . ccacorrcnt ())
            }
        }
        #[doc = "Carrier freq. offset estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CfoStat(pub u32);
        impl CfoStat {
            #[doc = "SYNC ok"]
            #[must_use]
            #[inline(always)]
            pub const fn syncok(&self) -> super::vals::Syncok {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Syncok::from_bits(val as u8)
            }
            #[doc = "SYNC ok"]
            #[inline(always)]
            pub const fn set_syncok(&mut self, val: super::vals::Syncok) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
        }
        impl Default for CfoStat {
            #[inline(always)]
            fn default() -> CfoStat {
                CfoStat(0)
            }
        }
        impl core::fmt::Debug for CfoStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CfoStat")
                    .field("syncok", &self.syncok())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CfoStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CfoStat {{ syncok: {:?} }}", self.syncok())
            }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clearpattern(pub u32);
        impl Clearpattern {
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[must_use]
            #[inline(always)]
            pub const fn clearpattern(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[inline(always)]
            pub const fn set_clearpattern(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clearpattern {
            #[inline(always)]
            fn default() -> Clearpattern {
                Clearpattern(0)
            }
        }
        impl core::fmt::Debug for Clearpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clearpattern")
                    .field("clearpattern", &self.clearpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clearpattern {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clearpattern {{ clearpattern: {=bool:?} }}",
                    self.clearpattern()
                )
            }
        }
        #[doc = "Description collection: AUXDATA configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnf(pub u32);
        impl Cnf {
            #[doc = "Acquisition mode (data from RADIO written to memory)"]
            #[must_use]
            #[inline(always)]
            pub const fn acqmode(&self) -> super::vals::Acqmode {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Acqmode::from_bits(val as u8)
            }
            #[doc = "Acquisition mode (data from RADIO written to memory)"]
            #[inline(always)]
            pub const fn set_acqmode(&mut self, val: super::vals::Acqmode) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "Data acquisition or injection"]
            #[must_use]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Data acquisition or injection"]
            #[inline(always)]
            pub const fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Cnf {
            #[inline(always)]
            fn default() -> Cnf {
                Cnf(0)
            }
        }
        impl core::fmt::Debug for Cnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnf")
                    .field("acqmode", &self.acqmode())
                    .field("dir", &self.dir())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cnf {{ acqmode: {:?}, dir: {:?} }}",
                    self.acqmode(),
                    self.dir()
                )
            }
        }
        #[doc = "CRC configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccnf(pub u32);
        impl Crccnf {
            #[doc = "CRC length in number of bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn len(&self) -> super::vals::Len {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Len::from_bits(val as u8)
            }
            #[doc = "CRC length in number of bytes."]
            #[inline(always)]
            pub const fn set_len(&mut self, val: super::vals::Len) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[must_use]
            #[inline(always)]
            pub const fn skipaddr(&self) -> super::vals::Skipaddr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Skipaddr::from_bits(val as u8)
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[inline(always)]
            pub const fn set_skipaddr(&mut self, val: super::vals::Skipaddr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
        }
        impl Default for Crccnf {
            #[inline(always)]
            fn default() -> Crccnf {
                Crccnf(0)
            }
        }
        impl core::fmt::Debug for Crccnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccnf")
                    .field("len", &self.len())
                    .field("skipaddr", &self.skipaddr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccnf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccnf {{ len: {:?}, skipaddr: {:?} }}",
                    self.len(),
                    self.skipaddr()
                )
            }
        }
        #[doc = "CRC initial value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcinit(pub u32);
        impl Crcinit {
            #[doc = "CRC initial value"]
            #[must_use]
            #[inline(always)]
            pub const fn crcinit(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC initial value"]
            #[inline(always)]
            pub const fn set_crcinit(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcinit {
            #[inline(always)]
            fn default() -> Crcinit {
                Crcinit(0)
            }
        }
        impl core::fmt::Debug for Crcinit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcinit")
                    .field("crcinit", &self.crcinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcinit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcinit {{ crcinit: {=u32:?} }}", self.crcinit())
            }
        }
        #[doc = "CRC polynomial"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcpoly(pub u32);
        impl Crcpoly {
            #[doc = "CRC polynomial"]
            #[must_use]
            #[inline(always)]
            pub const fn crcpoly(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC polynomial"]
            #[inline(always)]
            pub const fn set_crcpoly(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcpoly {
            #[inline(always)]
            fn default() -> Crcpoly {
                Crcpoly(0)
            }
        }
        impl core::fmt::Debug for Crcpoly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcpoly")
                    .field("crcpoly", &self.crcpoly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcpoly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcpoly {{ crcpoly: {=u32:?} }}", self.crcpoly())
            }
        }
        #[doc = "CRC status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcstatus(pub u32);
        impl Crcstatus {
            #[doc = "CRC status of packet received"]
            #[must_use]
            #[inline(always)]
            pub const fn crcstatus(&self) -> super::vals::Crcstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Crcstatus::from_bits(val as u8)
            }
            #[doc = "CRC status of packet received"]
            #[inline(always)]
            pub const fn set_crcstatus(&mut self, val: super::vals::Crcstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Crcstatus {
            #[inline(always)]
            fn default() -> Crcstatus {
                Crcstatus(0)
            }
        }
        impl core::fmt::Debug for Crcstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcstatus")
                    .field("crcstatus", &self.crcstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcstatus {{ crcstatus: {:?} }}", self.crcstatus())
            }
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CstonesMode(pub u32);
        impl CstonesMode {
            #[doc = "Enable or disable TPM"]
            #[must_use]
            #[inline(always)]
            pub const fn tpm(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TPM"]
            #[inline(always)]
            pub const fn set_tpm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable TFM"]
            #[must_use]
            #[inline(always)]
            pub const fn tfm(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TFM"]
            #[inline(always)]
            pub const fn set_tfm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CstonesMode {
            #[inline(always)]
            fn default() -> CstonesMode {
                CstonesMode(0)
            }
        }
        impl core::fmt::Debug for CstonesMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CstonesMode")
                    .field("tpm", &self.tpm())
                    .field("tfm", &self.tfm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CstonesMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CstonesMode {{ tpm: {=bool:?}, tfm: {=bool:?} }}",
                    self.tpm(),
                    self.tfm()
                )
            }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cteinlineconf(pub u32);
        impl Cteinlineconf {
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinectrlen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[inline(always)]
            pub const fn set_cteinlinectrlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinfoins1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[inline(always)]
            pub const fn set_cteinfoins1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[must_use]
            #[inline(always)]
            pub const fn cteerrorhandling(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[inline(always)]
            pub const fn set_cteerrorhandling(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Max range of CTETime"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetimevalidrange(&self) -> super::vals::Ctetimevalidrange {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Ctetimevalidrange::from_bits(val as u8)
            }
            #[doc = "Max range of CTETime"]
            #[inline(always)]
            pub const fn set_ctetimevalidrange(&mut self, val: super::vals::Ctetimevalidrange) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinerxmode1us(&self) -> super::vals::Cteinlinerxmode1us {
                let val = (self.0 >> 10usize) & 0x07;
                super::vals::Cteinlinerxmode1us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn set_cteinlinerxmode1us(&mut self, val: super::vals::Cteinlinerxmode1us) {
                self.0 =
                    (self.0 & !(0x07 << 10usize)) | (((val.to_bits() as u32) & 0x07) << 10usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinerxmode2us(&self) -> super::vals::Cteinlinerxmode2us {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Cteinlinerxmode2us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn set_cteinlinerxmode2us(&mut self, val: super::vals::Cteinlinerxmode2us) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "S0 bit pattern to match"]
            #[must_use]
            #[inline(always)]
            pub const fn s0conf(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit pattern to match"]
            #[inline(always)]
            pub const fn set_s0conf(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[must_use]
            #[inline(always)]
            pub const fn s0mask(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[inline(always)]
            pub const fn set_s0mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cteinlineconf {
            #[inline(always)]
            fn default() -> Cteinlineconf {
                Cteinlineconf(0)
            }
        }
        impl core::fmt::Debug for Cteinlineconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cteinlineconf")
                    .field("cteinlinectrlen", &self.cteinlinectrlen())
                    .field("cteinfoins1", &self.cteinfoins1())
                    .field("cteerrorhandling", &self.cteerrorhandling())
                    .field("ctetimevalidrange", &self.ctetimevalidrange())
                    .field("cteinlinerxmode1us", &self.cteinlinerxmode1us())
                    .field("cteinlinerxmode2us", &self.cteinlinerxmode2us())
                    .field("s0conf", &self.s0conf())
                    .field("s0mask", &self.s0mask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cteinlineconf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cteinlineconf {{ cteinlinectrlen: {=bool:?}, cteinfoins1: {=bool:?}, cteerrorhandling: {=bool:?}, ctetimevalidrange: {:?}, cteinlinerxmode1us: {:?}, cteinlinerxmode2us: {:?}, s0conf: {=u8:?}, s0mask: {=u8:?} }}" , self . cteinlinectrlen () , self . cteinfoins1 () , self . cteerrorhandling () , self . ctetimevalidrange () , self . cteinlinerxmode1us () , self . cteinlinerxmode2us () , self . s0conf () , self . s0mask ())
            }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctestatus(pub u32);
        impl Ctestatus {
            #[doc = "CTETime parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetime(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "CTETime parsed from packet"]
            #[inline(always)]
            pub const fn set_ctetime(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "RFU parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn rfu(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "RFU parsed from packet"]
            #[inline(always)]
            pub const fn set_rfu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "CTEType parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetype(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "CTEType parsed from packet"]
            #[inline(always)]
            pub const fn set_ctetype(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Ctestatus {
            #[inline(always)]
            fn default() -> Ctestatus {
                Ctestatus(0)
            }
        }
        impl core::fmt::Debug for Ctestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctestatus")
                    .field("ctetime", &self.ctetime())
                    .field("rfu", &self.rfu())
                    .field("ctetype", &self.ctetype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctestatus {{ ctetime: {=u8:?}, rfu: {=bool:?}, ctetype: {=u8:?} }}",
                    self.ctetime(),
                    self.rfu(),
                    self.ctetype()
                )
            }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Device address match configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacnf(pub u32);
        impl Dacnf {
            #[doc = "Enable or disable device address matching using device address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ena0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 0"]
            #[inline(always)]
            pub const fn set_ena0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ena1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[inline(always)]
            pub const fn set_ena1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ena2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[inline(always)]
            pub const fn set_ena2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ena3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[inline(always)]
            pub const fn set_ena3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ena4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[inline(always)]
            pub const fn set_ena4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ena5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[inline(always)]
            pub const fn set_ena5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ena6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[inline(always)]
            pub const fn set_ena6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ena7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[inline(always)]
            pub const fn set_ena7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "TxAdd for device address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 0"]
            #[inline(always)]
            pub const fn set_txadd0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "TxAdd for device address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 1"]
            #[inline(always)]
            pub const fn set_txadd1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "TxAdd for device address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 2"]
            #[inline(always)]
            pub const fn set_txadd2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TxAdd for device address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 3"]
            #[inline(always)]
            pub const fn set_txadd3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TxAdd for device address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 4"]
            #[inline(always)]
            pub const fn set_txadd4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TxAdd for device address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 5"]
            #[inline(always)]
            pub const fn set_txadd5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "TxAdd for device address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 6"]
            #[inline(always)]
            pub const fn set_txadd6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "TxAdd for device address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 7"]
            #[inline(always)]
            pub const fn set_txadd7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Dacnf {
            #[inline(always)]
            fn default() -> Dacnf {
                Dacnf(0)
            }
        }
        impl core::fmt::Debug for Dacnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacnf")
                    .field("ena0", &self.ena0())
                    .field("ena1", &self.ena1())
                    .field("ena2", &self.ena2())
                    .field("ena3", &self.ena3())
                    .field("ena4", &self.ena4())
                    .field("ena5", &self.ena5())
                    .field("ena6", &self.ena6())
                    .field("ena7", &self.ena7())
                    .field("txadd0", &self.txadd0())
                    .field("txadd1", &self.txadd1())
                    .field("txadd2", &self.txadd2())
                    .field("txadd3", &self.txadd3())
                    .field("txadd4", &self.txadd4())
                    .field("txadd5", &self.txadd5())
                    .field("txadd6", &self.txadd6())
                    .field("txadd7", &self.txadd7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dacnf {{ ena0: {=bool:?}, ena1: {=bool:?}, ena2: {=bool:?}, ena3: {=bool:?}, ena4: {=bool:?}, ena5: {=bool:?}, ena6: {=bool:?}, ena7: {=bool:?}, txadd0: {=bool:?}, txadd1: {=bool:?}, txadd2: {=bool:?}, txadd3: {=bool:?}, txadd4: {=bool:?}, txadd5: {=bool:?}, txadd6: {=bool:?}, txadd7: {=bool:?} }}" , self . ena0 () , self . ena1 () , self . ena2 () , self . ena3 () , self . ena4 () , self . ena5 () , self . ena6 () , self . ena7 () , self . txadd0 () , self . txadd1 () , self . txadd2 () , self . txadd3 () , self . txadd4 () , self . txadd5 () , self . txadd6 () , self . txadd7 ())
            }
        }
        #[doc = "Device address match index"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dai(pub u32);
        impl Dai {
            #[doc = "Device address match index"]
            #[must_use]
            #[inline(always)]
            pub const fn dai(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Device address match index"]
            #[inline(always)]
            pub const fn set_dai(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Dai {
            #[inline(always)]
            fn default() -> Dai {
                Dai(0)
            }
        }
        impl core::fmt::Debug for Dai {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dai").field("dai", &self.dai()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dai {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dai {{ dai: {=u8:?} }}", self.dai())
            }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dap(pub u32);
        impl Dap {
            #[doc = "Device address prefix n"]
            #[must_use]
            #[inline(always)]
            pub const fn dap(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Device address prefix n"]
            #[inline(always)]
            pub const fn set_dap(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dap {
            #[inline(always)]
            fn default() -> Dap {
                Dap(0)
            }
        }
        impl core::fmt::Debug for Dap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dap").field("dap", &self.dap()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dap {{ dap: {=u16:?} }}", self.dap())
            }
        }
        #[doc = "Data whitening configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datawhite(pub u32);
        impl Datawhite {
            #[doc = "Whitening initial value"]
            #[must_use]
            #[inline(always)]
            pub const fn iv(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Whitening initial value"]
            #[inline(always)]
            pub const fn set_iv(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Whitening polynomial"]
            #[must_use]
            #[inline(always)]
            pub const fn poly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Whitening polynomial"]
            #[inline(always)]
            pub const fn set_poly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Datawhite {
            #[inline(always)]
            fn default() -> Datawhite {
                Datawhite(0)
            }
        }
        impl core::fmt::Debug for Datawhite {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datawhite")
                    .field("iv", &self.iv())
                    .field("poly", &self.poly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datawhite {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Datawhite {{ iv: {=u16:?}, poly: {=u16:?} }}",
                    self.iv(),
                    self.poly()
                )
            }
        }
        #[doc = "Correlator thresholds"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbccorr(pub u32);
        impl Dbccorr {
            #[doc = "Correlation threshold"]
            #[must_use]
            #[inline(always)]
            pub const fn th(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Correlation threshold"]
            #[inline(always)]
            pub const fn set_th(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Dbccorr {
            #[inline(always)]
            fn default() -> Dbccorr {
                Dbccorr(0)
            }
        }
        impl core::fmt::Debug for Dbccorr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbccorr").field("th", &self.th()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbccorr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dbccorr {{ th: {=u8:?} }}", self.th())
            }
        }
        #[doc = "Various configuration for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl1(pub u32);
        impl Dfectrl1 {
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[must_use]
            #[inline(always)]
            pub const fn numberof8us(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[inline(always)]
            pub const fn set_numberof8us(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[must_use]
            #[inline(always)]
            pub const fn dfeinextension(&self) -> super::vals::Dfeinextension {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dfeinextension::from_bits(val as u8)
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[inline(always)]
            pub const fn set_dfeinextension(&mut self, val: super::vals::Dfeinextension) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[must_use]
            #[inline(always)]
            pub const fn tswitchspacing(&self) -> super::vals::Tswitchspacing {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tswitchspacing::from_bits(val as u8)
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[inline(always)]
            pub const fn set_tswitchspacing(&mut self, val: super::vals::Tswitchspacing) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[must_use]
            #[inline(always)]
            pub const fn tsamplespacingref(&self) -> super::vals::Tsamplespacingref {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Tsamplespacingref::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[inline(always)]
            pub const fn set_tsamplespacingref(&mut self, val: super::vals::Tsamplespacingref) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[must_use]
            #[inline(always)]
            pub const fn sampletype(&self) -> super::vals::Sampletype {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sampletype::from_bits(val as u8)
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[inline(always)]
            pub const fn set_sampletype(&mut self, val: super::vals::Sampletype) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[must_use]
            #[inline(always)]
            pub const fn tsamplespacing(&self) -> super::vals::Tsamplespacing {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Tsamplespacing::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[inline(always)]
            pub const fn set_tsamplespacing(&mut self, val: super::vals::Tsamplespacing) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[must_use]
            #[inline(always)]
            pub const fn repeatpattern(&self) -> super::vals::Repeatpattern {
                let val = (self.0 >> 20usize) & 0x0f;
                super::vals::Repeatpattern::from_bits(val as u8)
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[inline(always)]
            pub const fn set_repeatpattern(&mut self, val: super::vals::Repeatpattern) {
                self.0 =
                    (self.0 & !(0x0f << 20usize)) | (((val.to_bits() as u32) & 0x0f) << 20usize);
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[must_use]
            #[inline(always)]
            pub const fn agcbackoffgain(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[inline(always)]
            pub const fn set_agcbackoffgain(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Dfectrl1 {
            #[inline(always)]
            fn default() -> Dfectrl1 {
                Dfectrl1(0)
            }
        }
        impl core::fmt::Debug for Dfectrl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl1")
                    .field("numberof8us", &self.numberof8us())
                    .field("dfeinextension", &self.dfeinextension())
                    .field("tswitchspacing", &self.tswitchspacing())
                    .field("tsamplespacingref", &self.tsamplespacingref())
                    .field("sampletype", &self.sampletype())
                    .field("tsamplespacing", &self.tsamplespacing())
                    .field("repeatpattern", &self.repeatpattern())
                    .field("agcbackoffgain", &self.agcbackoffgain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dfectrl1 {{ numberof8us: {=u8:?}, dfeinextension: {:?}, tswitchspacing: {:?}, tsamplespacingref: {:?}, sampletype: {:?}, tsamplespacing: {:?}, repeatpattern: {:?}, agcbackoffgain: {=u8:?} }}" , self . numberof8us () , self . dfeinextension () , self . tswitchspacing () , self . tsamplespacingref () , self . sampletype () , self . tsamplespacing () , self . repeatpattern () , self . agcbackoffgain ())
            }
        }
        #[doc = "Start offset for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl2(pub u32);
        impl Dfectrl2 {
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn tswitchoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[inline(always)]
            pub const fn set_tswitchoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[must_use]
            #[inline(always)]
            pub const fn tsampleoffset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[inline(always)]
            pub const fn set_tsampleoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Dfectrl2 {
            #[inline(always)]
            fn default() -> Dfectrl2 {
                Dfectrl2(0)
            }
        }
        impl core::fmt::Debug for Dfectrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl2")
                    .field("tswitchoffset", &self.tswitchoffset())
                    .field("tsampleoffset", &self.tsampleoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dfectrl2 {{ tswitchoffset: {=u16:?}, tsampleoffset: {=u16:?} }}",
                    self.tswitchoffset(),
                    self.tsampleoffset()
                )
            }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfemode(pub u32);
        impl Dfemode {
            #[doc = "Direction finding operation mode"]
            #[must_use]
            #[inline(always)]
            pub const fn dfeopmode(&self) -> super::vals::Dfeopmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Dfeopmode::from_bits(val as u8)
            }
            #[doc = "Direction finding operation mode"]
            #[inline(always)]
            pub const fn set_dfeopmode(&mut self, val: super::vals::Dfeopmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Dfemode {
            #[inline(always)]
            fn default() -> Dfemode {
                Dfemode(0)
            }
        }
        impl core::fmt::Debug for Dfemode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfemode")
                    .field("dfeopmode", &self.dfeopmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfemode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dfemode {{ dfeopmode: {:?} }}", self.dfeopmode())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DfepacketAmount(pub u32);
        impl DfepacketAmount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DfepacketAmount {
            #[inline(always)]
            fn default() -> DfepacketAmount {
                DfepacketAmount(0)
            }
        }
        impl core::fmt::Debug for DfepacketAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DfepacketAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DfepacketAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DfepacketAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DfepacketMaxcnt(pub u32);
        impl DfepacketMaxcnt {
            #[doc = "Maximum number of bytes to transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes to transfer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DfepacketMaxcnt {
            #[inline(always)]
            fn default() -> DfepacketMaxcnt {
                DfepacketMaxcnt(0)
            }
        }
        impl core::fmt::Debug for DfepacketMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DfepacketMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DfepacketMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DfepacketMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "DFE status information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfestatus(pub u32);
        impl Dfestatus {
            #[doc = "Internal state of switching state machine"]
            #[must_use]
            #[inline(always)]
            pub const fn switchingstate(&self) -> super::vals::Switchingstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Switchingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of switching state machine"]
            #[inline(always)]
            pub const fn set_switchingstate(&mut self, val: super::vals::Switchingstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Internal state of sampling state machine"]
            #[must_use]
            #[inline(always)]
            pub const fn samplingstate(&self) -> super::vals::Samplingstate {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Samplingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of sampling state machine"]
            #[inline(always)]
            pub const fn set_samplingstate(&mut self, val: super::vals::Samplingstate) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Dfestatus {
            #[inline(always)]
            fn default() -> Dfestatus {
                Dfestatus(0)
            }
        }
        impl core::fmt::Debug for Dfestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfestatus")
                    .field("switchingstate", &self.switchingstate())
                    .field("samplingstate", &self.samplingstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dfestatus {{ switchingstate: {:?}, samplingstate: {:?} }}",
                    self.switchingstate(),
                    self.samplingstate()
                )
            }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Downsample(pub u32);
        impl Downsample {
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[must_use]
            #[inline(always)]
            pub const fn enablefilter(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[inline(always)]
            pub const fn set_enablefilter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[must_use]
            #[inline(always)]
            pub const fn rate(&self) -> super::vals::Rate {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rate::from_bits(val as u8)
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[inline(always)]
            pub const fn set_rate(&mut self, val: super::vals::Rate) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Downsample {
            #[inline(always)]
            fn default() -> Downsample {
                Downsample(0)
            }
        }
        impl core::fmt::Debug for Downsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Downsample")
                    .field("enablefilter", &self.enablefilter())
                    .field("rate", &self.rate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Downsample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Downsample {{ enablefilter: {=bool:?}, rate: {:?} }}",
                    self.enablefilter(),
                    self.rate()
                )
            }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edctrl(pub u32);
        impl Edctrl {
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[must_use]
            #[inline(always)]
            pub const fn edcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x001f_ffff;
                val as u32
            }
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[inline(always)]
            pub const fn set_edcnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x001f_ffff << 0usize)) | (((val as u32) & 0x001f_ffff) << 0usize);
            }
            #[doc = "IEEE 802.15.4 energy detect period, 4us resolution, no averaging except the IEEE 802.15.4 ED range 128us (32)"]
            #[must_use]
            #[inline(always)]
            pub const fn edperiod(&self) -> super::vals::Edperiod {
                let val = (self.0 >> 24usize) & 0x3f;
                super::vals::Edperiod::from_bits(val as u8)
            }
            #[doc = "IEEE 802.15.4 energy detect period, 4us resolution, no averaging except the IEEE 802.15.4 ED range 128us (32)"]
            #[inline(always)]
            pub const fn set_edperiod(&mut self, val: super::vals::Edperiod) {
                self.0 =
                    (self.0 & !(0x3f << 24usize)) | (((val.to_bits() as u32) & 0x3f) << 24usize);
            }
        }
        impl Default for Edctrl {
            #[inline(always)]
            fn default() -> Edctrl {
                Edctrl(0)
            }
        }
        impl core::fmt::Debug for Edctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edctrl")
                    .field("edcnt", &self.edcnt())
                    .field("edperiod", &self.edperiod())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Edctrl {{ edcnt: {=u32:?}, edperiod: {:?} }}",
                    self.edcnt(),
                    self.edperiod()
                )
            }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edsample(pub u32);
        impl Edsample {
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[must_use]
            #[inline(always)]
            pub const fn edlvl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[inline(always)]
            pub const fn set_edlvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Edsample {
            #[inline(always)]
            fn default() -> Edsample {
                Edsample(0)
            }
        }
        impl core::fmt::Debug for Edsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edsample")
                    .field("edlvl", &self.edlvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edsample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Edsample {{ edlvl: {=u8:?} }}", self.edlvl())
            }
        }
        #[doc = "Description cluster: Enable or disable data acquisition"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable data acquisition"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable data acquisition"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Faepeer(pub u32);
        impl Faepeer {
            #[doc = "Units 31.25 ppb."]
            #[must_use]
            #[inline(always)]
            pub const fn faepeer(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Units 31.25 ppb."]
            #[inline(always)]
            pub const fn set_faepeer(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Faepeer {
            #[inline(always)]
            fn default() -> Faepeer {
                Faepeer(0)
            }
        }
        impl core::fmt::Debug for Faepeer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Faepeer")
                    .field("faepeer", &self.faepeer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Faepeer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Faepeer {{ faepeer: {=u8:?} }}", self.faepeer())
            }
        }
        #[doc = "Config register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feconfig(pub u32);
        impl Feconfig {
            #[doc = "Mode for narrow scaling output."]
            #[must_use]
            #[inline(always)]
            pub const fn scalermode(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Mode for narrow scaling output."]
            #[inline(always)]
            pub const fn set_scalermode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Feconfig {
            #[inline(always)]
            fn default() -> Feconfig {
                Feconfig(0)
            }
        }
        impl core::fmt::Debug for Feconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feconfig")
                    .field("scalermode", &self.scalermode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feconfig {{ scalermode: {=bool:?} }}", self.scalermode())
            }
        }
        #[doc = "FFO estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffoest(pub u32);
        impl Ffoest {
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[must_use]
            #[inline(always)]
            pub const fn ffoest(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub const fn set_ffoest(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Ffoest {
            #[inline(always)]
            fn default() -> Ffoest {
                Ffoest(0)
            }
        }
        impl core::fmt::Debug for Ffoest {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffoest")
                    .field("ffoest", &self.ffoest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffoest {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ffoest {{ ffoest: {=u16:?} }}", self.ffoest())
            }
        }
        #[doc = "Fine tuning of the RF frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freqfinetune(pub u32);
        impl Freqfinetune {
            #[doc = "Twos-complement number for fine-tuning the frequency. The step size is 488.28125 Hz, giving a range from -1 MHz to (one step short of) +1 MHz."]
            #[must_use]
            #[inline(always)]
            pub const fn freqfinetune(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Twos-complement number for fine-tuning the frequency. The step size is 488.28125 Hz, giving a range from -1 MHz to (one step short of) +1 MHz."]
            #[inline(always)]
            pub const fn set_freqfinetune(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Freqfinetune {
            #[inline(always)]
            fn default() -> Freqfinetune {
                Freqfinetune(0)
            }
        }
        impl core::fmt::Debug for Freqfinetune {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freqfinetune")
                    .field("freqfinetune", &self.freqfinetune())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freqfinetune {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Freqfinetune {{ freqfinetune: {=u16:?} }}",
                    self.freqfinetune()
                )
            }
        }
        #[doc = "Frequency offset estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freqoffset(pub u32);
        impl Freqoffset {
            #[must_use]
            #[inline(always)]
            pub const fn freqoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_freqoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Freqoffset {
            #[inline(always)]
            fn default() -> Freqoffset {
                Freqoffset(0)
            }
        }
        impl core::fmt::Debug for Freqoffset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freqoffset")
                    .field("freqoffset", &self.freqoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freqoffset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Freqoffset {{ freqoffset: {=u16:?} }}",
                    self.freqoffset()
                )
            }
        }
        #[doc = "Frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[must_use]
            #[inline(always)]
            pub const fn map(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn set_map(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .field("map", &self.map())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Frequency {{ frequency: {=u8:?}, map: {=bool:?} }}",
                    self.frequency(),
                    self.map()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int0(pub u32);
        impl Int0 {
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn txready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[inline(always)]
            pub const fn set_txready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn framestart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub const fn set_framestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[must_use]
            #[inline(always)]
            pub const fn payload(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[inline(always)]
            pub const fn set_payload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[inline(always)]
            pub const fn set_phyend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[inline(always)]
            pub const fn set_disabled(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn devmatch(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[inline(always)]
            pub const fn set_devmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[must_use]
            #[inline(always)]
            pub const fn devmiss(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[inline(always)]
            pub const fn set_devmiss(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[must_use]
            #[inline(always)]
            pub const fn crcok(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[inline(always)]
            pub const fn set_crcok(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[inline(always)]
            pub const fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn bcmatch(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[inline(always)]
            pub const fn set_bcmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[must_use]
            #[inline(always)]
            pub const fn edend(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[inline(always)]
            pub const fn set_edend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn edstopped(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[inline(always)]
            pub const fn set_edstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[inline(always)]
            pub const fn set_ccaidle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[must_use]
            #[inline(always)]
            pub const fn ccabusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[inline(always)]
            pub const fn set_ccabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn ccastopped(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[inline(always)]
            pub const fn set_ccastopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[must_use]
            #[inline(always)]
            pub const fn rateboost(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[inline(always)]
            pub const fn set_rateboost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn mhrmatch(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[inline(always)]
            pub const fn set_mhrmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[must_use]
            #[inline(always)]
            pub const fn sync(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[inline(always)]
            pub const fn set_sync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[must_use]
            #[inline(always)]
            pub const fn ctepresent(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[inline(always)]
            pub const fn set_ctepresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Int0 {
            #[inline(always)]
            fn default() -> Int0 {
                Int0(0)
            }
        }
        impl core::fmt::Debug for Int0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int0")
                    .field("ready", &self.ready())
                    .field("txready", &self.txready())
                    .field("rxready", &self.rxready())
                    .field("address", &self.address())
                    .field("framestart", &self.framestart())
                    .field("payload", &self.payload())
                    .field("end", &self.end())
                    .field("phyend", &self.phyend())
                    .field("disabled", &self.disabled())
                    .field("devmatch", &self.devmatch())
                    .field("devmiss", &self.devmiss())
                    .field("crcok", &self.crcok())
                    .field("crcerror", &self.crcerror())
                    .field("bcmatch", &self.bcmatch())
                    .field("edend", &self.edend())
                    .field("edstopped", &self.edstopped())
                    .field("ccaidle", &self.ccaidle())
                    .field("ccabusy", &self.ccabusy())
                    .field("ccastopped", &self.ccastopped())
                    .field("rateboost", &self.rateboost())
                    .field("mhrmatch", &self.mhrmatch())
                    .field("sync", &self.sync())
                    .field("ctepresent", &self.ctepresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int0 {{ ready: {=bool:?}, txready: {=bool:?}, rxready: {=bool:?}, address: {=bool:?}, framestart: {=bool:?}, payload: {=bool:?}, end: {=bool:?}, phyend: {=bool:?}, disabled: {=bool:?}, devmatch: {=bool:?}, devmiss: {=bool:?}, crcok: {=bool:?}, crcerror: {=bool:?}, bcmatch: {=bool:?}, edend: {=bool:?}, edstopped: {=bool:?}, ccaidle: {=bool:?}, ccabusy: {=bool:?}, ccastopped: {=bool:?}, rateboost: {=bool:?}, mhrmatch: {=bool:?}, sync: {=bool:?}, ctepresent: {=bool:?} }}" , self . ready () , self . txready () , self . rxready () , self . address () , self . framestart () , self . payload () , self . end () , self . phyend () , self . disabled () , self . devmatch () , self . devmiss () , self . crcok () , self . crcerror () , self . bcmatch () , self . edend () , self . edstopped () , self . ccaidle () , self . ccabusy () , self . ccastopped () , self . rateboost () , self . mhrmatch () , self . sync () , self . ctepresent ())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int1(pub u32);
        impl Int1 {
            #[doc = "Write '1' to disable interrupt for event PLLREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn pllready(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PLLREADY"]
            #[inline(always)]
            pub const fn set_pllready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write '1' to disable interrupt for event RXADDRESS"]
            #[must_use]
            #[inline(always)]
            pub const fn rxaddress(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RXADDRESS"]
            #[inline(always)]
            pub const fn set_rxaddress(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Write '1' to disable interrupt for event AUXDATADMAEND"]
            #[must_use]
            #[inline(always)]
            pub const fn auxdatadmaend(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event AUXDATADMAEND"]
            #[inline(always)]
            pub const fn set_auxdatadmaend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event CSTONESEND"]
            #[must_use]
            #[inline(always)]
            pub const fn cstonesend(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CSTONESEND"]
            #[inline(always)]
            pub const fn set_cstonesend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Int1 {
            #[inline(always)]
            fn default() -> Int1 {
                Int1(0)
            }
        }
        impl core::fmt::Debug for Int1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int1")
                    .field("pllready", &self.pllready())
                    .field("rxaddress", &self.rxaddress())
                    .field("auxdatadmaend", &self.auxdatadmaend())
                    .field("cstonesend", &self.cstonesend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int1 {{ pllready: {=bool:?}, rxaddress: {=bool:?}, auxdatadmaend: {=bool:?}, cstonesend: {=bool:?} }}" , self . pllready () , self . rxaddress () , self . auxdatadmaend () , self . cstonesend ())
            }
        }
        #[doc = "Mean of IQ values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iqrawmean(pub u32);
        impl Iqrawmean {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn iqrawmeani(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_iqrawmeani(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[must_use]
            #[inline(always)]
            pub const fn iqrawmeanq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn set_iqrawmeanq(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Iqrawmean {
            #[inline(always)]
            fn default() -> Iqrawmean {
                Iqrawmean(0)
            }
        }
        impl core::fmt::Debug for Iqrawmean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iqrawmean")
                    .field("iqrawmeani", &self.iqrawmeani())
                    .field("iqrawmeanq", &self.iqrawmeanq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iqrawmean {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iqrawmean {{ iqrawmeani: {=u16:?}, iqrawmeanq: {=u16:?} }}",
                    self.iqrawmeani(),
                    self.iqrawmeanq()
                )
            }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magphasemean(pub u32);
        impl Magphasemean {
            #[doc = "Mean phase"]
            #[must_use]
            #[inline(always)]
            pub const fn phase(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean phase"]
            #[inline(always)]
            pub const fn set_phase(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Mean magnitude"]
            #[must_use]
            #[inline(always)]
            pub const fn mag(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean magnitude"]
            #[inline(always)]
            pub const fn set_mag(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Magphasemean {
            #[inline(always)]
            fn default() -> Magphasemean {
                Magphasemean(0)
            }
        }
        impl core::fmt::Debug for Magphasemean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magphasemean")
                    .field("phase", &self.phase())
                    .field("mag", &self.mag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magphasemean {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Magphasemean {{ phase: {=u16:?}, mag: {=u16:?} }}",
                    self.phase(),
                    self.mag()
                )
            }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magstd(pub u32);
        impl Magstd {
            #[doc = "Magnitude standard deviation approximation"]
            #[must_use]
            #[inline(always)]
            pub const fn magstd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Magnitude standard deviation approximation"]
            #[inline(always)]
            pub const fn set_magstd(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Magstd {
            #[inline(always)]
            fn default() -> Magstd {
                Magstd(0)
            }
        }
        impl core::fmt::Debug for Magstd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magstd")
                    .field("magstd", &self.magstd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magstd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Magstd {{ magstd: {=u16:?} }}", self.magstd())
            }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nextfrequency(pub u32);
        impl Nextfrequency {
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[must_use]
            #[inline(always)]
            pub const fn nextfrequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[inline(always)]
            pub const fn set_nextfrequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Nextfrequency {
            #[inline(always)]
            fn default() -> Nextfrequency {
                Nextfrequency(0)
            }
        }
        impl core::fmt::Debug for Nextfrequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nextfrequency")
                    .field("nextfrequency", &self.nextfrequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nextfrequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nextfrequency {{ nextfrequency: {=u8:?} }}",
                    self.nextfrequency()
                )
            }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamples(pub u32);
        impl Numsamples {
            #[doc = "Maximum value supported is 160"]
            #[must_use]
            #[inline(always)]
            pub const fn numsamples(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum value supported is 160"]
            #[inline(always)]
            pub const fn set_numsamples(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Numsamples {
            #[inline(always)]
            fn default() -> Numsamples {
                Numsamples(0)
            }
        }
        impl core::fmt::Debug for Numsamples {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamples")
                    .field("numsamples", &self.numsamples())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamples {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Numsamples {{ numsamples: {=u8:?} }}", self.numsamples())
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamplescoeff(pub u32);
        impl Numsamplescoeff {
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[must_use]
            #[inline(always)]
            pub const fn numsamplescoeff(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[inline(always)]
            pub const fn set_numsamplescoeff(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Numsamplescoeff {
            #[inline(always)]
            fn default() -> Numsamplescoeff {
                Numsamplescoeff(0)
            }
        }
        impl core::fmt::Debug for Numsamplescoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamplescoeff")
                    .field("numsamplescoeff", &self.numsamplescoeff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamplescoeff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Numsamplescoeff {{ numsamplescoeff: {=u16:?} }}",
                    self.numsamplescoeff()
                )
            }
        }
        #[doc = "Packet configuration register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf0(pub u32);
        impl Pcnf0 {
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[must_use]
            #[inline(always)]
            pub const fn lflen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[inline(always)]
            pub const fn set_lflen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn s0len(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[inline(always)]
            pub const fn set_s0len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[must_use]
            #[inline(always)]
            pub const fn s1len(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[inline(always)]
            pub const fn set_s1len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[must_use]
            #[inline(always)]
            pub const fn s1incl(&self) -> super::vals::S1incl {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::S1incl::from_bits(val as u8)
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[inline(always)]
            pub const fn set_s1incl(&mut self, val: super::vals::S1incl) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "Length of code indicator - long range"]
            #[must_use]
            #[inline(always)]
            pub const fn cilen(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "Length of code indicator - long range"]
            #[inline(always)]
            pub const fn set_cilen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[must_use]
            #[inline(always)]
            pub const fn plen(&self) -> super::vals::Plen {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Plen::from_bits(val as u8)
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[inline(always)]
            pub const fn set_plen(&mut self, val: super::vals::Plen) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[must_use]
            #[inline(always)]
            pub const fn crcinc(&self) -> super::vals::Crcinc {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Crcinc::from_bits(val as u8)
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[inline(always)]
            pub const fn set_crcinc(&mut self, val: super::vals::Crcinc) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[must_use]
            #[inline(always)]
            pub const fn termlen(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[inline(always)]
            pub const fn set_termlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Pcnf0 {
            #[inline(always)]
            fn default() -> Pcnf0 {
                Pcnf0(0)
            }
        }
        impl core::fmt::Debug for Pcnf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf0")
                    .field("lflen", &self.lflen())
                    .field("s0len", &self.s0len())
                    .field("s1len", &self.s1len())
                    .field("s1incl", &self.s1incl())
                    .field("cilen", &self.cilen())
                    .field("plen", &self.plen())
                    .field("crcinc", &self.crcinc())
                    .field("termlen", &self.termlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcnf0 {{ lflen: {=u8:?}, s0len: {=bool:?}, s1len: {=u8:?}, s1incl: {:?}, cilen: {=u8:?}, plen: {:?}, crcinc: {:?}, termlen: {=u8:?} }}" , self . lflen () , self . s0len () , self . s1len () , self . s1incl () , self . cilen () , self . plen () , self . crcinc () , self . termlen ())
            }
        }
        #[doc = "Packet configuration register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf1(pub u32);
        impl Pcnf1 {
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[must_use]
            #[inline(always)]
            pub const fn maxlen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[inline(always)]
            pub const fn set_maxlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Static length in number of bytes"]
            #[must_use]
            #[inline(always)]
            pub const fn statlen(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Static length in number of bytes"]
            #[inline(always)]
            pub const fn set_statlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Base address length in number of bytes"]
            #[must_use]
            #[inline(always)]
            pub const fn balen(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "Base address length in number of bytes"]
            #[inline(always)]
            pub const fn set_balen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable packet whitening"]
            #[must_use]
            #[inline(always)]
            pub const fn whiteen(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable packet whitening"]
            #[inline(always)]
            pub const fn set_whiteen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[must_use]
            #[inline(always)]
            pub const fn whiteoffset(&self) -> super::vals::Whiteoffset {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Whiteoffset::from_bits(val as u8)
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[inline(always)]
            pub const fn set_whiteoffset(&mut self, val: super::vals::Whiteoffset) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Pcnf1 {
            #[inline(always)]
            fn default() -> Pcnf1 {
                Pcnf1(0)
            }
        }
        impl core::fmt::Debug for Pcnf1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf1")
                    .field("maxlen", &self.maxlen())
                    .field("statlen", &self.statlen())
                    .field("balen", &self.balen())
                    .field("endian", &self.endian())
                    .field("whiteen", &self.whiteen())
                    .field("whiteoffset", &self.whiteoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcnf1 {{ maxlen: {=u8:?}, statlen: {=u8:?}, balen: {=u8:?}, endian: {:?}, whiteen: {=bool:?}, whiteoffset: {:?} }}" , self . maxlen () , self . statlen () , self . balen () , self . endian () , self . whiteen () , self . whiteoffset ())
            }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pct16(pub u32);
        impl Pct16 {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn pct16i(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_pct16i(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[must_use]
            #[inline(always)]
            pub const fn pct16q(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn set_pct16q(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Pct16 {
            #[inline(always)]
            fn default() -> Pct16 {
                Pct16(0)
            }
        }
        impl core::fmt::Debug for Pct16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pct16")
                    .field("pct16i", &self.pct16i())
                    .field("pct16q", &self.pct16q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pct16 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pct16 {{ pct16i: {=u16:?}, pct16q: {=u16:?} }}",
                    self.pct16i(),
                    self.pct16q()
                )
            }
        }
        #[doc = "Payload status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdustat(pub u32);
        impl Pdustat {
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[must_use]
            #[inline(always)]
            pub const fn pdustat(&self) -> super::vals::Pdustat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pdustat::from_bits(val as u8)
            }
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[inline(always)]
            pub const fn set_pdustat(&mut self, val: super::vals::Pdustat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[must_use]
            #[inline(always)]
            pub const fn cistat(&self) -> super::vals::Cistat {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Cistat::from_bits(val as u8)
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[inline(always)]
            pub const fn set_cistat(&mut self, val: super::vals::Cistat) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
        }
        impl Default for Pdustat {
            #[inline(always)]
            fn default() -> Pdustat {
                Pdustat(0)
            }
        }
        impl core::fmt::Debug for Pdustat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdustat")
                    .field("pdustat", &self.pdustat())
                    .field("cistat", &self.cistat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdustat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pdustat {{ pdustat: {:?}, cistat: {:?} }}",
                    self.pdustat(),
                    self.cistat()
                )
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Phaseshift(pub u32);
        impl Phaseshift {
            #[doc = "Phase shift used in TPM calculation"]
            #[must_use]
            #[inline(always)]
            pub const fn phaseshift(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Phase shift used in TPM calculation"]
            #[inline(always)]
            pub const fn set_phaseshift(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Phaseshift {
            #[inline(always)]
            fn default() -> Phaseshift {
                Phaseshift(0)
            }
        }
        impl core::fmt::Debug for Phaseshift {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Phaseshift")
                    .field("phaseshift", &self.phaseshift())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Phaseshift {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Phaseshift {{ phaseshift: {=u16:?} }}",
                    self.phaseshift()
                )
            }
        }
        #[doc = "Configurable delay of PHYEND event for TX"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Phyendtxdelay(pub u32);
        impl Phyendtxdelay {
            #[doc = "For modes with 4 Mbps on-air bit rate, unit is 2 bit periods (Nrf_4Mbit0_5 and Nrf_4Mbit0_25 modes)"]
            #[must_use]
            #[inline(always)]
            pub const fn rate4m(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "For modes with 4 Mbps on-air bit rate, unit is 2 bit periods (Nrf_4Mbit0_5 and Nrf_4Mbit0_25 modes)"]
            #[inline(always)]
            pub const fn set_rate4m(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "For modes with 2 Mbps on-air bit rate, unit is 1 bit period (Nrf_2Mbit, Ble_2Mbit, and Ieee802154_250Kbit modes)"]
            #[must_use]
            #[inline(always)]
            pub const fn rate2m(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x07;
                val as u8
            }
            #[doc = "For modes with 2 Mbps on-air bit rate, unit is 1 bit period (Nrf_2Mbit, Ble_2Mbit, and Ieee802154_250Kbit modes)"]
            #[inline(always)]
            pub const fn set_rate2m(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
            }
            #[doc = "For modes with 1 Mbps on-air bit rate, unit is 1/2 bit period (Nrf_1Mbit, Ble_1Mbit, Ble_LR125Kbit, and Ble_LR500Kbit modes)"]
            #[must_use]
            #[inline(always)]
            pub const fn rate1m(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x07;
                val as u8
            }
            #[doc = "For modes with 1 Mbps on-air bit rate, unit is 1/2 bit period (Nrf_1Mbit, Ble_1Mbit, Ble_LR125Kbit, and Ble_LR500Kbit modes)"]
            #[inline(always)]
            pub const fn set_rate1m(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize);
            }
            #[doc = "For modes with 250 kbps on-air bit rate, unit is 1/8 bit period (Nrf_250Kbit mode)"]
            #[must_use]
            #[inline(always)]
            pub const fn rate250k(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "For modes with 250 kbps on-air bit rate, unit is 1/8 bit period (Nrf_250Kbit mode)"]
            #[inline(always)]
            pub const fn set_rate250k(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize);
            }
        }
        impl Default for Phyendtxdelay {
            #[inline(always)]
            fn default() -> Phyendtxdelay {
                Phyendtxdelay(0)
            }
        }
        impl core::fmt::Debug for Phyendtxdelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Phyendtxdelay")
                    .field("rate4m", &self.rate4m())
                    .field("rate2m", &self.rate2m())
                    .field("rate1m", &self.rate1m())
                    .field("rate250k", &self.rate250k())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Phyendtxdelay {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Phyendtxdelay {{ rate4m: {=u8:?}, rate2m: {=u8:?}, rate1m: {=u8:?}, rate250k: {=u8:?} }}" , self . rate4m () , self . rate2m () , self . rate1m () , self . rate250k ())
            }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix0(pub u32);
        impl Prefix0 {
            #[doc = "Address prefix 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ap0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 0"]
            #[inline(always)]
            pub const fn set_ap0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ap1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 1"]
            #[inline(always)]
            pub const fn set_ap1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ap2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 2"]
            #[inline(always)]
            pub const fn set_ap2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ap3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 3"]
            #[inline(always)]
            pub const fn set_ap3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix0 {
            #[inline(always)]
            fn default() -> Prefix0 {
                Prefix0(0)
            }
        }
        impl core::fmt::Debug for Prefix0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix0")
                    .field("ap0", &self.ap0())
                    .field("ap1", &self.ap1())
                    .field("ap2", &self.ap2())
                    .field("ap3", &self.ap3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prefix0 {{ ap0: {=u8:?}, ap1: {=u8:?}, ap2: {=u8:?}, ap3: {=u8:?} }}",
                    self.ap0(),
                    self.ap1(),
                    self.ap2(),
                    self.ap3()
                )
            }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix1(pub u32);
        impl Prefix1 {
            #[doc = "Address prefix 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ap4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 4"]
            #[inline(always)]
            pub const fn set_ap4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ap5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 5"]
            #[inline(always)]
            pub const fn set_ap5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ap6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 6"]
            #[inline(always)]
            pub const fn set_ap6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ap7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 7"]
            #[inline(always)]
            pub const fn set_ap7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix1 {
            #[inline(always)]
            fn default() -> Prefix1 {
                Prefix1(0)
            }
        }
        impl core::fmt::Debug for Prefix1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix1")
                    .field("ap4", &self.ap4())
                    .field("ap5", &self.ap5())
                    .field("ap6", &self.ap6())
                    .field("ap7", &self.ap7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prefix1 {{ ap4: {=u8:?}, ap5: {=u8:?}, ap6: {=u8:?}, ap7: {=u8:?} }}",
                    self.ap4(),
                    self.ap5(),
                    self.ap6(),
                    self.ap7()
                )
            }
        }
        #[doc = "Data rate and modulation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RadioMode(pub u32);
        impl RadioMode {
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for RadioMode {
            #[inline(always)]
            fn default() -> RadioMode {
                RadioMode(0)
            }
        }
        impl core::fmt::Debug for RadioMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RadioMode")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RadioMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RadioMode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "RSSI sample"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rssisample(pub u32);
        impl Rssisample {
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[must_use]
            #[inline(always)]
            pub const fn rssisample(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[inline(always)]
            pub const fn set_rssisample(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Rssisample {
            #[inline(always)]
            fn default() -> Rssisample {
                Rssisample(0)
            }
        }
        impl core::fmt::Debug for Rssisample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rssisample")
                    .field("rssisample", &self.rssisample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rssisample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rssisample {{ rssisample: {=u8:?} }}", self.rssisample())
            }
        }
        #[doc = "RTT Config."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RttConfig(pub u32);
        impl RttConfig {
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[must_use]
            #[inline(always)]
            pub const fn enfullaa(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[inline(always)]
            pub const fn set_enfullaa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[must_use]
            #[inline(always)]
            pub const fn role(&self) -> super::vals::Role {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Role::from_bits(val as u8)
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[inline(always)]
            pub const fn set_role(&mut self, val: super::vals::Role) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[must_use]
            #[inline(always)]
            pub const fn numsegments(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[inline(always)]
            pub const fn set_numsegments(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[must_use]
            #[inline(always)]
            pub const fn efsdelay(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x01ff;
                val as u16
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[inline(always)]
            pub const fn set_efsdelay(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 8usize)) | (((val as u32) & 0x01ff) << 8usize);
            }
        }
        impl Default for RttConfig {
            #[inline(always)]
            fn default() -> RttConfig {
                RttConfig(0)
            }
        }
        impl core::fmt::Debug for RttConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RttConfig")
                    .field("en", &self.en())
                    .field("enfullaa", &self.enfullaa())
                    .field("role", &self.role())
                    .field("numsegments", &self.numsegments())
                    .field("efsdelay", &self.efsdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RttConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RttConfig {{ en: {=bool:?}, enfullaa: {=bool:?}, role: {:?}, numsegments: {=u8:?}, efsdelay: {=u16:?} }}" , self . en () , self . enfullaa () , self . role () , self . numsegments () , self . efsdelay ())
            }
        }
        #[doc = "Receive address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxaddresses(pub u32);
        impl Rxaddresses {
            #[doc = "Enable or disable reception on logical address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn addr0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 0"]
            #[inline(always)]
            pub const fn set_addr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn addr1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[inline(always)]
            pub const fn set_addr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn addr2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[inline(always)]
            pub const fn set_addr2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn addr3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[inline(always)]
            pub const fn set_addr3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn addr4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[inline(always)]
            pub const fn set_addr4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn addr5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[inline(always)]
            pub const fn set_addr5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn addr6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[inline(always)]
            pub const fn set_addr6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn addr7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[inline(always)]
            pub const fn set_addr7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rxaddresses {
            #[inline(always)]
            fn default() -> Rxaddresses {
                Rxaddresses(0)
            }
        }
        impl core::fmt::Debug for Rxaddresses {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxaddresses")
                    .field("addr0", &self.addr0())
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .field("addr3", &self.addr3())
                    .field("addr4", &self.addr4())
                    .field("addr5", &self.addr5())
                    .field("addr6", &self.addr6())
                    .field("addr7", &self.addr7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxaddresses {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rxaddresses {{ addr0: {=bool:?}, addr1: {=bool:?}, addr2: {=bool:?}, addr3: {=bool:?}, addr4: {=bool:?}, addr5: {=bool:?}, addr6: {=bool:?}, addr7: {=bool:?} }}" , self . addr0 () , self . addr1 () , self . addr2 () , self . addr3 () , self . addr4 () , self . addr5 () , self . addr6 () , self . addr7 ())
            }
        }
        #[doc = "CRC field of previously received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxcrc(pub u32);
        impl Rxcrc {
            #[doc = "CRC field of previously received packet"]
            #[must_use]
            #[inline(always)]
            pub const fn rxcrc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC field of previously received packet"]
            #[inline(always)]
            pub const fn set_rxcrc(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Rxcrc {
            #[inline(always)]
            fn default() -> Rxcrc {
                Rxcrc(0)
            }
        }
        impl core::fmt::Debug for Rxcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxcrc")
                    .field("rxcrc", &self.rxcrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxcrc {{ rxcrc: {=u32:?} }}", self.rxcrc())
            }
        }
        #[doc = "Override configuration of receiver gain control loop"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxgainConfig(pub u32);
        impl RxgainConfig {
            #[doc = "Override value for AAF"]
            #[must_use]
            #[inline(always)]
            pub const fn agcaafoverride(&self) -> u8 {
                let val = (self.0 >> 17usize) & 0x0f;
                val as u8
            }
            #[doc = "Override value for AAF"]
            #[inline(always)]
            pub const fn set_agcaafoverride(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 17usize)) | (((val as u32) & 0x0f) << 17usize);
            }
            #[doc = "Override value for MIX"]
            #[must_use]
            #[inline(always)]
            pub const fn agcmixoverride(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Override value for MIX"]
            #[inline(always)]
            pub const fn set_agcmixoverride(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Override value for LNA"]
            #[must_use]
            #[inline(always)]
            pub const fn agclnaoverride(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "Override value for LNA"]
            #[inline(always)]
            pub const fn set_agclnaoverride(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "Enable AGC override"]
            #[must_use]
            #[inline(always)]
            pub const fn agcoverridegain(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable AGC override"]
            #[inline(always)]
            pub const fn set_agcoverridegain(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for RxgainConfig {
            #[inline(always)]
            fn default() -> RxgainConfig {
                RxgainConfig(0)
            }
        }
        impl core::fmt::Debug for RxgainConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxgainConfig")
                    .field("agcaafoverride", &self.agcaafoverride())
                    .field("agcmixoverride", &self.agcmixoverride())
                    .field("agclnaoverride", &self.agclnaoverride())
                    .field("agcoverridegain", &self.agcoverridegain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxgainConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RxgainConfig {{ agcaafoverride: {=u8:?}, agcmixoverride: {=bool:?}, agclnaoverride: {=u8:?}, agcoverridegain: {=bool:?} }}" , self . agcaafoverride () , self . agcmixoverride () , self . agclnaoverride () , self . agcoverridegain ())
            }
        }
        #[doc = "Received address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxmatch(pub u32);
        impl Rxmatch {
            #[doc = "Received address"]
            #[must_use]
            #[inline(always)]
            pub const fn rxmatch(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Received address"]
            #[inline(always)]
            pub const fn set_rxmatch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxmatch {
            #[inline(always)]
            fn default() -> Rxmatch {
                Rxmatch(0)
            }
        }
        impl core::fmt::Debug for Rxmatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxmatch")
                    .field("rxmatch", &self.rxmatch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxmatch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxmatch {{ rxmatch: {=u8:?} }}", self.rxmatch())
            }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sfd(pub u32);
        impl Sfd {
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[must_use]
            #[inline(always)]
            pub const fn sfd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[inline(always)]
            pub const fn set_sfd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Sfd {
            #[inline(always)]
            fn default() -> Sfd {
                Sfd(0)
            }
        }
        impl core::fmt::Debug for Sfd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sfd").field("sfd", &self.sfd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sfd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sfd {{ sfd: {=u8:?} }}", self.sfd())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task START"]
            #[inline(always)]
            pub const fn set_ready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled_txen(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[inline(always)]
            pub const fn set_disabled_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled_rxen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[inline(always)]
            pub const fn set_disabled_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[must_use]
            #[inline(always)]
            pub const fn address_rssistart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[inline(always)]
            pub const fn set_address_rssistart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn address_bcstart(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[inline(always)]
            pub const fn set_address_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready_ccastart(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[inline(always)]
            pub const fn set_rxready_ccastart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle_txen(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[inline(always)]
            pub const fn set_ccaidle_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ccabusy_disable(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[inline(always)]
            pub const fn set_ccabusy_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn framestart_bcstart(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[inline(always)]
            pub const fn set_framestart_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_edstart(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[inline(always)]
            pub const fn set_ready_edstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn edend_disable(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[inline(always)]
            pub const fn set_edend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle_stop(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[inline(always)]
            pub const fn set_ccaidle_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn txready_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[inline(always)]
            pub const fn set_txready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready_start(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[inline(always)]
            pub const fn set_rxready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend_disable(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[inline(always)]
            pub const fn set_phyend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend_start(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[inline(always)]
            pub const fn set_phyend_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_start", &self.ready_start())
                    .field("disabled_txen", &self.disabled_txen())
                    .field("disabled_rxen", &self.disabled_rxen())
                    .field("address_rssistart", &self.address_rssistart())
                    .field("end_start", &self.end_start())
                    .field("address_bcstart", &self.address_bcstart())
                    .field("rxready_ccastart", &self.rxready_ccastart())
                    .field("ccaidle_txen", &self.ccaidle_txen())
                    .field("ccabusy_disable", &self.ccabusy_disable())
                    .field("framestart_bcstart", &self.framestart_bcstart())
                    .field("ready_edstart", &self.ready_edstart())
                    .field("edend_disable", &self.edend_disable())
                    .field("ccaidle_stop", &self.ccaidle_stop())
                    .field("txready_start", &self.txready_start())
                    .field("rxready_start", &self.rxready_start())
                    .field("phyend_disable", &self.phyend_disable())
                    .field("phyend_start", &self.phyend_start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_start: {=bool:?}, disabled_txen: {=bool:?}, disabled_rxen: {=bool:?}, address_rssistart: {=bool:?}, end_start: {=bool:?}, address_bcstart: {=bool:?}, rxready_ccastart: {=bool:?}, ccaidle_txen: {=bool:?}, ccabusy_disable: {=bool:?}, framestart_bcstart: {=bool:?}, ready_edstart: {=bool:?}, edend_disable: {=bool:?}, ccaidle_stop: {=bool:?}, txready_start: {=bool:?}, rxready_start: {=bool:?}, phyend_disable: {=bool:?}, phyend_start: {=bool:?} }}" , self . ready_start () , self . disabled_txen () , self . disabled_rxen () , self . address_rssistart () , self . end_start () , self . address_bcstart () , self . rxready_ccastart () , self . ccaidle_txen () , self . ccabusy_disable () , self . framestart_bcstart () , self . ready_edstart () , self . edend_disable () , self . ccaidle_stop () , self . txready_start () , self . rxready_start () , self . phyend_disable () , self . phyend_start ())
            }
        }
        #[doc = "Current radio state"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct State(pub u32);
        impl State {
            #[doc = "Current radio state"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Current radio state"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for State {
            #[inline(always)]
            fn default() -> State {
                State(0)
            }
        }
        impl core::fmt::Debug for State {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("State")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for State {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "State {{ state: {:?} }}", self.state())
            }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Switchpattern(pub u32);
        impl Switchpattern {
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[must_use]
            #[inline(always)]
            pub const fn switchpattern(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[inline(always)]
            pub const fn set_switchpattern(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Switchpattern {
            #[inline(always)]
            fn default() -> Switchpattern {
                Switchpattern(0)
            }
        }
        impl core::fmt::Debug for Switchpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Switchpattern")
                    .field("switchpattern", &self.switchpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Switchpattern {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Switchpattern {{ switchpattern: {=u8:?} }}",
                    self.switchpattern()
                )
            }
        }
        #[doc = "Interframe spacing in us"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tifs(pub u32);
        impl Tifs {
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[must_use]
            #[inline(always)]
            pub const fn tifs(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[inline(always)]
            pub const fn set_tifs(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Tifs {
            #[inline(always)]
            fn default() -> Tifs {
                Tifs(0)
            }
        }
        impl core::fmt::Debug for Tifs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tifs").field("tifs", &self.tifs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tifs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tifs {{ tifs: {=u16:?} }}", self.tifs())
            }
        }
        #[doc = "Timing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timing(pub u32);
        impl Timing {
            #[doc = "Ramp-up time"]
            #[must_use]
            #[inline(always)]
            pub const fn ru(&self) -> super::vals::Ru {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ru::from_bits(val as u8)
            }
            #[doc = "Ramp-up time"]
            #[inline(always)]
            pub const fn set_ru(&mut self, val: super::vals::Ru) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Timing {
            #[inline(always)]
            fn default() -> Timing {
                Timing(0)
            }
        }
        impl core::fmt::Debug for Timing {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timing").field("ru", &self.ru()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timing {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Timing {{ ru: {:?} }}", self.ru())
            }
        }
        #[doc = "Transmit address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txaddress(pub u32);
        impl Txaddress {
            #[doc = "Transmit address select"]
            #[must_use]
            #[inline(always)]
            pub const fn txaddress(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Transmit address select"]
            #[inline(always)]
            pub const fn set_txaddress(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Txaddress {
            #[inline(always)]
            fn default() -> Txaddress {
                Txaddress(0)
            }
        }
        impl core::fmt::Debug for Txaddress {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txaddress")
                    .field("txaddress", &self.txaddress())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txaddress {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txaddress {{ txaddress: {=u8:?} }}", self.txaddress())
            }
        }
        #[doc = "Output power"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txpower(pub u32);
        impl Txpower {
            #[doc = "RADIO output power"]
            #[must_use]
            #[inline(always)]
            pub const fn txpower(&self) -> super::vals::Txpower {
                let val = (self.0 >> 0usize) & 0x07ff;
                super::vals::Txpower::from_bits(val as u16)
            }
            #[doc = "RADIO output power"]
            #[inline(always)]
            pub const fn set_txpower(&mut self, val: super::vals::Txpower) {
                self.0 =
                    (self.0 & !(0x07ff << 0usize)) | (((val.to_bits() as u32) & 0x07ff) << 0usize);
            }
        }
        impl Default for Txpower {
            #[inline(always)]
            fn default() -> Txpower {
                Txpower(0)
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txpower")
                    .field("txpower", &self.txpower())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txpower {{ txpower: {:?} }}", self.txpower())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acqmode {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Baseband Channel Sounding RTT Data"]
            RTT = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Acqmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acqmode {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acqmode {
            #[inline(always)]
            fn from(val: u8) -> Acqmode {
                Acqmode::from_bits(val)
            }
        }
        impl From<Acqmode> for u8 {
            #[inline(always)]
            fn from(val: Acqmode) -> u8 {
                Acqmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccamode {
            #[doc = "Energy above threshold"]
            ED_MODE = 0x0,
            #[doc = "Carrier seen"]
            CARRIER_MODE = 0x01,
            #[doc = "Energy above threshold AND carrier seen"]
            CARRIER_AND_ED_MODE = 0x02,
            #[doc = "Energy above threshold OR carrier seen"]
            CARRIER_OR_ED_MODE = 0x03,
            #[doc = "Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging."]
            ED_MODE_TEST1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ccamode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccamode {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccamode {
            #[inline(always)]
            fn from(val: u8) -> Ccamode {
                Ccamode::from_bits(val)
            }
        }
        impl From<Ccamode> for u8 {
            #[inline(always)]
            fn from(val: Ccamode) -> u8 {
                Ccamode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cistat {
            #[doc = "Frame is received at 125 kbps"]
            LR125KBIT = 0x0,
            #[doc = "Frame is received at 500 kbps"]
            LR500KBIT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cistat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cistat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cistat {
            #[inline(always)]
            fn from(val: u8) -> Cistat {
                Cistat::from_bits(val)
            }
        }
        impl From<Cistat> for u8 {
            #[inline(always)]
            fn from(val: Cistat) -> u8 {
                Cistat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcinc {
            #[doc = "LENGTH does not contain CRC"]
            EXCLUDE = 0x0,
            #[doc = "LENGTH includes CRC"]
            INCLUDE = 0x01,
        }
        impl Crcinc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcinc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcinc {
            #[inline(always)]
            fn from(val: u8) -> Crcinc {
                Crcinc::from_bits(val)
            }
        }
        impl From<Crcinc> for u8 {
            #[inline(always)]
            fn from(val: Crcinc) -> u8 {
                Crcinc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcstatus {
            #[doc = "Packet received with CRC error"]
            CRCERROR = 0x0,
            #[doc = "Packet received with CRC ok"]
            CRCOK = 0x01,
        }
        impl Crcstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcstatus {
            #[inline(always)]
            fn from(val: u8) -> Crcstatus {
                Crcstatus::from_bits(val)
            }
        }
        impl From<Crcstatus> for u8 {
            #[inline(always)]
            fn from(val: Crcstatus) -> u8 {
                Crcstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode1us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode1us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode1us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode1us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode1us {
                Cteinlinerxmode1us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode1us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode1us) -> u8 {
                Cteinlinerxmode1us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode2us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode2us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode2us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode2us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode2us {
                Cteinlinerxmode2us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode2us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode2us) -> u8 {
                Cteinlinerxmode2us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctetimevalidrange {
            #[doc = "20 in 8us unit (default) Set to 20 if parsed CTETime is larger han 20"]
            _20 = 0x0,
            #[doc = "31 in 8us unit"]
            _31 = 0x01,
            #[doc = "63 in 8us unit"]
            _63 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctetimevalidrange {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctetimevalidrange {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctetimevalidrange {
            #[inline(always)]
            fn from(val: u8) -> Ctetimevalidrange {
                Ctetimevalidrange::from_bits(val)
            }
        }
        impl From<Ctetimevalidrange> for u8 {
            #[inline(always)]
            fn from(val: Ctetimevalidrange) -> u8 {
                Ctetimevalidrange::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeinextension {
            #[doc = "Antenna switching/sampling is done in the packet payload"]
            PAYLOAD = 0x0,
            #[doc = "AoA/AoD procedure triggered at end of CRC"]
            CRC = 0x01,
        }
        impl Dfeinextension {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeinextension {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeinextension {
            #[inline(always)]
            fn from(val: u8) -> Dfeinextension {
                Dfeinextension::from_bits(val)
            }
        }
        impl From<Dfeinextension> for u8 {
            #[inline(always)]
            fn from(val: Dfeinextension) -> u8 {
                Dfeinextension::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeopmode {
            #[doc = "Direction finding mode disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Direction finding mode set to AoD"]
            AO_D = 0x02,
            #[doc = "Direction finding mode set to AoA"]
            AO_A = 0x03,
        }
        impl Dfeopmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeopmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeopmode {
            #[inline(always)]
            fn from(val: u8) -> Dfeopmode {
                Dfeopmode::from_bits(val)
            }
        }
        impl From<Dfeopmode> for u8 {
            #[inline(always)]
            fn from(val: Dfeopmode) -> u8 {
                Dfeopmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            #[doc = "Peripheral to memory"]
            ACQ = 0x0,
            #[doc = "Memory to peripheral"]
            INJ = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edperiod {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            #[doc = "Unspecified"]
            DEFAULT = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Edperiod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edperiod {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edperiod {
            #[inline(always)]
            fn from(val: u8) -> Edperiod {
                Edperiod::from_bits(val)
            }
        }
        impl From<Edperiod> for u8 {
            #[inline(always)]
            fn from(val: Edperiod) -> u8 {
                Edperiod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Least significant bit on air first"]
            LITTLE = 0x0,
            #[doc = "Most significant bit on air first"]
            BIG = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Len {
            #[doc = "CRC length is zero and CRC calculation is disabled"]
            DISABLED = 0x0,
            #[doc = "CRC length is one byte and CRC calculation is enabled"]
            ONE = 0x01,
            #[doc = "CRC length is two bytes and CRC calculation is enabled"]
            TWO = 0x02,
            #[doc = "CRC length is three bytes and CRC calculation is enabled"]
            THREE = 0x03,
        }
        impl Len {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Len {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Len {
            #[inline(always)]
            fn from(val: u8) -> Len {
                Len::from_bits(val)
            }
        }
        impl From<Len> for u8 {
            #[inline(always)]
            fn from(val: Len) -> u8 {
                Len::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "1 Mbps Nordic proprietary radio mode"]
            NRF_1MBIT = 0x0,
            #[doc = "2 Mbps Nordic proprietary radio mode"]
            NRF_2MBIT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "1 Mbps BLE"]
            BLE_1MBIT = 0x03,
            #[doc = "2 Mbps BLE"]
            BLE_2MBIT = 0x04,
            #[doc = "Long range 125 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR125KBIT = 0x05,
            #[doc = "Long range 500 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR500KBIT = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.6/h=0.5)"]
            NRF_4MBIT_0BT6 = 0x09,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.4/h=0.5)"]
            NRF_4MBIT_0BT4 = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "IEEE 802.15.4-2006 250 kbps"]
            IEEE802154_250KBIT = 0x0f,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdustat {
            #[doc = "Payload less than PCNF1.MAXLEN"]
            LESS_THAN = 0x0,
            #[doc = "Payload greater than PCNF1.MAXLEN"]
            GREATER_THAN = 0x01,
        }
        impl Pdustat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdustat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdustat {
            #[inline(always)]
            fn from(val: u8) -> Pdustat {
                Pdustat::from_bits(val)
            }
        }
        impl From<Pdustat> for u8 {
            #[inline(always)]
            fn from(val: Pdustat) -> u8 {
                Pdustat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Plen {
            #[doc = "8-bit preamble"]
            _8BIT = 0x0,
            #[doc = "16-bit preamble"]
            _16BIT = 0x01,
            #[doc = "32-bit zero preamble - used for IEEE 802.15.4"]
            _32BIT_ZERO = 0x02,
            #[doc = "Preamble - used for BLE long range"]
            LONG_RANGE = 0x03,
        }
        impl Plen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Plen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Plen {
            #[inline(always)]
            fn from(val: u8) -> Plen {
                Plen::from_bits(val)
            }
        }
        impl From<Plen> for u8 {
            #[inline(always)]
            fn from(val: Plen) -> u8 {
                Plen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rate {
            #[doc = "Radio mode BLE1M is used"]
            BLE1M = 0x0,
            #[doc = "Radio mode BLE2M is used"]
            BLE2M = 0x01,
        }
        impl Rate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rate {
            #[inline(always)]
            fn from(val: u8) -> Rate {
                Rate::from_bits(val)
            }
        }
        impl From<Rate> for u8 {
            #[inline(always)]
            fn from(val: Rate) -> u8 {
                Rate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Repeatpattern {
            #[doc = "Do not repeat (1 time in total)"]
            NO_REPEAT = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Repeatpattern {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Repeatpattern {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Repeatpattern {
            #[inline(always)]
            fn from(val: u8) -> Repeatpattern {
                Repeatpattern::from_bits(val)
            }
        }
        impl From<Repeatpattern> for u8 {
            #[inline(always)]
            fn from(val: Repeatpattern) -> u8 {
                Repeatpattern::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Role {
            #[doc = "Initiator"]
            INITIATOR = 0x0,
            #[doc = "Reflector"]
            REFLECTOR = 0x01,
        }
        impl Role {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Role {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Role {
            #[inline(always)]
            fn from(val: u8) -> Role {
                Role::from_bits(val)
            }
        }
        impl From<Role> for u8 {
            #[inline(always)]
            fn from(val: Role) -> u8 {
                Role::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ru {
            #[doc = "Legacy ramp-up time"]
            LEGACY = 0x0,
            #[doc = "Fast ramp-up (default)"]
            FAST = 0x01,
        }
        impl Ru {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ru {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ru {
            #[inline(always)]
            fn from(val: u8) -> Ru {
                Ru::from_bits(val)
            }
        }
        impl From<Ru> for u8 {
            #[inline(always)]
            fn from(val: Ru) -> u8 {
                Ru::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum S1incl {
            #[doc = "Include S1 field in RAM only if S1LEN &gt; 0"]
            AUTOMATIC = 0x0,
            #[doc = "Always include S1 field in RAM independent of S1LEN"]
            INCLUDE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl S1incl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> S1incl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for S1incl {
            #[inline(always)]
            fn from(val: u8) -> S1incl {
                S1incl::from_bits(val)
            }
        }
        impl From<S1incl> for u8 {
            #[inline(always)]
            fn from(val: S1incl) -> u8 {
                S1incl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampletype {
            #[doc = "Complex samples in I and Q"]
            IQ = 0x0,
            #[doc = "Complex samples as magnitude and phase"]
            MAG_PHASE = 0x01,
        }
        impl Sampletype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampletype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampletype {
            #[inline(always)]
            fn from(val: u8) -> Sampletype {
                Sampletype::from_bits(val)
            }
        }
        impl From<Sampletype> for u8 {
            #[inline(always)]
            fn from(val: Sampletype) -> u8 {
                Sampletype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Samplingstate {
            #[doc = "Sampling state Idle"]
            IDLE = 0x0,
            #[doc = "Sampling state Sampling"]
            SAMPLING = 0x01,
        }
        impl Samplingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Samplingstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Samplingstate {
            #[inline(always)]
            fn from(val: u8) -> Samplingstate {
                Samplingstate::from_bits(val)
            }
        }
        impl From<Samplingstate> for u8 {
            #[inline(always)]
            fn from(val: Samplingstate) -> u8 {
                Samplingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Skipaddr {
            #[doc = "CRC calculation includes address field"]
            INCLUDE = 0x0,
            #[doc = "CRC calculation starting at first byte after address field."]
            SKIP = 0x01,
            #[doc = "CRC calculation starting at first byte after length field (as per 802.15.4 standard)."]
            IEEE802154 = 0x02,
            #[doc = "CRC calculation starting at first byte after S0 field."]
            SKIP_S0 = 0x03,
            #[doc = "CRC calculation starting at first byte after S1 field."]
            SKIP_S1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Skipaddr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Skipaddr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Skipaddr {
            #[inline(always)]
            fn from(val: u8) -> Skipaddr {
                Skipaddr::from_bits(val)
            }
        }
        impl From<Skipaddr> for u8 {
            #[inline(always)]
            fn from(val: Skipaddr) -> u8 {
                Skipaddr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "RADIO is in the DISABLED state"]
            DISABLED = 0x0,
            #[doc = "RADIO is in the RXRU state"]
            RX_RU = 0x01,
            #[doc = "RADIO is in the RXIDLE state"]
            RX_IDLE = 0x02,
            #[doc = "RADIO is in the RX state"]
            RX = 0x03,
            #[doc = "RADIO is in the RXDISABLE state"]
            RX_DISABLE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "RADIO is in the TXRU state"]
            TX_RU = 0x09,
            #[doc = "RADIO is in the TXIDLE state"]
            TX_IDLE = 0x0a,
            #[doc = "RADIO is in the TX state"]
            TX = 0x0b,
            #[doc = "RADIO is in the TXDISABLE state"]
            TX_DISABLE = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Switchingstate {
            #[doc = "Switching state Idle"]
            IDLE = 0x0,
            #[doc = "Switching state Offset"]
            OFFSET = 0x01,
            #[doc = "Switching state Guard"]
            GUARD = 0x02,
            #[doc = "Switching state Ref"]
            REF = 0x03,
            #[doc = "Switching state Switching"]
            SWITCHING = 0x04,
            #[doc = "Switching state Ending"]
            ENDING = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Switchingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Switchingstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Switchingstate {
            #[inline(always)]
            fn from(val: u8) -> Switchingstate {
                Switchingstate::from_bits(val)
            }
        }
        impl From<Switchingstate> for u8 {
            #[inline(always)]
            fn from(val: Switchingstate) -> u8 {
                Switchingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Syncok {
            #[doc = "Unspecified"]
            SYNC_NOT_OK = 0x0,
            #[doc = "Unspecified"]
            SYNC_OK = 0x01,
        }
        impl Syncok {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Syncok {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Syncok {
            #[inline(always)]
            fn from(val: u8) -> Syncok {
                Syncok::from_bits(val)
            }
        }
        impl From<Syncok> for u8 {
            #[inline(always)]
            fn from(val: Syncok) -> u8 {
                Syncok::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacing {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacing {
                Tsamplespacing::from_bits(val)
            }
        }
        impl From<Tsamplespacing> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacing) -> u8 {
                Tsamplespacing::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacingref {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacingref {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacingref {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacingref {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacingref {
                Tsamplespacingref::from_bits(val)
            }
        }
        impl From<Tsamplespacingref> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacingref) -> u8 {
                Tsamplespacingref::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tswitchspacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tswitchspacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tswitchspacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tswitchspacing {
            #[inline(always)]
            fn from(val: u8) -> Tswitchspacing {
                Tswitchspacing::from_bits(val)
            }
        }
        impl From<Tswitchspacing> for u8 {
            #[inline(always)]
            fn from(val: Tswitchspacing) -> u8 {
                Tswitchspacing::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Txpower(u16);
        impl Txpower {
            #[doc = "Minimum output power"]
            pub const MIN_DBM: Self = Self(0x0);
            #[doc = "-28 dBm"]
            pub const NEG28_DBM: Self = Self(0x01);
            #[doc = "-20 dBm"]
            pub const NEG20_DBM: Self = Self(0x02);
            #[doc = "-22 dBm"]
            pub const NEG22_DBM: Self = Self(0x02);
            #[doc = "-18 dBm"]
            pub const NEG18_DBM: Self = Self(0x03);
            #[doc = "-16 dBm"]
            pub const NEG16_DBM: Self = Self(0x04);
            #[doc = "-14 dBm"]
            pub const NEG14_DBM: Self = Self(0x05);
            #[doc = "-12 dBm"]
            pub const NEG12_DBM: Self = Self(0x06);
            #[doc = "-10 dBm"]
            pub const NEG10_DBM: Self = Self(0x07);
            #[doc = "-9 dBm"]
            pub const NEG9_DBM: Self = Self(0x08);
            #[doc = "-8 dBm"]
            pub const NEG8_DBM: Self = Self(0x09);
            #[doc = "-7 dBm"]
            pub const NEG7_DBM: Self = Self(0x0a);
            #[doc = "-6 dBm"]
            pub const NEG6_DBM: Self = Self(0x0b);
            #[doc = "-5 dBm"]
            pub const NEG5_DBM: Self = Self(0x0d);
            #[doc = "-4 dBm"]
            pub const NEG4_DBM: Self = Self(0x0f);
            #[doc = "-3 dBm"]
            pub const NEG3_DBM: Self = Self(0x11);
            #[doc = "-2 dBm"]
            pub const NEG2_DBM: Self = Self(0x13);
            #[doc = "-1 dBm"]
            pub const NEG1_DBM: Self = Self(0x15);
            #[doc = "0 dBm"]
            pub const _0_DBM: Self = Self(0x18);
            #[doc = "+1 dBm"]
            pub const POS1_DBM: Self = Self(0x1b);
            #[doc = "+2 dBm"]
            pub const POS2_DBM: Self = Self(0x1f);
            #[doc = "+3 dBm"]
            pub const POS3_DBM: Self = Self(0x23);
            #[doc = "+4 dBm"]
            pub const POS4_DBM: Self = Self(0x28);
            #[doc = "+5 dBm"]
            pub const POS5_DBM: Self = Self(0x2d);
            #[doc = "+6 dBm"]
            pub const POS6_DBM: Self = Self(0x33);
            #[doc = "+7 dBm"]
            pub const POS7_DBM: Self = Self(0x39);
            #[doc = "+8 dBm"]
            pub const MAX_DBM: Self = Self(0x3f);
            #[doc = "+8 dBm"]
            pub const POS8_DBM: Self = Self(0x3f);
            #[doc = "-46 dBm"]
            pub const NEG46_DBM: Self = Self(0x0110);
            #[doc = "-40 dBm"]
            pub const NEG40_DBM: Self = Self(0x0130);
        }
        impl Txpower {
            pub const fn from_bits(val: u16) -> Txpower {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_DBM"),
                    0x01 => f.write_str("NEG28_DBM"),
                    0x02 => f.write_str("NEG20_DBM"),
                    0x02 => f.write_str("NEG22_DBM"),
                    0x03 => f.write_str("NEG18_DBM"),
                    0x04 => f.write_str("NEG16_DBM"),
                    0x05 => f.write_str("NEG14_DBM"),
                    0x06 => f.write_str("NEG12_DBM"),
                    0x07 => f.write_str("NEG10_DBM"),
                    0x08 => f.write_str("NEG9_DBM"),
                    0x09 => f.write_str("NEG8_DBM"),
                    0x0a => f.write_str("NEG7_DBM"),
                    0x0b => f.write_str("NEG6_DBM"),
                    0x0d => f.write_str("NEG5_DBM"),
                    0x0f => f.write_str("NEG4_DBM"),
                    0x11 => f.write_str("NEG3_DBM"),
                    0x13 => f.write_str("NEG2_DBM"),
                    0x15 => f.write_str("NEG1_DBM"),
                    0x18 => f.write_str("_0_DBM"),
                    0x1b => f.write_str("POS1_DBM"),
                    0x1f => f.write_str("POS2_DBM"),
                    0x23 => f.write_str("POS3_DBM"),
                    0x28 => f.write_str("POS4_DBM"),
                    0x2d => f.write_str("POS5_DBM"),
                    0x33 => f.write_str("POS6_DBM"),
                    0x39 => f.write_str("POS7_DBM"),
                    0x3f => f.write_str("MAX_DBM"),
                    0x3f => f.write_str("POS8_DBM"),
                    0x0110 => f.write_str("NEG46_DBM"),
                    0x0130 => f.write_str("NEG40_DBM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_DBM"),
                    0x01 => defmt::write!(f, "NEG28_DBM"),
                    0x02 => defmt::write!(f, "NEG20_DBM"),
                    0x02 => defmt::write!(f, "NEG22_DBM"),
                    0x03 => defmt::write!(f, "NEG18_DBM"),
                    0x04 => defmt::write!(f, "NEG16_DBM"),
                    0x05 => defmt::write!(f, "NEG14_DBM"),
                    0x06 => defmt::write!(f, "NEG12_DBM"),
                    0x07 => defmt::write!(f, "NEG10_DBM"),
                    0x08 => defmt::write!(f, "NEG9_DBM"),
                    0x09 => defmt::write!(f, "NEG8_DBM"),
                    0x0a => defmt::write!(f, "NEG7_DBM"),
                    0x0b => defmt::write!(f, "NEG6_DBM"),
                    0x0d => defmt::write!(f, "NEG5_DBM"),
                    0x0f => defmt::write!(f, "NEG4_DBM"),
                    0x11 => defmt::write!(f, "NEG3_DBM"),
                    0x13 => defmt::write!(f, "NEG2_DBM"),
                    0x15 => defmt::write!(f, "NEG1_DBM"),
                    0x18 => defmt::write!(f, "_0_DBM"),
                    0x1b => defmt::write!(f, "POS1_DBM"),
                    0x1f => defmt::write!(f, "POS2_DBM"),
                    0x23 => defmt::write!(f, "POS3_DBM"),
                    0x28 => defmt::write!(f, "POS4_DBM"),
                    0x2d => defmt::write!(f, "POS5_DBM"),
                    0x33 => defmt::write!(f, "POS6_DBM"),
                    0x39 => defmt::write!(f, "POS7_DBM"),
                    0x3f => defmt::write!(f, "MAX_DBM"),
                    0x3f => defmt::write!(f, "POS8_DBM"),
                    0x0110 => defmt::write!(f, "NEG46_DBM"),
                    0x0130 => defmt::write!(f, "NEG40_DBM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Txpower {
            #[inline(always)]
            fn from(val: u16) -> Txpower {
                Txpower::from_bits(val)
            }
        }
        impl From<Txpower> for u16 {
            #[inline(always)]
            fn from(val: Txpower) -> u16 {
                Txpower::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Whiteoffset {
            #[doc = "S0 included in whitening"]
            INCLUDE = 0x0,
            #[doc = "S0 excluded from whitening"]
            EXCLUDE = 0x01,
        }
        impl Whiteoffset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Whiteoffset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Whiteoffset {
            #[inline(always)]
            fn from(val: u8) -> Whiteoffset {
                Whiteoffset::from_bits(val)
            }
        }
        impl From<Whiteoffset> for u8 {
            #[inline(always)]
            fn from(val: Whiteoffset) -> u8 {
                Whiteoffset::to_bits(val)
            }
        }
    }
}
pub mod regulators {
    #[doc = "Voltage regulators 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Regulators {
        ptr: *mut u8,
    }
    unsafe impl Send for Regulators {}
    unsafe impl Sync for Regulators {}
    impl Regulators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System OFF register"]
        #[inline(always)]
        pub const fn systemoff(self) -> crate::common::Reg<regs::Systemoff, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Power-fail comparator configuration"]
        #[inline(always)]
        pub const fn pofcon(self) -> crate::common::Reg<regs::Pofcon, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0530usize) as _) }
        }
        #[doc = "Power-fail comparator status register"]
        #[inline(always)]
        pub const fn pofstat(self) -> crate::common::Reg<regs::Pofstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Register interface for main voltage regulator."]
        #[inline(always)]
        pub const fn vregmain(self) -> Vregmain {
            unsafe { Vregmain::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
    }
    #[doc = "Register interface for main voltage regulator."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregmain {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregmain {}
    unsafe impl Sync for Vregmain {}
    impl Vregmain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable DC/DC converter"]
        #[inline(always)]
        pub const fn dcdcen(self) -> crate::common::Reg<regs::Dcdcen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[inline(always)]
        pub const fn inductordet(self) -> crate::common::Reg<regs::Inductordet, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable DC/DC converter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcdcen(pub u32);
        impl Dcdcen {
            #[doc = "Enable DC/DC buck converter"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable DC/DC buck converter"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dcdcen {
            #[inline(always)]
            fn default() -> Dcdcen {
                Dcdcen(0)
            }
        }
        impl core::fmt::Debug for Dcdcen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcdcen").field("val", &self.val()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcdcen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dcdcen {{ val: {=bool:?} }}", self.val())
            }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inductordet(pub u32);
        impl Inductordet {
            #[must_use]
            #[inline(always)]
            pub const fn detected(&self) -> super::vals::Detected {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detected::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_detected(&mut self, val: super::vals::Detected) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Inductordet {
            #[inline(always)]
            fn default() -> Inductordet {
                Inductordet(0)
            }
        }
        impl core::fmt::Debug for Inductordet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inductordet")
                    .field("detected", &self.detected())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inductordet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Inductordet {{ detected: {:?} }}", self.detected())
            }
        }
        #[doc = "Power-fail comparator configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofcon(pub u32);
        impl Pofcon {
            #[doc = "Enable or disable power-fail comparator"]
            #[must_use]
            #[inline(always)]
            pub const fn pof(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable power-fail comparator"]
            #[inline(always)]
            pub const fn set_pof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[must_use]
            #[inline(always)]
            pub const fn threshold(&self) -> super::vals::Threshold {
                let val = (self.0 >> 1usize) & 0x0f;
                super::vals::Threshold::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[inline(always)]
            pub const fn set_threshold(&mut self, val: super::vals::Threshold) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val.to_bits() as u32) & 0x0f) << 1usize);
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[must_use]
            #[inline(always)]
            pub const fn eventdisable(&self) -> super::vals::Eventdisable {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Eventdisable::from_bits(val as u8)
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[inline(always)]
            pub const fn set_eventdisable(&mut self, val: super::vals::Eventdisable) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Pofcon {
            #[inline(always)]
            fn default() -> Pofcon {
                Pofcon(0)
            }
        }
        impl core::fmt::Debug for Pofcon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofcon")
                    .field("pof", &self.pof())
                    .field("threshold", &self.threshold())
                    .field("eventdisable", &self.eventdisable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofcon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pofcon {{ pof: {=bool:?}, threshold: {:?}, eventdisable: {:?} }}",
                    self.pof(),
                    self.threshold(),
                    self.eventdisable()
                )
            }
        }
        #[doc = "Power-fail comparator status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofstat(pub u32);
        impl Pofstat {
            #[doc = "Power-fail comparator status"]
            #[must_use]
            #[inline(always)]
            pub const fn comparator(&self) -> super::vals::Comparator {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Comparator::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator status"]
            #[inline(always)]
            pub const fn set_comparator(&mut self, val: super::vals::Comparator) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Pofstat {
            #[inline(always)]
            fn default() -> Pofstat {
                Pofstat(0)
            }
        }
        impl core::fmt::Debug for Pofstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofstat")
                    .field("comparator", &self.comparator())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pofstat {{ comparator: {:?} }}", self.comparator())
            }
        }
        #[doc = "System OFF register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Systemoff(pub u32);
        impl Systemoff {
            #[doc = "Enable System OFF mode"]
            #[must_use]
            #[inline(always)]
            pub const fn systemoff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable System OFF mode"]
            #[inline(always)]
            pub const fn set_systemoff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Systemoff {
            #[inline(always)]
            fn default() -> Systemoff {
                Systemoff(0)
            }
        }
        impl core::fmt::Debug for Systemoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Systemoff")
                    .field("systemoff", &self.systemoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Systemoff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Systemoff {{ systemoff: {=bool:?} }}", self.systemoff())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Comparator {
            #[doc = "Voltage detected above VPOF threshold"]
            ABOVE = 0x0,
            #[doc = "Voltage detected below VPOF threshold"]
            BELOW = 0x01,
        }
        impl Comparator {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Comparator {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Comparator {
            #[inline(always)]
            fn from(val: u8) -> Comparator {
                Comparator::from_bits(val)
            }
        }
        impl From<Comparator> for u8 {
            #[inline(always)]
            fn from(val: Comparator) -> u8 {
                Comparator::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detected {
            #[doc = "VREGMAIN inductor not detected"]
            INDUCTOR_NOT_DETECTED = 0x0,
            #[doc = "VREGMAIN inductor detected"]
            INDUCTOR_DETECTED = 0x01,
        }
        impl Detected {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detected {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detected {
            #[inline(always)]
            fn from(val: u8) -> Detected {
                Detected::from_bits(val)
            }
        }
        impl From<Detected> for u8 {
            #[inline(always)]
            fn from(val: Detected) -> u8 {
                Detected::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eventdisable {
            #[doc = "POFWARN event is generated"]
            ENABLED = 0x0,
            #[doc = "POFWARN event is not generated"]
            DISABLED = 0x01,
        }
        impl Eventdisable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eventdisable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eventdisable {
            #[inline(always)]
            fn from(val: u8) -> Eventdisable {
                Eventdisable::from_bits(val)
            }
        }
        impl From<Eventdisable> for u8 {
            #[inline(always)]
            fn from(val: Eventdisable) -> u8 {
                Eventdisable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Threshold {
            #[doc = "Set threshold to 1.7 V for VDD"]
            V17 = 0x0,
            #[doc = "Set threshold to 1.8 V for VDD"]
            V18 = 0x01,
            #[doc = "Set threshold to 1.9 V for VDD"]
            V19 = 0x02,
            #[doc = "Set threshold to 2.0 V for VDD"]
            V20 = 0x03,
            #[doc = "Set threshold to 2.1 V for VDD"]
            V21 = 0x04,
            #[doc = "Set threshold to 2.2 V for VDD"]
            V22 = 0x05,
            #[doc = "Set threshold to 2.3 V for VDD"]
            V23 = 0x06,
            #[doc = "Set threshold to 2.4 V for VDD"]
            V24 = 0x07,
            #[doc = "Set threshold to 2.5 V for VDD"]
            V25 = 0x08,
            #[doc = "Set threshold to 2.6 V for VDD"]
            V26 = 0x09,
            #[doc = "Set threshold to 2.7 V for VDD"]
            V27 = 0x0a,
            #[doc = "Set threshold to 2.8 V for VDD"]
            V28 = 0x0b,
            #[doc = "Set threshold to 2.9 V for VDD"]
            V29 = 0x0c,
            #[doc = "Set threshold to 3.0 V for VDD"]
            V30 = 0x0d,
            #[doc = "Set threshold to 3.1 V for VDD"]
            V31 = 0x0e,
            #[doc = "Set threshold to 3.2 V for VDD"]
            V32 = 0x0f,
        }
        impl Threshold {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Threshold {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Threshold {
            #[inline(always)]
            fn from(val: u8) -> Threshold {
                Threshold::from_bits(val)
            }
        }
        impl From<Threshold> for u8 {
            #[inline(always)]
            fn from(val: Threshold) -> u8 {
                Threshold::to_bits(val)
            }
        }
    }
}
pub mod reset {
    #[doc = "Reset control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Reset {
        ptr: *mut u8,
    }
    unsafe impl Send for Reset {}
    unsafe impl Sync for Reset {}
    impl Reset {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Reset reason"]
        #[inline(always)]
        pub const fn resetreas(self) -> crate::common::Reg<regs::Resetreas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Reset reason"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resetreas(pub u32);
        impl Resetreas {
            #[doc = "Reset from pin reset detected"]
            #[must_use]
            #[inline(always)]
            pub const fn resetpin(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from pin reset detected"]
            #[inline(always)]
            pub const fn set_resetpin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[must_use]
            #[inline(always)]
            pub const fn dog0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[inline(always)]
            pub const fn set_dog0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[must_use]
            #[inline(always)]
            pub const fn dog1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[inline(always)]
            pub const fn set_dog1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlapsoft(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[inline(always)]
            pub const fn set_ctrlapsoft(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlaphard(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[inline(always)]
            pub const fn set_ctrlaphard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlappin(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[inline(always)]
            pub const fn set_ctrlappin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Reset from soft reset detected"]
            #[must_use]
            #[inline(always)]
            pub const fn sreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from soft reset detected"]
            #[inline(always)]
            pub const fn set_sreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Reset from CPU lockup detected"]
            #[must_use]
            #[inline(always)]
            pub const fn lockup(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from CPU lockup detected"]
            #[inline(always)]
            pub const fn set_lockup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[must_use]
            #[inline(always)]
            pub const fn off(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[inline(always)]
            pub const fn set_off(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[must_use]
            #[inline(always)]
            pub const fn lpcomp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[inline(always)]
            pub const fn set_lpcomp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[must_use]
            #[inline(always)]
            pub const fn dif(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[inline(always)]
            pub const fn set_dif(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[must_use]
            #[inline(always)]
            pub const fn grtc(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[inline(always)]
            pub const fn set_grtc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[must_use]
            #[inline(always)]
            pub const fn nfc(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[inline(always)]
            pub const fn set_nfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[must_use]
            #[inline(always)]
            pub const fn sectamper(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[inline(always)]
            pub const fn set_sectamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Reset after wakeup from System OFF mode due to VBUS rising into valid range"]
            #[must_use]
            #[inline(always)]
            pub const fn vbus(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Reset after wakeup from System OFF mode due to VBUS rising into valid range"]
            #[inline(always)]
            pub const fn set_vbus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Resetreas {
            #[inline(always)]
            fn default() -> Resetreas {
                Resetreas(0)
            }
        }
        impl core::fmt::Debug for Resetreas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resetreas")
                    .field("resetpin", &self.resetpin())
                    .field("dog0", &self.dog0())
                    .field("dog1", &self.dog1())
                    .field("ctrlapsoft", &self.ctrlapsoft())
                    .field("ctrlaphard", &self.ctrlaphard())
                    .field("ctrlappin", &self.ctrlappin())
                    .field("sreq", &self.sreq())
                    .field("lockup", &self.lockup())
                    .field("off", &self.off())
                    .field("lpcomp", &self.lpcomp())
                    .field("dif", &self.dif())
                    .field("grtc", &self.grtc())
                    .field("nfc", &self.nfc())
                    .field("sectamper", &self.sectamper())
                    .field("vbus", &self.vbus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resetreas {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Resetreas {{ resetpin: {=bool:?}, dog0: {=bool:?}, dog1: {=bool:?}, ctrlapsoft: {=bool:?}, ctrlaphard: {=bool:?}, ctrlappin: {=bool:?}, sreq: {=bool:?}, lockup: {=bool:?}, off: {=bool:?}, lpcomp: {=bool:?}, dif: {=bool:?}, grtc: {=bool:?}, nfc: {=bool:?}, sectamper: {=bool:?}, vbus: {=bool:?} }}" , self . resetpin () , self . dog0 () , self . dog1 () , self . ctrlapsoft () , self . ctrlaphard () , self . ctrlappin () , self . sreq () , self . lockup () , self . off () , self . lpcomp () , self . dif () , self . grtc () , self . nfc () , self . sectamper () , self . vbus ())
            }
        }
    }
}
pub mod rramc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bufstatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bufstatus {}
    unsafe impl Sync for Bufstatus {}
    impl Bufstatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Internal write-buffer is empty"]
        #[inline(always)]
        pub const fn writebufempty(
            self,
        ) -> crate::common::Reg<regs::Writebufempty, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecc {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecc {}
    unsafe impl Sync for Ecc {}
    impl Ecc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the first ECC error that could not be corrected"]
        #[inline(always)]
        pub const fn erroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Erase {
        ptr: *mut u8,
    }
    unsafe impl Send for Erase {}
    unsafe impl Sync for Erase {}
    impl Erase {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Erase RRAM, including UICR All information in SICR, including keys, are also erased"]
        #[inline(always)]
        pub const fn eraseall(self) -> crate::common::Reg<regs::Eraseall, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Power configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::PowerConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Low power mode configuration"]
        #[inline(always)]
        pub const fn lowpowerconfig(
            self,
        ) -> crate::common::Reg<regs::Lowpowerconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "RRAMC can apply access privileges to regions of the RRAM. Some regions are dedicated for system use and are not available for configuration - refer to the instantiation table for details."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Region {
        ptr: *mut u8,
    }
    unsafe impl Send for Region {}
    unsafe impl Sync for Region {}
    impl Region {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Region address"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Region configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RegionConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "RRAM controller GLITCH detector"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rramc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rramc {}
    unsafe impl Sync for Rramc {}
    impl Rramc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Wakeup the RRAM from low power mode"]
        #[inline(always)]
        pub const fn tasks_wakeup(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Clear internal write-buffer"]
        #[inline(always)]
        pub const fn tasks_clrwritebuf(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Commits the data stored in internal write-buffer to RRAM"]
        #[inline(always)]
        pub const fn tasks_commitwritebuf(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task WAKEUP"]
        #[inline(always)]
        pub const fn subscribe_wakeup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLRWRITEBUF"]
        #[inline(always)]
        pub const fn subscribe_clrwritebuf(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task COMMITWRITEBUF"]
        #[inline(always)]
        pub const fn subscribe_commitwritebuf(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "RRAMC is woken up from low power mode"]
        #[inline(always)]
        pub const fn events_wokenup(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "RRAMC is ready"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Ready to accept a new write operation"]
        #[inline(always)]
        pub const fn events_readynext(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "RRAM access error"]
        #[inline(always)]
        pub const fn events_accesserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event WOKENUP"]
        #[inline(always)]
        pub const fn publish_wokenup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "RRAMC ready status"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<regs::Ready, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Ready next flag"]
        #[inline(always)]
        pub const fn readynext(self) -> crate::common::Reg<regs::Readynext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Address of the first access error"]
        #[inline(always)]
        pub const fn accesserroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0408usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn bufstatus(self) -> Bufstatus {
            unsafe { Bufstatus::from_ptr(self.ptr.wrapping_add(0x0410usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ecc(self) -> Ecc {
            unsafe { Ecc::from_ptr(self.ptr.wrapping_add(0x0420usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RramcConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[inline(always)]
        pub const fn readynexttimeout(
            self,
        ) -> crate::common::Reg<regs::Readynexttimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self) -> Power {
            unsafe { Power::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn erase(self) -> Erase {
            unsafe { Erase::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "RRAMC can apply access privileges to regions of the RRAM. Some regions are dedicated for system use and are not available for configuration - refer to the instantiation table for details."]
        #[inline(always)]
        pub const fn region(self, n: usize) -> Region {
            assert!(n < 6usize);
            unsafe { Region::from_ptr(self.ptr.wrapping_add(0x0550usize + n * 8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Erase RRAM, including UICR All information in SICR, including keys, are also erased"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eraseall(pub u32);
        impl Eraseall {
            #[doc = "Erase RRAM"]
            #[must_use]
            #[inline(always)]
            pub const fn erase(&self) -> super::vals::Erase {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Erase::from_bits(val as u8)
            }
            #[doc = "Erase RRAM"]
            #[inline(always)]
            pub const fn set_erase(&mut self, val: super::vals::Erase) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Eraseall {
            #[inline(always)]
            fn default() -> Eraseall {
                Eraseall(0)
            }
        }
        impl core::fmt::Debug for Eraseall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eraseall")
                    .field("erase", &self.erase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eraseall {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eraseall {{ erase: {:?} }}", self.erase())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[must_use]
            #[inline(always)]
            pub const fn wokenup(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[inline(always)]
            pub const fn set_wokenup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[must_use]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[inline(always)]
            pub const fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn accesserror(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[inline(always)]
            pub const fn set_accesserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("wokenup", &self.wokenup())
                    .field("ready", &self.ready())
                    .field("readynext", &self.readynext())
                    .field("accesserror", &self.accesserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ wokenup: {=bool:?}, ready: {=bool:?}, readynext: {=bool:?}, accesserror: {=bool:?} }}" , self . wokenup () , self . ready () , self . readynext () , self . accesserror ())
            }
        }
        #[doc = "Low power mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lowpowerconfig(pub u32);
        impl Lowpowerconfig {
            #[doc = "RRAM low power mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "RRAM low power mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Lowpowerconfig {
            #[inline(always)]
            fn default() -> Lowpowerconfig {
                Lowpowerconfig(0)
            }
        }
        impl core::fmt::Debug for Lowpowerconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lowpowerconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lowpowerconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lowpowerconfig {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Power configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PowerConfig(pub u32);
        impl PowerConfig {
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[must_use]
            #[inline(always)]
            pub const fn accesstimeout(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[inline(always)]
            pub const fn set_accesstimeout(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Power on failure warning handling configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn pof(&self) -> super::vals::Pof {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pof::from_bits(val as u8)
            }
            #[doc = "Power on failure warning handling configuration"]
            #[inline(always)]
            pub const fn set_pof(&mut self, val: super::vals::Pof) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PowerConfig {
            #[inline(always)]
            fn default() -> PowerConfig {
                PowerConfig(0)
            }
        }
        impl core::fmt::Debug for PowerConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PowerConfig")
                    .field("accesstimeout", &self.accesstimeout())
                    .field("pof", &self.pof())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PowerConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PowerConfig {{ accesstimeout: {=u16:?}, pof: {:?} }}",
                    self.accesstimeout(),
                    self.pof()
                )
            }
        }
        #[doc = "RRAMC ready status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ready(pub u32);
        impl Ready {
            #[doc = "RRAMC is ready or busy"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC is ready or busy"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ready {
            #[inline(always)]
            fn default() -> Ready {
                Ready(0)
            }
        }
        impl core::fmt::Debug for Ready {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ready")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ready {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ready {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Ready next flag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynext(pub u32);
        impl Readynext {
            #[doc = "RRAMC can accept a new write operation"]
            #[must_use]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC can accept a new write operation"]
            #[inline(always)]
            pub const fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Readynext {
            #[inline(always)]
            fn default() -> Readynext {
                Readynext(0)
            }
        }
        impl core::fmt::Debug for Readynext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynext")
                    .field("readynext", &self.readynext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynext {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Readynext {{ readynext: {=bool:?} }}", self.readynext())
            }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynexttimeout(pub u32);
        impl Readynexttimeout {
            #[doc = "Preload value for waiting for a next write"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Preload value for waiting for a next write"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Enable ready next timeout"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Enable ready next timeout"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Readynexttimeout {
            #[inline(always)]
            fn default() -> Readynexttimeout {
                Readynexttimeout(0)
            }
        }
        impl core::fmt::Debug for Readynexttimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynexttimeout")
                    .field("value", &self.value())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynexttimeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Readynexttimeout {{ value: {=u16:?}, en: {=bool:?} }}",
                    self.value(),
                    self.en()
                )
            }
        }
        #[doc = "Description cluster: Region configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionConfig(pub u32);
        impl RegionConfig {
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Owner ID"]
            #[must_use]
            #[inline(always)]
            pub const fn owner(&self) -> super::vals::Owner {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Owner::from_bits(val as u8)
            }
            #[doc = "Owner ID"]
            #[inline(always)]
            pub const fn set_owner(&mut self, val: super::vals::Owner) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Write-once"]
            #[must_use]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for RegionConfig {
            #[inline(always)]
            fn default() -> RegionConfig {
                RegionConfig(0)
            }
        }
        impl core::fmt::Debug for RegionConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionConfig")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("owner", &self.owner())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RegionConfig {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, owner: {:?}, writeonce: {=bool:?}, lock: {=bool:?}, size: {=u8:?} }}" , self . read () , self . write () , self . execute () , self . secure () , self . owner () , self . writeonce () , self . lock () , self . size ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RramcConfig(pub u32);
        impl RramcConfig {
            #[doc = "Write enable"]
            #[must_use]
            #[inline(always)]
            pub const fn wen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write enable"]
            #[inline(always)]
            pub const fn set_wen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[must_use]
            #[inline(always)]
            pub const fn writebufsize(&self) -> super::vals::Writebufsize {
                let val = (self.0 >> 8usize) & 0x3f;
                super::vals::Writebufsize::from_bits(val as u8)
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[inline(always)]
            pub const fn set_writebufsize(&mut self, val: super::vals::Writebufsize) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val.to_bits() as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for RramcConfig {
            #[inline(always)]
            fn default() -> RramcConfig {
                RramcConfig(0)
            }
        }
        impl core::fmt::Debug for RramcConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RramcConfig")
                    .field("wen", &self.wen())
                    .field("writebufsize", &self.writebufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RramcConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RramcConfig {{ wen: {=bool:?}, writebufsize: {:?} }}",
                    self.wen(),
                    self.writebufsize()
                )
            }
        }
        #[doc = "Internal write-buffer is empty"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writebufempty(pub u32);
        impl Writebufempty {
            #[must_use]
            #[inline(always)]
            pub const fn empty(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Writebufempty {
            #[inline(always)]
            fn default() -> Writebufempty {
                Writebufempty(0)
            }
        }
        impl core::fmt::Debug for Writebufempty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writebufempty")
                    .field("empty", &self.empty())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writebufempty {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Writebufempty {{ empty: {=bool:?} }}", self.empty())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Erase {
            #[doc = "No operation"]
            NO_OPERATION = 0x0,
            #[doc = "Start erase of chip"]
            ERASE = 0x01,
        }
        impl Erase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Erase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Erase {
            #[inline(always)]
            fn from(val: u8) -> Erase {
                Erase::from_bits(val)
            }
        }
        impl From<Erase> for u8 {
            #[inline(always)]
            fn from(val: Erase) -> u8 {
                Erase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "The RRAM is powered Off"]
            POWER_OFF = 0x0,
            #[doc = "The RRAM automatically goes into standby mode while the RRAM is not being accessed"]
            STANDBY = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Owner {
            #[doc = "Owner ID protection is not enforced"]
            NOT_ENFORCED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Owner {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Owner {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Owner {
            #[inline(always)]
            fn from(val: u8) -> Owner {
                Owner::from_bits(val)
            }
        }
        impl From<Owner> for u8 {
            #[inline(always)]
            fn from(val: Owner) -> u8 {
                Owner::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pof {
            #[doc = "Wait until the current RRAM write finishes"]
            WAIT = 0x0,
            #[doc = "Abort the current RRAM write"]
            ABORT = 0x01,
        }
        impl Pof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pof {
            #[inline(always)]
            fn from(val: u8) -> Pof {
                Pof::from_bits(val)
            }
        }
        impl From<Pof> for u8 {
            #[inline(always)]
            fn from(val: Pof) -> u8 {
                Pof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Writebufsize {
            #[doc = "Disable buffering"]
            UNBUFFERED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Writebufsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Writebufsize {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Writebufsize {
            #[inline(always)]
            fn from(val: u8) -> Writebufsize {
                Writebufsize::from_bits(val)
            }
        }
        impl From<Writebufsize> for u8 {
            #[inline(always)]
            fn from(val: Writebufsize) -> u8 {
                Writebufsize::to_bits(val)
            }
        }
    }
}
pub mod saadc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ch {
        ptr: *mut u8,
    }
    unsafe impl Send for Ch {}
    unsafe impl Sync for Ch {}
    impl Ch {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pselp(self) -> crate::common::Reg<regs::Pselp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pseln(self) -> crate::common::Reg<regs::Pseln, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsCh {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsCh {}
    unsafe impl Sync for EventsCh {}
    impl EventsCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Last results is above CH\\[n\\].LIMIT.HIGH"]
        #[inline(always)]
        pub const fn limith(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Last results is below CH\\[n\\].LIMIT.LOW"]
        #[inline(always)]
        pub const fn limitl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishCh {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishCh {}
    unsafe impl Sync for PublishCh {}
    impl PublishCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITH"]
        #[inline(always)]
        pub const fn limith(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITL"]
        #[inline(always)]
        pub const fn limitl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "RESULT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Result {
        ptr: *mut u8,
    }
    unsafe impl Send for Result {}
    unsafe impl Sync for Result {}
    impl Result {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of buffer bytes to transfer. Note that one sample is two bytes."]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Analog to Digital Converter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Saadc {
        ptr: *mut u8,
    }
    unsafe impl Send for Saadc {}
    unsafe impl Sync for Saadc {}
    impl Saadc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the ADC and prepare the result buffer in RAM"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Take one ADC sample, if scan is enabled all channels are sampled. This task requires that SAADC has started, i.e. EVENTS_STARTED was set and EVENTS_STOPPED was not."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Stop the ADC and terminate any on-going conversion"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Starts offset auto-calibration"]
        #[inline(always)]
        pub const fn tasks_calibrateoffset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CALIBRATEOFFSET"]
        #[inline(always)]
        pub const fn subscribe_calibrateoffset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "The ADC DMA has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "The ADC has filled up the Result buffer"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM."]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "A result is ready to get transferred to RAM."]
        #[inline(always)]
        pub const fn events_resultdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Calibration is complete"]
        #[inline(always)]
        pub const fn events_calibratedone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "The ADC DMA has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_ch(self, n: usize) -> EventsCh {
            assert!(n < 8usize);
            unsafe { EventsCh::from_ptr(self.ptr.wrapping_add(0x0118usize + n * 8usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event RESULTDONE"]
        #[inline(always)]
        pub const fn publish_resultdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event CALIBRATEDONE"]
        #[inline(always)]
        pub const fn publish_calibratedone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_ch(self, n: usize) -> PublishCh {
            assert!(n < 8usize);
            unsafe { PublishCh::from_ptr(self.ptr.wrapping_add(0x0198usize + n * 8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trim(self) -> Trim {
            unsafe { Trim::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Enable or disable ADC"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> Ch {
            assert!(n < 8usize);
            unsafe { Ch::from_ptr(self.ptr.wrapping_add(0x0510usize + n * 16usize) as _) }
        }
        #[doc = "Enable burst mode"]
        #[inline(always)]
        pub const fn burst(self) -> crate::common::Reg<regs::Burst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05e8usize) as _) }
        }
        #[doc = "Resolution configuration"]
        #[inline(always)]
        pub const fn resolution(self) -> crate::common::Reg<regs::Resolution, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f0usize) as _) }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN unless burst is enabled. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[inline(always)]
        pub const fn oversample(self) -> crate::common::Reg<regs::Oversample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f4usize) as _) }
        }
        #[doc = "Configures the sampling rate for either task-triggered or continuous operation using a local timer"]
        #[inline(always)]
        pub const fn samplerate(self) -> crate::common::Reg<regs::Samplerate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f8usize) as _) }
        }
        #[doc = "RESULT EasyDMA channel"]
        #[inline(always)]
        pub const fn result(self) -> Result {
            unsafe { Result::from_ptr(self.ptr.wrapping_add(0x0628usize) as _) }
        }
        #[doc = "SAADC provides two operational noise shaping modes (one that prioritizes higher bandwith, while the other prioritizes higher accuracy) that allow trade-offs between ADC resolution, power consumption, and signal bandwidth."]
        #[inline(always)]
        pub const fn noiseshape(self) -> crate::common::Reg<regs::Noiseshape, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0654usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trim {
        ptr: *mut u8,
    }
    unsafe impl Send for Trim {}
    unsafe impl Sync for Trim {}
    impl Trim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[inline(always)]
        pub const fn lincalcoeff(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Lincalcoeff, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Enable burst mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Burst(pub u32);
        impl Burst {
            #[doc = "Enable burst mode"]
            #[must_use]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable burst mode"]
            #[inline(always)]
            pub const fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Burst {
            #[inline(always)]
            fn default() -> Burst {
                Burst(0)
            }
        }
        impl core::fmt::Debug for Burst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Burst")
                    .field("burst", &self.burst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Burst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Burst {{ burst: {=bool:?} }}", self.burst())
            }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable chopping"]
            #[must_use]
            #[inline(always)]
            pub const fn chopping(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable chopping"]
            #[inline(always)]
            pub const fn set_chopping(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Gain control"]
            #[must_use]
            #[inline(always)]
            pub const fn gain(&self) -> super::vals::Gain {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Gain control"]
            #[inline(always)]
            pub const fn set_gain(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Reference control"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference control"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable differential mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::ConfigMode {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::ConfigMode::from_bits(val as u8)
            }
            #[doc = "Enable differential mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::ConfigMode) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[must_use]
            #[inline(always)]
            pub const fn tacq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[inline(always)]
            pub const fn set_tacq(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[must_use]
            #[inline(always)]
            pub const fn tconv(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x07;
                val as u8
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[inline(always)]
            pub const fn set_tconv(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("chopping", &self.chopping())
                    .field("gain", &self.gain())
                    .field("refsel", &self.refsel())
                    .field("mode", &self.mode())
                    .field("tacq", &self.tacq())
                    .field("tconv", &self.tconv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ chopping: {=bool:?}, gain: {:?}, refsel: {:?}, mode: {:?}, tacq: {=u16:?}, tconv: {=u8:?} }}" , self . chopping () , self . gain () , self . refsel () , self . mode () , self . tacq () , self . tconv ())
            }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Enable or disable ADC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable ADC"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable ADC"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[must_use]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn resultdone(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[inline(always)]
            pub const fn set_resultdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn calibratedone(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[inline(always)]
            pub const fn set_calibratedone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimith(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[inline(always)]
            pub const fn set_chlimith(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimitl(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[inline(always)]
            pub const fn set_chlimitl(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("end", &self.end())
                    .field("done", &self.done())
                    .field("resultdone", &self.resultdone())
                    .field("calibratedone", &self.calibratedone())
                    .field("stopped", &self.stopped())
                    .field("chlimith[0]", &self.chlimith(0usize))
                    .field("chlimith[1]", &self.chlimith(1usize))
                    .field("chlimith[2]", &self.chlimith(2usize))
                    .field("chlimith[3]", &self.chlimith(3usize))
                    .field("chlimith[4]", &self.chlimith(4usize))
                    .field("chlimith[5]", &self.chlimith(5usize))
                    .field("chlimith[6]", &self.chlimith(6usize))
                    .field("chlimith[7]", &self.chlimith(7usize))
                    .field("chlimitl[0]", &self.chlimitl(0usize))
                    .field("chlimitl[1]", &self.chlimitl(1usize))
                    .field("chlimitl[2]", &self.chlimitl(2usize))
                    .field("chlimitl[3]", &self.chlimitl(3usize))
                    .field("chlimitl[4]", &self.chlimitl(4usize))
                    .field("chlimitl[5]", &self.chlimitl(5usize))
                    .field("chlimitl[6]", &self.chlimitl(6usize))
                    .field("chlimitl[7]", &self.chlimitl(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, end: {=bool:?}, done: {=bool:?}, resultdone: {=bool:?}, calibratedone: {=bool:?}, stopped: {=bool:?}, chlimith[0]: {=bool:?}, chlimith[1]: {=bool:?}, chlimith[2]: {=bool:?}, chlimith[3]: {=bool:?}, chlimith[4]: {=bool:?}, chlimith[5]: {=bool:?}, chlimith[6]: {=bool:?}, chlimith[7]: {=bool:?}, chlimitl[0]: {=bool:?}, chlimitl[1]: {=bool:?}, chlimitl[2]: {=bool:?}, chlimitl[3]: {=bool:?}, chlimitl[4]: {=bool:?}, chlimitl[5]: {=bool:?}, chlimitl[6]: {=bool:?}, chlimitl[7]: {=bool:?} }}" , self . started () , self . end () , self . done () , self . resultdone () , self . calibratedone () , self . stopped () , self . chlimith (0usize) , self . chlimith (1usize) , self . chlimith (2usize) , self . chlimith (3usize) , self . chlimith (4usize) , self . chlimith (5usize) , self . chlimith (6usize) , self . chlimith (7usize) , self . chlimitl (0usize) , self . chlimitl (1usize) , self . chlimitl (2usize) , self . chlimitl (3usize) , self . chlimitl (4usize) , self . chlimitl (5usize) , self . chlimitl (6usize) , self . chlimitl (7usize))
            }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "Low level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Low level limit"]
            #[inline(always)]
            pub const fn set_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "High level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn high(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "High level limit"]
            #[inline(always)]
            pub const fn set_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("low", &self.low())
                    .field("high", &self.high())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Limit {{ low: {=u16:?}, high: {=u16:?} }}",
                    self.low(),
                    self.high()
                )
            }
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lincalcoeff(pub u32);
        impl Lincalcoeff {
            #[doc = "value"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "value"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Lincalcoeff {
            #[inline(always)]
            fn default() -> Lincalcoeff {
                Lincalcoeff(0)
            }
        }
        impl core::fmt::Debug for Lincalcoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lincalcoeff")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lincalcoeff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lincalcoeff {{ val: {=u16:?} }}", self.val())
            }
        }
        #[doc = "Maximum number of buffer bytes to transfer. Note that one sample is two bytes."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of buffer bytes to transfer. Note that one sample is two bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum number of buffer bytes to transfer. Note that one sample is two bytes."]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "SAADC provides two operational noise shaping modes (one that prioritizes higher bandwith, while the other prioritizes higher accuracy) that allow trade-offs between ADC resolution, power consumption, and signal bandwidth."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Noiseshape(pub u32);
        impl Noiseshape {
            #[doc = "Noise shaping configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn noiseshape(&self) -> super::vals::Noiseshape {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Noiseshape::from_bits(val as u8)
            }
            #[doc = "Noise shaping configuration"]
            #[inline(always)]
            pub const fn set_noiseshape(&mut self, val: super::vals::Noiseshape) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Noiseshape {
            #[inline(always)]
            fn default() -> Noiseshape {
                Noiseshape(0)
            }
        }
        impl core::fmt::Debug for Noiseshape {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Noiseshape")
                    .field("noiseshape", &self.noiseshape())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Noiseshape {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Noiseshape {{ noiseshape: {:?} }}", self.noiseshape())
            }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN unless burst is enabled. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oversample(pub u32);
        impl Oversample {
            #[doc = "Oversample control"]
            #[must_use]
            #[inline(always)]
            pub const fn oversample(&self) -> super::vals::Oversample {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Oversample::from_bits(val as u8)
            }
            #[doc = "Oversample control"]
            #[inline(always)]
            pub const fn set_oversample(&mut self, val: super::vals::Oversample) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Oversample {
            #[inline(always)]
            fn default() -> Oversample {
                Oversample(0)
            }
        }
        impl core::fmt::Debug for Oversample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oversample")
                    .field("oversample", &self.oversample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oversample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oversample {{ oversample: {:?} }}", self.oversample())
            }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pseln(pub u32);
        impl Pseln {
            #[doc = "GPIO pin selection."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Internal input selection for analog negative input when CH\\[n\\].PSELN.CONNECT = Internal"]
            #[must_use]
            #[inline(always)]
            pub const fn internal(&self) -> super::vals::PselnInternal {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::PselnInternal::from_bits(val as u8)
            }
            #[doc = "Internal input selection for analog negative input when CH\\[n\\].PSELN.CONNECT = Internal"]
            #[inline(always)]
            pub const fn set_internal(&mut self, val: super::vals::PselnInternal) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselnConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselnConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::PselnConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pseln {
            #[inline(always)]
            fn default() -> Pseln {
                Pseln(0)
            }
        }
        impl core::fmt::Debug for Pseln {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pseln")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("internal", &self.internal())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pseln {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pseln {{ pin: {=u8:?}, port: {=u8:?}, internal: {:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.internal(),
                    self.connect()
                )
            }
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pselp(pub u32);
        impl Pselp {
            #[doc = "GPIO pin selection."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[must_use]
            #[inline(always)]
            pub const fn internal(&self) -> super::vals::PselpInternal {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::PselpInternal::from_bits(val as u8)
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[inline(always)]
            pub const fn set_internal(&mut self, val: super::vals::PselpInternal) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselpConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselpConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::PselpConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pselp {
            #[inline(always)]
            fn default() -> Pselp {
                Pselp(0)
            }
        }
        impl core::fmt::Debug for Pselp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pselp")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("internal", &self.internal())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pselp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pselp {{ pin: {=u8:?}, port: {=u8:?}, internal: {:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.internal(),
                    self.connect()
                )
            }
        }
        #[doc = "Resolution configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resolution(pub u32);
        impl Resolution {
            #[doc = "Set the resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> super::vals::Val {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Val::from_bits(val as u8)
            }
            #[doc = "Set the resolution"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: super::vals::Val) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Resolution {
            #[inline(always)]
            fn default() -> Resolution {
                Resolution(0)
            }
        }
        impl core::fmt::Debug for Resolution {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resolution")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resolution {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Resolution {{ val: {:?} }}", self.val())
            }
        }
        #[doc = "Configures the sampling rate for either task-triggered or continuous operation using a local timer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Samplerate(pub u32);
        impl Samplerate {
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[must_use]
            #[inline(always)]
            pub const fn cc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[inline(always)]
            pub const fn set_cc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Select mode for sample rate control"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::SamplerateMode {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::SamplerateMode::from_bits(val as u8)
            }
            #[doc = "Select mode for sample rate control"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::SamplerateMode) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Samplerate {
            #[inline(always)]
            fn default() -> Samplerate {
                Samplerate(0)
            }
        }
        impl core::fmt::Debug for Samplerate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Samplerate")
                    .field("cc", &self.cc())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Samplerate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Samplerate {{ cc: {=u16:?}, mode: {:?} }}",
                    self.cc(),
                    self.mode()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event DONE and task SAMPLE"]
            #[must_use]
            #[inline(always)]
            pub const fn done_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DONE and task SAMPLE"]
            #[inline(always)]
            pub const fn set_done_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("done_sample", &self.done_sample())
                    .field("end_start", &self.end_start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Shorts {{ done_sample: {=bool:?}, end_start: {=bool:?} }}",
                    self.done_sample(),
                    self.end_start()
                )
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "Status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigMode {
            #[doc = "Single ended, PSELN will be ignored, negative input to ADC shorted to GND"]
            SE = 0x0,
            #[doc = "Differential"]
            DIFF = 0x01,
        }
        impl ConfigMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigMode {
            #[inline(always)]
            fn from(val: u8) -> ConfigMode {
                ConfigMode::from_bits(val)
            }
        }
        impl From<ConfigMode> for u8 {
            #[inline(always)]
            fn from(val: ConfigMode) -> u8 {
                ConfigMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain {
            #[doc = "2"]
            GAIN2 = 0x0,
            #[doc = "1"]
            GAIN1 = 0x01,
            #[doc = "2/3"]
            GAIN2_3 = 0x02,
            #[doc = "2/4"]
            GAIN2_4 = 0x03,
            #[doc = "2/5"]
            GAIN2_5 = 0x04,
            #[doc = "2/6"]
            GAIN2_6 = 0x05,
            #[doc = "2/7"]
            GAIN2_7 = 0x06,
            #[doc = "2/8"]
            GAIN2_8 = 0x07,
        }
        impl Gain {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Noiseshape {
            #[doc = "Disable noiseshaping. Configurable oversampling."]
            DISABLE = 0x0,
            #[doc = "Noiseshaping and decimating. Larger passband. Decimation ratio 8, 125 kS/s, with resulting bandwidth around 45 kHz. Takes precedence over the OVERSAMPLING register."]
            NS1 = 0x01,
            #[doc = "Noiseshaping and decimating. Smaller passband. Decimation ratio 32, 31.25 kS/s, with resulting bandwidth around 7 kHz. Takes precedence over the OVERSAMPLING register."]
            NS2 = 0x02,
            #[doc = "Noise shaping with oversampling set by the OVERSAMPLE register"]
            NS3 = 0x03,
        }
        impl Noiseshape {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Noiseshape {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Noiseshape {
            #[inline(always)]
            fn from(val: u8) -> Noiseshape {
                Noiseshape::from_bits(val)
            }
        }
        impl From<Noiseshape> for u8 {
            #[inline(always)]
            fn from(val: Noiseshape) -> u8 {
                Noiseshape::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oversample {
            #[doc = "Bypass oversampling"]
            BYPASS = 0x0,
            #[doc = "Oversample 2x"]
            OVER2X = 0x01,
            #[doc = "Oversample 4x"]
            OVER4X = 0x02,
            #[doc = "Oversample 8x"]
            OVER8X = 0x03,
            #[doc = "Oversample 16x"]
            OVER16X = 0x04,
            #[doc = "Oversample 32x"]
            OVER32X = 0x05,
            #[doc = "Oversample 64x"]
            OVER64X = 0x06,
            #[doc = "Oversample 128x"]
            OVER128X = 0x07,
            #[doc = "Oversample 256x"]
            OVER256X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Oversample {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oversample {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oversample {
            #[inline(always)]
            fn from(val: u8) -> Oversample {
                Oversample::from_bits(val)
            }
        }
        impl From<Oversample> for u8 {
            #[inline(always)]
            fn from(val: Oversample) -> u8 {
                Oversample::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselnConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselnConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselnConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselnConnect {
            #[inline(always)]
            fn from(val: u8) -> PselnConnect {
                PselnConnect::from_bits(val)
            }
        }
        impl From<PselnConnect> for u8 {
            #[inline(always)]
            fn from(val: PselnConnect) -> u8 {
                PselnConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselnInternal {
            #[doc = "Connected to the internal 0.9V analog supply rail"]
            AVDD = 0x0,
            #[doc = "Connected to the internal 0.9V digital supply rail"]
            DVDD = 0x01,
            #[doc = "Connected to VDD"]
            VDD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselnInternal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselnInternal {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselnInternal {
            #[inline(always)]
            fn from(val: u8) -> PselnInternal {
                PselnInternal::from_bits(val)
            }
        }
        impl From<PselnInternal> for u8 {
            #[inline(always)]
            fn from(val: PselnInternal) -> u8 {
                PselnInternal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselpConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            #[doc = "Selects internal inputs."]
            INTERNAL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselpConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselpConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselpConnect {
            #[inline(always)]
            fn from(val: u8) -> PselpConnect {
                PselpConnect::from_bits(val)
            }
        }
        impl From<PselpConnect> for u8 {
            #[inline(always)]
            fn from(val: PselpConnect) -> u8 {
                PselpConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselpInternal {
            #[doc = "Connected to the internal 0.9V analog supply rail"]
            AVDD = 0x0,
            #[doc = "Connected to the internal 0.9V digital supply rail"]
            DVDD = 0x01,
            #[doc = "Connected to VDD"]
            VDD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselpInternal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselpInternal {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselpInternal {
            #[inline(always)]
            fn from(val: u8) -> PselpInternal {
                PselpInternal::from_bits(val)
            }
        }
        impl From<PselpInternal> for u8 {
            #[inline(always)]
            fn from(val: PselpInternal) -> u8 {
                PselpInternal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "Internal reference (0.9 V)"]
            INTERNAL = 0x0,
            #[doc = "External reference given at PADC_EXT_REF_1V2"]
            EXTERNAL = 0x01,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SamplerateMode {
            #[doc = "Rate is controlled from SAMPLE task"]
            TASK = 0x0,
            #[doc = "Rate is controlled from local timer (use CC to control the rate)"]
            TIMERS = 0x01,
        }
        impl SamplerateMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SamplerateMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SamplerateMode {
            #[inline(always)]
            fn from(val: u8) -> SamplerateMode {
                SamplerateMode::from_bits(val)
            }
        }
        impl From<SamplerateMode> for u8 {
            #[inline(always)]
            fn from(val: SamplerateMode) -> u8 {
                SamplerateMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "ADC is ready. No on-going conversion."]
            READY = 0x0,
            #[doc = "ADC is busy. Conversion is in progress."]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Val {
            #[doc = "8 bit"]
            _8BIT = 0x0,
            #[doc = "10 bit"]
            _10BIT = 0x01,
            #[doc = "12 bit"]
            _12BIT = 0x02,
            #[doc = "14 bit"]
            _14BIT = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Val {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Val {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Val {
            #[inline(always)]
            fn from(val: u8) -> Val {
                Val::from_bits(val)
            }
        }
        impl From<Val> for u8 {
            #[inline(always)]
            fn from(val: Val) -> u8 {
                Val::to_bits(val)
            }
        }
    }
}
pub mod shared {
    pub mod regs {
        #[doc = "Pin number configuration for PDM CLK signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Pin number"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.connect()
                )
            }
        }
        #[doc = "Publish configuration for event END"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Publish(pub u32);
        impl Publish {
            #[doc = "DPPI channel that event END will publish to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that event END will publish to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Publish {
            #[inline(always)]
            fn default() -> Publish {
                Publish(0)
            }
        }
        impl core::fmt::Debug for Publish {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Publish")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Publish {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Publish {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
        #[doc = "Subscribe configuration for task START"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Subscribe(pub u32);
        impl Subscribe {
            #[doc = "DPPI channel that task START will subscribe to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that task START will subscribe to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Subscribe {
            #[inline(always)]
            fn default() -> Subscribe {
                Subscribe(0)
            }
        }
        impl core::fmt::Debug for Subscribe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Subscribe")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Subscribe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Subscribe {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Connect {
            #[doc = "Connect"]
            CONNECTED = 0x0,
            #[doc = "Disconnect"]
            DISCONNECTED = 0x01,
        }
        impl Connect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Connect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Connect {
            #[inline(always)]
            fn from(val: u8) -> Connect {
                Connect::from_bits(val)
            }
        }
        impl From<Connect> for u8 {
            #[inline(always)]
            fn from(val: Connect) -> u8 {
                Connect::to_bits(val)
            }
        }
    }
}
pub mod sicr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Sicr {}
    unsafe impl Sync for Sicr {}
    impl Sicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
}
pub mod spim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iftiming {
        ptr: *mut u8,
    }
    unsafe impl Send for Iftiming {}
    unsafe impl Sync for Iftiming {}
    impl Iftiming {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Sample delay for input serial data on SDI"]
        #[inline(always)]
        pub const fn rxdelay(self) -> crate::common::Reg<regs::Rxdelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[inline(always)]
        pub const fn csndur(self) -> crate::common::Reg<regs::Csndur, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDO signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for SDI signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for DCX signal"]
        #[inline(always)]
        pub const fn dcx(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Pin select for CSN"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spim {
        ptr: *mut u8,
    }
    unsafe impl Send for Spim {}
    unsafe impl Sync for Spim {}
    impl Spim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start SPI transaction"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop SPI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Suspend SPI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Resume SPI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "SPI transaction has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "SPI transaction has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "End of RXD buffer and TXD buffer reached"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable SPIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x052cusize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpimConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0554usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn iftiming(self) -> Iftiming {
            unsafe { Iftiming::from_ptr(self.ptr.wrapping_add(0x05acusize) as _) }
        }
        #[doc = "DCX configuration"]
        #[inline(always)]
        pub const fn dcxcnt(self) -> crate::common::Reg<regs::Dcxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05b4usize) as _) }
        }
        #[doc = "Polarity of CSN output"]
        #[inline(always)]
        pub const fn csnpol(self) -> crate::common::Reg<regs::Csnpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05b8usize) as _) }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csndur(pub u32);
        impl Csndur {
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[must_use]
            #[inline(always)]
            pub const fn csndur(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[inline(always)]
            pub const fn set_csndur(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Csndur {
            #[inline(always)]
            fn default() -> Csndur {
                Csndur(0)
            }
        }
        impl core::fmt::Debug for Csndur {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csndur")
                    .field("csndur", &self.csndur())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csndur {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Csndur {{ csndur: {=u8:?} }}", self.csndur())
            }
        }
        #[doc = "Polarity of CSN output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csnpol(pub u32);
        impl Csnpol {
            #[doc = "Polarity of CSN output"]
            #[must_use]
            #[inline(always)]
            pub const fn csnpol_0(&self) -> super::vals::Csnpol0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csnpol0::from_bits(val as u8)
            }
            #[doc = "Polarity of CSN output"]
            #[inline(always)]
            pub const fn set_csnpol_0(&mut self, val: super::vals::Csnpol0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Csnpol {
            #[inline(always)]
            fn default() -> Csnpol {
                Csnpol(0)
            }
        }
        impl core::fmt::Debug for Csnpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csnpol")
                    .field("csnpol_0", &self.csnpol_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csnpol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Csnpol {{ csnpol_0: {:?} }}", self.csnpol_0())
            }
        }
        #[doc = "DCX configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcxcnt(pub u32);
        impl Dcxcnt {
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn dcxcnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[inline(always)]
            pub const fn set_dcxcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Dcxcnt {
            #[inline(always)]
            fn default() -> Dcxcnt {
                Dcxcnt(0)
            }
        }
        impl core::fmt::Debug for Dcxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcxcnt")
                    .field("dcxcnt", &self.dcxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dcxcnt {{ dcxcnt: {=u8:?} }}", self.dcxcnt())
            }
        }
        #[doc = "Enable SPIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch[0]", &self.dmarxmatch(0usize))
                    .field("dmarxmatch[1]", &self.dmarxmatch(1usize))
                    .field("dmarxmatch[2]", &self.dmarxmatch(2usize))
                    .field("dmarxmatch[3]", &self.dmarxmatch(3usize))
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, stopped: {=bool:?}, end: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch[0]: {=bool:?}, dmarxmatch[1]: {=bool:?}, dmarxmatch[2]: {=bool:?}, dmarxmatch[3]: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . started () , self . stopped () , self . end () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch (0usize) , self . dmarxmatch (1usize) , self . dmarxmatch (2usize) , self . dmarxmatch (3usize) , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Core clock to SCK divisor"]
            #[must_use]
            #[inline(always)]
            pub const fn divisor(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Core clock to SCK divisor"]
            #[inline(always)]
            pub const fn set_divisor(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("divisor", &self.divisor())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ divisor: {=u8:?} }}", self.divisor())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxList(pub u32);
        impl RxList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::RxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::RxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for RxList {
            #[inline(always)]
            fn default() -> RxList {
                RxList(0)
            }
        }
        impl core::fmt::Debug for RxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxList {{ type_: {:?} }}", self.type_())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Sample delay for input serial data on SDI"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxdelay(pub u32);
        impl Rxdelay {
            #[doc = "Sample delay for input serial data on SDI. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[must_use]
            #[inline(always)]
            pub const fn rxdelay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Sample delay for input serial data on SDI. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[inline(always)]
            pub const fn set_rxdelay(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxdelay {
            #[inline(always)]
            fn default() -> Rxdelay {
                Rxdelay(0)
            }
        }
        impl core::fmt::Debug for Rxdelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxdelay")
                    .field("rxdelay", &self.rxdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxdelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxdelay {{ rxdelay: {=u8:?} }}", self.rxdelay())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_start", &self.end_start())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ end_start: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . end_start () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpimConfig(pub u32);
        impl SpimConfig {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpimConfig {
            #[inline(always)]
            fn default() -> SpimConfig {
                SpimConfig(0)
            }
        }
        impl core::fmt::Debug for SpimConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpimConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpimConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpimConfig {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxList(pub u32);
        impl TxList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::TxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::TxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::TxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for TxList {
            #[inline(always)]
            fn default() -> TxList {
                TxList(0)
            }
        }
        impl core::fmt::Debug for TxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxList {{ type_: {:?} }}", self.type_())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csnpol0 {
            #[doc = "Active low (idle state high)"]
            LOW = 0x0,
            #[doc = "Active high (idle state low)"]
            HIGH = 0x01,
        }
        impl Csnpol0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csnpol0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csnpol0 {
            #[inline(always)]
            fn from(val: u8) -> Csnpol0 {
                Csnpol0::from_bits(val)
            }
        }
        impl From<Csnpol0> for u8 {
            #[inline(always)]
            fn from(val: Csnpol0) -> u8 {
                Csnpol0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Enable SPIM"]
            ENABLED = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxListType {
            #[inline(always)]
            fn from(val: u8) -> RxListType {
                RxListType::from_bits(val)
            }
        }
        impl From<RxListType> for u8 {
            #[inline(always)]
            fn from(val: RxListType) -> u8 {
                RxListType::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl TxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxListType {
            #[inline(always)]
            fn from(val: u8) -> TxListType {
                TxListType::from_bits(val)
            }
        }
        impl From<TxListType> for u8 {
            #[inline(always)]
            fn from(val: TxListType) -> u8 {
                TxListType::to_bits(val)
            }
        }
    }
}
pub mod spis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for SDI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for CSN signal"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "SPI Slave 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spis {
        ptr: *mut u8,
    }
    unsafe impl Send for Spis {}
    unsafe impl Sync for Spis {}
    impl Spis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Acquire SPI semaphore"]
        #[inline(always)]
        pub const fn tasks_acquire(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Release SPI semaphore, enabling the SPI slave to acquire it"]
        #[inline(always)]
        pub const fn tasks_release(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACQUIRE"]
        #[inline(always)]
        pub const fn subscribe_acquire(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task RELEASE"]
        #[inline(always)]
        pub const fn subscribe_release(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "Granted transaction completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Semaphore acquired"]
        #[inline(always)]
        pub const fn events_acquired(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACQUIRED"]
        #[inline(always)]
        pub const fn publish_acquired(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Semaphore status register"]
        #[inline(always)]
        pub const fn semstat(self) -> crate::common::Reg<regs::Semstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Status from last transaction"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Enable SPI slave"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0554usize) as _) }
        }
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[inline(always)]
        pub const fn def(self) -> crate::common::Reg<regs::Def, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x055cusize) as _) }
        }
        #[doc = "Over-read character"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Def(pub u32);
        impl Def {
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[must_use]
            #[inline(always)]
            pub const fn def(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[inline(always)]
            pub const fn set_def(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Def {
            #[inline(always)]
            fn default() -> Def {
                Def(0)
            }
        }
        impl core::fmt::Debug for Def {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Def").field("def", &self.def()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Def {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Def {{ def: {=u8:?} }}", self.def())
            }
        }
        #[doc = "Enable SPI slave"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPI slave"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPI slave"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[must_use]
            #[inline(always)]
            pub const fn acquired(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[inline(always)]
            pub const fn set_acquired(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("acquired", &self.acquired())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch[0]", &self.dmarxmatch(0usize))
                    .field("dmarxmatch[1]", &self.dmarxmatch(1usize))
                    .field("dmarxmatch[2]", &self.dmarxmatch(2usize))
                    .field("dmarxmatch[3]", &self.dmarxmatch(3usize))
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ end: {=bool:?}, acquired: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch[0]: {=bool:?}, dmarxmatch[1]: {=bool:?}, dmarxmatch[2]: {=bool:?}, dmarxmatch[3]: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . end () , self . acquired () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch (0usize) , self . dmarxmatch (1usize) , self . dmarxmatch (2usize) , self . dmarxmatch (3usize) , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Over-read character"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Semaphore status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semstat(pub u32);
        impl Semstat {
            #[doc = "Semaphore status"]
            #[must_use]
            #[inline(always)]
            pub const fn semstat(&self) -> super::vals::Semstat {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Semstat::from_bits(val as u8)
            }
            #[doc = "Semaphore status"]
            #[inline(always)]
            pub const fn set_semstat(&mut self, val: super::vals::Semstat) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Semstat {
            #[inline(always)]
            fn default() -> Semstat {
                Semstat(0)
            }
        }
        impl core::fmt::Debug for Semstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semstat")
                    .field("semstat", &self.semstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Semstat {{ semstat: {:?} }}", self.semstat())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[must_use]
            #[inline(always)]
            pub const fn end_acquire(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[inline(always)]
            pub const fn set_end_acquire(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_acquire", &self.end_acquire())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ end_acquire: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . end_acquire () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpisConfig(pub u32);
        impl SpisConfig {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpisConfig {
            #[inline(always)]
            fn default() -> SpisConfig {
                SpisConfig(0)
            }
        }
        impl core::fmt::Debug for SpisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpisConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpisConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpisConfig {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Status from last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("overread", &self.overread())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ overread: {=bool:?}, overflow: {=bool:?} }}",
                    self.overread(),
                    self.overflow()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPI slave"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable SPI slave"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Semstat {
            #[doc = "Semaphore is free"]
            FREE = 0x0,
            #[doc = "Semaphore is assigned to CPU"]
            CPU = 0x01,
            #[doc = "Semaphore is assigned to SPI slave"]
            SPIS = 0x02,
            #[doc = "Semaphore is assigned to SPI but a handover to the CPU is pending"]
            CPUPENDING = 0x03,
        }
        impl Semstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Semstat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Semstat {
            #[inline(always)]
            fn from(val: u8) -> Semstat {
                Semstat::from_bits(val)
            }
        }
        impl From<Semstat> for u8 {
            #[inline(always)]
            fn from(val: Semstat) -> u8 {
                Semstat::to_bits(val)
            }
        }
    }
}
pub mod spu {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Security configuration for channel n of DPPIC"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::DppicCh, crate::common::RW> {
            assert!(n < 24usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Security configuration for channel group n of DPPIC"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Feature {
        ptr: *mut u8,
    }
    unsafe impl Send for Feature {}
    unsafe impl Sync for Feature {}
    impl Feature {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dppic(self) -> Dppic {
            unsafe { Dppic::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpiote(self, n: usize) -> Gpiote {
            assert!(n < 2usize);
            unsafe { Gpiote::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 64usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpio(self, n: usize) -> Gpio {
            assert!(n < 4usize);
            unsafe { Gpio::from_ptr(self.ptr.wrapping_add(0x0200usize + n * 128usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn grtc(self) -> Grtc {
            unsafe { Grtc::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Security configuration for GPIO\\[n\\] PIN\\[o\\]"]
        #[inline(always)]
        pub const fn pin(self, n: usize) -> crate::common::Reg<regs::Pin, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Security configuration for channel o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::GpioteCh, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Security configuration for interrupt o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GpioteInterrupt, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Security configuration for CC n of GRTC"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 24usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Security Configuration for PWMCONFIG of GRTC"]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x74usize) as _) }
        }
        #[doc = "Security configuration for CLKOUT/CLKCFG of GRTC"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<regs::Clk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x78usize) as _) }
        }
        #[doc = "Security configuration for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[inline(always)]
        pub const fn syscounter(self) -> crate::common::Reg<regs::Syscounter, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x7cusize) as _) }
        }
        #[doc = "Description collection: Security configuration for interrupt n of GRTC"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GrtcInterrupt, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periph {
        ptr: *mut u8,
    }
    unsafe impl Send for Periph {}
    unsafe impl Sync for Periph {}
    impl Periph {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periphaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Periphaccerr {}
    unsafe impl Sync for Periphaccerr {}
    impl Periphaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the transaction that caused first error."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "System protection unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spu {
        ptr: *mut u8,
    }
    unsafe impl Send for Spu {}
    unsafe impl Sync for Spu {}
    impl Spu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A security violation has been detected on one or several peripherals"]
        #[inline(always)]
        pub const fn events_periphaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periphaccerr(self) -> Periphaccerr {
            unsafe { Periphaccerr::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periph(self, n: usize) -> Periph {
            assert!(n < 64usize);
            unsafe { Periph::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn feature(self) -> Feature {
            unsafe { Feature::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address of the transaction that caused first error."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u16:?} }}", self.address())
            }
        }
        #[doc = "Description collection: Security configuration for CC n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cc {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Security configuration for channel group n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Chg {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Security configuration for CLKOUT/CLKCFG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clk(pub u32);
        impl Clk {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Clk {
            #[inline(always)]
            fn default() -> Clk {
                Clk(0)
            }
        }
        impl core::fmt::Debug for Clk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clk")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clk {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Security configuration for channel n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DppicCh(pub u32);
        impl DppicCh {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for DppicCh {
            #[inline(always)]
            fn default() -> DppicCh {
                DppicCh(0)
            }
        }
        impl core::fmt::Debug for DppicCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DppicCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DppicCh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DppicCh {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Security configuration for channel o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteCh(pub u32);
        impl GpioteCh {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteCh {
            #[inline(always)]
            fn default() -> GpioteCh {
                GpioteCh(0)
            }
        }
        impl core::fmt::Debug for GpioteCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteCh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioteCh {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Security configuration for interrupt o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteInterrupt(pub u32);
        impl GpioteInterrupt {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteInterrupt {
            #[inline(always)]
            fn default() -> GpioteInterrupt {
                GpioteInterrupt(0)
            }
        }
        impl core::fmt::Debug for GpioteInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteInterrupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioteInterrupt {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Security configuration for interrupt n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GrtcInterrupt(pub u32);
        impl GrtcInterrupt {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GrtcInterrupt {
            #[inline(always)]
            fn default() -> GrtcInterrupt {
                GrtcInterrupt(0)
            }
        }
        impl core::fmt::Debug for GrtcInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GrtcInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GrtcInterrupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GrtcInterrupt {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn periphaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[inline(always)]
            pub const fn set_periphaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("periphaccerr", &self.periphaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ periphaccerr: {=bool:?} }}", self.periphaccerr())
            }
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[must_use]
            #[inline(always)]
            pub const fn securemapping(&self) -> super::vals::Securemapping {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Securemapping::from_bits(val as u8)
            }
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub const fn set_securemapping(&mut self, val: super::vals::Securemapping) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[must_use]
            #[inline(always)]
            pub const fn dma(&self) -> super::vals::Dma {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Dma::from_bits(val as u8)
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[inline(always)]
            pub const fn set_dma(&mut self, val: super::vals::Dma) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Peripheral security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn dmasec(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[inline(always)]
            pub const fn set_dmasec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Register lock"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Register lock"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[inline(always)]
            pub const fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("securemapping", &self.securemapping())
                    .field("dma", &self.dma())
                    .field("secattr", &self.secattr())
                    .field("dmasec", &self.dmasec())
                    .field("lock", &self.lock())
                    .field("present", &self.present())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Perm {{ securemapping: {:?}, dma: {:?}, secattr: {=bool:?}, dmasec: {=bool:?}, lock: {=bool:?}, present: {:?} }}" , self . securemapping () , self . dma () , self . secattr () , self . dmasec () , self . lock () , self . present ())
            }
        }
        #[doc = "Description collection: Security configuration for GPIO\\[n\\] PIN\\[o\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pin(pub u32);
        impl Pin {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pin {
            #[inline(always)]
            fn default() -> Pin {
                Pin(0)
            }
        }
        impl core::fmt::Debug for Pin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pin")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pin {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Security Configuration for PWMCONFIG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwmconfig {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Security configuration for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounter(pub u32);
        impl Syscounter {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Syscounter {
            #[inline(always)]
            fn default() -> Syscounter {
                Syscounter(0)
            }
        }
        impl core::fmt::Debug for Syscounter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounter")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounter {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Syscounter {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dma {
            #[doc = "Peripheral has no DMA capability"]
            NO_DMA = 0x0,
            #[doc = "Peripheral has DMA and DMA transfers always have the same security attribute as assigned to the peripheral"]
            NO_SEPARATE_ATTRIBUTE = 0x01,
            #[doc = "Peripheral has DMA and DMA transfers can have a different security attribute than the one assigned to the peripheral"]
            SEPARATE_ATTRIBUTE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dma {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dma {
            #[inline(always)]
            fn from(val: u8) -> Dma {
                Dma::from_bits(val)
            }
        }
        impl From<Dma> for u8 {
            #[inline(always)]
            fn from(val: Dma) -> u8 {
                Dma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "Peripheral is not present"]
            NOT_PRESENT = 0x0,
            #[doc = "Peripheral is present"]
            IS_PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Securemapping {
            #[doc = "This peripheral is always accessible as a non-secure peripheral"]
            NON_SECURE = 0x0,
            #[doc = "This peripheral is always accessible as a secure peripheral"]
            SECURE = 0x01,
            #[doc = "Non-secure or secure attribute for this peripheral is defined by the PERIPH\\[n\\].PERM register"]
            USER_SELECTABLE = 0x02,
            #[doc = "This peripheral implements the split security mechanism."]
            SPLIT = 0x03,
        }
        impl Securemapping {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Securemapping {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Securemapping {
            #[inline(always)]
            fn from(val: u8) -> Securemapping {
                Securemapping::from_bits(val)
            }
        }
        impl From<Securemapping> for u8 {
            #[inline(always)]
            fn from(val: Securemapping) -> u8 {
                Securemapping::to_bits(val)
            }
        }
    }
}
pub mod tad {
    #[doc = "Trace and debug control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tad {
        ptr: *mut u8,
    }
    unsafe impl Send for Tad {}
    unsafe impl Sync for Tad {}
    impl Tad {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System power-up request"]
        #[inline(always)]
        pub const fn syspwrupreq(self) -> crate::common::Reg<regs::Syspwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Debug power-up request"]
        #[inline(always)]
        pub const fn dbgpwrupreq(self) -> crate::common::Reg<regs::Dbgpwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Trace port speed"]
        #[inline(always)]
        pub const fn traceportspeed(
            self,
        ) -> crate::common::Reg<regs::Traceportspeed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgpwrupreq(pub u32);
        impl Dbgpwrupreq {
            #[doc = "Activate power-up request"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbgpwrupreq {
            #[inline(always)]
            fn default() -> Dbgpwrupreq {
                Dbgpwrupreq(0)
            }
        }
        impl core::fmt::Debug for Dbgpwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgpwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgpwrupreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dbgpwrupreq {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "System power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syspwrupreq(pub u32);
        impl Syspwrupreq {
            #[doc = "Activate power-up request"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Syspwrupreq {
            #[inline(always)]
            fn default() -> Syspwrupreq {
                Syspwrupreq(0)
            }
        }
        impl core::fmt::Debug for Syspwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syspwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syspwrupreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Syspwrupreq {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Trace port speed"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Traceportspeed(pub u32);
        impl Traceportspeed {
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[must_use]
            #[inline(always)]
            pub const fn traceportspeed(&self) -> super::vals::Traceportspeed {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Traceportspeed::from_bits(val as u8)
            }
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[inline(always)]
            pub const fn set_traceportspeed(&mut self, val: super::vals::Traceportspeed) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Traceportspeed {
            #[inline(always)]
            fn default() -> Traceportspeed {
                Traceportspeed(0)
            }
        }
        impl core::fmt::Debug for Traceportspeed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Traceportspeed")
                    .field("traceportspeed", &self.traceportspeed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Traceportspeed {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Traceportspeed {{ traceportspeed: {:?} }}",
                    self.traceportspeed()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Traceportspeed {
            #[doc = "Trace port speed equals CPU clock"]
            DIV1 = 0x0,
            #[doc = "Trace port speed equals CPU clock divided by 2"]
            DIV2 = 0x01,
            #[doc = "Trace port speed equals CPU clock divided by 4"]
            DIV4 = 0x02,
            #[doc = "Trace port speed equals CPU clock divided by 32"]
            DIV32 = 0x03,
        }
        impl Traceportspeed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Traceportspeed {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Traceportspeed {
            #[inline(always)]
            fn from(val: u8) -> Traceportspeed {
                Traceportspeed::from_bits(val)
            }
        }
        impl From<Traceportspeed> for u8 {
            #[inline(always)]
            fn from(val: Traceportspeed) -> u8 {
                Traceportspeed::to_bits(val)
            }
        }
    }
}
pub mod tampc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ap {
        ptr: *mut u8,
    }
    unsafe impl Send for Ap {}
    unsafe impl Sync for Ap {}
    impl Ap {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> ApDbgen {
            unsafe { ApDbgen::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ApDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for ApDbgen {}
    unsafe impl Sync for ApDbgen {}
    impl ApDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain ns access port."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ApDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain ns access port."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ApDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Enable tamper detector from CRACEN."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracentamp {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracentamp {}
    unsafe impl Sync for Cracentamp {}
    impl Cracentamp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::CracentampCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::CracentampStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Domain {
        ptr: *mut u8,
    }
    unsafe impl Send for Domain {}
    unsafe impl Sync for Domain {}
    impl Domain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> DomainDbgen {
            unsafe { DomainDbgen::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn niden(self) -> Niden {
            unsafe { Niden::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spiden(self) -> Spiden {
            unsafe { Spiden::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spniden(self) -> Spniden {
            unsafe { Spniden::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DomainDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for DomainDbgen {}
    unsafe impl Sync for DomainDbgen {}
    impl DomainDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::DomainDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::DomainDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Device erase protection."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for erase protection."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::EraseprotectCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for eraseprotect."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::EraseprotectStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Extreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Extreseten {}
    unsafe impl Sync for Extreseten {}
    impl Extreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ExtresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ExtresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Enable fast domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchfastdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchfastdomain {}
    unsafe impl Sync for Glitchfastdomain {}
    impl Glitchfastdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Enable slow domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchslowdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchslowdomain {}
    unsafe impl Sync for Glitchslowdomain {}
    impl Glitchslowdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Intreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Intreseten {}
    unsafe impl Sync for Intreseten {}
    impl Intreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::IntresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IntresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Niden {
        ptr: *mut u8,
    }
    unsafe impl Send for Niden {}
    unsafe impl Sync for Niden {}
    impl Niden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::NidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::NidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Protect {
        ptr: *mut u8,
    }
    unsafe impl Send for Protect {}
    unsafe impl Sync for Protect {}
    impl Protect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn domain(self, n: usize) -> Domain {
            assert!(n < 1usize);
            unsafe { Domain::from_ptr(self.ptr.wrapping_add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ap(self, n: usize) -> Ap {
            assert!(n < 1usize);
            unsafe { Ap::from_ptr(self.ptr.wrapping_add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Enable active shield detector."]
        #[inline(always)]
        pub const fn activeshield(self) -> ProtectActiveshield {
            unsafe { ProtectActiveshield::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Enable tamper detector from CRACEN."]
        #[inline(always)]
        pub const fn cracentamp(self) -> Cracentamp {
            unsafe { Cracentamp::from_ptr(self.ptr.wrapping_add(0x0438usize) as _) }
        }
        #[doc = "Enable slow domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchslowdomain(self) -> Glitchslowdomain {
            unsafe { Glitchslowdomain::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Enable fast domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchfastdomain(self) -> Glitchfastdomain {
            unsafe { Glitchfastdomain::from_ptr(self.ptr.wrapping_add(0x0448usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
        #[inline(always)]
        pub const fn extreseten(self) -> Extreseten {
            unsafe { Extreseten::from_ptr(self.ptr.wrapping_add(0x0470usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
        #[inline(always)]
        pub const fn intreseten(self) -> Intreseten {
            unsafe { Intreseten::from_ptr(self.ptr.wrapping_add(0x0478usize) as _) }
        }
        #[doc = "Device erase protection."]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.wrapping_add(0x0480usize) as _) }
        }
    }
    #[doc = "Enable active shield detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ProtectActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for ProtectActiveshield {}
    unsafe impl Sync for ProtectActiveshield {}
    impl ProtectActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ActiveshieldCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::ActiveshieldStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spiden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spiden {}
    unsafe impl Sync for Spiden {}
    impl Spiden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spniden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spniden {}
    unsafe impl Sync for Spniden {}
    impl Spniden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpnidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpnidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Tamper controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tampc {
        ptr: *mut u8,
    }
    unsafe impl Send for Tampc {}
    unsafe impl Sync for Tampc {}
    impl Tampc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Tamper controller detected an error."]
        #[inline(always)]
        pub const fn events_tamper(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Attempt to write a VALUE in PROTECT registers without clearing the WRITEPROTECT."]
        #[inline(always)]
        pub const fn events_writeerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "The tamper controller status."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::TampcStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn activeshield(self) -> TampcActiveshield {
            unsafe { TampcActiveshield::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn protect(self) -> Protect {
            unsafe { Protect::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TampcActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for TampcActiveshield {}
    unsafe impl Sync for TampcActiveshield {}
    impl TampcActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Active shield detector channel enable register."]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldCtrl(pub u32);
        impl ActiveshieldCtrl {
            #[doc = "Set value of active shield enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ActiveshieldCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ActiveshieldCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of active shield enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ActiveshieldCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ActiveshieldCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ActiveshieldCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ActiveshieldCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ActiveshieldCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ActiveshieldCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ActiveshieldCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ActiveshieldCtrl {
            #[inline(always)]
            fn default() -> ActiveshieldCtrl {
                ActiveshieldCtrl(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ActiveshieldCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldStatus(pub u32);
        impl ActiveshieldStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ActiveshieldStatus {
            #[inline(always)]
            fn default() -> ActiveshieldStatus {
                ActiveshieldStatus(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ActiveshieldStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain ns access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenCtrl(pub u32);
        impl ApDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ApDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ApDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ApDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ApDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ApDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ApDbgenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ApDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ApDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ApDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ApDbgenCtrl {
            #[inline(always)]
            fn default() -> ApDbgenCtrl {
                ApDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for ApDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ApDbgenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain ns access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenStatus(pub u32);
        impl ApDbgenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ApDbgenStatus {
            #[inline(always)]
            fn default() -> ApDbgenStatus {
                ApDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for ApDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApDbgenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Active shield detector channel enable register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable active shield channel 0."]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable active shield channel 0."]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chen {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize))
            }
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampCtrl(pub u32);
        impl CracentampCtrl {
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::CracentampCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CracentampCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::CracentampCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::CracentampCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::CracentampCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::CracentampCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::CracentampCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::CracentampCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::CracentampCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CracentampCtrl {
            #[inline(always)]
            fn default() -> CracentampCtrl {
                CracentampCtrl(0)
            }
        }
        impl core::fmt::Debug for CracentampCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CracentampCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampStatus(pub u32);
        impl CracentampStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CracentampStatus {
            #[inline(always)]
            fn default() -> CracentampStatus {
                CracentampStatus(0)
            }
        }
        impl core::fmt::Debug for CracentampStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CracentampStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenCtrl(pub u32);
        impl DomainDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::DomainDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DomainDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::DomainDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::DomainDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::DomainDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::DomainDbgenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::DomainDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::DomainDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::DomainDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for DomainDbgenCtrl {
            #[inline(always)]
            fn default() -> DomainDbgenCtrl {
                DomainDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DomainDbgenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenStatus(pub u32);
        impl DomainDbgenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DomainDbgenStatus {
            #[inline(always)]
            fn default() -> DomainDbgenStatus {
                DomainDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DomainDbgenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for erase protection."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectCtrl(pub u32);
        impl EraseprotectCtrl {
            #[doc = "Set value of eraseprotect signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::EraseprotectCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EraseprotectCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of eraseprotect signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::EraseprotectCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::EraseprotectCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::EraseprotectCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::EraseprotectCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::EraseprotectCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::EraseprotectCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::EraseprotectCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for EraseprotectCtrl {
            #[inline(always)]
            fn default() -> EraseprotectCtrl {
                EraseprotectCtrl(0)
            }
        }
        impl core::fmt::Debug for EraseprotectCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EraseprotectCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for eraseprotect."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectStatus(pub u32);
        impl EraseprotectStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EraseprotectStatus {
            #[inline(always)]
            fn default() -> EraseprotectStatus {
                EraseprotectStatus(0)
            }
        }
        impl core::fmt::Debug for EraseprotectStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenCtrl(pub u32);
        impl ExtresetenCtrl {
            #[doc = "Set value of external tamper reset enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ExtresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ExtresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of external tamper reset enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ExtresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ExtresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ExtresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ExtresetenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ExtresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ExtresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ExtresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ExtresetenCtrl {
            #[inline(always)]
            fn default() -> ExtresetenCtrl {
                ExtresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for ExtresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ExtresetenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenStatus(pub u32);
        impl ExtresetenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ExtresetenStatus {
            #[inline(always)]
            fn default() -> ExtresetenStatus {
                ExtresetenStatus(0)
            }
        }
        impl core::fmt::Debug for ExtresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ExtresetenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainCtrl(pub u32);
        impl GlitchfastdomainCtrl {
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchfastdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchfastdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::GlitchfastdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchfastdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchfastdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchfastdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchfastdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchfastdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::GlitchfastdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchfastdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchfastdomainCtrl {
                GlitchfastdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GlitchfastdomainCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainStatus(pub u32);
        impl GlitchfastdomainStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchfastdomainStatus {
            #[inline(always)]
            fn default() -> GlitchfastdomainStatus {
                GlitchfastdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlitchfastdomainStatus {{ error: {=bool:?} }}",
                    self.error()
                )
            }
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainCtrl(pub u32);
        impl GlitchslowdomainCtrl {
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchslowdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchslowdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::GlitchslowdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchslowdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchslowdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchslowdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchslowdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchslowdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::GlitchslowdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchslowdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchslowdomainCtrl {
                GlitchslowdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GlitchslowdomainCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainStatus(pub u32);
        impl GlitchslowdomainStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchslowdomainStatus {
            #[inline(always)]
            fn default() -> GlitchslowdomainStatus {
                GlitchslowdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlitchslowdomainStatus {{ error: {=bool:?} }}",
                    self.error()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[must_use]
            #[inline(always)]
            pub const fn tamper(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[inline(always)]
            pub const fn set_tamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn writeerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[inline(always)]
            pub const fn set_writeerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tamper", &self.tamper())
                    .field("writeerror", &self.writeerror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ tamper: {=bool:?}, writeerror: {=bool:?} }}",
                    self.tamper(),
                    self.writeerror()
                )
            }
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenCtrl(pub u32);
        impl IntresetenCtrl {
            #[doc = "Set value of internal tamper reset enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::IntresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IntresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of internal tamper reset enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::IntresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::IntresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::IntresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::IntresetenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::IntresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::IntresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::IntresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for IntresetenCtrl {
            #[inline(always)]
            fn default() -> IntresetenCtrl {
                IntresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for IntresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IntresetenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenStatus(pub u32);
        impl IntresetenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IntresetenStatus {
            #[inline(always)]
            fn default() -> IntresetenStatus {
                IntresetenStatus(0)
            }
        }
        impl core::fmt::Debug for IntresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntresetenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenCtrl(pub u32);
        impl NidenCtrl {
            #[doc = "Set value of niden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::NidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::NidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of niden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::NidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::NidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::NidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::NidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::NidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::NidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::NidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for NidenCtrl {
            #[inline(always)]
            fn default() -> NidenCtrl {
                NidenCtrl(0)
            }
        }
        impl core::fmt::Debug for NidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "NidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenStatus(pub u32);
        impl NidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for NidenStatus {
            #[inline(always)]
            fn default() -> NidenStatus {
                NidenStatus(0)
            }
        }
        impl core::fmt::Debug for NidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "NidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenCtrl(pub u32);
        impl SpidenCtrl {
            #[doc = "Set value of spiden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spiden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::SpidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::SpidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::SpidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpidenCtrl {
            #[inline(always)]
            fn default() -> SpidenCtrl {
                SpidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenStatus(pub u32);
        impl SpidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpidenStatus {
            #[inline(always)]
            fn default() -> SpidenStatus {
                SpidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenCtrl(pub u32);
        impl SpnidenCtrl {
            #[doc = "Set value of spniden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpnidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpnidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spniden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::SpnidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpnidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpnidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::SpnidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpnidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpnidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::SpnidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpnidenCtrl {
            #[inline(always)]
            fn default() -> SpnidenCtrl {
                SpnidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpnidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpnidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenStatus(pub u32);
        impl SpnidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpnidenStatus {
            #[inline(always)]
            fn default() -> SpnidenStatus {
                SpnidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpnidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpnidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "The tamper controller status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TampcStatus(pub u32);
        impl TampcStatus {
            #[doc = "Active shield detector detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn activeshield(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Active shield detector detected an error."]
            #[inline(always)]
            pub const fn set_activeshield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error detected for the protected signals."]
            #[must_use]
            #[inline(always)]
            pub const fn protect(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Error detected for the protected signals."]
            #[inline(always)]
            pub const fn set_protect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CRACEN detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn cracentamp(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CRACEN detected an error."]
            #[inline(always)]
            pub const fn set_cracentamp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn glitchslowdomain(&self, n: usize) -> bool {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn set_glitchslowdomain(&mut self, n: usize, val: bool) {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn glitchfastdomain(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn set_glitchfastdomain(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for TampcStatus {
            #[inline(always)]
            fn default() -> TampcStatus {
                TampcStatus(0)
            }
        }
        impl core::fmt::Debug for TampcStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TampcStatus")
                    .field("activeshield", &self.activeshield())
                    .field("protect", &self.protect())
                    .field("cracentamp", &self.cracentamp())
                    .field("glitchslowdomain[0]", &self.glitchslowdomain(0usize))
                    .field("glitchfastdomain[0]", &self.glitchfastdomain(0usize))
                    .field("glitchfastdomain[1]", &self.glitchfastdomain(1usize))
                    .field("glitchfastdomain[2]", &self.glitchfastdomain(2usize))
                    .field("glitchfastdomain[3]", &self.glitchfastdomain(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TampcStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TampcStatus {{ activeshield: {=bool:?}, protect: {=bool:?}, cracentamp: {=bool:?}, glitchslowdomain[0]: {=bool:?}, glitchfastdomain[0]: {=bool:?}, glitchfastdomain[1]: {=bool:?}, glitchfastdomain[2]: {=bool:?}, glitchfastdomain[3]: {=bool:?} }}" , self . activeshield () , self . protect () , self . cracentamp () , self . glitchslowdomain (0usize) , self . glitchfastdomain (0usize) , self . glitchfastdomain (1usize) , self . glitchfastdomain (2usize) , self . glitchfastdomain (3usize))
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ActiveshieldCtrlKey(u16);
        impl ActiveshieldCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ActiveshieldCtrlKey {
            pub const fn from_bits(val: u16) -> ActiveshieldCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ActiveshieldCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ActiveshieldCtrlKey {
                ActiveshieldCtrlKey::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlKey) -> u16 {
                ActiveshieldCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ActiveshieldCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlValue {
                ActiveshieldCtrlValue::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlValue) -> u8 {
                ActiveshieldCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlWriteprotection {
                ActiveshieldCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlWriteprotection) -> u8 {
                ActiveshieldCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApDbgenCtrlKey(u16);
        impl ApDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ApDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> ApDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ApDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ApDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ApDbgenCtrlKey {
                ApDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlKey) -> u16 {
                ApDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlValue {
            #[doc = "Signal is logic 0, indicating that invasive debug is disabled."]
            LOW = 0x0,
            #[doc = "Signal is logic 1, indicating that invasive debug is enabled."]
            HIGH = 0x01,
        }
        impl ApDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlValue {
                ApDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlValue) -> u8 {
                ApDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ApDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlWriteprotection {
                ApDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlWriteprotection) -> u8 {
                ApDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct CracentampCtrlKey(u16);
        impl CracentampCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl CracentampCtrlKey {
            pub const fn from_bits(val: u16) -> CracentampCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for CracentampCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for CracentampCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> CracentampCtrlKey {
                CracentampCtrlKey::from_bits(val)
            }
        }
        impl From<CracentampCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: CracentampCtrlKey) -> u16 {
                CracentampCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl CracentampCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlValue {
                CracentampCtrlValue::from_bits(val)
            }
        }
        impl From<CracentampCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlValue) -> u8 {
                CracentampCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl CracentampCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlWriteprotection {
                CracentampCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<CracentampCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlWriteprotection) -> u8 {
                CracentampCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct DomainDbgenCtrlKey(u16);
        impl DomainDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl DomainDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> DomainDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for DomainDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> DomainDbgenCtrlKey {
                DomainDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlKey) -> u16 {
                DomainDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlValue {
            #[doc = "Signal is logic 0, indicating that invasive debug is disabled."]
            LOW = 0x0,
            #[doc = "Signal is logic 1, indicating that invasive debug is enabled."]
            HIGH = 0x01,
        }
        impl DomainDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlValue {
                DomainDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlValue) -> u8 {
                DomainDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlWriteprotection {
                DomainDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlWriteprotection) -> u8 {
                DomainDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectCtrlKey(u16);
        impl EraseprotectCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl EraseprotectCtrlKey {
            pub const fn from_bits(val: u16) -> EraseprotectCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for EraseprotectCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> EraseprotectCtrlKey {
                EraseprotectCtrlKey::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlKey) -> u16 {
                EraseprotectCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl EraseprotectCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlValue {
                EraseprotectCtrlValue::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlValue) -> u8 {
                EraseprotectCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl EraseprotectCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlWriteprotection {
                EraseprotectCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlWriteprotection) -> u8 {
                EraseprotectCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ExtresetenCtrlKey(u16);
        impl ExtresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ExtresetenCtrlKey {
            pub const fn from_bits(val: u16) -> ExtresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ExtresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ExtresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ExtresetenCtrlKey {
                ExtresetenCtrlKey::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlKey) -> u16 {
                ExtresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ExtresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlValue {
                ExtresetenCtrlValue::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlValue) -> u8 {
                ExtresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ExtresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlWriteprotection {
                ExtresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlWriteprotection) -> u8 {
                ExtresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchfastdomainCtrlKey(u16);
        impl GlitchfastdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchfastdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchfastdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchfastdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchfastdomainCtrlKey {
                GlitchfastdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlKey) -> u16 {
                GlitchfastdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchfastdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlValue {
                GlitchfastdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlValue) -> u8 {
                GlitchfastdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                GlitchfastdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlWriteprotection) -> u8 {
                GlitchfastdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchslowdomainCtrlKey(u16);
        impl GlitchslowdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchslowdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchslowdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchslowdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchslowdomainCtrlKey {
                GlitchslowdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlKey) -> u16 {
                GlitchslowdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchslowdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlValue {
                GlitchslowdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlValue) -> u8 {
                GlitchslowdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                GlitchslowdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlWriteprotection) -> u8 {
                GlitchslowdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct IntresetenCtrlKey(u16);
        impl IntresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl IntresetenCtrlKey {
            pub const fn from_bits(val: u16) -> IntresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for IntresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for IntresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> IntresetenCtrlKey {
                IntresetenCtrlKey::from_bits(val)
            }
        }
        impl From<IntresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: IntresetenCtrlKey) -> u16 {
                IntresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl IntresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlValue {
                IntresetenCtrlValue::from_bits(val)
            }
        }
        impl From<IntresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlValue) -> u8 {
                IntresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl IntresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlWriteprotection {
                IntresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<IntresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlWriteprotection) -> u8 {
                IntresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct NidenCtrlKey(u16);
        impl NidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl NidenCtrlKey {
            pub const fn from_bits(val: u16) -> NidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for NidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for NidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> NidenCtrlKey {
                NidenCtrlKey::from_bits(val)
            }
        }
        impl From<NidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: NidenCtrlKey) -> u16 {
                NidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlValue {
            #[doc = "Signal is logic 0, indicating that non-invasive debug is disabled."]
            LOW = 0x0,
            #[doc = "Signal is logic 1, indicating that non-invasive debug is enabled."]
            HIGH = 0x01,
        }
        impl NidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlValue {
                NidenCtrlValue::from_bits(val)
            }
        }
        impl From<NidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlValue) -> u8 {
                NidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl NidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlWriteprotection {
                NidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<NidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlWriteprotection) -> u8 {
                NidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpidenCtrlKey(u16);
        impl SpidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpidenCtrlKey {
                SpidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpidenCtrlKey) -> u16 {
                SpidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlValue {
            #[doc = "Signal is logic 0, indicating that secure priviliged invasive debug is disabled."]
            LOW = 0x0,
            #[doc = "Signal is logic 1, indicating that secure priviliged invasive debug is enabled."]
            HIGH = 0x01,
        }
        impl SpidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlValue {
                SpidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlValue) -> u8 {
                SpidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlWriteprotection {
                SpidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlWriteprotection) -> u8 {
                SpidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpnidenCtrlKey(u16);
        impl SpnidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpnidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpnidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpnidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpnidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpnidenCtrlKey {
                SpnidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpnidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpnidenCtrlKey) -> u16 {
                SpnidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlValue {
            #[doc = "Signal is logic 0, indicating that secure priviliged non-invasive debug is disabled."]
            LOW = 0x0,
            #[doc = "Signal is logic 1, indicating that secure priviliged non-invasive debug is enabled."]
            HIGH = 0x01,
        }
        impl SpnidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlValue {
                SpnidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpnidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlValue) -> u8 {
                SpnidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpnidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlWriteprotection {
                SpnidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpnidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlWriteprotection) -> u8 {
                SpnidenCtrlWriteprotection::to_bits(val)
            }
        }
    }
}
pub mod tdm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Channel {
        ptr: *mut u8,
    }
    unsafe impl Send for Channel {}
    unsafe impl Sync for Channel {}
    impl Channel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Select which channels are to be used."]
        #[inline(always)]
        pub const fn mask(self) -> crate::common::Reg<regs::Mask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Select number of channels."]
        #[inline(always)]
        pub const fn num(self) -> crate::common::Reg<regs::Num, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Set channel delay."]
        #[inline(always)]
        pub const fn delay(self) -> crate::common::Reg<regs::Delay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Configuration registers."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Mode configuration"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::ConfigMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Reception (RX) and transmission (TX) enable."]
        #[inline(always)]
        pub const fn rxtxen(self) -> crate::common::Reg<regs::Rxtxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn mck(self) -> Mck {
            unsafe { Mck::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn sck(self) -> Sck {
            unsafe { Sck::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Sample and word width configuration."]
        #[inline(always)]
        pub const fn swidth(self) -> crate::common::Reg<regs::Swidth, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Alignment of sample within the audio data word."]
        #[inline(always)]
        pub const fn align(self) -> crate::common::Reg<regs::Align, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn channel(self) -> Channel {
            unsafe { Channel::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn fsync(self) -> Fsync {
            unsafe { Fsync::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Over-read sample: Extra sample(s) to be transmitted after TXD.MAXCNT bytes have been transmitted."]
        #[inline(always)]
        pub const fn ors(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fsync {
        ptr: *mut u8,
    }
    unsafe impl Send for Fsync {}
    unsafe impl Sync for Fsync {}
    impl Fsync {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Set FSYNC Polarity."]
        #[inline(always)]
        pub const fn polarity(self) -> crate::common::Reg<regs::FsyncPolarity, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Set FSYNC duration."]
        #[inline(always)]
        pub const fn duration(self) -> crate::common::Reg<regs::Duration, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mck {
        ptr: *mut u8,
    }
    unsafe impl Send for Mck {}
    unsafe impl Sync for Mck {}
    impl Mck {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Master clock generator enable."]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<regs::En, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "MCK divider."]
        #[inline(always)]
        pub const fn div(self) -> crate::common::Reg<regs::MckDiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "MCK clock source selection"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<regs::MckSrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for MCK signal"]
        #[inline(always)]
        pub const fn mck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SCK signal"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for FSYNC signal"]
        #[inline(always)]
        pub const fn fsync(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for SDIN signal"]
        #[inline(always)]
        pub const fn sdin(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Pin select for SDOUT signal"]
        #[inline(always)]
        pub const fn sdout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::RxdCurrentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Configure EasyDMA mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::RxdMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxdTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sck {
        ptr: *mut u8,
    }
    unsafe impl Send for Sck {}
    unsafe impl Sync for Sck {}
    impl Sck {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SCK divider."]
        #[inline(always)]
        pub const fn div(self) -> crate::common::Reg<regs::SckDiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "SCK clock source selection"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<regs::SckSrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Set SCK Polarity."]
        #[inline(always)]
        pub const fn polarity(self) -> crate::common::Reg<regs::SckPolarity, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Time division multiplexed audio interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tdm {
        ptr: *mut u8,
    }
    unsafe impl Send for Tdm {}
    unsafe impl Sync for Tdm {}
    impl Tdm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous TDM transfer. Also starts MCK when this is enabled"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops TDM transfer after the completion of MAXCNT bytes. Triggering this task will cause the STOPPED event to be generated."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Abort TDM transfer without completing MAXCNT bytes. Triggering this task will cause the ABORTED event to be generated."]
        #[inline(always)]
        pub const fn tasks_abort(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task ABORT"]
        #[inline(always)]
        pub const fn subscribe_abort(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "The RXD.PTR register has been copied to internal double-buffers. When TDM is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT bytes received on the SDIN pin."]
        #[inline(always)]
        pub const fn events_rxptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Transfer stopped."]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Transfer aborted."]
        #[inline(always)]
        pub const fn events_aborted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "The TDX.PTR register has been copied to internal double-buffers. When TDM is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT bytes that are sent on the SDOUT pin."]
        #[inline(always)]
        pub const fn events_txptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Generated on the active edge of FSYNC, after both RX and TX DMA transfers have completed. An initial MAXCNT event is also triggered on the first active edge of FSYNC after the START task is issued."]
        #[inline(always)]
        pub const fn events_maxcnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0120usize) as _) }
        }
        #[doc = "Publish configuration for event RXPTRUPD"]
        #[inline(always)]
        pub const fn publish_rxptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event ABORTED"]
        #[inline(always)]
        pub const fn publish_aborted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event TXPTRUPD"]
        #[inline(always)]
        pub const fn publish_txptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event MAXCNT"]
        #[inline(always)]
        pub const fn publish_maxcnt(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a0usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Enable TDM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Configuration registers."]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0570usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.wrapping_add(0x0740usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::TxdCurrentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Configure EasyDMA mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::TxdMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxdTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Alignment of sample within the audio data word."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Align(pub u32);
        impl Align {
            #[doc = "Alignment of sample within the audio data word."]
            #[must_use]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Alignment of sample within the audio data word."]
            #[inline(always)]
            pub const fn set_align(&mut self, val: super::vals::Align) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Align {
            #[inline(always)]
            fn default() -> Align {
                Align(0)
            }
        }
        impl core::fmt::Debug for Align {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Align")
                    .field("align", &self.align())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Align {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Align {{ align: {:?} }}", self.align())
            }
        }
        #[doc = "Mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConfigMode(pub u32);
        impl ConfigMode {
            #[doc = "Mode configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Mode configuration"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ConfigMode {
            #[inline(always)]
            fn default() -> ConfigMode {
                ConfigMode(0)
            }
        }
        impl core::fmt::Debug for ConfigMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConfigMode")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConfigMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConfigMode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Set channel delay."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Delay(pub u32);
        impl Delay {
            #[doc = "Configure number of inactive SCK periods from edge of FSYNC until start of first data bit."]
            #[must_use]
            #[inline(always)]
            pub const fn delay(&self) -> super::vals::Delay {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Delay::from_bits(val as u8)
            }
            #[doc = "Configure number of inactive SCK periods from edge of FSYNC until start of first data bit."]
            #[inline(always)]
            pub const fn set_delay(&mut self, val: super::vals::Delay) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Delay {
            #[inline(always)]
            fn default() -> Delay {
                Delay(0)
            }
        }
        impl core::fmt::Debug for Delay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Delay")
                    .field("delay", &self.delay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Delay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Delay {{ delay: {:?} }}", self.delay())
            }
        }
        #[doc = "Set FSYNC duration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Duration(pub u32);
        impl Duration {
            #[doc = "Set the duration of the active period of FSYNC in Master mode."]
            #[must_use]
            #[inline(always)]
            pub const fn duration(&self) -> super::vals::Duration {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Duration::from_bits(val as u8)
            }
            #[doc = "Set the duration of the active period of FSYNC in Master mode."]
            #[inline(always)]
            pub const fn set_duration(&mut self, val: super::vals::Duration) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Duration {
            #[inline(always)]
            fn default() -> Duration {
                Duration(0)
            }
        }
        impl core::fmt::Debug for Duration {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Duration")
                    .field("duration", &self.duration())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Duration {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Duration {{ duration: {:?} }}", self.duration())
            }
        }
        #[doc = "Master clock generator enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct En(pub u32);
        impl En {
            #[doc = "Master clock generator enable."]
            #[must_use]
            #[inline(always)]
            pub const fn mcken(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master clock generator enable."]
            #[inline(always)]
            pub const fn set_mcken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for En {
            #[inline(always)]
            fn default() -> En {
                En(0)
            }
        }
        impl core::fmt::Debug for En {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("En").field("mcken", &self.mcken()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for En {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "En {{ mcken: {=bool:?} }}", self.mcken())
            }
        }
        #[doc = "Enable TDM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable TDM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable TDM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Set FSYNC Polarity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FsyncPolarity(pub u32);
        impl FsyncPolarity {
            #[doc = "Set the polarity of the active period of FSYNC."]
            #[must_use]
            #[inline(always)]
            pub const fn polarity(&self) -> super::vals::Polarity {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Polarity::from_bits(val as u8)
            }
            #[doc = "Set the polarity of the active period of FSYNC."]
            #[inline(always)]
            pub const fn set_polarity(&mut self, val: super::vals::Polarity) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for FsyncPolarity {
            #[inline(always)]
            fn default() -> FsyncPolarity {
                FsyncPolarity(0)
            }
        }
        impl core::fmt::Debug for FsyncPolarity {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FsyncPolarity")
                    .field("polarity", &self.polarity())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FsyncPolarity {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "FsyncPolarity {{ polarity: {:?} }}", self.polarity())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn rxptrupd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[inline(always)]
            pub const fn set_rxptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event ABORTED"]
            #[must_use]
            #[inline(always)]
            pub const fn aborted(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ABORTED"]
            #[inline(always)]
            pub const fn set_aborted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn txptrupd(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[inline(always)]
            pub const fn set_txptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event MAXCNT"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event MAXCNT"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxptrupd", &self.rxptrupd())
                    .field("stopped", &self.stopped())
                    .field("aborted", &self.aborted())
                    .field("txptrupd", &self.txptrupd())
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ rxptrupd: {=bool:?}, stopped: {=bool:?}, aborted: {=bool:?}, txptrupd: {=bool:?}, maxcnt: {=bool:?} }}" , self . rxptrupd () , self . stopped () , self . aborted () , self . txptrupd () , self . maxcnt ())
            }
        }
        #[doc = "Select which channels are to be used."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mask(pub u32);
        impl Mask {
            #[must_use]
            #[inline(always)]
            pub const fn rx0enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx0enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx1enable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx1enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx2enable(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx2enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx3enable(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx3enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx4enable(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx4enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx5enable(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx5enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx6enable(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx6enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rx7enable(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rx7enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx0enable(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx0enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx1enable(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx1enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx2enable(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx2enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx3enable(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx3enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx4enable(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx4enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx5enable(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx5enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx6enable(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx6enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn tx7enable(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_tx7enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Mask {
            #[inline(always)]
            fn default() -> Mask {
                Mask(0)
            }
        }
        impl core::fmt::Debug for Mask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mask")
                    .field("rx0enable", &self.rx0enable())
                    .field("rx1enable", &self.rx1enable())
                    .field("rx2enable", &self.rx2enable())
                    .field("rx3enable", &self.rx3enable())
                    .field("rx4enable", &self.rx4enable())
                    .field("rx5enable", &self.rx5enable())
                    .field("rx6enable", &self.rx6enable())
                    .field("rx7enable", &self.rx7enable())
                    .field("tx0enable", &self.tx0enable())
                    .field("tx1enable", &self.tx1enable())
                    .field("tx2enable", &self.tx2enable())
                    .field("tx3enable", &self.tx3enable())
                    .field("tx4enable", &self.tx4enable())
                    .field("tx5enable", &self.tx5enable())
                    .field("tx6enable", &self.tx6enable())
                    .field("tx7enable", &self.tx7enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mask {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Mask {{ rx0enable: {=bool:?}, rx1enable: {=bool:?}, rx2enable: {=bool:?}, rx3enable: {=bool:?}, rx4enable: {=bool:?}, rx5enable: {=bool:?}, rx6enable: {=bool:?}, rx7enable: {=bool:?}, tx0enable: {=bool:?}, tx1enable: {=bool:?}, tx2enable: {=bool:?}, tx3enable: {=bool:?}, tx4enable: {=bool:?}, tx5enable: {=bool:?}, tx6enable: {=bool:?}, tx7enable: {=bool:?} }}" , self . rx0enable () , self . rx1enable () , self . rx2enable () , self . rx3enable () , self . rx4enable () , self . rx5enable () , self . rx6enable () , self . rx7enable () , self . tx0enable () , self . tx1enable () , self . tx2enable () , self . tx3enable () , self . tx4enable () , self . tx5enable () , self . tx6enable () , self . tx7enable ())
            }
        }
        #[doc = "MCK divider."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MckDiv(pub u32);
        impl MckDiv {
            #[doc = "MCK frequency configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn div(&self) -> super::vals::Div {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Div::from_bits(val as u32)
            }
            #[doc = "MCK frequency configuration"]
            #[inline(always)]
            pub const fn set_div(&mut self, val: super::vals::Div) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for MckDiv {
            #[inline(always)]
            fn default() -> MckDiv {
                MckDiv(0)
            }
        }
        impl core::fmt::Debug for MckDiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MckDiv").field("div", &self.div()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MckDiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MckDiv {{ div: {:?} }}", self.div())
            }
        }
        #[doc = "MCK clock source selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MckSrc(pub u32);
        impl MckSrc {
            #[doc = "Clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn clksrc(&self) -> super::vals::MckSrcClksrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::MckSrcClksrc::from_bits(val as u8)
            }
            #[doc = "Clock source selection"]
            #[inline(always)]
            pub const fn set_clksrc(&mut self, val: super::vals::MckSrcClksrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Bypass clock generator. MCK will be equal to source input. If bypass is enabled the MCKFREQ setting has no effect."]
            #[must_use]
            #[inline(always)]
            pub const fn bypass(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass clock generator. MCK will be equal to source input. If bypass is enabled the MCKFREQ setting has no effect."]
            #[inline(always)]
            pub const fn set_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for MckSrc {
            #[inline(always)]
            fn default() -> MckSrc {
                MckSrc(0)
            }
        }
        impl core::fmt::Debug for MckSrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MckSrc")
                    .field("clksrc", &self.clksrc())
                    .field("bypass", &self.bypass())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MckSrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "MckSrc {{ clksrc: {:?}, bypass: {=bool:?} }}",
                    self.clksrc(),
                    self.bypass()
                )
            }
        }
        #[doc = "Select number of channels."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Num(pub u32);
        impl Num {
            #[doc = "Select number of channels."]
            #[must_use]
            #[inline(always)]
            pub const fn num(&self) -> super::vals::Num {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Num::from_bits(val as u8)
            }
            #[doc = "Select number of channels."]
            #[inline(always)]
            pub const fn set_num(&mut self, val: super::vals::Num) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Num {
            #[inline(always)]
            fn default() -> Num {
                Num(0)
            }
        }
        impl core::fmt::Debug for Num {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Num").field("num", &self.num()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Num {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Num {{ num: {:?} }}", self.num())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdCurrentamount(pub u32);
        impl RxdCurrentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxdCurrentamount {
            #[inline(always)]
            fn default() -> RxdCurrentamount {
                RxdCurrentamount(0)
            }
        }
        impl core::fmt::Debug for RxdCurrentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdCurrentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdCurrentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdCurrentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Configure EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMode(pub u32);
        impl RxdMode {
            #[doc = "Enable low-power operation, or use low-latency"]
            #[must_use]
            #[inline(always)]
            pub const fn lpop(&self) -> super::vals::RxdModeLpop {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::RxdModeLpop::from_bits(val as u8)
            }
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub const fn set_lpop(&mut self, val: super::vals::RxdModeLpop) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for RxdMode {
            #[inline(always)]
            fn default() -> RxdMode {
                RxdMode(0)
            }
        }
        impl core::fmt::Debug for RxdMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMode")
                    .field("lpop", &self.lpop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMode {{ lpop: {:?} }}", self.lpop())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdTerminateonbuserror(pub u32);
        impl RxdTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxdTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxdTerminateonbuserror {
                RxdTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxdTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxdTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Reception (RX) and transmission (TX) enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxtxen(pub u32);
        impl Rxtxen {
            #[doc = "Enable reception or transmission."]
            #[must_use]
            #[inline(always)]
            pub const fn rxtxen(&self) -> super::vals::Rxtxen {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Rxtxen::from_bits(val as u8)
            }
            #[doc = "Enable reception or transmission."]
            #[inline(always)]
            pub const fn set_rxtxen(&mut self, val: super::vals::Rxtxen) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Rxtxen {
            #[inline(always)]
            fn default() -> Rxtxen {
                Rxtxen(0)
            }
        }
        impl core::fmt::Debug for Rxtxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxtxen")
                    .field("rxtxen", &self.rxtxen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxtxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxtxen {{ rxtxen: {:?} }}", self.rxtxen())
            }
        }
        #[doc = "SCK divider."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SckDiv(pub u32);
        impl SckDiv {
            #[doc = "SCK frequency configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn sckdiv(&self) -> super::vals::Sckdiv {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Sckdiv::from_bits(val as u32)
            }
            #[doc = "SCK frequency configuration"]
            #[inline(always)]
            pub const fn set_sckdiv(&mut self, val: super::vals::Sckdiv) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SckDiv {
            #[inline(always)]
            fn default() -> SckDiv {
                SckDiv(0)
            }
        }
        impl core::fmt::Debug for SckDiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SckDiv")
                    .field("sckdiv", &self.sckdiv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SckDiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SckDiv {{ sckdiv: {:?} }}", self.sckdiv())
            }
        }
        #[doc = "Set SCK Polarity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SckPolarity(pub u32);
        impl SckPolarity {
            #[doc = "Set the polarity of the active SCK edge."]
            #[must_use]
            #[inline(always)]
            pub const fn sckpolarity(&self) -> super::vals::Sckpolarity {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sckpolarity::from_bits(val as u8)
            }
            #[doc = "Set the polarity of the active SCK edge."]
            #[inline(always)]
            pub const fn set_sckpolarity(&mut self, val: super::vals::Sckpolarity) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SckPolarity {
            #[inline(always)]
            fn default() -> SckPolarity {
                SckPolarity(0)
            }
        }
        impl core::fmt::Debug for SckPolarity {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SckPolarity")
                    .field("sckpolarity", &self.sckpolarity())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SckPolarity {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SckPolarity {{ sckpolarity: {:?} }}", self.sckpolarity())
            }
        }
        #[doc = "SCK clock source selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SckSrc(pub u32);
        impl SckSrc {
            #[doc = "Clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn clksrc(&self) -> super::vals::SckSrcClksrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SckSrcClksrc::from_bits(val as u8)
            }
            #[doc = "Clock source selection"]
            #[inline(always)]
            pub const fn set_clksrc(&mut self, val: super::vals::SckSrcClksrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Bypass clock generator. SCK will be equal to source input. If bypass is enabled the SCKFREQ setting has no effect."]
            #[must_use]
            #[inline(always)]
            pub const fn bypass(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass clock generator. SCK will be equal to source input. If bypass is enabled the SCKFREQ setting has no effect."]
            #[inline(always)]
            pub const fn set_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for SckSrc {
            #[inline(always)]
            fn default() -> SckSrc {
                SckSrc(0)
            }
        }
        impl core::fmt::Debug for SckSrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SckSrc")
                    .field("clksrc", &self.clksrc())
                    .field("bypass", &self.bypass())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SckSrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SckSrc {{ clksrc: {:?}, bypass: {=bool:?} }}",
                    self.clksrc(),
                    self.bypass()
                )
            }
        }
        #[doc = "Sample and word width configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swidth(pub u32);
        impl Swidth {
            #[doc = "Sample and word width"]
            #[must_use]
            #[inline(always)]
            pub const fn swidth(&self) -> super::vals::Swidth {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Swidth::from_bits(val as u8)
            }
            #[doc = "Sample and word width"]
            #[inline(always)]
            pub const fn set_swidth(&mut self, val: super::vals::Swidth) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Swidth {
            #[inline(always)]
            fn default() -> Swidth {
                Swidth(0)
            }
        }
        impl core::fmt::Debug for Swidth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swidth")
                    .field("swidth", &self.swidth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swidth {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Swidth {{ swidth: {:?} }}", self.swidth())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdCurrentamount(pub u32);
        impl TxdCurrentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxdCurrentamount {
            #[inline(always)]
            fn default() -> TxdCurrentamount {
                TxdCurrentamount(0)
            }
        }
        impl core::fmt::Debug for TxdCurrentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdCurrentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdCurrentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdCurrentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Configure EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMode(pub u32);
        impl TxdMode {
            #[doc = "Enable low-power operation, or use low-latency"]
            #[must_use]
            #[inline(always)]
            pub const fn lpop(&self) -> super::vals::TxdModeLpop {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TxdModeLpop::from_bits(val as u8)
            }
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub const fn set_lpop(&mut self, val: super::vals::TxdModeLpop) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TxdMode {
            #[inline(always)]
            fn default() -> TxdMode {
                TxdMode(0)
            }
        }
        impl core::fmt::Debug for TxdMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMode")
                    .field("lpop", &self.lpop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMode {{ lpop: {:?} }}", self.lpop())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdTerminateonbuserror(pub u32);
        impl TxdTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxdTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxdTerminateonbuserror {
                TxdTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxdTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxdTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            #[doc = "Left-aligned."]
            LEFT = 0x0,
            #[doc = "Right-aligned."]
            RIGHT = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Delay {
            #[doc = "No delay. Used with I2S DSP/Aligned format."]
            DELAY0CK = 0x0,
            #[doc = "One clock pulse delay. Used with Original I2S format."]
            DELAY1CK = 0x01,
            #[doc = "Two clock pulses delay."]
            DELAY2CK = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Delay {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Delay {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Delay {
            #[inline(always)]
            fn from(val: u8) -> Delay {
                Delay::from_bits(val)
            }
        }
        impl From<Delay> for u8 {
            #[inline(always)]
            fn from(val: Delay) -> u8 {
                Delay::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Div(u32);
        impl Div {
            #[doc = "CK divided by 125"]
            pub const CKDIV125: Self = Self(0x020c_0000);
            #[doc = "CK divided by 63"]
            pub const CKDIV63: Self = Self(0x0410_0000);
            #[doc = "CK divided by 42"]
            pub const CKDIV42: Self = Self(0x0600_0000);
            #[doc = "CK divided by 32"]
            pub const CKDIV32: Self = Self(0x0800_0000);
            #[doc = "CK divided by 31"]
            pub const CKDIV31: Self = Self(0x0840_0000);
            #[doc = "CK divided by 30"]
            pub const CKDIV30: Self = Self(0x0880_0000);
            #[doc = "CK divided by 23"]
            pub const CKDIV23: Self = Self(0x0b00_0000);
            #[doc = "CK divided by 21"]
            pub const CKDIV21: Self = Self(0x0c00_0000);
            #[doc = "CK divided by 16"]
            pub const CKDIV16: Self = Self(0x1000_0000);
            #[doc = "CK divided by 15"]
            pub const CKDIV15: Self = Self(0x1100_0000);
            #[doc = "CK divided by 11"]
            pub const CKDIV11: Self = Self(0x1600_0000);
            #[doc = "CK divided by 10"]
            pub const CKDIV10: Self = Self(0x1800_0000);
            #[doc = "CK divided by 8"]
            pub const CKDIV8: Self = Self(0x2000_0000);
            #[doc = "CK divided by 6"]
            pub const CKDIV6: Self = Self(0x2800_0000);
            #[doc = "CK divided by 5"]
            pub const CKDIV5: Self = Self(0x3000_0000);
            #[doc = "CK divided by 4"]
            pub const CKDIV4: Self = Self(0x4000_0000);
            #[doc = "CK divided by 3"]
            pub const CKDIV3: Self = Self(0x5000_0000);
            #[doc = "CK divided by 2"]
            pub const CKDIV2: Self = Self(0x8000_0000);
        }
        impl Div {
            pub const fn from_bits(val: u32) -> Div {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Div {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x020c_0000 => f.write_str("CKDIV125"),
                    0x0410_0000 => f.write_str("CKDIV63"),
                    0x0600_0000 => f.write_str("CKDIV42"),
                    0x0800_0000 => f.write_str("CKDIV32"),
                    0x0840_0000 => f.write_str("CKDIV31"),
                    0x0880_0000 => f.write_str("CKDIV30"),
                    0x0b00_0000 => f.write_str("CKDIV23"),
                    0x0c00_0000 => f.write_str("CKDIV21"),
                    0x1000_0000 => f.write_str("CKDIV16"),
                    0x1100_0000 => f.write_str("CKDIV15"),
                    0x1600_0000 => f.write_str("CKDIV11"),
                    0x1800_0000 => f.write_str("CKDIV10"),
                    0x2000_0000 => f.write_str("CKDIV8"),
                    0x2800_0000 => f.write_str("CKDIV6"),
                    0x3000_0000 => f.write_str("CKDIV5"),
                    0x4000_0000 => f.write_str("CKDIV4"),
                    0x5000_0000 => f.write_str("CKDIV3"),
                    0x8000_0000 => f.write_str("CKDIV2"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Div {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x020c_0000 => defmt::write!(f, "CKDIV125"),
                    0x0410_0000 => defmt::write!(f, "CKDIV63"),
                    0x0600_0000 => defmt::write!(f, "CKDIV42"),
                    0x0800_0000 => defmt::write!(f, "CKDIV32"),
                    0x0840_0000 => defmt::write!(f, "CKDIV31"),
                    0x0880_0000 => defmt::write!(f, "CKDIV30"),
                    0x0b00_0000 => defmt::write!(f, "CKDIV23"),
                    0x0c00_0000 => defmt::write!(f, "CKDIV21"),
                    0x1000_0000 => defmt::write!(f, "CKDIV16"),
                    0x1100_0000 => defmt::write!(f, "CKDIV15"),
                    0x1600_0000 => defmt::write!(f, "CKDIV11"),
                    0x1800_0000 => defmt::write!(f, "CKDIV10"),
                    0x2000_0000 => defmt::write!(f, "CKDIV8"),
                    0x2800_0000 => defmt::write!(f, "CKDIV6"),
                    0x3000_0000 => defmt::write!(f, "CKDIV5"),
                    0x4000_0000 => defmt::write!(f, "CKDIV4"),
                    0x5000_0000 => defmt::write!(f, "CKDIV3"),
                    0x8000_0000 => defmt::write!(f, "CKDIV2"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Div {
            #[inline(always)]
            fn from(val: u32) -> Div {
                Div::from_bits(val)
            }
        }
        impl From<Div> for u32 {
            #[inline(always)]
            fn from(val: Div) -> u32 {
                Div::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Duration {
            #[doc = "FSYNC is active for the duration of one SCK period"]
            SCK = 0x0,
            #[doc = "FSYNC is active for the duration of channel"]
            CHANNEL = 0x01,
        }
        impl Duration {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Duration {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Duration {
            #[inline(always)]
            fn from(val: u8) -> Duration {
                Duration::from_bits(val)
            }
        }
        impl From<Duration> for u8 {
            #[inline(always)]
            fn from(val: Duration) -> u8 {
                Duration::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MckSrcClksrc {
            #[doc = "Peripheral clock (instantiation table shows the TDM PCLK frequency)"]
            PCLK = 0x0,
            #[doc = "Audio PLL clock"]
            ACLK = 0x01,
        }
        impl MckSrcClksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MckSrcClksrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MckSrcClksrc {
            #[inline(always)]
            fn from(val: u8) -> MckSrcClksrc {
                MckSrcClksrc::from_bits(val)
            }
        }
        impl From<MckSrcClksrc> for u8 {
            #[inline(always)]
            fn from(val: MckSrcClksrc) -> u8 {
                MckSrcClksrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Master mode. SCK and FSYNC are created internally and output on PSEL.SCK and PSEL.FSYNC."]
            MASTER = 0x0,
            #[doc = "Slave mode. SCK and FSYNC are received on PSEL.SCK and PSEL.FSYNC."]
            SLAVE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Num {
            #[doc = "1-channel audio (mono)."]
            TDM1CH = 0x0,
            #[doc = "2-channel audio (stereo)."]
            TDM2CH = 0x01,
            #[doc = "3-channel audio."]
            TDM3CH = 0x02,
            #[doc = "4-channel audio."]
            TDM4CH = 0x03,
            #[doc = "5-channel audio."]
            TDM5CH = 0x04,
            #[doc = "6-channel audio."]
            TDM6CH = 0x05,
            #[doc = "7-channel audio."]
            TDM7CH = 0x06,
            #[doc = "8-channel audio."]
            TDM8CH = 0x07,
        }
        impl Num {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Num {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Num {
            #[inline(always)]
            fn from(val: u8) -> Num {
                Num::from_bits(val)
            }
        }
        impl From<Num> for u8 {
            #[inline(always)]
            fn from(val: Num) -> u8 {
                Num::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Polarity {
            #[doc = "Frame starts at falling edge of FSYNC."]
            NEG_EDGE = 0x0,
            #[doc = "Frame starts at rising edge of FSYNC."]
            POS_EDGE = 0x01,
        }
        impl Polarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Polarity {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Polarity {
            #[inline(always)]
            fn from(val: u8) -> Polarity {
                Polarity::from_bits(val)
            }
        }
        impl From<Polarity> for u8 {
            #[inline(always)]
            fn from(val: Polarity) -> u8 {
                Polarity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxdModeLpop {
            #[doc = "Low-latency operation"]
            LOW_LAT = 0x0,
            #[doc = "Low-power operation"]
            LOW_POWER = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl RxdModeLpop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxdModeLpop {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxdModeLpop {
            #[inline(always)]
            fn from(val: u8) -> RxdModeLpop {
                RxdModeLpop::from_bits(val)
            }
        }
        impl From<RxdModeLpop> for u8 {
            #[inline(always)]
            fn from(val: RxdModeLpop) -> u8 {
                RxdModeLpop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxtxen {
            #[doc = "Enable both reception and transmission. Data will be written to the RXD.PTR address and data transmitted from the TXD.PTR address."]
            DUPLEX = 0x0,
            #[doc = "Enable reception, disable transmission. Data will be written to the RXD.PTR address."]
            RX = 0x01,
            #[doc = "Enable transmission, disable reception. Data will be transmitted from the TXD.PTR address."]
            TX = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Rxtxen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxtxen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxtxen {
            #[inline(always)]
            fn from(val: u8) -> Rxtxen {
                Rxtxen::from_bits(val)
            }
        }
        impl From<Rxtxen> for u8 {
            #[inline(always)]
            fn from(val: Rxtxen) -> u8 {
                Rxtxen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SckSrcClksrc {
            #[doc = "Peripheral clock (instantiation table shows the TDM PCLK frequency)"]
            PCLK = 0x0,
            #[doc = "Audio PLL clock"]
            ACLK = 0x01,
        }
        impl SckSrcClksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SckSrcClksrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SckSrcClksrc {
            #[inline(always)]
            fn from(val: u8) -> SckSrcClksrc {
                SckSrcClksrc::from_bits(val)
            }
        }
        impl From<SckSrcClksrc> for u8 {
            #[inline(always)]
            fn from(val: SckSrcClksrc) -> u8 {
                SckSrcClksrc::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Sckdiv(u32);
        impl Sckdiv {
            #[doc = "CK divided by 125"]
            pub const CKDIV125: Self = Self(0x020c_0000);
            #[doc = "CK divided by 63"]
            pub const CKDIV63: Self = Self(0x0410_0000);
            #[doc = "CK divided by 42"]
            pub const CKDIV42: Self = Self(0x0600_0000);
            #[doc = "CK divided by 32"]
            pub const CKDIV32: Self = Self(0x0800_0000);
            #[doc = "CK divided by 31"]
            pub const CKDIV31: Self = Self(0x0840_0000);
            #[doc = "CK divided by 30"]
            pub const CKDIV30: Self = Self(0x0880_0000);
            #[doc = "CK divided by 23"]
            pub const CKDIV23: Self = Self(0x0b00_0000);
            #[doc = "CK divided by 21"]
            pub const CKDIV21: Self = Self(0x0c00_0000);
            #[doc = "CK divided by 16"]
            pub const CKDIV16: Self = Self(0x1000_0000);
            #[doc = "CK divided by 15"]
            pub const CKDIV15: Self = Self(0x1100_0000);
            #[doc = "CK divided by 11"]
            pub const CKDIV11: Self = Self(0x1600_0000);
            #[doc = "CK divided by 10"]
            pub const CKDIV10: Self = Self(0x1800_0000);
            #[doc = "CK divided by 8"]
            pub const CKDIV8: Self = Self(0x2000_0000);
            #[doc = "CK divided by 6"]
            pub const CKDIV6: Self = Self(0x2800_0000);
            #[doc = "CK divided by 5"]
            pub const CKDIV5: Self = Self(0x3000_0000);
            #[doc = "CK divided by 4"]
            pub const CKDIV4: Self = Self(0x4000_0000);
            #[doc = "CK divided by 3"]
            pub const CKDIV3: Self = Self(0x5000_0000);
            #[doc = "CK divided by 2"]
            pub const CKDIV2: Self = Self(0x8000_0000);
        }
        impl Sckdiv {
            pub const fn from_bits(val: u32) -> Sckdiv {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Sckdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x020c_0000 => f.write_str("CKDIV125"),
                    0x0410_0000 => f.write_str("CKDIV63"),
                    0x0600_0000 => f.write_str("CKDIV42"),
                    0x0800_0000 => f.write_str("CKDIV32"),
                    0x0840_0000 => f.write_str("CKDIV31"),
                    0x0880_0000 => f.write_str("CKDIV30"),
                    0x0b00_0000 => f.write_str("CKDIV23"),
                    0x0c00_0000 => f.write_str("CKDIV21"),
                    0x1000_0000 => f.write_str("CKDIV16"),
                    0x1100_0000 => f.write_str("CKDIV15"),
                    0x1600_0000 => f.write_str("CKDIV11"),
                    0x1800_0000 => f.write_str("CKDIV10"),
                    0x2000_0000 => f.write_str("CKDIV8"),
                    0x2800_0000 => f.write_str("CKDIV6"),
                    0x3000_0000 => f.write_str("CKDIV5"),
                    0x4000_0000 => f.write_str("CKDIV4"),
                    0x5000_0000 => f.write_str("CKDIV3"),
                    0x8000_0000 => f.write_str("CKDIV2"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sckdiv {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x020c_0000 => defmt::write!(f, "CKDIV125"),
                    0x0410_0000 => defmt::write!(f, "CKDIV63"),
                    0x0600_0000 => defmt::write!(f, "CKDIV42"),
                    0x0800_0000 => defmt::write!(f, "CKDIV32"),
                    0x0840_0000 => defmt::write!(f, "CKDIV31"),
                    0x0880_0000 => defmt::write!(f, "CKDIV30"),
                    0x0b00_0000 => defmt::write!(f, "CKDIV23"),
                    0x0c00_0000 => defmt::write!(f, "CKDIV21"),
                    0x1000_0000 => defmt::write!(f, "CKDIV16"),
                    0x1100_0000 => defmt::write!(f, "CKDIV15"),
                    0x1600_0000 => defmt::write!(f, "CKDIV11"),
                    0x1800_0000 => defmt::write!(f, "CKDIV10"),
                    0x2000_0000 => defmt::write!(f, "CKDIV8"),
                    0x2800_0000 => defmt::write!(f, "CKDIV6"),
                    0x3000_0000 => defmt::write!(f, "CKDIV5"),
                    0x4000_0000 => defmt::write!(f, "CKDIV4"),
                    0x5000_0000 => defmt::write!(f, "CKDIV3"),
                    0x8000_0000 => defmt::write!(f, "CKDIV2"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Sckdiv {
            #[inline(always)]
            fn from(val: u32) -> Sckdiv {
                Sckdiv::from_bits(val)
            }
        }
        impl From<Sckdiv> for u32 {
            #[inline(always)]
            fn from(val: Sckdiv) -> u32 {
                Sckdiv::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sckpolarity {
            #[doc = "TX data is written to the SDOUT pin on the falling edge of SCK, ready to be received on the rising edge of SCK."]
            POS_EDGE = 0x0,
            #[doc = "TX data is written to the SDOUT pin on the rising edge of SCK, ready to be received on the falling edge of SCK."]
            NEG_EDGE = 0x01,
        }
        impl Sckpolarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sckpolarity {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sckpolarity {
            #[inline(always)]
            fn from(val: u8) -> Sckpolarity {
                Sckpolarity::from_bits(val)
            }
        }
        impl From<Sckpolarity> for u8 {
            #[inline(always)]
            fn from(val: Sckpolarity) -> u8 {
                Sckpolarity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swidth {
            #[doc = "8 bit sample in an 8-bit word."]
            _8BIT = 0x0,
            #[doc = "16 bit sample in a 16-bit word."]
            _16BIT = 0x01,
            #[doc = "24 bit sample in a 24-bit word."]
            _24BIT = 0x02,
            #[doc = "32 bit sample in a 32-bit word."]
            _32BIT = 0x03,
            #[doc = "8 bit sample in a 16-bit word."]
            _8BIT_IN16 = 0x04,
            #[doc = "8 bit sample in a 32-bit word."]
            _8BIT_IN32 = 0x05,
            #[doc = "16 bit sample in a 32-bit word."]
            _16BIT_IN32 = 0x06,
            #[doc = "24 bit sample in a 32-bit word."]
            _24BIT_IN32 = 0x07,
        }
        impl Swidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swidth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swidth {
            #[inline(always)]
            fn from(val: u8) -> Swidth {
                Swidth::from_bits(val)
            }
        }
        impl From<Swidth> for u8 {
            #[inline(always)]
            fn from(val: Swidth) -> u8 {
                Swidth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxdModeLpop {
            #[doc = "Low-latency operation"]
            LOW_LAT = 0x0,
            #[doc = "Low-power operation"]
            LOW_POWER = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl TxdModeLpop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxdModeLpop {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxdModeLpop {
            #[inline(always)]
            fn from(val: u8) -> TxdModeLpop {
                TxdModeLpop::from_bits(val)
            }
        }
        impl From<TxdModeLpop> for u8 {
            #[inline(always)]
            fn from(val: TxdModeLpop) -> u8 {
                TxdModeLpop::to_bits(val)
            }
        }
    }
}
pub mod temp {
    #[doc = "Temperature Sensor 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Temp {
        ptr: *mut u8,
    }
    unsafe impl Send for Temp {}
    unsafe impl Sync for Temp {}
    impl Temp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start temperature measurement"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop temperature measurement"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Temperature measurement complete, data ready"]
        #[inline(always)]
        pub const fn events_datardy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Publish configuration for event DATARDY"]
        #[inline(always)]
        pub const fn publish_datardy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Temperature in degC (0.25deg steps)"]
        #[inline(always)]
        pub const fn temp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Slope of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn a(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize + n * 4usize) as _)
            }
        }
        #[doc = "y-intercept of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn b(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize + n * 4usize) as _)
            }
        }
        #[doc = "End point of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn t(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0560usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[must_use]
            #[inline(always)]
            pub const fn datardy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[inline(always)]
            pub const fn set_datardy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("datardy", &self.datardy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ datardy: {=bool:?} }}", self.datardy())
            }
        }
    }
}
pub mod timer {
    #[doc = "Timer/Counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer {}
    unsafe impl Sync for Timer {}
    impl Timer {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start Timer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop Timer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Increment Timer (Counter mode only)"]
        #[inline(always)]
        pub const fn tasks_count(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Clear time"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Capture Timer value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize + n * 4usize) as _)
            }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task COUNT"]
        #[inline(always)]
        pub const fn subscribe_count(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xc0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c0usize + n * 4usize) as _)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Timer mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Configure the number of bits used by the TIMER"]
        #[inline(always)]
        pub const fn bitmode(self) -> crate::common::Reg<regs::Bitmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Timer prescaler register"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Description collection: Capture/Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[inline(always)]
        pub const fn oneshoten(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Oneshoten, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0580usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Configure the number of bits used by the TIMER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bitmode(pub u32);
        impl Bitmode {
            #[doc = "Timer bit width"]
            #[must_use]
            #[inline(always)]
            pub const fn bitmode(&self) -> super::vals::Bitmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bitmode::from_bits(val as u8)
            }
            #[doc = "Timer bit width"]
            #[inline(always)]
            pub const fn set_bitmode(&mut self, val: super::vals::Bitmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Bitmode {
            #[inline(always)]
            fn default() -> Bitmode {
                Bitmode(0)
            }
        }
        impl core::fmt::Debug for Bitmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bitmode")
                    .field("bitmode", &self.bitmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bitmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bitmode {{ bitmode: {:?} }}", self.bitmode())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .field("compare[4]", &self.compare(4usize))
                    .field("compare[5]", &self.compare(5usize))
                    .field("compare[6]", &self.compare(6usize))
                    .field("compare[7]", &self.compare(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?}, compare[4]: {=bool:?}, compare[5]: {=bool:?}, compare[6]: {=bool:?}, compare[7]: {=bool:?} }}" , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize) , self . compare (4usize) , self . compare (5usize) , self . compare (6usize) , self . compare (7usize))
            }
        }
        #[doc = "Timer mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Timer mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Timer mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oneshoten(pub u32);
        impl Oneshoten {
            #[doc = "Enable one-shot operation"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshoten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable one-shot operation"]
            #[inline(always)]
            pub const fn set_oneshoten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Oneshoten {
            #[inline(always)]
            fn default() -> Oneshoten {
                Oneshoten(0)
            }
        }
        impl core::fmt::Debug for Oneshoten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oneshoten")
                    .field("oneshoten", &self.oneshoten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oneshoten {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oneshoten {{ oneshoten: {=bool:?} }}", self.oneshoten())
            }
        }
        #[doc = "Timer prescaler register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {=u8:?} }}", self.prescaler())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_clear(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn set_compare_clear(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_stop(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[inline(always)]
            pub const fn set_compare_stop(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("compare_clear[0]", &self.compare_clear(0usize))
                    .field("compare_clear[1]", &self.compare_clear(1usize))
                    .field("compare_clear[2]", &self.compare_clear(2usize))
                    .field("compare_clear[3]", &self.compare_clear(3usize))
                    .field("compare_clear[4]", &self.compare_clear(4usize))
                    .field("compare_clear[5]", &self.compare_clear(5usize))
                    .field("compare_clear[6]", &self.compare_clear(6usize))
                    .field("compare_clear[7]", &self.compare_clear(7usize))
                    .field("compare_stop[0]", &self.compare_stop(0usize))
                    .field("compare_stop[1]", &self.compare_stop(1usize))
                    .field("compare_stop[2]", &self.compare_stop(2usize))
                    .field("compare_stop[3]", &self.compare_stop(3usize))
                    .field("compare_stop[4]", &self.compare_stop(4usize))
                    .field("compare_stop[5]", &self.compare_stop(5usize))
                    .field("compare_stop[6]", &self.compare_stop(6usize))
                    .field("compare_stop[7]", &self.compare_stop(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ compare_clear[0]: {=bool:?}, compare_clear[1]: {=bool:?}, compare_clear[2]: {=bool:?}, compare_clear[3]: {=bool:?}, compare_clear[4]: {=bool:?}, compare_clear[5]: {=bool:?}, compare_clear[6]: {=bool:?}, compare_clear[7]: {=bool:?}, compare_stop[0]: {=bool:?}, compare_stop[1]: {=bool:?}, compare_stop[2]: {=bool:?}, compare_stop[3]: {=bool:?}, compare_stop[4]: {=bool:?}, compare_stop[5]: {=bool:?}, compare_stop[6]: {=bool:?}, compare_stop[7]: {=bool:?} }}" , self . compare_clear (0usize) , self . compare_clear (1usize) , self . compare_clear (2usize) , self . compare_clear (3usize) , self . compare_clear (4usize) , self . compare_clear (5usize) , self . compare_clear (6usize) , self . compare_clear (7usize) , self . compare_stop (0usize) , self . compare_stop (1usize) , self . compare_stop (2usize) , self . compare_stop (3usize) , self . compare_stop (4usize) , self . compare_stop (5usize) , self . compare_stop (6usize) , self . compare_stop (7usize))
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitmode {
            #[doc = "16 bit timer bit width"]
            _16BIT = 0x0,
            #[doc = "8 bit timer bit width"]
            _08BIT = 0x01,
            #[doc = "24 bit timer bit width"]
            _24BIT = 0x02,
            #[doc = "32 bit timer bit width"]
            _32BIT = 0x03,
        }
        impl Bitmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitmode {
            #[inline(always)]
            fn from(val: u8) -> Bitmode {
                Bitmode::from_bits(val)
            }
        }
        impl From<Bitmode> for u8 {
            #[inline(always)]
            fn from(val: Bitmode) -> u8 {
                Bitmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Select Timer mode"]
            TIMER = 0x0,
            #[doc = "Deprecated enumerator - Select Counter mode"]
            COUNTER = 0x01,
            #[doc = "Select Low Power Counter mode"]
            LOW_POWER_COUNTER = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod twim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that the transfer of MAXCNT bytes between memory and the peripheral has been fully completed."]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that the transfer of MAXCNT bytes between memory and the peripheral has been fully completed."]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Candidate, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twim {
        ptr: *mut u8,
    }
    unsafe impl Send for Twim {}
    unsafe impl Sync for Twim {}
    impl Twim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "SUSPEND task has been issued, TWI traffic is now suspended."]
        #[inline(always)]
        pub const fn events_suspended(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0128usize) as _) }
        }
        #[doc = "Byte boundary, starting to receive the last byte"]
        #[inline(always)]
        pub const fn events_lastrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0134usize) as _) }
        }
        #[doc = "Byte boundary, starting to transmit the last byte"]
        #[inline(always)]
        pub const fn events_lasttx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0138usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event SUSPENDED"]
        #[inline(always)]
        pub const fn publish_suspended(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event LASTRX"]
        #[inline(always)]
        pub const fn publish_lastrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event LASTTX"]
        #[inline(always)]
        pub const fn publish_lasttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04c4usize) as _) }
        }
        #[doc = "Enable TWIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[doc = "Address used in the TWI transfer"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0588usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address used in the TWI transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address used in the TWI transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Address used in the TWI transfer"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Candidate(pub u32);
        impl Candidate {
            #[doc = "Data to look for"]
            #[must_use]
            #[inline(always)]
            pub const fn data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data to look for"]
            #[inline(always)]
            pub const fn set_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Candidate {
            #[inline(always)]
            fn default() -> Candidate {
                Candidate(0)
            }
        }
        impl core::fmt::Debug for Candidate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Candidate")
                    .field("data", &self.data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Candidate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Candidate {{ data: {=u8:?} }}", self.data())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Enable TWIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn anack(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_anack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("anack", &self.anack())
                    .field("dnack", &self.dnack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overrun: {=bool:?}, anack: {=bool:?}, dnack: {=bool:?} }}",
                    self.overrun(),
                    self.anack(),
                    self.dnack()
                )
            }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "TWI master clock frequency"]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> super::vals::Frequency {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Frequency::from_bits(val as u32)
            }
            #[doc = "TWI master clock frequency"]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: super::vals::Frequency) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frequency {{ frequency: {:?} }}", self.frequency())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[must_use]
            #[inline(always)]
            pub const fn suspended(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[inline(always)]
            pub const fn set_suspended(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[inline(always)]
            pub const fn set_lastrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[inline(always)]
            pub const fn set_lasttx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("suspended", &self.suspended())
                    .field("lastrx", &self.lastrx())
                    .field("lasttx", &self.lasttx())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, suspended: {=bool:?}, lastrx: {=bool:?}, lasttx: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . stopped () , self . error () , self . suspended () , self . lastrx () , self . lasttx () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[inline(always)]
            pub const fn set_lasttx_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_suspend(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[inline(always)]
            pub const fn set_lasttx_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_stop(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[inline(always)]
            pub const fn set_lasttx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_dma_tx_start(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[inline(always)]
            pub const fn set_lastrx_dma_tx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_stop(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[inline(always)]
            pub const fn set_lastrx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("lasttx_dma_rx_start", &self.lasttx_dma_rx_start())
                    .field("lasttx_suspend", &self.lasttx_suspend())
                    .field("lasttx_stop", &self.lasttx_stop())
                    .field("lastrx_dma_tx_start", &self.lastrx_dma_tx_start())
                    .field("lastrx_stop", &self.lastrx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ lasttx_dma_rx_start: {=bool:?}, lasttx_suspend: {=bool:?}, lasttx_stop: {=bool:?}, lastrx_dma_tx_start: {=bool:?}, lastrx_stop: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . lasttx_dma_rx_start () , self . lasttx_suspend () , self . lasttx_stop () , self . lastrx_dma_tx_start () , self . lastrx_stop () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            #[doc = "Enable TWIM"]
            ENABLED = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frequency(u32);
        impl Frequency {
            #[doc = "100 kbps"]
            pub const K100: Self = Self(0x0198_0000);
            #[doc = "250 kbps"]
            pub const K250: Self = Self(0x0400_0000);
            #[doc = "400 kbps"]
            pub const K400: Self = Self(0x0640_0000);
            #[doc = "1000 kbps"]
            pub const K1000: Self = Self(0x0ff0_0000);
        }
        impl Frequency {
            pub const fn from_bits(val: u32) -> Frequency {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0198_0000 => f.write_str("K100"),
                    0x0400_0000 => f.write_str("K250"),
                    0x0640_0000 => f.write_str("K400"),
                    0x0ff0_0000 => f.write_str("K1000"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0198_0000 => defmt::write!(f, "K100"),
                    0x0400_0000 => defmt::write!(f, "K250"),
                    0x0640_0000 => defmt::write!(f, "K400"),
                    0x0ff0_0000 => defmt::write!(f, "K1000"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Frequency {
            #[inline(always)]
            fn from(val: u32) -> Frequency {
                Frequency::from_bits(val)
            }
        }
        impl From<Frequency> for u32 {
            #[inline(always)]
            fn from(val: Frequency) -> u32 {
                Frequency::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod twis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twis {
        ptr: *mut u8,
    }
    unsafe impl Send for Twis {}
    unsafe impl Sync for Twis {}
    impl Twis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a write command"]
        #[inline(always)]
        pub const fn tasks_preparerx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a read command"]
        #[inline(always)]
        pub const fn tasks_preparetx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARERX"]
        #[inline(always)]
        pub const fn subscribe_preparerx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARETX"]
        #[inline(always)]
        pub const fn subscribe_preparetx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0xb0usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Write command received"]
        #[inline(always)]
        pub const fn events_write(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x013cusize) as _) }
        }
        #[doc = "Read command received"]
        #[inline(always)]
        pub const fn events_read(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event WRITE"]
        #[inline(always)]
        pub const fn publish_write(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01bcusize) as _) }
        }
        #[doc = "Publish configuration for event READ"]
        #[inline(always)]
        pub const fn publish_read(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04d0usize) as _) }
        }
        #[doc = "Status register indicating which address had a match"]
        #[inline(always)]
        pub const fn match_(self) -> crate::common::Reg<regs::TwisMatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04d4usize) as _) }
        }
        #[doc = "Enable TWIS"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Description collection: TWI slave address n"]
        #[inline(always)]
        pub const fn address(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Address, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0588usize + n * 4usize) as _)
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::TwisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0594usize) as _) }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: TWI slave address n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "TWI slave address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "TWI slave address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Enable TWIS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIS"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIS"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overflow", &self.overflow())
                    .field("dnack", &self.dnack())
                    .field("overread", &self.overread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overflow: {=bool:?}, dnack: {=bool:?}, overread: {=bool:?} }}",
                    self.overflow(),
                    self.dnack(),
                    self.overread()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, write: {=bool:?}, read: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . stopped () , self . error () , self . write () , self . read () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn write_suspend(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[inline(always)]
            pub const fn set_write_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn read_suspend(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[inline(always)]
            pub const fn set_read_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("write_suspend", &self.write_suspend())
                    .field("read_suspend", &self.read_suspend())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ write_suspend: {=bool:?}, read_suspend: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . write_suspend () , self . read_suspend () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisConfig(pub u32);
        impl TwisConfig {
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[inline(always)]
            pub const fn set_address0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[inline(always)]
            pub const fn set_address1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for TwisConfig {
            #[inline(always)]
            fn default() -> TwisConfig {
                TwisConfig(0)
            }
        }
        impl core::fmt::Debug for TwisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisConfig")
                    .field("address0", &self.address0())
                    .field("address1", &self.address1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TwisConfig {{ address0: {=bool:?}, address1: {=bool:?} }}",
                    self.address0(),
                    self.address1()
                )
            }
        }
        #[doc = "Status register indicating which address had a match"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisMatch(pub u32);
        impl TwisMatch {
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[must_use]
            #[inline(always)]
            pub const fn match_(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[inline(always)]
            pub const fn set_match_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TwisMatch {
            #[inline(always)]
            fn default() -> TwisMatch {
                TwisMatch(0)
            }
        }
        impl core::fmt::Debug for TwisMatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisMatch")
                    .field("match_", &self.match_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisMatch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TwisMatch {{ match_: {=bool:?} }}", self.match_())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIS"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "Enable TWIS"]
            ENABLED = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod uarte {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after EasyDMA has completed its operation."]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after EasyDMA has completed its operation."]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Candidate, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for TXD signal"]
        #[inline(always)]
        pub const fn txd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for CTS signal"]
        #[inline(always)]
        pub const fn cts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for RXD signal"]
        #[inline(always)]
        pub const fn rxd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for RTS signal"]
        #[inline(always)]
        pub const fn rts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "UART with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uarte {
        ptr: *mut u8,
    }
    unsafe impl Send for Uarte {}
    unsafe impl Sync for Uarte {}
    impl Uarte {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Flush RX FIFO into RX buffer"]
        #[inline(always)]
        pub const fn tasks_flushrx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task FLUSHRX"]
        #[inline(always)]
        pub const fn subscribe_flushrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "CTS is activated (set low). Clear To Send."]
        #[inline(always)]
        pub const fn events_cts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "CTS is deactivated (set high). Not Clear To Send."]
        #[inline(always)]
        pub const fn events_ncts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Data sent from TXD"]
        #[inline(always)]
        pub const fn events_txdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Data received in RXD (but potentially not yet transferred to Data RAM)"]
        #[inline(always)]
        pub const fn events_rxdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Error detected"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Receiver timeout"]
        #[inline(always)]
        pub const fn events_rxto(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "Transmitter stopped"]
        #[inline(always)]
        pub const fn events_txstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0130usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Timed out due to bus being idle while receiving data."]
        #[inline(always)]
        pub const fn events_frametimeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0174usize) as _) }
        }
        #[doc = "Publish configuration for event CTS"]
        #[inline(always)]
        pub const fn publish_cts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event NCTS"]
        #[inline(always)]
        pub const fn publish_ncts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event TXDRDY"]
        #[inline(always)]
        pub const fn publish_txdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event RXDRDY"]
        #[inline(always)]
        pub const fn publish_rxdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXTO"]
        #[inline(always)]
        pub const fn publish_rxto(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event TXSTOPPED"]
        #[inline(always)]
        pub const fn publish_txstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMETIMEOUT"]
        #[inline(always)]
        pub const fn publish_frametimeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01f4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0480usize) as _) }
        }
        #[doc = "Enable UART"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn baudrate(self) -> crate::common::Reg<regs::Baudrate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::UarteConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x056cusize) as _) }
        }
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0574usize) as _) }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[inline(always)]
        pub const fn frametimeout(
            self,
        ) -> crate::common::Reg<regs::Frametimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0578usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0604usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Set address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Set address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Baudrate(pub u32);
        impl Baudrate {
            #[doc = "Baud rate"]
            #[must_use]
            #[inline(always)]
            pub const fn baudrate(&self) -> super::vals::Baudrate {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Baudrate::from_bits(val as u32)
            }
            #[doc = "Baud rate"]
            #[inline(always)]
            pub const fn set_baudrate(&mut self, val: super::vals::Baudrate) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Baudrate {
            #[inline(always)]
            fn default() -> Baudrate {
                Baudrate(0)
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Baudrate")
                    .field("baudrate", &self.baudrate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Baudrate {{ baudrate: {:?} }}", self.baudrate())
            }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Candidate(pub u32);
        impl Candidate {
            #[doc = "Data to look for"]
            #[must_use]
            #[inline(always)]
            pub const fn data(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Data to look for"]
            #[inline(always)]
            pub const fn set_data(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Candidate {
            #[inline(always)]
            fn default() -> Candidate {
                Candidate(0)
            }
        }
        impl core::fmt::Debug for Candidate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Candidate")
                    .field("data", &self.data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Candidate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Candidate {{ data: {=u8:?} }}", self.data())
            }
        }
        #[doc = "Enable UART"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable UARTE"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable UARTE"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity error"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Parity error"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Framing error occurred"]
            #[must_use]
            #[inline(always)]
            pub const fn framing(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Framing error occurred"]
            #[inline(always)]
            pub const fn set_framing(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Break condition"]
            #[must_use]
            #[inline(always)]
            pub const fn break_(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Break condition"]
            #[inline(always)]
            pub const fn set_break_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("parity", &self.parity())
                    .field("framing", &self.framing())
                    .field("break_", &self.break_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Errorsrc {{ overrun: {=bool:?}, parity: {=bool:?}, framing: {=bool:?}, break_: {=bool:?} }}" , self . overrun () , self . parity () , self . framing () , self . break_ ())
            }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frametimeout(pub u32);
        impl Frametimeout {
            #[doc = "Number of UARTE bits before timeout."]
            #[must_use]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Number of UARTE bits before timeout."]
            #[inline(always)]
            pub const fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Frametimeout {
            #[inline(always)]
            fn default() -> Frametimeout {
                Frametimeout(0)
            }
        }
        impl core::fmt::Debug for Frametimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frametimeout")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frametimeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Frametimeout {{ countertop: {=u16:?} }}",
                    self.countertop()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CTS"]
            #[must_use]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CTS"]
            #[inline(always)]
            pub const fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[must_use]
            #[inline(always)]
            pub const fn ncts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[inline(always)]
            pub const fn set_ncts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn txdrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[inline(always)]
            pub const fn set_txdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdrdy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[inline(always)]
            pub const fn set_rxdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[must_use]
            #[inline(always)]
            pub const fn rxto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[inline(always)]
            pub const fn set_rxto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn txstopped(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[inline(always)]
            pub const fn set_txstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[inline(always)]
            pub const fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cts", &self.cts())
                    .field("ncts", &self.ncts())
                    .field("txdrdy", &self.txdrdy())
                    .field("rxdrdy", &self.rxdrdy())
                    .field("error", &self.error())
                    .field("rxto", &self.rxto())
                    .field("txstopped", &self.txstopped())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ cts: {=bool:?}, ncts: {=bool:?}, txdrdy: {=bool:?}, rxdrdy: {=bool:?}, error: {=bool:?}, rxto: {=bool:?}, txstopped: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?}, frametimeout: {=bool:?} }}" , self . cts () , self . ncts () , self . txdrdy () , self . rxdrdy () , self . error () , self . rxto () , self . txstopped () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror () , self . frametimeout ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or continous"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or continous"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[inline(always)]
            pub const fn set_dma_rx_end_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn set_dma_rx_end_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_tx_end_dma_tx_stop(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[inline(always)]
            pub const fn set_dma_tx_end_dma_tx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn set_frametimeout_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("dma_rx_end_dma_rx_start", &self.dma_rx_end_dma_rx_start())
                    .field("dma_rx_end_dma_rx_stop", &self.dma_rx_end_dma_rx_stop())
                    .field("dma_tx_end_dma_tx_stop", &self.dma_tx_end_dma_tx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .field("frametimeout_dma_rx_stop", &self.frametimeout_dma_rx_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ dma_rx_end_dma_rx_start: {=bool:?}, dma_rx_end_dma_rx_stop: {=bool:?}, dma_tx_end_dma_tx_stop: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?}, frametimeout_dma_rx_stop: {=bool:?} }}" , self . dma_rx_end_dma_rx_start () , self . dma_rx_end_dma_rx_stop () , self . dma_tx_end_dma_tx_stop () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 () , self . frametimeout_dma_rx_stop ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct UarteConfig(pub u32);
        impl UarteConfig {
            #[doc = "Hardware flow control"]
            #[must_use]
            #[inline(always)]
            pub const fn hwfc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware flow control"]
            #[inline(always)]
            pub const fn set_hwfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> super::vals::ConfigParity {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::ConfigParity::from_bits(val as u8)
            }
            #[doc = "Parity"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: super::vals::ConfigParity) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "Stop bits"]
            #[must_use]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::ConfigStop {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ConfigStop::from_bits(val as u8)
            }
            #[doc = "Stop bits"]
            #[inline(always)]
            pub const fn set_stop(&mut self, val: super::vals::ConfigStop) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Even or odd parity type"]
            #[must_use]
            #[inline(always)]
            pub const fn paritytype(&self) -> super::vals::Paritytype {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Paritytype::from_bits(val as u8)
            }
            #[doc = "Even or odd parity type"]
            #[inline(always)]
            pub const fn set_paritytype(&mut self, val: super::vals::Paritytype) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Set the data frame size"]
            #[must_use]
            #[inline(always)]
            pub const fn framesize(&self) -> super::vals::Framesize {
                let val = (self.0 >> 9usize) & 0x0f;
                super::vals::Framesize::from_bits(val as u8)
            }
            #[doc = "Set the data frame size"]
            #[inline(always)]
            pub const fn set_framesize(&mut self, val: super::vals::Framesize) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val.to_bits() as u32) & 0x0f) << 9usize);
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable packet timeout."]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable packet timeout."]
            #[inline(always)]
            pub const fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for UarteConfig {
            #[inline(always)]
            fn default() -> UarteConfig {
                UarteConfig(0)
            }
        }
        impl core::fmt::Debug for UarteConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("UarteConfig")
                    .field("hwfc", &self.hwfc())
                    .field("parity", &self.parity())
                    .field("stop", &self.stop())
                    .field("paritytype", &self.paritytype())
                    .field("framesize", &self.framesize())
                    .field("endian", &self.endian())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for UarteConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "UarteConfig {{ hwfc: {=bool:?}, parity: {:?}, stop: {:?}, paritytype: {:?}, framesize: {:?}, endian: {:?}, frametimeout: {=bool:?} }}" , self . hwfc () , self . parity () , self . stop () , self . paritytype () , self . framesize () , self . endian () , self . frametimeout ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Baudrate(u32);
        impl Baudrate {
            #[doc = "1200 baud (actual rate: 1205) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1200: Self = Self(0x0004_f000);
            #[doc = "2400 baud (actual rate: 2396) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD2400: Self = Self(0x0009_d000);
            #[doc = "4800 baud (actual rate: 4808) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD4800: Self = Self(0x0013_b000);
            #[doc = "9600 baud (actual rate: 9598) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD9600: Self = Self(0x0027_5000);
            #[doc = "14400 baud (actual rate: 14401) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD14400: Self = Self(0x003a_f000);
            #[doc = "19200 baud (actual rate: 19208) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD19200: Self = Self(0x004e_a000);
            #[doc = "28800 baud (actual rate: 28777) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD28800: Self = Self(0x0075_c000);
            #[doc = "31250 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD31250: Self = Self(0x0080_0000);
            #[doc = "38400 baud (actual rate: 38369) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD38400: Self = Self(0x009d_0000);
            #[doc = "56000 baud (actual rate: 55944) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD56000: Self = Self(0x00e5_0000);
            #[doc = "57600 baud (actual rate: 57554) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD57600: Self = Self(0x00eb_0000);
            #[doc = "76800 baud (actual rate: 76923) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD76800: Self = Self(0x013a_9000);
            #[doc = "115200 baud (actual rate: 115108) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD115200: Self = Self(0x01d6_0000);
            #[doc = "230400 baud (actual rate: 231884) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD230400: Self = Self(0x03b0_0000);
            #[doc = "250000 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD250000: Self = Self(0x0400_0000);
            #[doc = "460800 baud (actual rate: 457143) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD460800: Self = Self(0x0740_0000);
            #[doc = "921600 baud (actual rate: 941176) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD921600: Self = Self(0x0f00_0000);
            #[doc = "1 megabaud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1M: Self = Self(0x1000_0000);
        }
        impl Baudrate {
            pub const fn from_bits(val: u32) -> Baudrate {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0004_f000 => f.write_str("BAUD1200"),
                    0x0009_d000 => f.write_str("BAUD2400"),
                    0x0013_b000 => f.write_str("BAUD4800"),
                    0x0027_5000 => f.write_str("BAUD9600"),
                    0x003a_f000 => f.write_str("BAUD14400"),
                    0x004e_a000 => f.write_str("BAUD19200"),
                    0x0075_c000 => f.write_str("BAUD28800"),
                    0x0080_0000 => f.write_str("BAUD31250"),
                    0x009d_0000 => f.write_str("BAUD38400"),
                    0x00e5_0000 => f.write_str("BAUD56000"),
                    0x00eb_0000 => f.write_str("BAUD57600"),
                    0x013a_9000 => f.write_str("BAUD76800"),
                    0x01d6_0000 => f.write_str("BAUD115200"),
                    0x03b0_0000 => f.write_str("BAUD230400"),
                    0x0400_0000 => f.write_str("BAUD250000"),
                    0x0740_0000 => f.write_str("BAUD460800"),
                    0x0f00_0000 => f.write_str("BAUD921600"),
                    0x1000_0000 => f.write_str("BAUD1M"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0004_f000 => defmt::write!(f, "BAUD1200"),
                    0x0009_d000 => defmt::write!(f, "BAUD2400"),
                    0x0013_b000 => defmt::write!(f, "BAUD4800"),
                    0x0027_5000 => defmt::write!(f, "BAUD9600"),
                    0x003a_f000 => defmt::write!(f, "BAUD14400"),
                    0x004e_a000 => defmt::write!(f, "BAUD19200"),
                    0x0075_c000 => defmt::write!(f, "BAUD28800"),
                    0x0080_0000 => defmt::write!(f, "BAUD31250"),
                    0x009d_0000 => defmt::write!(f, "BAUD38400"),
                    0x00e5_0000 => defmt::write!(f, "BAUD56000"),
                    0x00eb_0000 => defmt::write!(f, "BAUD57600"),
                    0x013a_9000 => defmt::write!(f, "BAUD76800"),
                    0x01d6_0000 => defmt::write!(f, "BAUD115200"),
                    0x03b0_0000 => defmt::write!(f, "BAUD230400"),
                    0x0400_0000 => defmt::write!(f, "BAUD250000"),
                    0x0740_0000 => defmt::write!(f, "BAUD460800"),
                    0x0f00_0000 => defmt::write!(f, "BAUD921600"),
                    0x1000_0000 => defmt::write!(f, "BAUD1M"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Baudrate {
            #[inline(always)]
            fn from(val: u32) -> Baudrate {
                Baudrate::from_bits(val)
            }
        }
        impl From<Baudrate> for u32 {
            #[inline(always)]
            fn from(val: Baudrate) -> u32 {
                Baudrate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigParity {
            #[doc = "Exclude parity bit"]
            EXCLUDED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Include parity bit"]
            INCLUDED = 0x07,
        }
        impl ConfigParity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigParity {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigParity {
            #[inline(always)]
            fn from(val: u8) -> ConfigParity {
                ConfigParity::from_bits(val)
            }
        }
        impl From<ConfigParity> for u8 {
            #[inline(always)]
            fn from(val: ConfigParity) -> u8 {
                ConfigParity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigStop {
            #[doc = "One stop bit"]
            ONE = 0x0,
            #[doc = "Two stop bits"]
            TWO = 0x01,
        }
        impl ConfigStop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigStop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigStop {
            #[inline(always)]
            fn from(val: u8) -> ConfigStop {
                ConfigStop::from_bits(val)
            }
        }
        impl From<ConfigStop> for u8 {
            #[inline(always)]
            fn from(val: ConfigStop) -> u8 {
                ConfigStop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable UARTE"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "Enable UARTE"]
            ENABLED = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Data is trimmed from MSB end."]
            MSB = 0x0,
            #[doc = "Data is trimmed from LSB end."]
            LSB = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framesize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "4 bit data frame size."]
            _4BIT = 0x04,
            #[doc = "5 bit data frame size."]
            _5BIT = 0x05,
            #[doc = "6 bit data frame size."]
            _6BIT = 0x06,
            #[doc = "7 bit data frame size."]
            _7BIT = 0x07,
            #[doc = "8 bit data frame size."]
            _8BIT = 0x08,
            #[doc = "9 bit data frame size. 9th bit is treated as address bit."]
            _9BIT = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Framesize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framesize {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framesize {
            #[inline(always)]
            fn from(val: u8) -> Framesize {
                Framesize::from_bits(val)
            }
        }
        impl From<Framesize> for u8 {
            #[inline(always)]
            fn from(val: Framesize) -> u8 {
                Framesize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Paritytype {
            #[doc = "Even parity"]
            EVEN = 0x0,
            #[doc = "Odd parity"]
            ODD = 0x01,
        }
        impl Paritytype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Paritytype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Paritytype {
            #[inline(always)]
            fn from(val: u8) -> Paritytype {
                Paritytype::from_bits(val)
            }
        }
        impl From<Paritytype> for u8 {
            #[inline(always)]
            fn from(val: Paritytype) -> u8 {
                Paritytype::to_bits(val)
            }
        }
    }
}
pub mod uicr {
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Approtect {
        ptr: *mut u8,
    }
    unsafe impl Send for Approtect {}
    unsafe impl Sync for Approtect {}
    impl Approtect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Authopkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Authopkey {}
    unsafe impl Sync for Authopkey {}
    impl Authopkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::AuthopkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Auxapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Auxapprotect {}
    unsafe impl Sync for Auxapprotect {}
    impl Auxapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Erase Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Pubkey {}
    unsafe impl Sync for Pubkey {}
    impl Pubkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PubkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Assets installed to establish initial Root of Trust in the device."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rot {
        ptr: *mut u8,
    }
    unsafe impl Send for Rot {}
    unsafe impl Sync for Rot {}
    impl Rot {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pubkey(self, n: usize) -> Pubkey {
            assert!(n < 4usize);
            unsafe { Pubkey::from_ptr(self.ptr.wrapping_add(0x0usize + n * 44usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn authopkey(self, n: usize) -> Authopkey {
            assert!(n < 4usize);
            unsafe { Authopkey::from_ptr(self.ptr.wrapping_add(0xb0usize + n * 44usize) as _) }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Secureapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Secureapprotect {}
    unsafe impl Sync for Secureapprotect {}
    impl Secureapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    #[doc = "User Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Uicr {}
    unsafe impl Sync for Uicr {}
    impl Uicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn approtect(self, n: usize) -> Approtect {
            assert!(n < 1usize);
            unsafe { Approtect::from_ptr(self.ptr.wrapping_add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn secureapprotect(self, n: usize) -> Secureapprotect {
            assert!(n < 1usize);
            unsafe {
                Secureapprotect::from_ptr(self.ptr.wrapping_add(0x20usize + n * 32usize) as _)
            }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn auxapprotect(self, n: usize) -> Auxapprotect {
            assert!(n < 1usize);
            unsafe { Auxapprotect::from_ptr(self.ptr.wrapping_add(0x40usize + n * 32usize) as _) }
        }
        #[doc = "Erase Protection Registers"]
        #[inline(always)]
        pub const fn eraseprotect(self, n: usize) -> Eraseprotect {
            assert!(n < 1usize);
            unsafe { Eraseprotect::from_ptr(self.ptr.wrapping_add(0x60usize + n * 32usize) as _) }
        }
        #[doc = "Immutable boot region configuration."]
        #[inline(always)]
        pub const fn bootconf(self) -> crate::common::Reg<regs::Bootconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn user(self) -> User {
            unsafe { User::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Description collection: One time programmable memory"]
        #[inline(always)]
        pub const fn otp(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 320usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct User {
        ptr: *mut u8,
    }
    unsafe impl Send for User {}
    unsafe impl Sync for User {}
    impl User {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Assets installed to establish initial Root of Trust in the device."]
        #[inline(always)]
        pub const fn rot(self) -> Rot {
            unsafe { Rot::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect0(pub u32);
        impl ApprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::ApprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect0 {
            #[inline(always)]
            fn default() -> ApprotectProtect0 {
                ApprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect1(pub u32);
        impl ApprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::ApprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect1 {
            #[inline(always)]
            fn default() -> ApprotectProtect1 {
                ApprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuthopkeyRevoke(pub u32);
        impl AuthopkeyRevoke {
            #[doc = "Revocation status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::AuthopkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuthopkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::AuthopkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuthopkeyRevoke {
            #[inline(always)]
            fn default() -> AuthopkeyRevoke {
                AuthopkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for AuthopkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuthopkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuthopkeyRevoke {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect0(pub u32);
        impl AuxapprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::AuxapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect0 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect0 {
                AuxapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxapprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect1(pub u32);
        impl AuxapprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::AuxapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect1 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect1 {
                AuxapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxapprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Immutable boot region configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bootconf(pub u32);
        impl Bootconf {
            #[doc = "Read access. Must be enabled in order for the Arm Cortex CPU to start executing from RRAM."]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access. Must be enabled in order for the Arm Cortex CPU to start executing from RRAM."]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write-once"]
            #[must_use]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock of configuration register"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock of configuration register"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Immutable boot region size"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x7f;
                val as u8
            }
            #[doc = "Immutable boot region size"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
            }
        }
        impl Default for Bootconf {
            #[inline(always)]
            fn default() -> Bootconf {
                Bootconf(0)
            }
        }
        impl core::fmt::Debug for Bootconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bootconf")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bootconf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bootconf {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, writeonce: {=bool:?}, lock: {=bool:?}, size: {=u8:?} }}" , self . read () , self . write () , self . execute () , self . secure () , self . writeonce () , self . lock () , self . size ())
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect0(pub u32);
        impl EraseprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::EraseprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect0 {
            #[inline(always)]
            fn default() -> EraseprotectProtect0 {
                EraseprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect1(pub u32);
        impl EraseprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::EraseprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect1 {
            #[inline(always)]
            fn default() -> EraseprotectProtect1 {
                EraseprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PubkeyRevoke(pub u32);
        impl PubkeyRevoke {
            #[doc = "Revocation status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::PubkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::PubkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::PubkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PubkeyRevoke {
            #[inline(always)]
            fn default() -> PubkeyRevoke {
                PubkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for PubkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PubkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PubkeyRevoke {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect0(pub u32);
        impl SecureapprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::SecureapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect0 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect0 {
                SecureapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SecureapprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect1(pub u32);
        impl SecureapprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::SecureapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect1 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect1 {
                SecureapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SecureapprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect0Pall(u32);
        impl ApprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect0Pall {
                ApprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect0Pall) -> u32 {
                ApprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect1Pall(u32);
        impl ApprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect1Pall {
                ApprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect1Pall) -> u32 {
                ApprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuthopkeyRevokeStatus(u32);
        impl AuthopkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl AuthopkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> AuthopkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuthopkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuthopkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> AuthopkeyRevokeStatus {
                AuthopkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<AuthopkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: AuthopkeyRevokeStatus) -> u32 {
                AuthopkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect0Pall(u32);
        impl AuxapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN signal protector unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect0Pall {
                AuxapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect0Pall) -> u32 {
                AuxapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect1Pall(u32);
        impl AuxapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN signal protector unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect1Pall {
                AuxapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect1Pall) -> u32 {
                AuxapprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect0Pall(u32);
        impl EraseprotectProtect0Pall {
            #[doc = "Erase protection is enabled and the signal protector is locked."]
            pub const PROTECTED: Self = Self(0x50fa_50fa);
        }
        impl EraseprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa_50fa => f.write_str("PROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa_50fa => defmt::write!(f, "PROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect0Pall {
                EraseprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect0Pall) -> u32 {
                EraseprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect1Pall(u32);
        impl EraseprotectProtect1Pall {
            #[doc = "Erase protection is enabled and the signal protector is locked."]
            pub const PROTECTED: Self = Self(0x50fa_50fa);
        }
        impl EraseprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa_50fa => f.write_str("PROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa_50fa => defmt::write!(f, "PROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect1Pall {
                EraseprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect1Pall) -> u32 {
                EraseprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct PubkeyRevokeStatus(u32);
        impl PubkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl PubkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> PubkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for PubkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for PubkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> PubkeyRevokeStatus {
                PubkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<PubkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: PubkeyRevokeStatus) -> u32 {
                PubkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect0Pall(u32);
        impl SecureapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect0Pall {
                SecureapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect0Pall) -> u32 {
                SecureapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect1Pall(u32);
        impl SecureapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect1Pall {
                SecureapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect1Pall) -> u32 {
                SecureapprotectProtect1Pall::to_bits(val)
            }
        }
    }
}
pub mod usbhs {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Phy {
        ptr: *mut u8,
    }
    unsafe impl Send for Phy {}
    unsafe impl Sync for Phy {}
    impl Phy {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "USB PHY parameter overrides"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "USB PHY clock configurations"]
        #[inline(always)]
        pub const fn clock(self) -> crate::common::Reg<regs::Clock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Enables overriding of individual signals to the PHY, the override values are set in PHY.OVERRIDEVALUES"]
        #[inline(always)]
        pub const fn inputoverride(
            self,
        ) -> crate::common::Reg<regs::Inputoverride, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Values that are used to override the input signals to the PHY."]
        #[inline(always)]
        pub const fn overridevalues(
            self,
        ) -> crate::common::Reg<regs::Overridevalues, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "The RTUNE mode is an alternative method for calibrating the DP and DM 45-Ohm source impedance."]
        #[inline(always)]
        pub const fn rtune(self) -> crate::common::Reg<regs::Rtune, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "USBHS 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Usbhs {
        ptr: *mut u8,
    }
    unsafe impl Send for Usbhs {}
    unsafe impl Sync for Usbhs {}
    impl Usbhs {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the USB peripheral."]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop the USB peripheral"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for SOF event."]
        #[inline(always)]
        pub const fn publish_sof(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Enable USB peripheral."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn phy(self) -> Phy {
            unsafe { Phy::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "USB PHY clock configurations"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clock(pub u32);
        impl Clock {
            #[doc = "Select reference clock frequency"]
            #[must_use]
            #[inline(always)]
            pub const fn fsel(&self) -> super::vals::Fsel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Fsel::from_bits(val as u8)
            }
            #[doc = "Select reference clock frequency"]
            #[inline(always)]
            pub const fn set_fsel(&mut self, val: super::vals::Fsel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "PLL bandwidth adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn pllbtune(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "PLL bandwidth adjustment"]
            #[inline(always)]
            pub const fn set_pllbtune(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Common block power down control"]
            #[must_use]
            #[inline(always)]
            pub const fn commononn(&self) -> super::vals::Commononn {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Commononn::from_bits(val as u8)
            }
            #[doc = "Common block power down control"]
            #[inline(always)]
            pub const fn set_commononn(&mut self, val: super::vals::Commononn) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Clock {
            #[inline(always)]
            fn default() -> Clock {
                Clock(0)
            }
        }
        impl core::fmt::Debug for Clock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clock")
                    .field("fsel", &self.fsel())
                    .field("pllbtune", &self.pllbtune())
                    .field("commononn", &self.commononn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clock {{ fsel: {:?}, pllbtune: {=bool:?}, commononn: {:?} }}",
                    self.fsel(),
                    self.pllbtune(),
                    self.commononn()
                )
            }
        }
        #[doc = "USB PHY parameter overrides"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "PLL Integral Path Tune"]
            #[must_use]
            #[inline(always)]
            pub const fn pllitune(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "PLL Integral Path Tune"]
            #[inline(always)]
            pub const fn set_pllitune(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "PLL Proportional Path Tune"]
            #[must_use]
            #[inline(always)]
            pub const fn pllptune(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x0f;
                val as u8
            }
            #[doc = "PLL Proportional Path Tune"]
            #[inline(always)]
            pub const fn set_pllptune(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 2usize)) | (((val as u32) & 0x0f) << 2usize);
            }
            #[doc = "Disconnect Threshold Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn compdistune0(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x07;
                val as u8
            }
            #[doc = "Disconnect Threshold Adjustment"]
            #[inline(always)]
            pub const fn set_compdistune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val as u32) & 0x07) << 6usize);
            }
            #[doc = "Squelch Threshold Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn sqrxtune0(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x07;
                val as u8
            }
            #[doc = "Squelch Threshold Adjustment"]
            #[inline(always)]
            pub const fn set_sqrxtune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 9usize)) | (((val as u32) & 0x07) << 9usize);
            }
            #[doc = "Data Detect Voltage Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn vdatreftune0(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x03;
                val as u8
            }
            #[doc = "Data Detect Voltage Adjustment"]
            #[inline(always)]
            pub const fn set_vdatreftune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize);
            }
            #[doc = "Transmitter High-Speed Crossover Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn txhsxvtune0(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0x03;
                val as u8
            }
            #[doc = "Transmitter High-Speed Crossover Adjustment"]
            #[inline(always)]
            pub const fn set_txhsxvtune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize);
            }
            #[doc = "FS/LS Source Impedance Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn txfslstune0(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "FS/LS Source Impedance Adjustment"]
            #[inline(always)]
            pub const fn set_txfslstune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "HS DC Voltage Level Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn txvreftune0(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "HS DC Voltage Level Adjustment"]
            #[inline(always)]
            pub const fn set_txvreftune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "HS Transmitter Rise/Fall Time Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn txrisetune0(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x03;
                val as u8
            }
            #[doc = "HS Transmitter Rise/Fall Time Adjustment"]
            #[inline(always)]
            pub const fn set_txrisetune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize);
            }
            #[doc = "USB Source Impedance Adjustment"]
            #[must_use]
            #[inline(always)]
            pub const fn txrestune0(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x03;
                val as u8
            }
            #[doc = "USB Source Impedance Adjustment"]
            #[inline(always)]
            pub const fn set_txrestune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize);
            }
            #[doc = "HS Transmitter Pre-Emphasis Current Control"]
            #[must_use]
            #[inline(always)]
            pub const fn txpreempamptune0(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x03;
                val as u8
            }
            #[doc = "HS Transmitter Pre-Emphasis Current Control"]
            #[inline(always)]
            pub const fn set_txpreempamptune0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize);
            }
            #[doc = "HS Transmitter Pre-Emphasis Duration Control"]
            #[must_use]
            #[inline(always)]
            pub const fn txpreemppulsetune0(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "HS Transmitter Pre-Emphasis Duration Control"]
            #[inline(always)]
            pub const fn set_txpreemppulsetune0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("pllitune", &self.pllitune())
                    .field("pllptune", &self.pllptune())
                    .field("compdistune0", &self.compdistune0())
                    .field("sqrxtune0", &self.sqrxtune0())
                    .field("vdatreftune0", &self.vdatreftune0())
                    .field("txhsxvtune0", &self.txhsxvtune0())
                    .field("txfslstune0", &self.txfslstune0())
                    .field("txvreftune0", &self.txvreftune0())
                    .field("txrisetune0", &self.txrisetune0())
                    .field("txrestune0", &self.txrestune0())
                    .field("txpreempamptune0", &self.txpreempamptune0())
                    .field("txpreemppulsetune0", &self.txpreemppulsetune0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ pllitune: {=u8:?}, pllptune: {=u8:?}, compdistune0: {=u8:?}, sqrxtune0: {=u8:?}, vdatreftune0: {=u8:?}, txhsxvtune0: {=u8:?}, txfslstune0: {=u8:?}, txvreftune0: {=u8:?}, txrisetune0: {=u8:?}, txrestune0: {=u8:?}, txpreempamptune0: {=u8:?}, txpreemppulsetune0: {=bool:?} }}" , self . pllitune () , self . pllptune () , self . compdistune0 () , self . sqrxtune0 () , self . vdatreftune0 () , self . txhsxvtune0 () , self . txfslstune0 () , self . txvreftune0 () , self . txrisetune0 () , self . txrestune0 () , self . txpreempamptune0 () , self . txpreemppulsetune0 ())
            }
        }
        #[doc = "Enable USB peripheral."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable USB Controller"]
            #[must_use]
            #[inline(always)]
            pub const fn core(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable USB Controller"]
            #[inline(always)]
            pub const fn set_core(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable USB PHY"]
            #[must_use]
            #[inline(always)]
            pub const fn phy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable USB PHY"]
            #[inline(always)]
            pub const fn set_phy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("core", &self.core())
                    .field("phy", &self.phy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Enable {{ core: {=bool:?}, phy: {=bool:?} }}",
                    self.core(),
                    self.phy()
                )
            }
        }
        #[doc = "Enables overriding of individual signals to the PHY, the override values are set in PHY.OVERRIDEVALUES"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inputoverride(pub u32);
        impl Inputoverride {
            #[must_use]
            #[inline(always)]
            pub const fn dppulldown(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_dppulldown(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dmpulldown(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_dmpulldown(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn vbusvalid(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_vbusvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Overrides OTG ID pin signal"]
            #[must_use]
            #[inline(always)]
            pub const fn id(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Overrides OTG ID pin signal"]
            #[inline(always)]
            pub const fn set_id(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Inputoverride {
            #[inline(always)]
            fn default() -> Inputoverride {
                Inputoverride(0)
            }
        }
        impl core::fmt::Debug for Inputoverride {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inputoverride")
                    .field("dppulldown", &self.dppulldown())
                    .field("dmpulldown", &self.dmpulldown())
                    .field("vbusvalid", &self.vbusvalid())
                    .field("id", &self.id())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inputoverride {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Inputoverride {{ dppulldown: {=bool:?}, dmpulldown: {=bool:?}, vbusvalid: {=bool:?}, id: {=bool:?} }}" , self . dppulldown () , self . dmpulldown () , self . vbusvalid () , self . id ())
            }
        }
        #[doc = "Values that are used to override the input signals to the PHY."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Overridevalues(pub u32);
        impl Overridevalues {
            #[doc = "This field controls the pull-down resistor on D+"]
            #[must_use]
            #[inline(always)]
            pub const fn dppulldown(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "This field controls the pull-down resistor on D+"]
            #[inline(always)]
            pub const fn set_dppulldown(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "This field controls the pull-down resistor on D-"]
            #[must_use]
            #[inline(always)]
            pub const fn dmpulldown(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "This field controls the pull-down resistor on D-"]
            #[inline(always)]
            pub const fn set_dmpulldown(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Signals to the PHY that VBUS is valid, and enables the pull-up resistor on D+"]
            #[must_use]
            #[inline(always)]
            pub const fn vbusvalid(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Signals to the PHY that VBUS is valid, and enables the pull-up resistor on D+"]
            #[inline(always)]
            pub const fn set_vbusvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Overrides OTG ID pin signal"]
            #[must_use]
            #[inline(always)]
            pub const fn id(&self) -> super::vals::Id {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Id::from_bits(val as u8)
            }
            #[doc = "Overrides OTG ID pin signal"]
            #[inline(always)]
            pub const fn set_id(&mut self, val: super::vals::Id) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Overridevalues {
            #[inline(always)]
            fn default() -> Overridevalues {
                Overridevalues(0)
            }
        }
        impl core::fmt::Debug for Overridevalues {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Overridevalues")
                    .field("dppulldown", &self.dppulldown())
                    .field("dmpulldown", &self.dmpulldown())
                    .field("vbusvalid", &self.vbusvalid())
                    .field("id", &self.id())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Overridevalues {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Overridevalues {{ dppulldown: {=bool:?}, dmpulldown: {=bool:?}, vbusvalid: {=bool:?}, id: {:?} }}" , self . dppulldown () , self . dmpulldown () , self . vbusvalid () , self . id ())
            }
        }
        #[doc = "The RTUNE mode is an alternative method for calibrating the DP and DM 45-Ohm source impedance."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rtune(pub u32);
        impl Rtune {
            #[doc = "This signal selects the tuning method for the high-speed DP and DM source impedance of the USBHS."]
            #[must_use]
            #[inline(always)]
            pub const fn rtunesel(&self) -> super::vals::Rtunesel {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rtunesel::from_bits(val as u8)
            }
            #[doc = "This signal selects the tuning method for the high-speed DP and DM source impedance of the USBHS."]
            #[inline(always)]
            pub const fn set_rtunesel(&mut self, val: super::vals::Rtunesel) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "This signal is used to tune the internal 200 ohm resistor or the USBHS DP and DM high-speed source impedance."]
            #[must_use]
            #[inline(always)]
            pub const fn rcalcode(&self) -> u8 {
                let val = (self.0 >> 1usize) & 0x0f;
                val as u8
            }
            #[doc = "This signal is used to tune the internal 200 ohm resistor or the USBHS DP and DM high-speed source impedance."]
            #[inline(always)]
            pub const fn set_rcalcode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val as u32) & 0x0f) << 1usize);
            }
        }
        impl Default for Rtune {
            #[inline(always)]
            fn default() -> Rtune {
                Rtune(0)
            }
        }
        impl core::fmt::Debug for Rtune {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rtune")
                    .field("rtunesel", &self.rtunesel())
                    .field("rcalcode", &self.rcalcode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rtune {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rtune {{ rtunesel: {:?}, rcalcode: {=u8:?} }}",
                    self.rtunesel(),
                    self.rcalcode()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Commononn {
            #[doc = "The REFCLOCK_LOGIC,bias and PLL blocks are powered in sleep or suspend mode."]
            POWERED = 0x0,
            #[doc = "The REFCLOCK_LOGIC, bias and PLL blocks are powered down in suspend mode and bias and PLL blocks are powered down in sleep mode."]
            SUSPEND = 0x01,
        }
        impl Commononn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Commononn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Commononn {
            #[inline(always)]
            fn from(val: u8) -> Commononn {
                Commononn::from_bits(val)
            }
        }
        impl From<Commononn> for u8 {
            #[inline(always)]
            fn from(val: Commononn) -> u8 {
                Commononn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fsel {
            #[doc = "Reference clock is 19.2MHz."]
            CLOCK19200KHZ = 0x0,
            #[doc = "Reference clock is 20MHz."]
            CLOCK20000KHZ = 0x01,
            #[doc = "Reference clock is 24MHz."]
            CLOCK24000KHZ = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Reference clock is 50MHz."]
            CLOCK50000KHZ = 0x07,
        }
        impl Fsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fsel {
            #[inline(always)]
            fn from(val: u8) -> Fsel {
                Fsel::from_bits(val)
            }
        }
        impl From<Fsel> for u8 {
            #[inline(always)]
            fn from(val: Fsel) -> u8 {
                Fsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id {
            #[doc = "Role is Host."]
            HOST = 0x0,
            #[doc = "Role is Device"]
            DEVICE = 0x01,
        }
        impl Id {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id {
            #[inline(always)]
            fn from(val: u8) -> Id {
                Id::from_bits(val)
            }
        }
        impl From<Id> for u8 {
            #[inline(always)]
            fn from(val: Id) -> u8 {
                Id::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rtunesel {
            #[doc = "The RCALCODE value is used for tuning the high-speed source impedance."]
            RTUNE = 0x0,
            #[doc = "The TXRTUNE pin, external resistor REXT, and resulting internal digital calibration code are used for tuning the high-speed source impedance."]
            TXRTUNE = 0x01,
        }
        impl Rtunesel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rtunesel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rtunesel {
            #[inline(always)]
            fn from(val: u8) -> Rtunesel {
                Rtunesel::from_bits(val)
            }
        }
        impl From<Rtunesel> for u8 {
            #[inline(always)]
            fn from(val: Rtunesel) -> u8 {
                Rtunesel::to_bits(val)
            }
        }
    }
}
pub mod usbhscore {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dwcotgdfifo {
        ptr: *mut u8,
    }
    unsafe impl Send for Dwcotgdfifo {}
    unsafe impl Sync for Dwcotgdfifo {}
    impl Dwcotgdfifo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Data FIFO Access Register Map 0"]
        #[inline(always)]
        pub const fn data(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 1024usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dwcotgdfifodirectaccess {
        ptr: *mut u8,
    }
    unsafe impl Send for Dwcotgdfifodirectaccess {}
    unsafe impl Sync for Dwcotgdfifodirectaccess {}
    impl Dwcotgdfifodirectaccess {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Data FIFO Direct Access Register Map"]
        #[inline(always)]
        pub const fn data(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 3073usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hc {
        ptr: *mut u8,
    }
    unsafe impl Send for Hc {}
    unsafe impl Sync for Hc {}
    impl Hc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Host Channel Characteristics Register"]
        #[inline(always)]
        pub const fn char(self) -> crate::common::Reg<regs::Char, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Host Channel Interrupt Register"]
        #[inline(always)]
        pub const fn int(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Host Channel Interrupt Mask Register"]
        #[inline(always)]
        pub const fn intmsk(self) -> crate::common::Reg<regs::Intmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Description cluster: Host Channel Transfer Size Register"]
        #[inline(always)]
        pub const fn tsiz(self) -> crate::common::Reg<regs::Tsiz, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Host Channel DMA Address Register"]
        #[inline(always)]
        pub const fn dma(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
    }
    #[doc = "USBHSCORE 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Usbhscore {
        ptr: *mut u8,
    }
    unsafe impl Send for Usbhscore {}
    unsafe impl Sync for Usbhscore {}
    impl Usbhscore {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control and Status Register"]
        #[inline(always)]
        pub const fn gotgctl(self) -> crate::common::Reg<regs::Gotgctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Interrupt Register"]
        #[inline(always)]
        pub const fn gotgint(self) -> crate::common::Reg<regs::Gotgint, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "AHB Configuration Register"]
        #[inline(always)]
        pub const fn gahbcfg(self) -> crate::common::Reg<regs::Gahbcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "USB Configuration Register"]
        #[inline(always)]
        pub const fn gusbcfg(self) -> crate::common::Reg<regs::Gusbcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Reset Register"]
        #[inline(always)]
        pub const fn grstctl(self) -> crate::common::Reg<regs::Grstctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Interrupt Register"]
        #[inline(always)]
        pub const fn gintsts(self) -> crate::common::Reg<regs::Gintsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Interrupt Mask Register"]
        #[inline(always)]
        pub const fn gintmsk(self) -> crate::common::Reg<regs::Gintmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Receive Status Debug Read Register"]
        #[inline(always)]
        pub const fn grxstsr(self) -> crate::common::Reg<regs::Grxstsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Receive Status Read/Pop Register"]
        #[inline(always)]
        pub const fn grxstsp(self) -> crate::common::Reg<regs::Grxstsp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Receive FIFO Size Register"]
        #[inline(always)]
        pub const fn grxfsiz(self) -> crate::common::Reg<regs::Grxfsiz, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Non-periodic Transmit FIFO Size Register"]
        #[inline(always)]
        pub const fn gnptxfsiz(self) -> crate::common::Reg<regs::Gnptxfsiz, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Non-periodic Transmit FIFO/Queue Status Register"]
        #[inline(always)]
        pub const fn gnptxsts(self) -> crate::common::Reg<regs::Gnptxsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "General Purpose Input/Output Register"]
        #[inline(always)]
        pub const fn ggpio(self) -> crate::common::Reg<regs::Ggpio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "User ID Register"]
        #[inline(always)]
        pub const fn guid(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
        #[doc = "Identification register"]
        #[inline(always)]
        pub const fn gsnpsid(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize) as _) }
        }
        #[doc = "User Hardware Configuration 1 Register"]
        #[inline(always)]
        pub const fn ghwcfg1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
        #[doc = "User Hardware Configuration 2 Register"]
        #[inline(always)]
        pub const fn ghwcfg2(self) -> crate::common::Reg<regs::Ghwcfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x48usize) as _) }
        }
        #[doc = "User Hardware Configuration 3 Register"]
        #[inline(always)]
        pub const fn ghwcfg3(self) -> crate::common::Reg<regs::Ghwcfg3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x4cusize) as _) }
        }
        #[doc = "User Hardware Configuration 4 Register"]
        #[inline(always)]
        pub const fn ghwcfg4(self) -> crate::common::Reg<regs::Ghwcfg4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x50usize) as _) }
        }
        #[doc = "LPM Config Register"]
        #[inline(always)]
        pub const fn glpmcfg(self) -> crate::common::Reg<regs::Glpmcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x54usize) as _) }
        }
        #[doc = "Global Power Down Register"]
        #[inline(always)]
        pub const fn gpwrdn(self) -> crate::common::Reg<regs::Gpwrdn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x58usize) as _) }
        }
        #[doc = "Global DFIFO Configuration Register"]
        #[inline(always)]
        pub const fn gdfifocfg(self) -> crate::common::Reg<regs::Gdfifocfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x5cusize) as _) }
        }
        #[doc = "Interrupt Mask Register 2"]
        #[inline(always)]
        pub const fn gintmsk2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x68usize) as _) }
        }
        #[doc = "Interrupt Register 2"]
        #[inline(always)]
        pub const fn gintsts2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x6cusize) as _) }
        }
        #[doc = "Host Periodic Transmit FIFO Size Register"]
        #[inline(always)]
        pub const fn hptxfsiz(self) -> crate::common::Reg<regs::Hptxfsiz, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Description collection: Device IN Endpoint Transmit FIFO Size Register"]
        #[inline(always)]
        pub const fn dieptxf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Dieptxf, crate::common::RW> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize + n * 4usize) as _)
            }
        }
        #[doc = "Host Configuration Register"]
        #[inline(always)]
        pub const fn hcfg(self) -> crate::common::Reg<regs::Hcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Host Frame Interval Register"]
        #[inline(always)]
        pub const fn hfir(self) -> crate::common::Reg<regs::Hfir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Host Frame Number/Frame Time Remaining Register"]
        #[inline(always)]
        pub const fn hfnum(self) -> crate::common::Reg<regs::Hfnum, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0408usize) as _) }
        }
        #[doc = "Host All Channels Interrupt Register"]
        #[inline(always)]
        pub const fn haint(self) -> crate::common::Reg<regs::Haint, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0414usize) as _) }
        }
        #[doc = "Host All Channels Interrupt Mask Register"]
        #[inline(always)]
        pub const fn haintmsk(self) -> crate::common::Reg<regs::Haintmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0418usize) as _) }
        }
        #[doc = "Host Port Control and Status Register"]
        #[inline(always)]
        pub const fn hprt(self) -> crate::common::Reg<regs::Hprt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn hc(self, n: usize) -> Hc {
            assert!(n < 16usize);
            unsafe { Hc::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 28usize) as _) }
        }
        #[doc = "Device Configuration Register"]
        #[inline(always)]
        pub const fn dcfg(self) -> crate::common::Reg<regs::Dcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0800usize) as _) }
        }
        #[doc = "Device Control Register"]
        #[inline(always)]
        pub const fn dctl(self) -> crate::common::Reg<regs::Dctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0804usize) as _) }
        }
        #[doc = "Device Status Register"]
        #[inline(always)]
        pub const fn dsts(self) -> crate::common::Reg<regs::Dsts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0808usize) as _) }
        }
        #[doc = "Device IN Endpoint Common Interrupt Mask Register"]
        #[inline(always)]
        pub const fn diepmsk(self) -> crate::common::Reg<regs::Diepmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0810usize) as _) }
        }
        #[doc = "Device OUT Endpoint Common Interrupt Mask Register"]
        #[inline(always)]
        pub const fn doepmsk(self) -> crate::common::Reg<regs::Doepmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0814usize) as _) }
        }
        #[doc = "Device All Endpoints Interrupt Register"]
        #[inline(always)]
        pub const fn daint(self) -> crate::common::Reg<regs::Daint, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0818usize) as _) }
        }
        #[doc = "Device All Endpoints Interrupt Mask Register"]
        #[inline(always)]
        pub const fn daintmsk(self) -> crate::common::Reg<regs::Daintmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x081cusize) as _) }
        }
        #[doc = "Device VBUS Discharge Time Register"]
        #[inline(always)]
        pub const fn dvbusdis(self) -> crate::common::Reg<regs::Dvbusdis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0828usize) as _) }
        }
        #[doc = "Device VBUS Pulsing Time Register"]
        #[inline(always)]
        pub const fn dvbuspulse(self) -> crate::common::Reg<regs::Dvbuspulse, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x082cusize) as _) }
        }
        #[doc = "Device Threshold Control Register"]
        #[inline(always)]
        pub const fn dthrctl(self) -> crate::common::Reg<regs::Dthrctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0830usize) as _) }
        }
        #[doc = "Device IN Endpoint FIFO Empty Interrupt Mask Register"]
        #[inline(always)]
        pub const fn diepempmsk(self) -> crate::common::Reg<regs::Diepempmsk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0834usize) as _) }
        }
        #[doc = "Device Control IN Endpoint 0 Control Register"]
        #[inline(always)]
        pub const fn diepctl0(self) -> crate::common::Reg<regs::Diepctl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0900usize) as _) }
        }
        #[doc = "Device IN Endpoint 0 Interrupt Register"]
        #[inline(always)]
        pub const fn diepint0(self) -> crate::common::Reg<regs::Diepint0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0908usize) as _) }
        }
        #[doc = "Device IN Endpoint 0 Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz0(self) -> crate::common::Reg<regs::Dieptsiz0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0910usize) as _) }
        }
        #[doc = "Device IN Endpoint 0 DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0914usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register 0"]
        #[inline(always)]
        pub const fn dtxfsts0(self) -> crate::common::Reg<regs::Dtxfsts0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0918usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl1(self) -> crate::common::Reg<regs::Diepctl1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0920usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint1(self) -> crate::common::Reg<regs::Diepint1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0928usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz1(self) -> crate::common::Reg<regs::Dieptsiz1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0930usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0934usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts1(self) -> crate::common::Reg<regs::Dtxfsts1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0938usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl2(self) -> crate::common::Reg<regs::Diepctl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0940usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint2(self) -> crate::common::Reg<regs::Diepint2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0948usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz2(self) -> crate::common::Reg<regs::Dieptsiz2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0950usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0954usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts2(self) -> crate::common::Reg<regs::Dtxfsts2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0958usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl3(self) -> crate::common::Reg<regs::Diepctl3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0960usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint3(self) -> crate::common::Reg<regs::Diepint3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0968usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz3(self) -> crate::common::Reg<regs::Dieptsiz3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0970usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0974usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts3(self) -> crate::common::Reg<regs::Dtxfsts3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0978usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl4(self) -> crate::common::Reg<regs::Diepctl4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0980usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint4(self) -> crate::common::Reg<regs::Diepint4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0988usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz4(self) -> crate::common::Reg<regs::Dieptsiz4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0990usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0994usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts4(self) -> crate::common::Reg<regs::Dtxfsts4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0998usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl5(self) -> crate::common::Reg<regs::Diepctl5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09a0usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint5(self) -> crate::common::Reg<regs::Diepint5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09a8usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz5(self) -> crate::common::Reg<regs::Dieptsiz5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09b0usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma5(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09b4usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts5(self) -> crate::common::Reg<regs::Dtxfsts5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09b8usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl6(self) -> crate::common::Reg<regs::Diepctl6, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09c0usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint6(self) -> crate::common::Reg<regs::Diepint6, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09c8usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz6(self) -> crate::common::Reg<regs::Dieptsiz6, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09d0usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma6(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09d4usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts6(self) -> crate::common::Reg<regs::Dtxfsts6, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09d8usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl7(self) -> crate::common::Reg<regs::Diepctl7, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09e0usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint7(self) -> crate::common::Reg<regs::Diepint7, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09e8usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz7(self) -> crate::common::Reg<regs::Dieptsiz7, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09f0usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma7(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09f4usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts7(self) -> crate::common::Reg<regs::Dtxfsts7, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x09f8usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl8(self) -> crate::common::Reg<regs::Diepctl8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a00usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint8(self) -> crate::common::Reg<regs::Diepint8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a08usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz8(self) -> crate::common::Reg<regs::Dieptsiz8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a10usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma8(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a14usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts8(self) -> crate::common::Reg<regs::Dtxfsts8, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a18usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl9(self) -> crate::common::Reg<regs::Diepctl9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a20usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint9(self) -> crate::common::Reg<regs::Diepint9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a28usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz9(self) -> crate::common::Reg<regs::Dieptsiz9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a30usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma9(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a34usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts9(self) -> crate::common::Reg<regs::Dtxfsts9, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a38usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl10(self) -> crate::common::Reg<regs::Diepctl10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a40usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint10(self) -> crate::common::Reg<regs::Diepint10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a48usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz10(self) -> crate::common::Reg<regs::Dieptsiz10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a50usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma10(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a54usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts10(self) -> crate::common::Reg<regs::Dtxfsts10, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a58usize) as _) }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[inline(always)]
        pub const fn diepctl11(self) -> crate::common::Reg<regs::Diepctl11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a60usize) as _) }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn diepint11(self) -> crate::common::Reg<regs::Diepint11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a68usize) as _) }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn dieptsiz11(self) -> crate::common::Reg<regs::Dieptsiz11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a70usize) as _) }
        }
        #[doc = "Device IN Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn diepdma11(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a74usize) as _) }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[inline(always)]
        pub const fn dtxfsts11(self) -> crate::common::Reg<regs::Dtxfsts11, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a78usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint 0 Control Register"]
        #[inline(always)]
        pub const fn doepctl0(self) -> crate::common::Reg<regs::Doepctl0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b00usize) as _) }
        }
        #[doc = "Device OUT Endpoint 0 Interrupt Register"]
        #[inline(always)]
        pub const fn doepint0(self) -> crate::common::Reg<regs::Doepint0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b08usize) as _) }
        }
        #[doc = "Device OUT Endpoint 0 Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz0(self) -> crate::common::Reg<regs::Doeptsiz0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b10usize) as _) }
        }
        #[doc = "Device OUT Endpoint 0 DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b14usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl1(self) -> crate::common::Reg<regs::Doepctl1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b20usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint1(self) -> crate::common::Reg<regs::Doepint1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b28usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz1(self) -> crate::common::Reg<regs::Doeptsiz1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b30usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b34usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl2(self) -> crate::common::Reg<regs::Doepctl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b40usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint2(self) -> crate::common::Reg<regs::Doepint2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b48usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz2(self) -> crate::common::Reg<regs::Doeptsiz2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b50usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b54usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl3(self) -> crate::common::Reg<regs::Doepctl3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b60usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint3(self) -> crate::common::Reg<regs::Doepint3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b68usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz3(self) -> crate::common::Reg<regs::Doeptsiz3, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b70usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b74usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl4(self) -> crate::common::Reg<regs::Doepctl4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b80usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint4(self) -> crate::common::Reg<regs::Doepint4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b88usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz4(self) -> crate::common::Reg<regs::Doeptsiz4, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b90usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b94usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl5(self) -> crate::common::Reg<regs::Doepctl5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ba0usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint5(self) -> crate::common::Reg<regs::Doepint5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ba8usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz5(self) -> crate::common::Reg<regs::Doeptsiz5, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0bb0usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma5(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0bb4usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl12(self) -> crate::common::Reg<regs::Doepctl12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c80usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint12(self) -> crate::common::Reg<regs::Doepint12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c88usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz12(self) -> crate::common::Reg<regs::Doeptsiz12, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c90usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma12(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c94usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl13(self) -> crate::common::Reg<regs::Doepctl13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ca0usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint13(self) -> crate::common::Reg<regs::Doepint13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ca8usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz13(self) -> crate::common::Reg<regs::Doeptsiz13, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cb0usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma13(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cb4usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl14(self) -> crate::common::Reg<regs::Doepctl14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cc0usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint14(self) -> crate::common::Reg<regs::Doepint14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cc8usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz14(self) -> crate::common::Reg<regs::Doeptsiz14, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cd0usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma14(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cd4usize) as _) }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[inline(always)]
        pub const fn doepctl15(self) -> crate::common::Reg<regs::Doepctl15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ce0usize) as _) }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[inline(always)]
        pub const fn doepint15(self) -> crate::common::Reg<regs::Doepint15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ce8usize) as _) }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[inline(always)]
        pub const fn doeptsiz15(self) -> crate::common::Reg<regs::Doeptsiz15, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cf0usize) as _) }
        }
        #[doc = "Device OUT Endpoint DMA Address Register"]
        #[inline(always)]
        pub const fn doepdma15(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cf4usize) as _) }
        }
        #[doc = "Power and Clock Gating Control Register"]
        #[inline(always)]
        pub const fn pcgcctl(self) -> crate::common::Reg<regs::Pcgcctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0e00usize) as _) }
        }
        #[doc = "Global STAR Fix Disable Register"]
        #[inline(always)]
        pub const fn gstarfxdis(self) -> crate::common::Reg<regs::Gstarfxdis, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dwcotgdfifo(self, n: usize) -> Dwcotgdfifo {
            assert!(n < 16usize);
            unsafe {
                Dwcotgdfifo::from_ptr(self.ptr.wrapping_add(0x1000usize + n * 4096usize) as _)
            }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dwcotgdfifodirectaccess(self) -> Dwcotgdfifodirectaccess {
            unsafe {
                Dwcotgdfifodirectaccess::from_ptr(self.ptr.wrapping_add(0x0001_1000usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Host Channel Characteristics Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Char(pub u32);
        impl Char {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Endpoint Number (EPNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn epnum(&self) -> super::vals::Epnum {
                let val = (self.0 >> 11usize) & 0x0f;
                super::vals::Epnum::from_bits(val as u8)
            }
            #[doc = "Endpoint Number (EPNum)"]
            #[inline(always)]
            pub const fn set_epnum(&mut self, val: super::vals::Epnum) {
                self.0 =
                    (self.0 & !(0x0f << 11usize)) | (((val.to_bits() as u32) & 0x0f) << 11usize);
            }
            #[doc = "Endpoint Direction (EPDir)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdir(&self) -> super::vals::Epdir {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Epdir::from_bits(val as u8)
            }
            #[doc = "Endpoint Direction (EPDir)"]
            #[inline(always)]
            pub const fn set_epdir(&mut self, val: super::vals::Epdir) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Low-Speed Device (LSpdDev)"]
            #[must_use]
            #[inline(always)]
            pub const fn lspddev(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Low-Speed Device (LSpdDev)"]
            #[inline(always)]
            pub const fn set_lspddev(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::CharEptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::CharEptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::CharEptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "Multi Count (MC) / Error Count (EC)"]
            #[must_use]
            #[inline(always)]
            pub const fn ec(&self) -> super::vals::Ec {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::Ec::from_bits(val as u8)
            }
            #[doc = "Multi Count (MC) / Error Count (EC)"]
            #[inline(always)]
            pub const fn set_ec(&mut self, val: super::vals::Ec) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "Device Address (DevAddr)"]
            #[must_use]
            #[inline(always)]
            pub const fn devaddr(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x7f;
                val as u8
            }
            #[doc = "Device Address (DevAddr)"]
            #[inline(always)]
            pub const fn set_devaddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 22usize)) | (((val as u32) & 0x7f) << 22usize);
            }
            #[doc = "Odd Frame (OddFrm)"]
            #[must_use]
            #[inline(always)]
            pub const fn oddfrm(&self) -> super::vals::Oddfrm {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Oddfrm::from_bits(val as u8)
            }
            #[doc = "Odd Frame (OddFrm)"]
            #[inline(always)]
            pub const fn set_oddfrm(&mut self, val: super::vals::Oddfrm) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Channel Disable (ChDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn chdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Channel Disable (ChDis)"]
            #[inline(always)]
            pub const fn set_chdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Channel Enable (ChEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn chena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Channel Enable (ChEna)"]
            #[inline(always)]
            pub const fn set_chena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Char {
            #[inline(always)]
            fn default() -> Char {
                Char(0)
            }
        }
        impl core::fmt::Debug for Char {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Char")
                    .field("mps", &self.mps())
                    .field("epnum", &self.epnum())
                    .field("epdir", &self.epdir())
                    .field("lspddev", &self.lspddev())
                    .field("eptype", &self.eptype())
                    .field("ec", &self.ec())
                    .field("devaddr", &self.devaddr())
                    .field("oddfrm", &self.oddfrm())
                    .field("chdis", &self.chdis())
                    .field("chena", &self.chena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Char {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Char {{ mps: {=u16:?}, epnum: {:?}, epdir: {:?}, lspddev: {=bool:?}, eptype: {:?}, ec: {:?}, devaddr: {=u8:?}, oddfrm: {:?}, chdis: {=bool:?}, chena: {=bool:?} }}" , self . mps () , self . epnum () , self . epdir () , self . lspddev () , self . eptype () , self . ec () , self . devaddr () , self . oddfrm () , self . chdis () , self . chena ())
            }
        }
        #[doc = "Device All Endpoints Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Daint(pub u32);
        impl Daint {
            #[doc = "IN Endpoint 0 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 0 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "IN Endpoint 1 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 1 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "IN Endpoint 2 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 2 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "IN Endpoint 3 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 3 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Endpoint 4 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 4 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Endpoint 5 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 5 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint 6 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 6 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "IN Endpoint 7 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 7 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "IN Endpoint 8 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 8 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "IN Endpoint 9 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 9 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "IN Endpoint 10 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 10 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "IN Endpoint 11 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepint11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint 11 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_inepint11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "OUT Endpoint 0 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 0 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "OUT Endpoint 1 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 1 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "OUT Endpoint 2 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 2 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "OUT Endpoint 3 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 3 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "OUT Endpoint 4 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 4 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "OUT Endpoint 5 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 5 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "OUT Endpoint 12 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint12(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 12 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "OUT Endpoint 13 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint13(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 13 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "OUT Endpoint 14 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint14(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 14 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "OUT Endpoint 15 Interrupt Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepint15(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Endpoint 15 Interrupt Bit"]
            #[inline(always)]
            pub const fn set_outepint15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Daint {
            #[inline(always)]
            fn default() -> Daint {
                Daint(0)
            }
        }
        impl core::fmt::Debug for Daint {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Daint")
                    .field("inepint0", &self.inepint0())
                    .field("inepint1", &self.inepint1())
                    .field("inepint2", &self.inepint2())
                    .field("inepint3", &self.inepint3())
                    .field("inepint4", &self.inepint4())
                    .field("inepint5", &self.inepint5())
                    .field("inepint6", &self.inepint6())
                    .field("inepint7", &self.inepint7())
                    .field("inepint8", &self.inepint8())
                    .field("inepint9", &self.inepint9())
                    .field("inepint10", &self.inepint10())
                    .field("inepint11", &self.inepint11())
                    .field("outepint0", &self.outepint0())
                    .field("outepint1", &self.outepint1())
                    .field("outepint2", &self.outepint2())
                    .field("outepint3", &self.outepint3())
                    .field("outepint4", &self.outepint4())
                    .field("outepint5", &self.outepint5())
                    .field("outepint12", &self.outepint12())
                    .field("outepint13", &self.outepint13())
                    .field("outepint14", &self.outepint14())
                    .field("outepint15", &self.outepint15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Daint {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Daint {{ inepint0: {=bool:?}, inepint1: {=bool:?}, inepint2: {=bool:?}, inepint3: {=bool:?}, inepint4: {=bool:?}, inepint5: {=bool:?}, inepint6: {=bool:?}, inepint7: {=bool:?}, inepint8: {=bool:?}, inepint9: {=bool:?}, inepint10: {=bool:?}, inepint11: {=bool:?}, outepint0: {=bool:?}, outepint1: {=bool:?}, outepint2: {=bool:?}, outepint3: {=bool:?}, outepint4: {=bool:?}, outepint5: {=bool:?}, outepint12: {=bool:?}, outepint13: {=bool:?}, outepint14: {=bool:?}, outepint15: {=bool:?} }}" , self . inepint0 () , self . inepint1 () , self . inepint2 () , self . inepint3 () , self . inepint4 () , self . inepint5 () , self . inepint6 () , self . inepint7 () , self . inepint8 () , self . inepint9 () , self . inepint10 () , self . inepint11 () , self . outepint0 () , self . outepint1 () , self . outepint2 () , self . outepint3 () , self . outepint4 () , self . outepint5 () , self . outepint12 () , self . outepint13 () , self . outepint14 () , self . outepint15 ())
            }
        }
        #[doc = "Device All Endpoints Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Daintmsk(pub u32);
        impl Daintmsk {
            #[doc = "IN Endpoint 0 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk0(&self) -> super::vals::Inepmsk0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Inepmsk0::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 0 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk0(&mut self, val: super::vals::Inepmsk0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "IN Endpoint 1 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk1(&self) -> super::vals::Inepmsk1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Inepmsk1::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 1 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk1(&mut self, val: super::vals::Inepmsk1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "IN Endpoint 2 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk2(&self) -> super::vals::Inepmsk2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Inepmsk2::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 2 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk2(&mut self, val: super::vals::Inepmsk2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "IN Endpoint 3 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk3(&self) -> super::vals::Inepmsk3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Inepmsk3::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 3 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk3(&mut self, val: super::vals::Inepmsk3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Endpoint 4 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk4(&self) -> super::vals::Inepmsk4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Inepmsk4::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 4 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk4(&mut self, val: super::vals::Inepmsk4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Endpoint 5 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk5(&self) -> super::vals::Inepmsk5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Inepmsk5::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 5 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk5(&mut self, val: super::vals::Inepmsk5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint 6 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk6(&self) -> super::vals::Inepmsk6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Inepmsk6::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 6 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk6(&mut self, val: super::vals::Inepmsk6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "IN Endpoint 7 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk7(&self) -> super::vals::Inepmsk7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Inepmsk7::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 7 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk7(&mut self, val: super::vals::Inepmsk7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "IN Endpoint 8 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk8(&self) -> super::vals::Inepmsk8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Inepmsk8::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 8 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk8(&mut self, val: super::vals::Inepmsk8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "IN Endpoint 9 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk9(&self) -> super::vals::Inepmsk9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Inepmsk9::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 9 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk9(&mut self, val: super::vals::Inepmsk9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "IN Endpoint 10 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk10(&self) -> super::vals::Inepmsk10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Inepmsk10::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 10 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk10(&mut self, val: super::vals::Inepmsk10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "IN Endpoint 11 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn inepmsk11(&self) -> super::vals::Inepmsk11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Inepmsk11::from_bits(val as u8)
            }
            #[doc = "IN Endpoint 11 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_inepmsk11(&mut self, val: super::vals::Inepmsk11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "OUT Endpoint 0 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk0(&self) -> super::vals::Outepmsk0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Outepmsk0::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 0 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk0(&mut self, val: super::vals::Outepmsk0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "OUT Endpoint 1 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk1(&self) -> super::vals::Outepmsk1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Outepmsk1::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 1 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk1(&mut self, val: super::vals::Outepmsk1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "OUT Endpoint 2 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk2(&self) -> super::vals::Outepmsk2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Outepmsk2::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 2 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk2(&mut self, val: super::vals::Outepmsk2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "OUT Endpoint 3 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk3(&self) -> super::vals::Outepmsk3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Outepmsk3::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 3 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk3(&mut self, val: super::vals::Outepmsk3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "OUT Endpoint 4 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk4(&self) -> super::vals::Outepmsk4 {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Outepmsk4::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 4 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk4(&mut self, val: super::vals::Outepmsk4) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "OUT Endpoint 5 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk5(&self) -> super::vals::Outepmsk5 {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Outepmsk5::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 5 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk5(&mut self, val: super::vals::Outepmsk5) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "OUT Endpoint 12 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk12(&self) -> super::vals::Outepmsk12 {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Outepmsk12::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 12 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk12(&mut self, val: super::vals::Outepmsk12) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "OUT Endpoint 13 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk13(&self) -> super::vals::Outepmsk13 {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Outepmsk13::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 13 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk13(&mut self, val: super::vals::Outepmsk13) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "OUT Endpoint 14 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk14(&self) -> super::vals::Outepmsk14 {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Outepmsk14::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 14 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk14(&mut self, val: super::vals::Outepmsk14) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "OUT Endpoint 15 Interrupt mask Bit"]
            #[must_use]
            #[inline(always)]
            pub const fn outepmsk15(&self) -> super::vals::Outepmsk15 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Outepmsk15::from_bits(val as u8)
            }
            #[doc = "OUT Endpoint 15 Interrupt mask Bit"]
            #[inline(always)]
            pub const fn set_outepmsk15(&mut self, val: super::vals::Outepmsk15) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Daintmsk {
            #[inline(always)]
            fn default() -> Daintmsk {
                Daintmsk(0)
            }
        }
        impl core::fmt::Debug for Daintmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Daintmsk")
                    .field("inepmsk0", &self.inepmsk0())
                    .field("inepmsk1", &self.inepmsk1())
                    .field("inepmsk2", &self.inepmsk2())
                    .field("inepmsk3", &self.inepmsk3())
                    .field("inepmsk4", &self.inepmsk4())
                    .field("inepmsk5", &self.inepmsk5())
                    .field("inepmsk6", &self.inepmsk6())
                    .field("inepmsk7", &self.inepmsk7())
                    .field("inepmsk8", &self.inepmsk8())
                    .field("inepmsk9", &self.inepmsk9())
                    .field("inepmsk10", &self.inepmsk10())
                    .field("inepmsk11", &self.inepmsk11())
                    .field("outepmsk0", &self.outepmsk0())
                    .field("outepmsk1", &self.outepmsk1())
                    .field("outepmsk2", &self.outepmsk2())
                    .field("outepmsk3", &self.outepmsk3())
                    .field("outepmsk4", &self.outepmsk4())
                    .field("outepmsk5", &self.outepmsk5())
                    .field("outepmsk12", &self.outepmsk12())
                    .field("outepmsk13", &self.outepmsk13())
                    .field("outepmsk14", &self.outepmsk14())
                    .field("outepmsk15", &self.outepmsk15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Daintmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Daintmsk {{ inepmsk0: {:?}, inepmsk1: {:?}, inepmsk2: {:?}, inepmsk3: {:?}, inepmsk4: {:?}, inepmsk5: {:?}, inepmsk6: {:?}, inepmsk7: {:?}, inepmsk8: {:?}, inepmsk9: {:?}, inepmsk10: {:?}, inepmsk11: {:?}, outepmsk0: {:?}, outepmsk1: {:?}, outepmsk2: {:?}, outepmsk3: {:?}, outepmsk4: {:?}, outepmsk5: {:?}, outepmsk12: {:?}, outepmsk13: {:?}, outepmsk14: {:?}, outepmsk15: {:?} }}" , self . inepmsk0 () , self . inepmsk1 () , self . inepmsk2 () , self . inepmsk3 () , self . inepmsk4 () , self . inepmsk5 () , self . inepmsk6 () , self . inepmsk7 () , self . inepmsk8 () , self . inepmsk9 () , self . inepmsk10 () , self . inepmsk11 () , self . outepmsk0 () , self . outepmsk1 () , self . outepmsk2 () , self . outepmsk3 () , self . outepmsk4 () , self . outepmsk5 () , self . outepmsk12 () , self . outepmsk13 () , self . outepmsk14 () , self . outepmsk15 ())
            }
        }
        #[doc = "Device Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcfg(pub u32);
        impl Dcfg {
            #[doc = "Device Speed (DevSpd)"]
            #[must_use]
            #[inline(always)]
            pub const fn devspd(&self) -> super::vals::Devspd {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Devspd::from_bits(val as u8)
            }
            #[doc = "Device Speed (DevSpd)"]
            #[inline(always)]
            pub const fn set_devspd(&mut self, val: super::vals::Devspd) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)"]
            #[must_use]
            #[inline(always)]
            pub const fn nzstsouthshk(&self) -> super::vals::Nzstsouthshk {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Nzstsouthshk::from_bits(val as u8)
            }
            #[doc = "Non-Zero-Length Status OUT Handshake (NZStsOUTHShk)"]
            #[inline(always)]
            pub const fn set_nzstsouthshk(&mut self, val: super::vals::Nzstsouthshk) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable 32 KHz Suspend mode (Ena32KHzSusp)"]
            #[must_use]
            #[inline(always)]
            pub const fn ena32khzsusp(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32 KHz Suspend mode (Ena32KHzSusp)"]
            #[inline(always)]
            pub const fn set_ena32khzsusp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Device Address (DevAddr)"]
            #[must_use]
            #[inline(always)]
            pub const fn devaddr(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x7f;
                val as u8
            }
            #[doc = "Device Address (DevAddr)"]
            #[inline(always)]
            pub const fn set_devaddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 4usize)) | (((val as u32) & 0x7f) << 4usize);
            }
            #[doc = "Periodic Frame Interval (PerFrInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn perfrint(&self) -> super::vals::Perfrint {
                let val = (self.0 >> 11usize) & 0x03;
                super::vals::Perfrint::from_bits(val as u8)
            }
            #[doc = "Periodic Frame Interval (PerFrInt)"]
            #[inline(always)]
            pub const fn set_perfrint(&mut self, val: super::vals::Perfrint) {
                self.0 =
                    (self.0 & !(0x03 << 11usize)) | (((val.to_bits() as u32) & 0x03) << 11usize);
            }
            #[doc = "XCVRDLY"]
            #[must_use]
            #[inline(always)]
            pub const fn xcvrdly(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "XCVRDLY"]
            #[inline(always)]
            pub const fn set_xcvrdly(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Erratic Error Interrupt Mask"]
            #[must_use]
            #[inline(always)]
            pub const fn erraticintmsk(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Erratic Error Interrupt Mask"]
            #[inline(always)]
            pub const fn set_erraticintmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Worst-Case Inter-Packet Gap ISOC OUT Support (ipgisocSupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn ipgisocsupt(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Worst-Case Inter-Packet Gap ISOC OUT Support (ipgisocSupt)"]
            #[inline(always)]
            pub const fn set_ipgisocsupt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Periodic Scheduling Interval (PerSchIntvl)"]
            #[must_use]
            #[inline(always)]
            pub const fn perschintvl(&self) -> super::vals::Perschintvl {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Perschintvl::from_bits(val as u8)
            }
            #[doc = "Periodic Scheduling Interval (PerSchIntvl)"]
            #[inline(always)]
            pub const fn set_perschintvl(&mut self, val: super::vals::Perschintvl) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Resume Validation Period (ResValid)"]
            #[must_use]
            #[inline(always)]
            pub const fn resvalid(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x3f;
                val as u8
            }
            #[doc = "Resume Validation Period (ResValid)"]
            #[inline(always)]
            pub const fn set_resvalid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 26usize)) | (((val as u32) & 0x3f) << 26usize);
            }
        }
        impl Default for Dcfg {
            #[inline(always)]
            fn default() -> Dcfg {
                Dcfg(0)
            }
        }
        impl core::fmt::Debug for Dcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcfg")
                    .field("devspd", &self.devspd())
                    .field("nzstsouthshk", &self.nzstsouthshk())
                    .field("ena32khzsusp", &self.ena32khzsusp())
                    .field("devaddr", &self.devaddr())
                    .field("perfrint", &self.perfrint())
                    .field("xcvrdly", &self.xcvrdly())
                    .field("erraticintmsk", &self.erraticintmsk())
                    .field("ipgisocsupt", &self.ipgisocsupt())
                    .field("perschintvl", &self.perschintvl())
                    .field("resvalid", &self.resvalid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dcfg {{ devspd: {:?}, nzstsouthshk: {:?}, ena32khzsusp: {=bool:?}, devaddr: {=u8:?}, perfrint: {:?}, xcvrdly: {=bool:?}, erraticintmsk: {=bool:?}, ipgisocsupt: {=bool:?}, perschintvl: {:?}, resvalid: {=u8:?} }}" , self . devspd () , self . nzstsouthshk () , self . ena32khzsusp () , self . devaddr () , self . perfrint () , self . xcvrdly () , self . erraticintmsk () , self . ipgisocsupt () , self . perschintvl () , self . resvalid ())
            }
        }
        #[doc = "Device Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dctl(pub u32);
        impl Dctl {
            #[doc = "Remote Wakeup Signaling (RmtWkUpSig)"]
            #[must_use]
            #[inline(always)]
            pub const fn rmtwkupsig(&self) -> super::vals::Rmtwkupsig {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Rmtwkupsig::from_bits(val as u8)
            }
            #[doc = "Remote Wakeup Signaling (RmtWkUpSig)"]
            #[inline(always)]
            pub const fn set_rmtwkupsig(&mut self, val: super::vals::Rmtwkupsig) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Soft Disconnect (SftDiscon)"]
            #[must_use]
            #[inline(always)]
            pub const fn sftdiscon(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Soft Disconnect (SftDiscon)"]
            #[inline(always)]
            pub const fn set_sftdiscon(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Global Non-periodic IN NAK Status (GNPINNakSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn gnpinnaksts(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Global Non-periodic IN NAK Status (GNPINNakSts)"]
            #[inline(always)]
            pub const fn set_gnpinnaksts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Global OUT NAK Status (GOUTNakSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn goutnaksts(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Global OUT NAK Status (GOUTNakSts)"]
            #[inline(always)]
            pub const fn set_goutnaksts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Test Control (TstCtl)"]
            #[must_use]
            #[inline(always)]
            pub const fn tstctl(&self) -> super::vals::Tstctl {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Tstctl::from_bits(val as u8)
            }
            #[doc = "Test Control (TstCtl)"]
            #[inline(always)]
            pub const fn set_tstctl(&mut self, val: super::vals::Tstctl) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
            }
            #[doc = "Set Global Non-periodic IN NAK (SGNPInNak)"]
            #[must_use]
            #[inline(always)]
            pub const fn sgnpinnak(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Set Global Non-periodic IN NAK (SGNPInNak)"]
            #[inline(always)]
            pub const fn set_sgnpinnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Clear Global Non-periodic IN NAK (CGNPInNak)"]
            #[must_use]
            #[inline(always)]
            pub const fn cgnpinnak(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Clear Global Non-periodic IN NAK (CGNPInNak)"]
            #[inline(always)]
            pub const fn set_cgnpinnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Set Global OUT NAK (SGOUTNak)"]
            #[must_use]
            #[inline(always)]
            pub const fn sgoutnak(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Set Global OUT NAK (SGOUTNak)"]
            #[inline(always)]
            pub const fn set_sgoutnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Clear Global OUT NAK (CGOUTNak)"]
            #[must_use]
            #[inline(always)]
            pub const fn cgoutnak(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Clear Global OUT NAK (CGOUTNak)"]
            #[inline(always)]
            pub const fn set_cgoutnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Power-On Programming Done (PWROnPrgDone)"]
            #[must_use]
            #[inline(always)]
            pub const fn pwronprgdone(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Power-On Programming Done (PWROnPrgDone)"]
            #[inline(always)]
            pub const fn set_pwronprgdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Ignore Frame Number Feature for Isochronous Endpoints (IgnrFrmNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn ignrfrmnum(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Ignore Frame Number Feature for Isochronous Endpoints (IgnrFrmNum)"]
            #[inline(always)]
            pub const fn set_ignrfrmnum(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "NAK on Babble Error (NakOnBble)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakonbble(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "NAK on Babble Error (NakOnBble)"]
            #[inline(always)]
            pub const fn set_nakonbble(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "DeepSleepBESLReject"]
            #[must_use]
            #[inline(always)]
            pub const fn deepsleepbeslreject(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "DeepSleepBESLReject"]
            #[inline(always)]
            pub const fn set_deepsleepbeslreject(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Service Interval based scheduling for Isochronous IN Endpoints"]
            #[must_use]
            #[inline(always)]
            pub const fn servint(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Service Interval based scheduling for Isochronous IN Endpoints"]
            #[inline(always)]
            pub const fn set_servint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface."]
            #[must_use]
            #[inline(always)]
            pub const fn utmitxvldcorrdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface."]
            #[inline(always)]
            pub const fn set_utmitxvldcorrdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Disable the correction of TermSel on UTMI Interface."]
            #[must_use]
            #[inline(always)]
            pub const fn utmitermselcorrdis(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Disable the correction of TermSel on UTMI Interface."]
            #[inline(always)]
            pub const fn set_utmitermselcorrdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dctl {
            #[inline(always)]
            fn default() -> Dctl {
                Dctl(0)
            }
        }
        impl core::fmt::Debug for Dctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dctl")
                    .field("rmtwkupsig", &self.rmtwkupsig())
                    .field("sftdiscon", &self.sftdiscon())
                    .field("gnpinnaksts", &self.gnpinnaksts())
                    .field("goutnaksts", &self.goutnaksts())
                    .field("tstctl", &self.tstctl())
                    .field("sgnpinnak", &self.sgnpinnak())
                    .field("cgnpinnak", &self.cgnpinnak())
                    .field("sgoutnak", &self.sgoutnak())
                    .field("cgoutnak", &self.cgoutnak())
                    .field("pwronprgdone", &self.pwronprgdone())
                    .field("ignrfrmnum", &self.ignrfrmnum())
                    .field("nakonbble", &self.nakonbble())
                    .field("deepsleepbeslreject", &self.deepsleepbeslreject())
                    .field("servint", &self.servint())
                    .field("utmitxvldcorrdis", &self.utmitxvldcorrdis())
                    .field("utmitermselcorrdis", &self.utmitermselcorrdis())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dctl {{ rmtwkupsig: {:?}, sftdiscon: {=bool:?}, gnpinnaksts: {=bool:?}, goutnaksts: {=bool:?}, tstctl: {:?}, sgnpinnak: {=bool:?}, cgnpinnak: {=bool:?}, sgoutnak: {=bool:?}, cgoutnak: {=bool:?}, pwronprgdone: {=bool:?}, ignrfrmnum: {=bool:?}, nakonbble: {=bool:?}, deepsleepbeslreject: {=bool:?}, servint: {=bool:?}, utmitxvldcorrdis: {=bool:?}, utmitermselcorrdis: {=bool:?} }}" , self . rmtwkupsig () , self . sftdiscon () , self . gnpinnaksts () , self . goutnaksts () , self . tstctl () , self . sgnpinnak () , self . cgnpinnak () , self . sgoutnak () , self . cgoutnak () , self . pwronprgdone () , self . ignrfrmnum () , self . nakonbble () , self . deepsleepbeslreject () , self . servint () , self . utmitxvldcorrdis () , self . utmitermselcorrdis ())
            }
        }
        #[doc = "Device Control IN Endpoint 0 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl0(pub u32);
        impl Diepctl0 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> super::vals::Diepctl0Mps {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Diepctl0Mps::from_bits(val as u8)
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: super::vals::Diepctl0Mps) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl0Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl0Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl0Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl0Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl0Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl0Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl0 {
            #[inline(always)]
            fn default() -> Diepctl0 {
                Diepctl0(0)
            }
        }
        impl core::fmt::Debug for Diepctl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl0")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl0 {{ mps: {:?}, usbactep: {=bool:?}, naksts: {=bool:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl1(pub u32);
        impl Diepctl1 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl1Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl1Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl1Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl1Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl1Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl1Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl1Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl1Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl1Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl1Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl1Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl1Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl1 {
            #[inline(always)]
            fn default() -> Diepctl1 {
                Diepctl1(0)
            }
        }
        impl core::fmt::Debug for Diepctl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl1")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl1 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl10(pub u32);
        impl Diepctl10 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl10Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl10Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl10Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl10Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl10Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl10Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl10Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl10Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl10Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl10Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl10Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl10Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl10 {
            #[inline(always)]
            fn default() -> Diepctl10 {
                Diepctl10(0)
            }
        }
        impl core::fmt::Debug for Diepctl10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl10")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl10 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl11(pub u32);
        impl Diepctl11 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl11Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl11Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl11Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl11Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl11Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl11Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl11Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl11Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl11Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl11Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl11Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl11Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl11 {
            #[inline(always)]
            fn default() -> Diepctl11 {
                Diepctl11(0)
            }
        }
        impl core::fmt::Debug for Diepctl11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl11")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl11 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl2(pub u32);
        impl Diepctl2 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl2Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl2Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl2Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl2Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl2Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl2Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl2Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl2Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl2Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl2Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl2Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl2Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl2 {
            #[inline(always)]
            fn default() -> Diepctl2 {
                Diepctl2(0)
            }
        }
        impl core::fmt::Debug for Diepctl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl2")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl2 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl3(pub u32);
        impl Diepctl3 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl3Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl3Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl3Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl3Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl3Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl3Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl3Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl3Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl3Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl3Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl3Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl3Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl3 {
            #[inline(always)]
            fn default() -> Diepctl3 {
                Diepctl3(0)
            }
        }
        impl core::fmt::Debug for Diepctl3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl3")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl3 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl4(pub u32);
        impl Diepctl4 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl4Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl4Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl4Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl4Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl4Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl4Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl4Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl4Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl4Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl4Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl4Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl4Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl4 {
            #[inline(always)]
            fn default() -> Diepctl4 {
                Diepctl4(0)
            }
        }
        impl core::fmt::Debug for Diepctl4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl4")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl4 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl5(pub u32);
        impl Diepctl5 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl5Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl5Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl5Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl5Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl5Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl5Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl5Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl5Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl5Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl5Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl5Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl5Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl5 {
            #[inline(always)]
            fn default() -> Diepctl5 {
                Diepctl5(0)
            }
        }
        impl core::fmt::Debug for Diepctl5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl5")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl5 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl5 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl6(pub u32);
        impl Diepctl6 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl6Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl6Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl6Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl6Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl6Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl6Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl6Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl6Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl6Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl6Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl6Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl6Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl6 {
            #[inline(always)]
            fn default() -> Diepctl6 {
                Diepctl6(0)
            }
        }
        impl core::fmt::Debug for Diepctl6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl6")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl6 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl6 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl7(pub u32);
        impl Diepctl7 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl7Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl7Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl7Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl7Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl7Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl7Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl7Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl7Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl7Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl7Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl7Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl7Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl7 {
            #[inline(always)]
            fn default() -> Diepctl7 {
                Diepctl7(0)
            }
        }
        impl core::fmt::Debug for Diepctl7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl7")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl7 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl7 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl8(pub u32);
        impl Diepctl8 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl8Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl8Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl8Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl8Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl8Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl8Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl8Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl8Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl8Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl8Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl8Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl8Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl8 {
            #[inline(always)]
            fn default() -> Diepctl8 {
                Diepctl8(0)
            }
        }
        impl core::fmt::Debug for Diepctl8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl8")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl8 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control IN Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepctl9(pub u32);
        impl Diepctl9 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::Diepctl9Dpid {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Diepctl9Dpid::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::Diepctl9Dpid) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Diepctl9Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Diepctl9Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Diepctl9Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Diepctl9Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Diepctl9Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Diepctl9Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::Diepctl9Txfnum {
                let val = (self.0 >> 22usize) & 0x0f;
                super::vals::Diepctl9Txfnum::from_bits(val as u8)
            }
            #[doc = "TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::Diepctl9Txfnum) {
                self.0 =
                    (self.0 & !(0x0f << 22usize)) | (((val.to_bits() as u32) & 0x0f) << 22usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Diepctl9 {
            #[inline(always)]
            fn default() -> Diepctl9 {
                Diepctl9(0)
            }
        }
        impl core::fmt::Debug for Diepctl9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepctl9")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("txfnum", &self.txfnum())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepctl9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepctl9 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, txfnum: {:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . txfnum () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device IN Endpoint FIFO Empty Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepempmsk(pub u32);
        impl Diepempmsk {
            #[doc = "IN EP Tx FIFO Empty Interrupt Mask Bits (InEpTxfEmpMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfempmsk(&self) -> super::vals::Ineptxfempmsk {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Ineptxfempmsk::from_bits(val as u16)
            }
            #[doc = "IN EP Tx FIFO Empty Interrupt Mask Bits (InEpTxfEmpMsk)"]
            #[inline(always)]
            pub const fn set_ineptxfempmsk(&mut self, val: super::vals::Ineptxfempmsk) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Diepempmsk {
            #[inline(always)]
            fn default() -> Diepempmsk {
                Diepempmsk(0)
            }
        }
        impl core::fmt::Debug for Diepempmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepempmsk")
                    .field("ineptxfempmsk", &self.ineptxfempmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepempmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Diepempmsk {{ ineptxfempmsk: {:?} }}",
                    self.ineptxfempmsk()
                )
            }
        }
        #[doc = "Device IN Endpoint 0 Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint0(pub u32);
        impl Diepint0 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint0 {
            #[inline(always)]
            fn default() -> Diepint0 {
                Diepint0(0)
            }
        }
        impl core::fmt::Debug for Diepint0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint0")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint0 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint1(pub u32);
        impl Diepint1 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint1 {
            #[inline(always)]
            fn default() -> Diepint1 {
                Diepint1(0)
            }
        }
        impl core::fmt::Debug for Diepint1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint1")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint1 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint10(pub u32);
        impl Diepint10 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint10 {
            #[inline(always)]
            fn default() -> Diepint10 {
                Diepint10(0)
            }
        }
        impl core::fmt::Debug for Diepint10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint10")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint10 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint10 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint11(pub u32);
        impl Diepint11 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint11 {
            #[inline(always)]
            fn default() -> Diepint11 {
                Diepint11(0)
            }
        }
        impl core::fmt::Debug for Diepint11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint11")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint11 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint11 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint2(pub u32);
        impl Diepint2 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint2 {
            #[inline(always)]
            fn default() -> Diepint2 {
                Diepint2(0)
            }
        }
        impl core::fmt::Debug for Diepint2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint2")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint2 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint3(pub u32);
        impl Diepint3 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint3 {
            #[inline(always)]
            fn default() -> Diepint3 {
                Diepint3(0)
            }
        }
        impl core::fmt::Debug for Diepint3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint3")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint3 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint4(pub u32);
        impl Diepint4 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint4 {
            #[inline(always)]
            fn default() -> Diepint4 {
                Diepint4(0)
            }
        }
        impl core::fmt::Debug for Diepint4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint4")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint4 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint5(pub u32);
        impl Diepint5 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint5 {
            #[inline(always)]
            fn default() -> Diepint5 {
                Diepint5(0)
            }
        }
        impl core::fmt::Debug for Diepint5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint5")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint5 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint5 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint6(pub u32);
        impl Diepint6 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint6 {
            #[inline(always)]
            fn default() -> Diepint6 {
                Diepint6(0)
            }
        }
        impl core::fmt::Debug for Diepint6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint6")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint6 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint6 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint7(pub u32);
        impl Diepint7 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint7 {
            #[inline(always)]
            fn default() -> Diepint7 {
                Diepint7(0)
            }
        }
        impl core::fmt::Debug for Diepint7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint7")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint7 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint7 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint8(pub u32);
        impl Diepint8 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint8 {
            #[inline(always)]
            fn default() -> Diepint8 {
                Diepint8(0)
            }
        }
        impl core::fmt::Debug for Diepint8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint8")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint8 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint8 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepint9(pub u32);
        impl Diepint9 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Timeout Condition (TimeOUT)"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfemp(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received When TxFIFO is Empty (INTknTXFEmp)"]
            #[inline(always)]
            pub const fn set_intkntxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmis(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "IN Token Received with EP Mismatch (INTknEPMis)"]
            #[inline(always)]
            pub const fn set_intknepmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "IN Endpoint NAK Effective (INEPNakEff)"]
            #[inline(always)]
            pub const fn set_inepnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfemp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transmit FIFO Empty (TxFEmp)"]
            #[inline(always)]
            pub const fn set_txfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrn(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Fifo Underrun (TxfifoUndrn)"]
            #[inline(always)]
            pub const fn set_txfifoundrn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Diepint9 {
            #[inline(always)]
            fn default() -> Diepint9 {
                Diepint9(0)
            }
        }
        impl core::fmt::Debug for Diepint9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepint9")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("timeout", &self.timeout())
                    .field("intkntxfemp", &self.intkntxfemp())
                    .field("intknepmis", &self.intknepmis())
                    .field("inepnakeff", &self.inepnakeff())
                    .field("txfemp", &self.txfemp())
                    .field("txfifoundrn", &self.txfifoundrn())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepint9 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepint9 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, timeout: {=bool:?}, intkntxfemp: {=bool:?}, intknepmis: {=bool:?}, inepnakeff: {=bool:?}, txfemp: {=bool:?}, txfifoundrn: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . timeout () , self . intkntxfemp () , self . intknepmis () , self . inepnakeff () , self . txfemp () , self . txfifoundrn () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt ())
            }
        }
        #[doc = "Device IN Endpoint Common Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Diepmsk(pub u32);
        impl Diepmsk {
            #[doc = "Transfer Completed Interrupt Mask (XferComplMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercomplmsk(&self) -> super::vals::DiepmskXfercomplmsk {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DiepmskXfercomplmsk::from_bits(val as u8)
            }
            #[doc = "Transfer Completed Interrupt Mask (XferComplMsk)"]
            #[inline(always)]
            pub const fn set_xfercomplmsk(&mut self, val: super::vals::DiepmskXfercomplmsk) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt Mask (EPDisbldMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbldmsk(&self) -> super::vals::DiepmskEpdisbldmsk {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::DiepmskEpdisbldmsk::from_bits(val as u8)
            }
            #[doc = "Endpoint Disabled Interrupt Mask (EPDisbldMsk)"]
            #[inline(always)]
            pub const fn set_epdisbldmsk(&mut self, val: super::vals::DiepmskEpdisbldmsk) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error Mask (AHBErrMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberrmsk(&self) -> super::vals::DiepmskAhberrmsk {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::DiepmskAhberrmsk::from_bits(val as u8)
            }
            #[doc = "AHB Error Mask (AHBErrMsk)"]
            #[inline(always)]
            pub const fn set_ahberrmsk(&mut self, val: super::vals::DiepmskAhberrmsk) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)"]
            #[must_use]
            #[inline(always)]
            pub const fn timeoutmsk(&self) -> super::vals::Timeoutmsk {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Timeoutmsk::from_bits(val as u8)
            }
            #[doc = "Timeout Condition Mask (TimeOUTMsk) (Non-isochronous endpoints)"]
            #[inline(always)]
            pub const fn set_timeoutmsk(&mut self, val: super::vals::Timeoutmsk) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn intkntxfempmsk(&self) -> super::vals::Intkntxfempmsk {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Intkntxfempmsk::from_bits(val as u8)
            }
            #[doc = "IN Token Received When TxFIFO Empty Mask (INTknTXFEmpMsk)"]
            #[inline(always)]
            pub const fn set_intkntxfempmsk(&mut self, val: super::vals::Intkntxfempmsk) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "IN Token received with EP Mismatch Mask (INTknEPMisMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn intknepmismsk(&self) -> super::vals::Intknepmismsk {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Intknepmismsk::from_bits(val as u8)
            }
            #[doc = "IN Token received with EP Mismatch Mask (INTknEPMisMsk)"]
            #[inline(always)]
            pub const fn set_intknepmismsk(&mut self, val: super::vals::Intknepmismsk) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "IN Endpoint NAK Effective Mask (INEPNakEffMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepnakeffmsk(&self) -> super::vals::Inepnakeffmsk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Inepnakeffmsk::from_bits(val as u8)
            }
            #[doc = "IN Endpoint NAK Effective Mask (INEPNakEffMsk)"]
            #[inline(always)]
            pub const fn set_inepnakeffmsk(&mut self, val: super::vals::Inepnakeffmsk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Fifo Underrun Mask (TxfifoUndrnMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfifoundrnmsk(&self) -> super::vals::Txfifoundrnmsk {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Txfifoundrnmsk::from_bits(val as u8)
            }
            #[doc = "Fifo Underrun Mask (TxfifoUndrnMsk)"]
            #[inline(always)]
            pub const fn set_txfifoundrnmsk(&mut self, val: super::vals::Txfifoundrnmsk) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "NAK interrupt Mask (NAKMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakmsk(&self) -> super::vals::DiepmskNakmsk {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::DiepmskNakmsk::from_bits(val as u8)
            }
            #[doc = "NAK interrupt Mask (NAKMsk)"]
            #[inline(always)]
            pub const fn set_nakmsk(&mut self, val: super::vals::DiepmskNakmsk) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Diepmsk {
            #[inline(always)]
            fn default() -> Diepmsk {
                Diepmsk(0)
            }
        }
        impl core::fmt::Debug for Diepmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Diepmsk")
                    .field("xfercomplmsk", &self.xfercomplmsk())
                    .field("epdisbldmsk", &self.epdisbldmsk())
                    .field("ahberrmsk", &self.ahberrmsk())
                    .field("timeoutmsk", &self.timeoutmsk())
                    .field("intkntxfempmsk", &self.intkntxfempmsk())
                    .field("intknepmismsk", &self.intknepmismsk())
                    .field("inepnakeffmsk", &self.inepnakeffmsk())
                    .field("txfifoundrnmsk", &self.txfifoundrnmsk())
                    .field("nakmsk", &self.nakmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Diepmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Diepmsk {{ xfercomplmsk: {:?}, epdisbldmsk: {:?}, ahberrmsk: {:?}, timeoutmsk: {:?}, intkntxfempmsk: {:?}, intknepmismsk: {:?}, inepnakeffmsk: {:?}, txfifoundrnmsk: {:?}, nakmsk: {:?} }}" , self . xfercomplmsk () , self . epdisbldmsk () , self . ahberrmsk () , self . timeoutmsk () , self . intkntxfempmsk () , self . intknepmismsk () , self . inepnakeffmsk () , self . txfifoundrnmsk () , self . nakmsk ())
            }
        }
        #[doc = "Device IN Endpoint 0 Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz0(pub u32);
        impl Dieptsiz0 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u8 {
                let val = (self.0 >> 19usize) & 0x03;
                val as u8
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 19usize)) | (((val as u32) & 0x03) << 19usize);
            }
        }
        impl Default for Dieptsiz0 {
            #[inline(always)]
            fn default() -> Dieptsiz0 {
                Dieptsiz0(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz0")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz0 {{ xfersize: {=u8:?}, pktcnt: {=u8:?} }}",
                    self.xfersize(),
                    self.pktcnt()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz1(pub u32);
        impl Dieptsiz1 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz1Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz1Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz1Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz1 {
            #[inline(always)]
            fn default() -> Dieptsiz1 {
                Dieptsiz1(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz1")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz1 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz10(pub u32);
        impl Dieptsiz10 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz10Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz10Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz10Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz10 {
            #[inline(always)]
            fn default() -> Dieptsiz10 {
                Dieptsiz10(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz10")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz10 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz11(pub u32);
        impl Dieptsiz11 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz11Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz11Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz11Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz11 {
            #[inline(always)]
            fn default() -> Dieptsiz11 {
                Dieptsiz11(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz11")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz11 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz2(pub u32);
        impl Dieptsiz2 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz2Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz2Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz2Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz2 {
            #[inline(always)]
            fn default() -> Dieptsiz2 {
                Dieptsiz2(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz2")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz2 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz3(pub u32);
        impl Dieptsiz3 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz3Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz3Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz3Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz3 {
            #[inline(always)]
            fn default() -> Dieptsiz3 {
                Dieptsiz3(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz3")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz3 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz4(pub u32);
        impl Dieptsiz4 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz4Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz4Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz4Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz4 {
            #[inline(always)]
            fn default() -> Dieptsiz4 {
                Dieptsiz4(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz4")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz4 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz5(pub u32);
        impl Dieptsiz5 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz5Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz5Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz5Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz5 {
            #[inline(always)]
            fn default() -> Dieptsiz5 {
                Dieptsiz5(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz5")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz5 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz6(pub u32);
        impl Dieptsiz6 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz6Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz6Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz6Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz6 {
            #[inline(always)]
            fn default() -> Dieptsiz6 {
                Dieptsiz6(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz6")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz6 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz6 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz7(pub u32);
        impl Dieptsiz7 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz7Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz7Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz7Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz7 {
            #[inline(always)]
            fn default() -> Dieptsiz7 {
                Dieptsiz7(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz7")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz7 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz7 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz8(pub u32);
        impl Dieptsiz8 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz8Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz8Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz8Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz8 {
            #[inline(always)]
            fn default() -> Dieptsiz8 {
                Dieptsiz8(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz8")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz8 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz8 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Device IN Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptsiz9(pub u32);
        impl Dieptsiz9 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "MC"]
            #[must_use]
            #[inline(always)]
            pub const fn mc(&self) -> super::vals::Dieptsiz9Mc {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Dieptsiz9Mc::from_bits(val as u8)
            }
            #[doc = "MC"]
            #[inline(always)]
            pub const fn set_mc(&mut self, val: super::vals::Dieptsiz9Mc) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Dieptsiz9 {
            #[inline(always)]
            fn default() -> Dieptsiz9 {
                Dieptsiz9(0)
            }
        }
        impl core::fmt::Debug for Dieptsiz9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptsiz9")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("mc", &self.mc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptsiz9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptsiz9 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, mc: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.mc()
                )
            }
        }
        #[doc = "Description collection: Device IN Endpoint Transmit FIFO Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dieptxf(pub u32);
        impl Dieptxf {
            #[doc = "IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepntxfstaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "IN Endpoint FIFOn Transmit RAM Start Address (INEPnTxFStAddr)"]
            #[inline(always)]
            pub const fn set_inepntxfstaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "IN Endpoint TxFIFO Depth (INEPnTxFDep)"]
            #[must_use]
            #[inline(always)]
            pub const fn inepntxfdep(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Depth (INEPnTxFDep)"]
            #[inline(always)]
            pub const fn set_inepntxfdep(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Dieptxf {
            #[inline(always)]
            fn default() -> Dieptxf {
                Dieptxf(0)
            }
        }
        impl core::fmt::Debug for Dieptxf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dieptxf")
                    .field("inepntxfstaddr", &self.inepntxfstaddr())
                    .field("inepntxfdep", &self.inepntxfdep())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dieptxf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dieptxf {{ inepntxfstaddr: {=u16:?}, inepntxfdep: {=u16:?} }}",
                    self.inepntxfstaddr(),
                    self.inepntxfdep()
                )
            }
        }
        #[doc = "Device Control OUT Endpoint 0 Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl0(pub u32);
        impl Doepctl0 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> super::vals::Doepctl0Mps {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Doepctl0Mps::from_bits(val as u8)
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: super::vals::Doepctl0Mps) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl0Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl0Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl0Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Clear NAK (CNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Clear NAK (CNAK)"]
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl0 {
            #[inline(always)]
            fn default() -> Doepctl0 {
                Doepctl0(0)
            }
        }
        impl core::fmt::Debug for Doepctl0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl0")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl0 {{ mps: {:?}, usbactep: {=bool:?}, naksts: {=bool:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl1(pub u32);
        impl Doepctl1 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl1Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl1Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl1Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl1Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl1Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl1Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl1 {
            #[inline(always)]
            fn default() -> Doepctl1 {
                Doepctl1(0)
            }
        }
        impl core::fmt::Debug for Doepctl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl1")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl1 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl12(pub u32);
        impl Doepctl12 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl12Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl12Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl12Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl12Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl12Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl12Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl12 {
            #[inline(always)]
            fn default() -> Doepctl12 {
                Doepctl12(0)
            }
        }
        impl core::fmt::Debug for Doepctl12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl12")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl12 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl13(pub u32);
        impl Doepctl13 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl13Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl13Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl13Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl13Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl13Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl13Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl13 {
            #[inline(always)]
            fn default() -> Doepctl13 {
                Doepctl13(0)
            }
        }
        impl core::fmt::Debug for Doepctl13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl13")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl13 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl14(pub u32);
        impl Doepctl14 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl14Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl14Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl14Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl14Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl14Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl14Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl14 {
            #[inline(always)]
            fn default() -> Doepctl14 {
                Doepctl14(0)
            }
        }
        impl core::fmt::Debug for Doepctl14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl14")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl14 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl15(pub u32);
        impl Doepctl15 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl15Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl15Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl15Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl15Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl15Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl15Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl15 {
            #[inline(always)]
            fn default() -> Doepctl15 {
                Doepctl15(0)
            }
        }
        impl core::fmt::Debug for Doepctl15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl15")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl15 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl15 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl2(pub u32);
        impl Doepctl2 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl2Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl2Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl2Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl2Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl2Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl2Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl2 {
            #[inline(always)]
            fn default() -> Doepctl2 {
                Doepctl2(0)
            }
        }
        impl core::fmt::Debug for Doepctl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl2")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl2 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl3(pub u32);
        impl Doepctl3 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl3Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl3Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl3Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl3Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl3Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl3Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl3 {
            #[inline(always)]
            fn default() -> Doepctl3 {
                Doepctl3(0)
            }
        }
        impl core::fmt::Debug for Doepctl3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl3")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl3 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl4(pub u32);
        impl Doepctl4 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl4Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl4Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl4Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl4Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl4Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl4Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl4 {
            #[inline(always)]
            fn default() -> Doepctl4 {
                Doepctl4(0)
            }
        }
        impl core::fmt::Debug for Doepctl4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl4")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl4 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device Control OUT Endpoint Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepctl5(pub u32);
        impl Doepctl5 {
            #[doc = "Maximum Packet Size (MPS)"]
            #[must_use]
            #[inline(always)]
            pub const fn mps(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Maximum Packet Size (MPS)"]
            #[inline(always)]
            pub const fn set_mps(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbactep(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "USB Active Endpoint (USBActEP)"]
            #[inline(always)]
            pub const fn set_usbactep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "NAK Status (NAKSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn naksts(&self) -> super::vals::Doepctl5Naksts {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Doepctl5Naksts::from_bits(val as u8)
            }
            #[doc = "NAK Status (NAKSts)"]
            #[inline(always)]
            pub const fn set_naksts(&mut self, val: super::vals::Doepctl5Naksts) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Endpoint Type (EPType)"]
            #[must_use]
            #[inline(always)]
            pub const fn eptype(&self) -> super::vals::Doepctl5Eptype {
                let val = (self.0 >> 18usize) & 0x03;
                super::vals::Doepctl5Eptype::from_bits(val as u8)
            }
            #[doc = "Endpoint Type (EPType)"]
            #[inline(always)]
            pub const fn set_eptype(&mut self, val: super::vals::Doepctl5Eptype) {
                self.0 =
                    (self.0 & !(0x03 << 18usize)) | (((val.to_bits() as u32) & 0x03) << 18usize);
            }
            #[doc = "STALL Handshake (Stall)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Handshake (Stall)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnak(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_cnak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Set NAK (SNAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn snak(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Set NAK (SNAK)"]
            #[inline(always)]
            pub const fn set_snak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd0pid(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA0 PID (SetD0PID)"]
            #[inline(always)]
            pub const fn set_setd0pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[must_use]
            #[inline(always)]
            pub const fn setd1pid(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Set DATA1 PID (SetD1PID)"]
            #[inline(always)]
            pub const fn set_setd1pid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdis(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disable (EPDis)"]
            #[inline(always)]
            pub const fn set_epdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn epena(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Enable (EPEna)"]
            #[inline(always)]
            pub const fn set_epena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Doepctl5 {
            #[inline(always)]
            fn default() -> Doepctl5 {
                Doepctl5(0)
            }
        }
        impl core::fmt::Debug for Doepctl5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepctl5")
                    .field("mps", &self.mps())
                    .field("usbactep", &self.usbactep())
                    .field("dpid", &self.dpid())
                    .field("naksts", &self.naksts())
                    .field("eptype", &self.eptype())
                    .field("stall", &self.stall())
                    .field("cnak", &self.cnak())
                    .field("snak", &self.snak())
                    .field("setd0pid", &self.setd0pid())
                    .field("setd1pid", &self.setd1pid())
                    .field("epdis", &self.epdis())
                    .field("epena", &self.epena())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepctl5 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepctl5 {{ mps: {=u16:?}, usbactep: {=bool:?}, dpid: {=bool:?}, naksts: {:?}, eptype: {:?}, stall: {=bool:?}, cnak: {=bool:?}, snak: {=bool:?}, setd0pid: {=bool:?}, setd1pid: {=bool:?}, epdis: {=bool:?}, epena: {=bool:?} }}" , self . mps () , self . usbactep () , self . dpid () , self . naksts () , self . eptype () , self . stall () , self . cnak () , self . snak () , self . setd0pid () , self . setd1pid () , self . epdis () , self . epena ())
            }
        }
        #[doc = "Device OUT Endpoint 0 Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint0(pub u32);
        impl Doepint0 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint0 {
            #[inline(always)]
            fn default() -> Doepint0 {
                Doepint0(0)
            }
        }
        impl core::fmt::Debug for Doepint0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint0")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint0 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint1(pub u32);
        impl Doepint1 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint1 {
            #[inline(always)]
            fn default() -> Doepint1 {
                Doepint1(0)
            }
        }
        impl core::fmt::Debug for Doepint1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint1")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint1 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint12(pub u32);
        impl Doepint12 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint12 {
            #[inline(always)]
            fn default() -> Doepint12 {
                Doepint12(0)
            }
        }
        impl core::fmt::Debug for Doepint12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint12")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint12 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint12 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint13(pub u32);
        impl Doepint13 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint13 {
            #[inline(always)]
            fn default() -> Doepint13 {
                Doepint13(0)
            }
        }
        impl core::fmt::Debug for Doepint13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint13")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint13 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint13 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint14(pub u32);
        impl Doepint14 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint14 {
            #[inline(always)]
            fn default() -> Doepint14 {
                Doepint14(0)
            }
        }
        impl core::fmt::Debug for Doepint14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint14")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint14 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint14 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint15(pub u32);
        impl Doepint15 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint15 {
            #[inline(always)]
            fn default() -> Doepint15 {
                Doepint15(0)
            }
        }
        impl core::fmt::Debug for Doepint15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint15")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint15 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint15 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint2(pub u32);
        impl Doepint2 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint2 {
            #[inline(always)]
            fn default() -> Doepint2 {
                Doepint2(0)
            }
        }
        impl core::fmt::Debug for Doepint2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint2")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint2 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint3(pub u32);
        impl Doepint3 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint3 {
            #[inline(always)]
            fn default() -> Doepint3 {
                Doepint3(0)
            }
        }
        impl core::fmt::Debug for Doepint3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint3")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint3 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint4(pub u32);
        impl Doepint4 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint4 {
            #[inline(always)]
            fn default() -> Doepint4 {
                Doepint4(0)
            }
        }
        impl core::fmt::Debug for Doepint4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint4")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint4 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepint5(pub u32);
        impl Doepint5 {
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed Interrupt (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbld(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Endpoint Disabled Interrupt (EPDisbld)"]
            #[inline(always)]
            pub const fn set_epdisbld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[must_use]
            #[inline(always)]
            pub const fn setup(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "SETUP Phase Done (SetUp)"]
            #[inline(always)]
            pub const fn set_setup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdis(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Token Received When Endpoint Disabled (OUTTknEPdis)"]
            #[inline(always)]
            pub const fn set_outtknepdis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Status Phase Received for Control Write (StsPhseRcvd)"]
            #[inline(always)]
            pub const fn set_stsphsercvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Back-to-Back SETUP Packets Received (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "OUT Packet Error (OutPktErr)"]
            #[inline(always)]
            pub const fn set_outpkterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bnaintr(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "BNA (Buffer Not Available) Interrupt (BNAIntr)"]
            #[inline(always)]
            pub const fn set_bnaintr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktdrpsts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Drop Status (PktDrpSts)"]
            #[inline(always)]
            pub const fn set_pktdrpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (BbleErr)"]
            #[inline(always)]
            pub const fn set_bbleerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakintrpt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Interrupt (NAKInterrupt)"]
            #[inline(always)]
            pub const fn set_nakintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetintrpt(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Interrupt (NYETIntrpt)"]
            #[inline(always)]
            pub const fn set_nyetintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Setup Packet Received"]
            #[must_use]
            #[inline(always)]
            pub const fn stuppktrcvd(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Setup Packet Received"]
            #[inline(always)]
            pub const fn set_stuppktrcvd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Doepint5 {
            #[inline(always)]
            fn default() -> Doepint5 {
                Doepint5(0)
            }
        }
        impl core::fmt::Debug for Doepint5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepint5")
                    .field("xfercompl", &self.xfercompl())
                    .field("epdisbld", &self.epdisbld())
                    .field("ahberr", &self.ahberr())
                    .field("setup", &self.setup())
                    .field("outtknepdis", &self.outtknepdis())
                    .field("stsphsercvd", &self.stsphsercvd())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterr", &self.outpkterr())
                    .field("bnaintr", &self.bnaintr())
                    .field("pktdrpsts", &self.pktdrpsts())
                    .field("bbleerr", &self.bbleerr())
                    .field("nakintrpt", &self.nakintrpt())
                    .field("nyetintrpt", &self.nyetintrpt())
                    .field("stuppktrcvd", &self.stuppktrcvd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepint5 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepint5 {{ xfercompl: {=bool:?}, epdisbld: {=bool:?}, ahberr: {=bool:?}, setup: {=bool:?}, outtknepdis: {=bool:?}, stsphsercvd: {=bool:?}, back2backsetup: {=bool:?}, outpkterr: {=bool:?}, bnaintr: {=bool:?}, pktdrpsts: {=bool:?}, bbleerr: {=bool:?}, nakintrpt: {=bool:?}, nyetintrpt: {=bool:?}, stuppktrcvd: {=bool:?} }}" , self . xfercompl () , self . epdisbld () , self . ahberr () , self . setup () , self . outtknepdis () , self . stsphsercvd () , self . back2backsetup () , self . outpkterr () , self . bnaintr () , self . pktdrpsts () , self . bbleerr () , self . nakintrpt () , self . nyetintrpt () , self . stuppktrcvd ())
            }
        }
        #[doc = "Device OUT Endpoint Common Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doepmsk(pub u32);
        impl Doepmsk {
            #[doc = "Transfer Completed Interrupt Mask (XferComplMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercomplmsk(&self) -> super::vals::DoepmskXfercomplmsk {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DoepmskXfercomplmsk::from_bits(val as u8)
            }
            #[doc = "Transfer Completed Interrupt Mask (XferComplMsk)"]
            #[inline(always)]
            pub const fn set_xfercomplmsk(&mut self, val: super::vals::DoepmskXfercomplmsk) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Endpoint Disabled Interrupt Mask (EPDisbldMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn epdisbldmsk(&self) -> super::vals::DoepmskEpdisbldmsk {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::DoepmskEpdisbldmsk::from_bits(val as u8)
            }
            #[doc = "Endpoint Disabled Interrupt Mask (EPDisbldMsk)"]
            #[inline(always)]
            pub const fn set_epdisbldmsk(&mut self, val: super::vals::DoepmskEpdisbldmsk) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErrMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberrmsk(&self) -> super::vals::DoepmskAhberrmsk {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::DoepmskAhberrmsk::from_bits(val as u8)
            }
            #[doc = "AHB Error (AHBErrMsk)"]
            #[inline(always)]
            pub const fn set_ahberrmsk(&mut self, val: super::vals::DoepmskAhberrmsk) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "SETUP Phase Done Mask (SetUPMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn setupmsk(&self) -> super::vals::Setupmsk {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Setupmsk::from_bits(val as u8)
            }
            #[doc = "SETUP Phase Done Mask (SetUPMsk)"]
            #[inline(always)]
            pub const fn set_setupmsk(&mut self, val: super::vals::Setupmsk) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn outtknepdismsk(&self) -> super::vals::Outtknepdismsk {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Outtknepdismsk::from_bits(val as u8)
            }
            #[doc = "OUT Token Received when Endpoint Disabled Mask (OUTTknEPdisMsk)"]
            #[inline(always)]
            pub const fn set_outtknepdismsk(&mut self, val: super::vals::Outtknepdismsk) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Status Phase Received Mask (StsPhseRcvdMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn stsphsercvdmsk(&self) -> super::vals::Stsphsercvdmsk {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Stsphsercvdmsk::from_bits(val as u8)
            }
            #[doc = "Status Phase Received Mask (StsPhseRcvdMsk)"]
            #[inline(always)]
            pub const fn set_stsphsercvdmsk(&mut self, val: super::vals::Stsphsercvdmsk) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Back-to-Back SETUP Packets Received Mask (Back2BackSETup)"]
            #[must_use]
            #[inline(always)]
            pub const fn back2backsetup(&self) -> super::vals::DoepmskBack2backsetup {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::DoepmskBack2backsetup::from_bits(val as u8)
            }
            #[doc = "Back-to-Back SETUP Packets Received Mask (Back2BackSETup)"]
            #[inline(always)]
            pub const fn set_back2backsetup(&mut self, val: super::vals::DoepmskBack2backsetup) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "OUT Packet Error Mask (OutPktErrMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn outpkterrmsk(&self) -> super::vals::Outpkterrmsk {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Outpkterrmsk::from_bits(val as u8)
            }
            #[doc = "OUT Packet Error Mask (OutPktErrMsk)"]
            #[inline(always)]
            pub const fn set_outpkterrmsk(&mut self, val: super::vals::Outpkterrmsk) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Babble Error interrupt Mask (BbleErrMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn bbleerrmsk(&self) -> super::vals::Bbleerrmsk {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Bbleerrmsk::from_bits(val as u8)
            }
            #[doc = "Babble Error interrupt Mask (BbleErrMsk)"]
            #[inline(always)]
            pub const fn set_bbleerrmsk(&mut self, val: super::vals::Bbleerrmsk) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "NAK interrupt Mask (NAKMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn nakmsk(&self) -> super::vals::DoepmskNakmsk {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::DoepmskNakmsk::from_bits(val as u8)
            }
            #[doc = "NAK interrupt Mask (NAKMsk)"]
            #[inline(always)]
            pub const fn set_nakmsk(&mut self, val: super::vals::DoepmskNakmsk) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "NYET interrupt Mask (NYETMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyetmsk(&self) -> super::vals::DoepmskNyetmsk {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::DoepmskNyetmsk::from_bits(val as u8)
            }
            #[doc = "NYET interrupt Mask (NYETMsk)"]
            #[inline(always)]
            pub const fn set_nyetmsk(&mut self, val: super::vals::DoepmskNyetmsk) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Doepmsk {
            #[inline(always)]
            fn default() -> Doepmsk {
                Doepmsk(0)
            }
        }
        impl core::fmt::Debug for Doepmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doepmsk")
                    .field("xfercomplmsk", &self.xfercomplmsk())
                    .field("epdisbldmsk", &self.epdisbldmsk())
                    .field("ahberrmsk", &self.ahberrmsk())
                    .field("setupmsk", &self.setupmsk())
                    .field("outtknepdismsk", &self.outtknepdismsk())
                    .field("stsphsercvdmsk", &self.stsphsercvdmsk())
                    .field("back2backsetup", &self.back2backsetup())
                    .field("outpkterrmsk", &self.outpkterrmsk())
                    .field("bbleerrmsk", &self.bbleerrmsk())
                    .field("nakmsk", &self.nakmsk())
                    .field("nyetmsk", &self.nyetmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doepmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Doepmsk {{ xfercomplmsk: {:?}, epdisbldmsk: {:?}, ahberrmsk: {:?}, setupmsk: {:?}, outtknepdismsk: {:?}, stsphsercvdmsk: {:?}, back2backsetup: {:?}, outpkterrmsk: {:?}, bbleerrmsk: {:?}, nakmsk: {:?}, nyetmsk: {:?} }}" , self . xfercomplmsk () , self . epdisbldmsk () , self . ahberrmsk () , self . setupmsk () , self . outtknepdismsk () , self . stsphsercvdmsk () , self . back2backsetup () , self . outpkterrmsk () , self . bbleerrmsk () , self . nakmsk () , self . nyetmsk ())
            }
        }
        #[doc = "Device OUT Endpoint 0 Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz0(pub u32);
        impl Doeptsiz0 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "SETUP Packet Count (SUPCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn supcnt(&self) -> super::vals::Supcnt {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Supcnt::from_bits(val as u8)
            }
            #[doc = "SETUP Packet Count (SUPCnt)"]
            #[inline(always)]
            pub const fn set_supcnt(&mut self, val: super::vals::Supcnt) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz0 {
            #[inline(always)]
            fn default() -> Doeptsiz0 {
                Doeptsiz0(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz0")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("supcnt", &self.supcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz0 {{ xfersize: {=u8:?}, pktcnt: {=bool:?}, supcnt: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.supcnt()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz1(pub u32);
        impl Doeptsiz1 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz1Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz1Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz1Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz1 {
            #[inline(always)]
            fn default() -> Doeptsiz1 {
                Doeptsiz1(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz1")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz1 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz12(pub u32);
        impl Doeptsiz12 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz12Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz12Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz12Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz12 {
            #[inline(always)]
            fn default() -> Doeptsiz12 {
                Doeptsiz12(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz12 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz12")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz12 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz12 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz13(pub u32);
        impl Doeptsiz13 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz13Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz13Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz13Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz13 {
            #[inline(always)]
            fn default() -> Doeptsiz13 {
                Doeptsiz13(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz13 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz13")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz13 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz13 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz14(pub u32);
        impl Doeptsiz14 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz14Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz14Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz14Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz14 {
            #[inline(always)]
            fn default() -> Doeptsiz14 {
                Doeptsiz14(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz14 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz14")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz14 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz14 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz15(pub u32);
        impl Doeptsiz15 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz15Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz15Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz15Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz15 {
            #[inline(always)]
            fn default() -> Doeptsiz15 {
                Doeptsiz15(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz15 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz15")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz15 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz15 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz2(pub u32);
        impl Doeptsiz2 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz2Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz2Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz2Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz2 {
            #[inline(always)]
            fn default() -> Doeptsiz2 {
                Doeptsiz2(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz2")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz2 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz3(pub u32);
        impl Doeptsiz3 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz3Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz3Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz3Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz3 {
            #[inline(always)]
            fn default() -> Doeptsiz3 {
                Doeptsiz3(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz3")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz3 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz4(pub u32);
        impl Doeptsiz4 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz4Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz4Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz4Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz4 {
            #[inline(always)]
            fn default() -> Doeptsiz4 {
                Doeptsiz4(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz4")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz4 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device OUT Endpoint Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Doeptsiz5(pub u32);
        impl Doeptsiz5 {
            #[doc = "Transfer Size (XferSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Transfer Size (XferSize)"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Packet Count (PktCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Packet Count (PktCnt)"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "RxDPID"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdpid(&self) -> super::vals::Doeptsiz5Rxdpid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Doeptsiz5Rxdpid::from_bits(val as u8)
            }
            #[doc = "RxDPID"]
            #[inline(always)]
            pub const fn set_rxdpid(&mut self, val: super::vals::Doeptsiz5Rxdpid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Doeptsiz5 {
            #[inline(always)]
            fn default() -> Doeptsiz5 {
                Doeptsiz5(0)
            }
        }
        impl core::fmt::Debug for Doeptsiz5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Doeptsiz5")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("rxdpid", &self.rxdpid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Doeptsiz5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Doeptsiz5 {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, rxdpid: {:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.rxdpid()
                )
            }
        }
        #[doc = "Device Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dsts(pub u32);
        impl Dsts {
            #[doc = "Suspend Status (SuspSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn suspsts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Suspend Status (SuspSts)"]
            #[inline(always)]
            pub const fn set_suspsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enumerated Speed (EnumSpd)"]
            #[must_use]
            #[inline(always)]
            pub const fn enumspd(&self) -> super::vals::Enumspd {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Enumspd::from_bits(val as u8)
            }
            #[doc = "Enumerated Speed (EnumSpd)"]
            #[inline(always)]
            pub const fn set_enumspd(&mut self, val: super::vals::Enumspd) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
            #[doc = "Erratic Error (ErrticErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn errticerr(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Erratic Error (ErrticErr)"]
            #[inline(always)]
            pub const fn set_errticerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Frame or Microframe Number of the Received SOF (SOFFN)"]
            #[must_use]
            #[inline(always)]
            pub const fn soffn(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x3fff;
                val as u16
            }
            #[doc = "Frame or Microframe Number of the Received SOF (SOFFN)"]
            #[inline(always)]
            pub const fn set_soffn(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 8usize)) | (((val as u32) & 0x3fff) << 8usize);
            }
            #[doc = "Device Line Status (DevLnSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn devlnsts(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "Device Line Status (DevLnSts)"]
            #[inline(always)]
            pub const fn set_devlnsts(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
        }
        impl Default for Dsts {
            #[inline(always)]
            fn default() -> Dsts {
                Dsts(0)
            }
        }
        impl core::fmt::Debug for Dsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dsts")
                    .field("suspsts", &self.suspsts())
                    .field("enumspd", &self.enumspd())
                    .field("errticerr", &self.errticerr())
                    .field("soffn", &self.soffn())
                    .field("devlnsts", &self.devlnsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dsts {{ suspsts: {=bool:?}, enumspd: {:?}, errticerr: {=bool:?}, soffn: {=u16:?}, devlnsts: {=u8:?} }}" , self . suspsts () , self . enumspd () , self . errticerr () , self . soffn () , self . devlnsts ())
            }
        }
        #[doc = "Device Threshold Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dthrctl(pub u32);
        impl Dthrctl {
            #[doc = "Non-ISO IN Endpoints Threshold Enable. (NonISOThrEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn nonisothren(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Non-ISO IN Endpoints Threshold Enable. (NonISOThrEn)"]
            #[inline(always)]
            pub const fn set_nonisothren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn isothren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_isothren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Transmit Threshold Length (TxThrLen)"]
            #[must_use]
            #[inline(always)]
            pub const fn txthrlen(&self) -> u16 {
                let val = (self.0 >> 2usize) & 0x01ff;
                val as u16
            }
            #[doc = "Transmit Threshold Length (TxThrLen)"]
            #[inline(always)]
            pub const fn set_txthrlen(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 2usize)) | (((val as u32) & 0x01ff) << 2usize);
            }
            #[doc = "AHB Threshold Ratio (AHBThrRatio)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbthrratio(&self) -> super::vals::Ahbthrratio {
                let val = (self.0 >> 11usize) & 0x03;
                super::vals::Ahbthrratio::from_bits(val as u8)
            }
            #[doc = "AHB Threshold Ratio (AHBThrRatio)"]
            #[inline(always)]
            pub const fn set_ahbthrratio(&mut self, val: super::vals::Ahbthrratio) {
                self.0 =
                    (self.0 & !(0x03 << 11usize)) | (((val.to_bits() as u32) & 0x03) << 11usize);
            }
            #[doc = "Receive Threshold Enable (RxThrEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxthren(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Receive Threshold Enable (RxThrEn)"]
            #[inline(always)]
            pub const fn set_rxthren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Receive Threshold Length (RxThrLen)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxthrlen(&self) -> u16 {
                let val = (self.0 >> 17usize) & 0x01ff;
                val as u16
            }
            #[doc = "Receive Threshold Length (RxThrLen)"]
            #[inline(always)]
            pub const fn set_rxthrlen(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 17usize)) | (((val as u32) & 0x01ff) << 17usize);
            }
            #[doc = "Arbiter Parking Enable (ArbPrkEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn arbprken(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Arbiter Parking Enable (ArbPrkEn)"]
            #[inline(always)]
            pub const fn set_arbprken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Dthrctl {
            #[inline(always)]
            fn default() -> Dthrctl {
                Dthrctl(0)
            }
        }
        impl core::fmt::Debug for Dthrctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dthrctl")
                    .field("nonisothren", &self.nonisothren())
                    .field("isothren", &self.isothren())
                    .field("txthrlen", &self.txthrlen())
                    .field("ahbthrratio", &self.ahbthrratio())
                    .field("rxthren", &self.rxthren())
                    .field("rxthrlen", &self.rxthrlen())
                    .field("arbprken", &self.arbprken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dthrctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dthrctl {{ nonisothren: {=bool:?}, isothren: {=bool:?}, txthrlen: {=u16:?}, ahbthrratio: {:?}, rxthren: {=bool:?}, rxthrlen: {=u16:?}, arbprken: {=bool:?} }}" , self . nonisothren () , self . isothren () , self . txthrlen () , self . ahbthrratio () , self . rxthren () , self . rxthrlen () , self . arbprken ())
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts0(pub u32);
        impl Dtxfsts0 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts0 {
            #[inline(always)]
            fn default() -> Dtxfsts0 {
                Dtxfsts0(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts0")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts0 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts1(pub u32);
        impl Dtxfsts1 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts1 {
            #[inline(always)]
            fn default() -> Dtxfsts1 {
                Dtxfsts1(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts1")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts1 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts10(pub u32);
        impl Dtxfsts10 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts10 {
            #[inline(always)]
            fn default() -> Dtxfsts10 {
                Dtxfsts10(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts10 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts10")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts10 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts10 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts11(pub u32);
        impl Dtxfsts11 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts11 {
            #[inline(always)]
            fn default() -> Dtxfsts11 {
                Dtxfsts11(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts11")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts11 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts2(pub u32);
        impl Dtxfsts2 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts2 {
            #[inline(always)]
            fn default() -> Dtxfsts2 {
                Dtxfsts2(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts2")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts2 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts3(pub u32);
        impl Dtxfsts3 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts3 {
            #[inline(always)]
            fn default() -> Dtxfsts3 {
                Dtxfsts3(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts3")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts3 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts4(pub u32);
        impl Dtxfsts4 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts4 {
            #[inline(always)]
            fn default() -> Dtxfsts4 {
                Dtxfsts4(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts4")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts4 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts5(pub u32);
        impl Dtxfsts5 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts5 {
            #[inline(always)]
            fn default() -> Dtxfsts5 {
                Dtxfsts5(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts5 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts5")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts5 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts5 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts6(pub u32);
        impl Dtxfsts6 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts6 {
            #[inline(always)]
            fn default() -> Dtxfsts6 {
                Dtxfsts6(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts6 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts6")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts6 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts6 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts7(pub u32);
        impl Dtxfsts7 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts7 {
            #[inline(always)]
            fn default() -> Dtxfsts7 {
                Dtxfsts7(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts7 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts7")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts7 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts7 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts8(pub u32);
        impl Dtxfsts8 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts8 {
            #[inline(always)]
            fn default() -> Dtxfsts8 {
                Dtxfsts8(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts8 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts8")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts8 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts8 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device IN Endpoint Transmit FIFO Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dtxfsts9(pub u32);
        impl Dtxfsts9 {
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "IN Endpoint TxFIFO Space Avail (INEPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_ineptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dtxfsts9 {
            #[inline(always)]
            fn default() -> Dtxfsts9 {
                Dtxfsts9(0)
            }
        }
        impl core::fmt::Debug for Dtxfsts9 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dtxfsts9")
                    .field("ineptxfspcavail", &self.ineptxfspcavail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dtxfsts9 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dtxfsts9 {{ ineptxfspcavail: {=u16:?} }}",
                    self.ineptxfspcavail()
                )
            }
        }
        #[doc = "Device VBUS Discharge Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dvbusdis(pub u32);
        impl Dvbusdis {
            #[doc = "Device VBUS Discharge Time (DVBUSDis)"]
            #[must_use]
            #[inline(always)]
            pub const fn dvbusdis(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Device VBUS Discharge Time (DVBUSDis)"]
            #[inline(always)]
            pub const fn set_dvbusdis(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dvbusdis {
            #[inline(always)]
            fn default() -> Dvbusdis {
                Dvbusdis(0)
            }
        }
        impl core::fmt::Debug for Dvbusdis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dvbusdis")
                    .field("dvbusdis", &self.dvbusdis())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dvbusdis {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dvbusdis {{ dvbusdis: {=u16:?} }}", self.dvbusdis())
            }
        }
        #[doc = "Device VBUS Pulsing Time Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dvbuspulse(pub u32);
        impl Dvbuspulse {
            #[doc = "Device VBUS Pulsing Time (DVBUSPulse)"]
            #[must_use]
            #[inline(always)]
            pub const fn dvbuspulse(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Device VBUS Pulsing Time (DVBUSPulse)"]
            #[inline(always)]
            pub const fn set_dvbuspulse(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Dvbuspulse {
            #[inline(always)]
            fn default() -> Dvbuspulse {
                Dvbuspulse(0)
            }
        }
        impl core::fmt::Debug for Dvbuspulse {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dvbuspulse")
                    .field("dvbuspulse", &self.dvbuspulse())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dvbuspulse {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dvbuspulse {{ dvbuspulse: {=u16:?} }}",
                    self.dvbuspulse()
                )
            }
        }
        #[doc = "AHB Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gahbcfg(pub u32);
        impl Gahbcfg {
            #[doc = "Mode: Host and device. Global Interrupt Mask (GlblIntrMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn glblintrmsk(&self) -> super::vals::Glblintrmsk {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Glblintrmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and device. Global Interrupt Mask (GlblIntrMsk)"]
            #[inline(always)]
            pub const fn set_glblintrmsk(&mut self, val: super::vals::Glblintrmsk) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode: Host and device. Burst Length/Type (HBstLen)"]
            #[must_use]
            #[inline(always)]
            pub const fn hbstlen(&self) -> super::vals::Hbstlen {
                let val = (self.0 >> 1usize) & 0x0f;
                super::vals::Hbstlen::from_bits(val as u8)
            }
            #[doc = "Mode: Host and device. Burst Length/Type (HBstLen)"]
            #[inline(always)]
            pub const fn set_hbstlen(&mut self, val: super::vals::Hbstlen) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val.to_bits() as u32) & 0x0f) << 1usize);
            }
            #[doc = "Mode: Host and device. DMA Enable (DMAEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaen(&self) -> super::vals::Dmaen {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Dmaen::from_bits(val as u8)
            }
            #[doc = "Mode: Host and device. DMA Enable (DMAEn)"]
            #[inline(always)]
            pub const fn set_dmaen(&mut self, val: super::vals::Dmaen) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Mode: Host and device. Non-Periodic TxFIFO Empty Level (NPTxFEmpLvl)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfemplvl(&self) -> super::vals::Nptxfemplvl {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Nptxfemplvl::from_bits(val as u8)
            }
            #[doc = "Mode: Host and device. Non-Periodic TxFIFO Empty Level (NPTxFEmpLvl)"]
            #[inline(always)]
            pub const fn set_nptxfemplvl(&mut self, val: super::vals::Nptxfemplvl) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Mode: Host and Device. Remote Memory Support (RemMemSupp)"]
            #[must_use]
            #[inline(always)]
            pub const fn remmemsupp(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Remote Memory Support (RemMemSupp)"]
            #[inline(always)]
            pub const fn set_remmemsupp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Mode: Host and Device. Notify All DMA Write Transactions (NotiAllDmaWrit)"]
            #[must_use]
            #[inline(always)]
            pub const fn notialldmawrit(&self) -> super::vals::Notialldmawrit {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Notialldmawrit::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Notify All DMA Write Transactions (NotiAllDmaWrit)"]
            #[inline(always)]
            pub const fn set_notialldmawrit(&mut self, val: super::vals::Notialldmawrit) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Mode: Host and Device. AHB Single Support (AHBSingle)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbsingle(&self) -> super::vals::Ahbsingle {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Ahbsingle::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. AHB Single Support (AHBSingle)"]
            #[inline(always)]
            pub const fn set_ahbsingle(&mut self, val: super::vals::Ahbsingle) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Gahbcfg {
            #[inline(always)]
            fn default() -> Gahbcfg {
                Gahbcfg(0)
            }
        }
        impl core::fmt::Debug for Gahbcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gahbcfg")
                    .field("glblintrmsk", &self.glblintrmsk())
                    .field("hbstlen", &self.hbstlen())
                    .field("dmaen", &self.dmaen())
                    .field("nptxfemplvl", &self.nptxfemplvl())
                    .field("remmemsupp", &self.remmemsupp())
                    .field("notialldmawrit", &self.notialldmawrit())
                    .field("ahbsingle", &self.ahbsingle())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gahbcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gahbcfg {{ glblintrmsk: {:?}, hbstlen: {:?}, dmaen: {:?}, nptxfemplvl: {:?}, remmemsupp: {=bool:?}, notialldmawrit: {:?}, ahbsingle: {:?} }}" , self . glblintrmsk () , self . hbstlen () , self . dmaen () , self . nptxfemplvl () , self . remmemsupp () , self . notialldmawrit () , self . ahbsingle ())
            }
        }
        #[doc = "Global DFIFO Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gdfifocfg(pub u32);
        impl Gdfifocfg {
            #[doc = "GDFIFOCfg"]
            #[must_use]
            #[inline(always)]
            pub const fn gdfifocfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "GDFIFOCfg"]
            #[inline(always)]
            pub const fn set_gdfifocfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "This field provides the start address of the EP info controller."]
            #[must_use]
            #[inline(always)]
            pub const fn epinfobaseaddr(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "This field provides the start address of the EP info controller."]
            #[inline(always)]
            pub const fn set_epinfobaseaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Gdfifocfg {
            #[inline(always)]
            fn default() -> Gdfifocfg {
                Gdfifocfg(0)
            }
        }
        impl core::fmt::Debug for Gdfifocfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gdfifocfg")
                    .field("gdfifocfg", &self.gdfifocfg())
                    .field("epinfobaseaddr", &self.epinfobaseaddr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gdfifocfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gdfifocfg {{ gdfifocfg: {=u16:?}, epinfobaseaddr: {=u16:?} }}",
                    self.gdfifocfg(),
                    self.epinfobaseaddr()
                )
            }
        }
        #[doc = "General Purpose Input/Output Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ggpio(pub u32);
        impl Ggpio {
            #[must_use]
            #[inline(always)]
            pub const fn gpi(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_gpi(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn gpo(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_gpo(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ggpio {
            #[inline(always)]
            fn default() -> Ggpio {
                Ggpio(0)
            }
        }
        impl core::fmt::Debug for Ggpio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ggpio")
                    .field("gpi", &self.gpi())
                    .field("gpo", &self.gpo())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ggpio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ggpio {{ gpi: {=u16:?}, gpo: {=u16:?} }}",
                    self.gpi(),
                    self.gpo()
                )
            }
        }
        #[doc = "User Hardware Configuration 2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ghwcfg2(pub u32);
        impl Ghwcfg2 {
            #[doc = "Mode of Operation (OtgMode)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgmode(&self) -> super::vals::Otgmode {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Otgmode::from_bits(val as u8)
            }
            #[doc = "Mode of Operation (OtgMode)"]
            #[inline(always)]
            pub const fn set_otgmode(&mut self, val: super::vals::Otgmode) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Architecture (OtgArch)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgarch(&self) -> super::vals::Otgarch {
                let val = (self.0 >> 3usize) & 0x03;
                super::vals::Otgarch::from_bits(val as u8)
            }
            #[doc = "Architecture (OtgArch)"]
            #[inline(always)]
            pub const fn set_otgarch(&mut self, val: super::vals::Otgarch) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val.to_bits() as u32) & 0x03) << 3usize);
            }
            #[doc = "Point-to-Point (SingPnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn singpnt(&self) -> super::vals::Singpnt {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Singpnt::from_bits(val as u8)
            }
            #[doc = "Point-to-Point (SingPnt)"]
            #[inline(always)]
            pub const fn set_singpnt(&mut self, val: super::vals::Singpnt) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "High-Speed PHY Interface Type (HSPhyType)"]
            #[must_use]
            #[inline(always)]
            pub const fn hsphytype(&self) -> super::vals::Hsphytype {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Hsphytype::from_bits(val as u8)
            }
            #[doc = "High-Speed PHY Interface Type (HSPhyType)"]
            #[inline(always)]
            pub const fn set_hsphytype(&mut self, val: super::vals::Hsphytype) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Full-Speed PHY Interface Type (FSPhyType)"]
            #[must_use]
            #[inline(always)]
            pub const fn fsphytype(&self) -> super::vals::Fsphytype {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Fsphytype::from_bits(val as u8)
            }
            #[doc = "Full-Speed PHY Interface Type (FSPhyType)"]
            #[inline(always)]
            pub const fn set_fsphytype(&mut self, val: super::vals::Fsphytype) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Number of Device Endpoints (NumDevEps)"]
            #[must_use]
            #[inline(always)]
            pub const fn numdeveps(&self) -> super::vals::Numdeveps {
                let val = (self.0 >> 10usize) & 0x0f;
                super::vals::Numdeveps::from_bits(val as u8)
            }
            #[doc = "Number of Device Endpoints (NumDevEps)"]
            #[inline(always)]
            pub const fn set_numdeveps(&mut self, val: super::vals::Numdeveps) {
                self.0 =
                    (self.0 & !(0x0f << 10usize)) | (((val.to_bits() as u32) & 0x0f) << 10usize);
            }
            #[doc = "Number of Host Channels (NumHstChnl)"]
            #[must_use]
            #[inline(always)]
            pub const fn numhstchnl(&self) -> super::vals::Numhstchnl {
                let val = (self.0 >> 14usize) & 0x0f;
                super::vals::Numhstchnl::from_bits(val as u8)
            }
            #[doc = "Number of Host Channels (NumHstChnl)"]
            #[inline(always)]
            pub const fn set_numhstchnl(&mut self, val: super::vals::Numhstchnl) {
                self.0 =
                    (self.0 & !(0x0f << 14usize)) | (((val.to_bits() as u32) & 0x0f) << 14usize);
            }
            #[doc = "Periodic OUT Channels Supported in Host Mode (PerioSupport)"]
            #[must_use]
            #[inline(always)]
            pub const fn periosupport(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Periodic OUT Channels Supported in Host Mode (PerioSupport)"]
            #[inline(always)]
            pub const fn set_periosupport(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Dynamic FIFO Sizing Enabled (DynFifoSizing)"]
            #[must_use]
            #[inline(always)]
            pub const fn dynfifosizing(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Dynamic FIFO Sizing Enabled (DynFifoSizing)"]
            #[inline(always)]
            pub const fn set_dynfifosizing(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Multi Processor Interrupt Enabled (MultiProcIntrpt)"]
            #[must_use]
            #[inline(always)]
            pub const fn multiprocintrpt(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Multi Processor Interrupt Enabled (MultiProcIntrpt)"]
            #[inline(always)]
            pub const fn set_multiprocintrpt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Non-periodic Request Queue Depth (NPTxQDepth)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxqdepth(&self) -> super::vals::Nptxqdepth {
                let val = (self.0 >> 22usize) & 0x03;
                super::vals::Nptxqdepth::from_bits(val as u8)
            }
            #[doc = "Non-periodic Request Queue Depth (NPTxQDepth)"]
            #[inline(always)]
            pub const fn set_nptxqdepth(&mut self, val: super::vals::Nptxqdepth) {
                self.0 =
                    (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
            }
            #[doc = "Host Mode Periodic Request Queue Depth (PTxQDepth)"]
            #[must_use]
            #[inline(always)]
            pub const fn ptxqdepth(&self) -> super::vals::Ptxqdepth {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Ptxqdepth::from_bits(val as u8)
            }
            #[doc = "Host Mode Periodic Request Queue Depth (PTxQDepth)"]
            #[inline(always)]
            pub const fn set_ptxqdepth(&mut self, val: super::vals::Ptxqdepth) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Device Mode IN Token Sequence Learning Queue Depth (TknQDepth)"]
            #[must_use]
            #[inline(always)]
            pub const fn tknqdepth(&self) -> u8 {
                let val = (self.0 >> 26usize) & 0x1f;
                val as u8
            }
            #[doc = "Device Mode IN Token Sequence Learning Queue Depth (TknQDepth)"]
            #[inline(always)]
            pub const fn set_tknqdepth(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 26usize)) | (((val as u32) & 0x1f) << 26usize);
            }
        }
        impl Default for Ghwcfg2 {
            #[inline(always)]
            fn default() -> Ghwcfg2 {
                Ghwcfg2(0)
            }
        }
        impl core::fmt::Debug for Ghwcfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ghwcfg2")
                    .field("otgmode", &self.otgmode())
                    .field("otgarch", &self.otgarch())
                    .field("singpnt", &self.singpnt())
                    .field("hsphytype", &self.hsphytype())
                    .field("fsphytype", &self.fsphytype())
                    .field("numdeveps", &self.numdeveps())
                    .field("numhstchnl", &self.numhstchnl())
                    .field("periosupport", &self.periosupport())
                    .field("dynfifosizing", &self.dynfifosizing())
                    .field("multiprocintrpt", &self.multiprocintrpt())
                    .field("nptxqdepth", &self.nptxqdepth())
                    .field("ptxqdepth", &self.ptxqdepth())
                    .field("tknqdepth", &self.tknqdepth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ghwcfg2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ghwcfg2 {{ otgmode: {:?}, otgarch: {:?}, singpnt: {:?}, hsphytype: {:?}, fsphytype: {:?}, numdeveps: {:?}, numhstchnl: {:?}, periosupport: {=bool:?}, dynfifosizing: {=bool:?}, multiprocintrpt: {=bool:?}, nptxqdepth: {:?}, ptxqdepth: {:?}, tknqdepth: {=u8:?} }}" , self . otgmode () , self . otgarch () , self . singpnt () , self . hsphytype () , self . fsphytype () , self . numdeveps () , self . numhstchnl () , self . periosupport () , self . dynfifosizing () , self . multiprocintrpt () , self . nptxqdepth () , self . ptxqdepth () , self . tknqdepth ())
            }
        }
        #[doc = "User Hardware Configuration 3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ghwcfg3(pub u32);
        impl Ghwcfg3 {
            #[doc = "Width of Transfer Size Counters (XferSizeWidth)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersizewidth(&self) -> super::vals::Xfersizewidth {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Xfersizewidth::from_bits(val as u8)
            }
            #[doc = "Width of Transfer Size Counters (XferSizeWidth)"]
            #[inline(always)]
            pub const fn set_xfersizewidth(&mut self, val: super::vals::Xfersizewidth) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Width of Packet Size Counters (PktSizeWidth)"]
            #[must_use]
            #[inline(always)]
            pub const fn pktsizewidth(&self) -> super::vals::Pktsizewidth {
                let val = (self.0 >> 4usize) & 0x07;
                super::vals::Pktsizewidth::from_bits(val as u8)
            }
            #[doc = "Width of Packet Size Counters (PktSizeWidth)"]
            #[inline(always)]
            pub const fn set_pktsizewidth(&mut self, val: super::vals::Pktsizewidth) {
                self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
            }
            #[doc = "OTG Function Enabled (OtgEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgen(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "OTG Function Enabled (OtgEn)"]
            #[inline(always)]
            pub const fn set_otgen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "I2C Selection (I2CIntSel)"]
            #[must_use]
            #[inline(always)]
            pub const fn i2cintsel(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "I2C Selection (I2CIntSel)"]
            #[inline(always)]
            pub const fn set_i2cintsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Vendor Control Interface Support (VndctlSupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn vndctlsupt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Vendor Control Interface Support (VndctlSupt)"]
            #[inline(always)]
            pub const fn set_vndctlsupt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Optional Features Removed (OptFeature)"]
            #[must_use]
            #[inline(always)]
            pub const fn optfeature(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Optional Features Removed (OptFeature)"]
            #[inline(always)]
            pub const fn set_optfeature(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Reset Style for Clocked always Blocks in RTL (RstType)"]
            #[must_use]
            #[inline(always)]
            pub const fn rsttype(&self) -> super::vals::Rsttype {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Rsttype::from_bits(val as u8)
            }
            #[doc = "Reset Style for Clocked always Blocks in RTL (RstType)"]
            #[inline(always)]
            pub const fn set_rsttype(&mut self, val: super::vals::Rsttype) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "This bit indicates whether ADP logic is present within or external to the controller"]
            #[must_use]
            #[inline(always)]
            pub const fn adpsupport(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates whether ADP logic is present within or external to the controller"]
            #[inline(always)]
            pub const fn set_adpsupport(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "HSIC mode specified for Mode of Operation"]
            #[must_use]
            #[inline(always)]
            pub const fn hsicmode(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "HSIC mode specified for Mode of Operation"]
            #[inline(always)]
            pub const fn set_hsicmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "This bit indicates the controller support for Battery Charger."]
            #[must_use]
            #[inline(always)]
            pub const fn bcsupport(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates the controller support for Battery Charger."]
            #[inline(always)]
            pub const fn set_bcsupport(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "LPM mode specified for Mode of Operation."]
            #[must_use]
            #[inline(always)]
            pub const fn lpmmode(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "LPM mode specified for Mode of Operation."]
            #[inline(always)]
            pub const fn set_lpmmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "DFIFO Depth (DfifoDepth - EP_LOC_CNT)"]
            #[must_use]
            #[inline(always)]
            pub const fn dfifodepth(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "DFIFO Depth (DfifoDepth - EP_LOC_CNT)"]
            #[inline(always)]
            pub const fn set_dfifodepth(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Ghwcfg3 {
            #[inline(always)]
            fn default() -> Ghwcfg3 {
                Ghwcfg3(0)
            }
        }
        impl core::fmt::Debug for Ghwcfg3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ghwcfg3")
                    .field("xfersizewidth", &self.xfersizewidth())
                    .field("pktsizewidth", &self.pktsizewidth())
                    .field("otgen", &self.otgen())
                    .field("i2cintsel", &self.i2cintsel())
                    .field("vndctlsupt", &self.vndctlsupt())
                    .field("optfeature", &self.optfeature())
                    .field("rsttype", &self.rsttype())
                    .field("adpsupport", &self.adpsupport())
                    .field("hsicmode", &self.hsicmode())
                    .field("bcsupport", &self.bcsupport())
                    .field("lpmmode", &self.lpmmode())
                    .field("dfifodepth", &self.dfifodepth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ghwcfg3 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ghwcfg3 {{ xfersizewidth: {:?}, pktsizewidth: {:?}, otgen: {=bool:?}, i2cintsel: {=bool:?}, vndctlsupt: {=bool:?}, optfeature: {=bool:?}, rsttype: {:?}, adpsupport: {=bool:?}, hsicmode: {=bool:?}, bcsupport: {=bool:?}, lpmmode: {=bool:?}, dfifodepth: {=u16:?} }}" , self . xfersizewidth () , self . pktsizewidth () , self . otgen () , self . i2cintsel () , self . vndctlsupt () , self . optfeature () , self . rsttype () , self . adpsupport () , self . hsicmode () , self . bcsupport () , self . lpmmode () , self . dfifodepth ())
            }
        }
        #[doc = "User Hardware Configuration 4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ghwcfg4(pub u32);
        impl Ghwcfg4 {
            #[doc = "Number of Device Mode Periodic IN Endpoints (NumDevPerioEps)"]
            #[must_use]
            #[inline(always)]
            pub const fn numdevperioeps(&self) -> super::vals::Numdevperioeps {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Numdevperioeps::from_bits(val as u8)
            }
            #[doc = "Number of Device Mode Periodic IN Endpoints (NumDevPerioEps)"]
            #[inline(always)]
            pub const fn set_numdevperioeps(&mut self, val: super::vals::Numdevperioeps) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Enable Partial Power Down (PartialPwrDn)"]
            #[must_use]
            #[inline(always)]
            pub const fn partialpwrdn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Partial Power Down (PartialPwrDn)"]
            #[inline(always)]
            pub const fn set_partialpwrdn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Minimum AHB Frequency Less Than 60 MHz (AhbFreq)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbfreq(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Minimum AHB Frequency Less Than 60 MHz (AhbFreq)"]
            #[inline(always)]
            pub const fn set_ahbfreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable Hibernation (Hibernation)"]
            #[must_use]
            #[inline(always)]
            pub const fn hibernation(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Hibernation (Hibernation)"]
            #[inline(always)]
            pub const fn set_hibernation(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable Hibernation"]
            #[must_use]
            #[inline(always)]
            pub const fn extendedhibernation(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Hibernation"]
            #[inline(always)]
            pub const fn set_extendedhibernation(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enhanced LPM Support1 (EnhancedLPMSupt1)"]
            #[must_use]
            #[inline(always)]
            pub const fn enhancedlpmsupt1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enhanced LPM Support1 (EnhancedLPMSupt1)"]
            #[inline(always)]
            pub const fn set_enhancedlpmsupt1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Service Interval Flow"]
            #[must_use]
            #[inline(always)]
            pub const fn servintflow(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Service Interval Flow"]
            #[inline(always)]
            pub const fn set_servintflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Interpacket Gap ISOC OUT Worst-case Support (ipgisocSupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn ipgisocsupt(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Interpacket Gap ISOC OUT Worst-case Support (ipgisocSupt)"]
            #[inline(always)]
            pub const fn set_ipgisocsupt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Active Clock Gating Support"]
            #[must_use]
            #[inline(always)]
            pub const fn acgsupt(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Active Clock Gating Support"]
            #[inline(always)]
            pub const fn set_acgsupt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enhanced LPM Support (EnhancedLPMSupt)"]
            #[must_use]
            #[inline(always)]
            pub const fn enhancedlpmsupt(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enhanced LPM Support (EnhancedLPMSupt)"]
            #[inline(always)]
            pub const fn set_enhancedlpmsupt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width"]
            #[must_use]
            #[inline(always)]
            pub const fn phydatawidth(&self) -> super::vals::Phydatawidth {
                let val = (self.0 >> 14usize) & 0x03;
                super::vals::Phydatawidth::from_bits(val as u8)
            }
            #[doc = "UTMI+ PHY/ULPI-to-Internal UTMI+ Wrapper Data Width"]
            #[inline(always)]
            pub const fn set_phydatawidth(&mut self, val: super::vals::Phydatawidth) {
                self.0 =
                    (self.0 & !(0x03 << 14usize)) | (((val.to_bits() as u32) & 0x03) << 14usize);
            }
            #[doc = "Number of Device Mode Control Endpoints in Addition to"]
            #[must_use]
            #[inline(always)]
            pub const fn numctleps(&self) -> super::vals::Numctleps {
                let val = (self.0 >> 16usize) & 0x0f;
                super::vals::Numctleps::from_bits(val as u8)
            }
            #[doc = "Number of Device Mode Control Endpoints in Addition to"]
            #[inline(always)]
            pub const fn set_numctleps(&mut self, val: super::vals::Numctleps) {
                self.0 =
                    (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
            }
            #[doc = "IDDIG Filter Enable (IddgFltr)"]
            #[must_use]
            #[inline(always)]
            pub const fn iddgfltr(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "IDDIG Filter Enable (IddgFltr)"]
            #[inline(always)]
            pub const fn set_iddgfltr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "VBUS Valid Filter Enabled (VBusValidFltr)"]
            #[must_use]
            #[inline(always)]
            pub const fn vbusvalidfltr(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "VBUS Valid Filter Enabled (VBusValidFltr)"]
            #[inline(always)]
            pub const fn set_vbusvalidfltr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "a_valid Filter Enabled (AValidFltr)"]
            #[must_use]
            #[inline(always)]
            pub const fn avalidfltr(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "a_valid Filter Enabled (AValidFltr)"]
            #[inline(always)]
            pub const fn set_avalidfltr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "b_valid Filter Enabled (BValidFltr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bvalidfltr(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "b_valid Filter Enabled (BValidFltr)"]
            #[inline(always)]
            pub const fn set_bvalidfltr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "session_end Filter Enabled (SessEndFltr)"]
            #[must_use]
            #[inline(always)]
            pub const fn sessendfltr(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "session_end Filter Enabled (SessEndFltr)"]
            #[inline(always)]
            pub const fn set_sessendfltr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable Dedicated Transmit FIFO for device IN Endpoints"]
            #[must_use]
            #[inline(always)]
            pub const fn dedfifomode(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Dedicated Transmit FIFO for device IN Endpoints"]
            #[inline(always)]
            pub const fn set_dedfifomode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Number of Device Mode IN Endpoints Including Control Endpoints (INEps)"]
            #[must_use]
            #[inline(always)]
            pub const fn ineps(&self) -> super::vals::Ineps {
                let val = (self.0 >> 26usize) & 0x0f;
                super::vals::Ineps::from_bits(val as u8)
            }
            #[doc = "Number of Device Mode IN Endpoints Including Control Endpoints (INEps)"]
            #[inline(always)]
            pub const fn set_ineps(&mut self, val: super::vals::Ineps) {
                self.0 =
                    (self.0 & !(0x0f << 26usize)) | (((val.to_bits() as u32) & 0x0f) << 26usize);
            }
            #[doc = "Scatter/Gather DMA configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn descdmaenabled(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Scatter/Gather DMA configuration"]
            #[inline(always)]
            pub const fn set_descdmaenabled(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Scatter/Gather DMA configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn descdma(&self) -> super::vals::Descdma {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Descdma::from_bits(val as u8)
            }
            #[doc = "Scatter/Gather DMA configuration"]
            #[inline(always)]
            pub const fn set_descdma(&mut self, val: super::vals::Descdma) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ghwcfg4 {
            #[inline(always)]
            fn default() -> Ghwcfg4 {
                Ghwcfg4(0)
            }
        }
        impl core::fmt::Debug for Ghwcfg4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ghwcfg4")
                    .field("numdevperioeps", &self.numdevperioeps())
                    .field("partialpwrdn", &self.partialpwrdn())
                    .field("ahbfreq", &self.ahbfreq())
                    .field("hibernation", &self.hibernation())
                    .field("extendedhibernation", &self.extendedhibernation())
                    .field("enhancedlpmsupt1", &self.enhancedlpmsupt1())
                    .field("servintflow", &self.servintflow())
                    .field("ipgisocsupt", &self.ipgisocsupt())
                    .field("acgsupt", &self.acgsupt())
                    .field("enhancedlpmsupt", &self.enhancedlpmsupt())
                    .field("phydatawidth", &self.phydatawidth())
                    .field("numctleps", &self.numctleps())
                    .field("iddgfltr", &self.iddgfltr())
                    .field("vbusvalidfltr", &self.vbusvalidfltr())
                    .field("avalidfltr", &self.avalidfltr())
                    .field("bvalidfltr", &self.bvalidfltr())
                    .field("sessendfltr", &self.sessendfltr())
                    .field("dedfifomode", &self.dedfifomode())
                    .field("ineps", &self.ineps())
                    .field("descdmaenabled", &self.descdmaenabled())
                    .field("descdma", &self.descdma())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ghwcfg4 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ghwcfg4 {{ numdevperioeps: {:?}, partialpwrdn: {=bool:?}, ahbfreq: {=bool:?}, hibernation: {=bool:?}, extendedhibernation: {=bool:?}, enhancedlpmsupt1: {=bool:?}, servintflow: {=bool:?}, ipgisocsupt: {=bool:?}, acgsupt: {=bool:?}, enhancedlpmsupt: {=bool:?}, phydatawidth: {:?}, numctleps: {:?}, iddgfltr: {=bool:?}, vbusvalidfltr: {=bool:?}, avalidfltr: {=bool:?}, bvalidfltr: {=bool:?}, sessendfltr: {=bool:?}, dedfifomode: {=bool:?}, ineps: {:?}, descdmaenabled: {=bool:?}, descdma: {:?} }}" , self . numdevperioeps () , self . partialpwrdn () , self . ahbfreq () , self . hibernation () , self . extendedhibernation () , self . enhancedlpmsupt1 () , self . servintflow () , self . ipgisocsupt () , self . acgsupt () , self . enhancedlpmsupt () , self . phydatawidth () , self . numctleps () , self . iddgfltr () , self . vbusvalidfltr () , self . avalidfltr () , self . bvalidfltr () , self . sessendfltr () , self . dedfifomode () , self . ineps () , self . descdmaenabled () , self . descdma ())
            }
        }
        #[doc = "Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gintmsk(pub u32);
        impl Gintmsk {
            #[doc = "Mode: Host and Device. Mode Mismatch Interrupt Mask (ModeMisMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn modemismsk(&self) -> super::vals::Modemismsk {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Modemismsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Mode Mismatch Interrupt Mask (ModeMisMsk)"]
            #[inline(always)]
            pub const fn set_modemismsk(&mut self, val: super::vals::Modemismsk) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Mode: Host and Device. OTG Interrupt Mask (OTGIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgintmsk(&self) -> super::vals::Otgintmsk {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Otgintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. OTG Interrupt Mask (OTGIntMsk)"]
            #[inline(always)]
            pub const fn set_otgintmsk(&mut self, val: super::vals::Otgintmsk) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Mode: Host and Device. Start of (micro)Frame Mask (SofMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn sofmsk(&self) -> super::vals::Sofmsk {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sofmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Start of (micro)Frame Mask (SofMsk)"]
            #[inline(always)]
            pub const fn set_sofmsk(&mut self, val: super::vals::Sofmsk) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Mode: Host and Device. Receive FIFO Non-Empty Mask (RxFLvlMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxflvlmsk(&self) -> super::vals::Rxflvlmsk {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Rxflvlmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Receive FIFO Non-Empty Mask (RxFLvlMsk)"]
            #[inline(always)]
            pub const fn set_rxflvlmsk(&mut self, val: super::vals::Rxflvlmsk) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Mode: Host and Device. Non-periodic TxFIFO Empty Mask (NPTxFEmpMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfempmsk(&self) -> super::vals::Nptxfempmsk {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Nptxfempmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Non-periodic TxFIFO Empty Mask (NPTxFEmpMsk)"]
            #[inline(always)]
            pub const fn set_nptxfempmsk(&mut self, val: super::vals::Nptxfempmsk) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Mode: Device only,. Global Non-periodic IN NAK Effective Mask (GINNakEffMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn ginnakeffmsk(&self) -> super::vals::Ginnakeffmsk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Ginnakeffmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only,. Global Non-periodic IN NAK Effective Mask (GINNakEffMsk)"]
            #[inline(always)]
            pub const fn set_ginnakeffmsk(&mut self, val: super::vals::Ginnakeffmsk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Mode: Device only. Global OUT NAK Effective Mask (GOUTNakEffMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn goutnakeffmsk(&self) -> super::vals::Goutnakeffmsk {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Goutnakeffmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Global OUT NAK Effective Mask (GOUTNakEffMsk)"]
            #[inline(always)]
            pub const fn set_goutnakeffmsk(&mut self, val: super::vals::Goutnakeffmsk) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Mode: Device only. Early Suspend Mask (ErlySuspMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn erlysuspmsk(&self) -> super::vals::Erlysuspmsk {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Erlysuspmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Early Suspend Mask (ErlySuspMsk)"]
            #[inline(always)]
            pub const fn set_erlysuspmsk(&mut self, val: super::vals::Erlysuspmsk) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Mode: Device only. USB Suspend Mask (USBSuspMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbsuspmsk(&self) -> super::vals::Usbsuspmsk {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Usbsuspmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. USB Suspend Mask (USBSuspMsk)"]
            #[inline(always)]
            pub const fn set_usbsuspmsk(&mut self, val: super::vals::Usbsuspmsk) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Mode: Device only. USB Reset Mask (USBRstMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbrstmsk(&self) -> super::vals::Usbrstmsk {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Usbrstmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. USB Reset Mask (USBRstMsk)"]
            #[inline(always)]
            pub const fn set_usbrstmsk(&mut self, val: super::vals::Usbrstmsk) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Mode: Device only. Enumeration Done Mask (EnumDoneMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn enumdonemsk(&self) -> super::vals::Enumdonemsk {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Enumdonemsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Enumeration Done Mask (EnumDoneMsk)"]
            #[inline(always)]
            pub const fn set_enumdonemsk(&mut self, val: super::vals::Enumdonemsk) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Mode: Device only. Isochronous OUT Packet Dropped Interrupt Mask (ISOOutDropMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn isooutdropmsk(&self) -> super::vals::Isooutdropmsk {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Isooutdropmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Isochronous OUT Packet Dropped Interrupt Mask (ISOOutDropMsk)"]
            #[inline(always)]
            pub const fn set_isooutdropmsk(&mut self, val: super::vals::Isooutdropmsk) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Mode: Device only. End of Periodic Frame Interrupt Mask (EOPFMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn eopfmsk(&self) -> super::vals::Eopfmsk {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Eopfmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. End of Periodic Frame Interrupt Mask (EOPFMsk)"]
            #[inline(always)]
            pub const fn set_eopfmsk(&mut self, val: super::vals::Eopfmsk) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Mode: Host and Device. Restore Done Interrupt Mask (RstrDoneIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn rstrdoneintmsk(&self) -> super::vals::Rstrdoneintmsk {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Rstrdoneintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Restore Done Interrupt Mask (RstrDoneIntMsk)"]
            #[inline(always)]
            pub const fn set_rstrdoneintmsk(&mut self, val: super::vals::Rstrdoneintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Mode: Device only. Endpoint Mismatch Interrupt Mask (EPMisMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn epmismsk(&self) -> super::vals::Epmismsk {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Epmismsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Endpoint Mismatch Interrupt Mask (EPMisMsk)"]
            #[inline(always)]
            pub const fn set_epmismsk(&mut self, val: super::vals::Epmismsk) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Mode: Device only. IN Endpoints Interrupt Mask (IEPIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn iepintmsk(&self) -> super::vals::Iepintmsk {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Iepintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. IN Endpoints Interrupt Mask (IEPIntMsk)"]
            #[inline(always)]
            pub const fn set_iepintmsk(&mut self, val: super::vals::Iepintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Mode: Device only. OUT Endpoints Interrupt Mask (OEPIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn oepintmsk(&self) -> super::vals::Oepintmsk {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oepintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. OUT Endpoints Interrupt Mask (OEPIntMsk)"]
            #[inline(always)]
            pub const fn set_oepintmsk(&mut self, val: super::vals::Oepintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "Incomplete Periodic Transfer Mask (incomplPMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn incomplpmsk(&self) -> super::vals::Incomplpmsk {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Incomplpmsk::from_bits(val as u8)
            }
            #[doc = "Incomplete Periodic Transfer Mask (incomplPMsk)"]
            #[inline(always)]
            pub const fn set_incomplpmsk(&mut self, val: super::vals::Incomplpmsk) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Mode: Device only. Data Fetch Suspended Mask (FetSuspMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetsuspmsk(&self) -> super::vals::Fetsuspmsk {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Fetsuspmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Data Fetch Suspended Mask (FetSuspMsk)"]
            #[inline(always)]
            pub const fn set_fetsuspmsk(&mut self, val: super::vals::Fetsuspmsk) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Mode: Device only. Reset detected Interrupt Mask (ResetDetMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn resetdetmsk(&self) -> super::vals::GintmskResetdetmsk {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::GintmskResetdetmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. Reset detected Interrupt Mask (ResetDetMsk)"]
            #[inline(always)]
            pub const fn set_resetdetmsk(&mut self, val: super::vals::GintmskResetdetmsk) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "Mode: Host only. Host Port Interrupt Mask (PrtIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtintmsk(&self) -> super::vals::Prtintmsk {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Prtintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host only. Host Port Interrupt Mask (PrtIntMsk)"]
            #[inline(always)]
            pub const fn set_prtintmsk(&mut self, val: super::vals::Prtintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Mode: Host only. Host Channels Interrupt Mask (HChIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn hchintmsk(&self) -> super::vals::Hchintmsk {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Hchintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host only. Host Channels Interrupt Mask (HChIntMsk)"]
            #[inline(always)]
            pub const fn set_hchintmsk(&mut self, val: super::vals::Hchintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "Mode: Host and Device. LPM Transaction Received Interrupt (LPM_Int)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmintmsk(&self) -> super::vals::Lpmintmsk {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Lpmintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. LPM Transaction Received Interrupt (LPM_Int)"]
            #[inline(always)]
            pub const fn set_lpmintmsk(&mut self, val: super::vals::Lpmintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
            #[doc = "Mode: Host and Device. Connector ID Status Change Mask (ConIDStsChngMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn conidstschngmsk(&self) -> super::vals::Conidstschngmsk {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Conidstschngmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Connector ID Status Change Mask (ConIDStsChngMsk)"]
            #[inline(always)]
            pub const fn set_conidstschngmsk(&mut self, val: super::vals::Conidstschngmsk) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Mode: Host and Device. Disconnect Detected Interrupt Mask (DisconnIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn disconnintmsk(&self) -> super::vals::Disconnintmsk {
                let val = (self.0 >> 29usize) & 0x01;
                super::vals::Disconnintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Disconnect Detected Interrupt Mask (DisconnIntMsk)"]
            #[inline(always)]
            pub const fn set_disconnintmsk(&mut self, val: super::vals::Disconnintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 29usize)) | (((val.to_bits() as u32) & 0x01) << 29usize);
            }
            #[doc = "Mode: Host and Device. Session Request/New Session Detected Interrupt Mask (SessReqIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn sessreqintmsk(&self) -> super::vals::Sessreqintmsk {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Sessreqintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Session Request/New Session Detected Interrupt Mask (SessReqIntMsk)"]
            #[inline(always)]
            pub const fn set_sessreqintmsk(&mut self, val: super::vals::Sessreqintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Mode: Host and Device. Resume/Remote Wakeup Detected Interrupt Mask (WkUpIntMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn wkupintmsk(&self) -> super::vals::Wkupintmsk {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Wkupintmsk::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Resume/Remote Wakeup Detected Interrupt Mask (WkUpIntMsk)"]
            #[inline(always)]
            pub const fn set_wkupintmsk(&mut self, val: super::vals::Wkupintmsk) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gintmsk {
            #[inline(always)]
            fn default() -> Gintmsk {
                Gintmsk(0)
            }
        }
        impl core::fmt::Debug for Gintmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gintmsk")
                    .field("modemismsk", &self.modemismsk())
                    .field("otgintmsk", &self.otgintmsk())
                    .field("sofmsk", &self.sofmsk())
                    .field("rxflvlmsk", &self.rxflvlmsk())
                    .field("nptxfempmsk", &self.nptxfempmsk())
                    .field("ginnakeffmsk", &self.ginnakeffmsk())
                    .field("goutnakeffmsk", &self.goutnakeffmsk())
                    .field("erlysuspmsk", &self.erlysuspmsk())
                    .field("usbsuspmsk", &self.usbsuspmsk())
                    .field("usbrstmsk", &self.usbrstmsk())
                    .field("enumdonemsk", &self.enumdonemsk())
                    .field("isooutdropmsk", &self.isooutdropmsk())
                    .field("eopfmsk", &self.eopfmsk())
                    .field("rstrdoneintmsk", &self.rstrdoneintmsk())
                    .field("epmismsk", &self.epmismsk())
                    .field("iepintmsk", &self.iepintmsk())
                    .field("oepintmsk", &self.oepintmsk())
                    .field("incomplpmsk", &self.incomplpmsk())
                    .field("fetsuspmsk", &self.fetsuspmsk())
                    .field("resetdetmsk", &self.resetdetmsk())
                    .field("prtintmsk", &self.prtintmsk())
                    .field("hchintmsk", &self.hchintmsk())
                    .field("lpmintmsk", &self.lpmintmsk())
                    .field("conidstschngmsk", &self.conidstschngmsk())
                    .field("disconnintmsk", &self.disconnintmsk())
                    .field("sessreqintmsk", &self.sessreqintmsk())
                    .field("wkupintmsk", &self.wkupintmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gintmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gintmsk {{ modemismsk: {:?}, otgintmsk: {:?}, sofmsk: {:?}, rxflvlmsk: {:?}, nptxfempmsk: {:?}, ginnakeffmsk: {:?}, goutnakeffmsk: {:?}, erlysuspmsk: {:?}, usbsuspmsk: {:?}, usbrstmsk: {:?}, enumdonemsk: {:?}, isooutdropmsk: {:?}, eopfmsk: {:?}, rstrdoneintmsk: {:?}, epmismsk: {:?}, iepintmsk: {:?}, oepintmsk: {:?}, incomplpmsk: {:?}, fetsuspmsk: {:?}, resetdetmsk: {:?}, prtintmsk: {:?}, hchintmsk: {:?}, lpmintmsk: {:?}, conidstschngmsk: {:?}, disconnintmsk: {:?}, sessreqintmsk: {:?}, wkupintmsk: {:?} }}" , self . modemismsk () , self . otgintmsk () , self . sofmsk () , self . rxflvlmsk () , self . nptxfempmsk () , self . ginnakeffmsk () , self . goutnakeffmsk () , self . erlysuspmsk () , self . usbsuspmsk () , self . usbrstmsk () , self . enumdonemsk () , self . isooutdropmsk () , self . eopfmsk () , self . rstrdoneintmsk () , self . epmismsk () , self . iepintmsk () , self . oepintmsk () , self . incomplpmsk () , self . fetsuspmsk () , self . resetdetmsk () , self . prtintmsk () , self . hchintmsk () , self . lpmintmsk () , self . conidstschngmsk () , self . disconnintmsk () , self . sessreqintmsk () , self . wkupintmsk ())
            }
        }
        #[doc = "Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gintsts(pub u32);
        impl Gintsts {
            #[doc = "Mode: Host and Device. Current Mode of Operation (CurMod)"]
            #[must_use]
            #[inline(always)]
            pub const fn curmod(&self) -> super::vals::GintstsCurmod {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GintstsCurmod::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Current Mode of Operation (CurMod)"]
            #[inline(always)]
            pub const fn set_curmod(&mut self, val: super::vals::GintstsCurmod) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode: Host and Device. Mode Mismatch Interrupt (ModeMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn modemis(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Mode Mismatch Interrupt (ModeMis)"]
            #[inline(always)]
            pub const fn set_modemis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Mode: Host and Device. OTG Interrupt (OTGInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgint(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. OTG Interrupt (OTGInt)"]
            #[inline(always)]
            pub const fn set_otgint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Mode: Host and Device. Start of (micro)Frame (Sof)"]
            #[must_use]
            #[inline(always)]
            pub const fn sof(&self) -> super::vals::Sof {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Sof::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Start of (micro)Frame (Sof)"]
            #[inline(always)]
            pub const fn set_sof(&mut self, val: super::vals::Sof) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Mode: Host and Device. RxFIFO Non-Empty (RxFLvl)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxflvl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. RxFIFO Non-Empty (RxFLvl)"]
            #[inline(always)]
            pub const fn set_rxflvl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Mode: Host and Device. Non-periodic TxFIFO Empty (NPTxFEmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfemp(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Non-periodic TxFIFO Empty (NPTxFEmp)"]
            #[inline(always)]
            pub const fn set_nptxfemp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Mode: Device only. Global IN Non-periodic NAK Effective (GINNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn ginnakeff(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Global IN Non-periodic NAK Effective (GINNakEff)"]
            #[inline(always)]
            pub const fn set_ginnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Mode: Device only. Global OUT NAK Effective (GOUTNakEff)"]
            #[must_use]
            #[inline(always)]
            pub const fn goutnakeff(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Global OUT NAK Effective (GOUTNakEff)"]
            #[inline(always)]
            pub const fn set_goutnakeff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Mode: Device only. Early Suspend (ErlySusp)"]
            #[must_use]
            #[inline(always)]
            pub const fn erlysusp(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Early Suspend (ErlySusp)"]
            #[inline(always)]
            pub const fn set_erlysusp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Mode: Device only. USB Suspend (USBSusp)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbsusp(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. USB Suspend (USBSusp)"]
            #[inline(always)]
            pub const fn set_usbsusp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Mode: Device only. USB Reset (USBRst)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbrst(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. USB Reset (USBRst)"]
            #[inline(always)]
            pub const fn set_usbrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Mode: Device only. Enumeration Done (EnumDone)"]
            #[must_use]
            #[inline(always)]
            pub const fn enumdone(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Enumeration Done (EnumDone)"]
            #[inline(always)]
            pub const fn set_enumdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Mode: Device only. Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)"]
            #[must_use]
            #[inline(always)]
            pub const fn isooutdrop(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Isochronous OUT Packet Dropped Interrupt (ISOOutDrop)"]
            #[inline(always)]
            pub const fn set_isooutdrop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Mode: Device only. End of Periodic Frame Interrupt (EOPF)"]
            #[must_use]
            #[inline(always)]
            pub const fn eopf(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. End of Periodic Frame Interrupt (EOPF)"]
            #[inline(always)]
            pub const fn set_eopf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Mode: Device only. Restore Done Interrupt (RstrDoneInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn rstrdoneint(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Restore Done Interrupt (RstrDoneInt)"]
            #[inline(always)]
            pub const fn set_rstrdoneint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Mode: Device only. Endpoint Mismatch Interrupt (EPMis)"]
            #[must_use]
            #[inline(always)]
            pub const fn epmis(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Endpoint Mismatch Interrupt (EPMis)"]
            #[inline(always)]
            pub const fn set_epmis(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Mode: Device only. IN Endpoints Interrupt (IEPInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn iepint(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. IN Endpoints Interrupt (IEPInt)"]
            #[inline(always)]
            pub const fn set_iepint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Mode: Device only. OUT Endpoints Interrupt (OEPInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn oepint(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. OUT Endpoints Interrupt (OEPInt)"]
            #[inline(always)]
            pub const fn set_oepint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Mode: Device only. Incomplete Isochronous IN Transfer (incompISOIN)"]
            #[must_use]
            #[inline(always)]
            pub const fn incompisoin(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Incomplete Isochronous IN Transfer (incompISOIN)"]
            #[inline(always)]
            pub const fn set_incompisoin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Incomplete Periodic Transfer (incomplP)"]
            #[must_use]
            #[inline(always)]
            pub const fn incomplp(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Incomplete Periodic Transfer (incomplP)"]
            #[inline(always)]
            pub const fn set_incomplp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Mode: Device only. Data Fetch Suspended (FetSusp)"]
            #[must_use]
            #[inline(always)]
            pub const fn fetsusp(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Data Fetch Suspended (FetSusp)"]
            #[inline(always)]
            pub const fn set_fetsusp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Mode: Device only. Reset detected Interrupt (ResetDet)"]
            #[must_use]
            #[inline(always)]
            pub const fn resetdet(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Reset detected Interrupt (ResetDet)"]
            #[inline(always)]
            pub const fn set_resetdet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Mode: Host only. Host Port Interrupt (PrtInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtint(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. Host Port Interrupt (PrtInt)"]
            #[inline(always)]
            pub const fn set_prtint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Mode: Host only. Host Channels Interrupt (HChInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn hchint(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. Host Channels Interrupt (HChInt)"]
            #[inline(always)]
            pub const fn set_hchint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Mode: Host and Device. LPM Transaction Received Interrupt (LPM_Int)."]
            #[must_use]
            #[inline(always)]
            pub const fn lpmint(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. LPM Transaction Received Interrupt (LPM_Int)."]
            #[inline(always)]
            pub const fn set_lpmint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Mode: Host and Device. Connector ID Status Change (ConIDStsChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn conidstschng(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Connector ID Status Change (ConIDStsChng)"]
            #[inline(always)]
            pub const fn set_conidstschng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Mode: Host only. Disconnect Detected Interrupt (DisconnInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn disconnint(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. Disconnect Detected Interrupt (DisconnInt)"]
            #[inline(always)]
            pub const fn set_disconnint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Mode: Host and Device. Session Request/New Session Detected Interrupt (SessReqInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn sessreqint(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Session Request/New Session Detected Interrupt (SessReqInt)"]
            #[inline(always)]
            pub const fn set_sessreqint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Mode: Host and Device. Resume/Remote Wakeup Detected Interrupt (WkUpInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn wkupint(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Resume/Remote Wakeup Detected Interrupt (WkUpInt)"]
            #[inline(always)]
            pub const fn set_wkupint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gintsts {
            #[inline(always)]
            fn default() -> Gintsts {
                Gintsts(0)
            }
        }
        impl core::fmt::Debug for Gintsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gintsts")
                    .field("curmod", &self.curmod())
                    .field("modemis", &self.modemis())
                    .field("otgint", &self.otgint())
                    .field("sof", &self.sof())
                    .field("rxflvl", &self.rxflvl())
                    .field("nptxfemp", &self.nptxfemp())
                    .field("ginnakeff", &self.ginnakeff())
                    .field("goutnakeff", &self.goutnakeff())
                    .field("erlysusp", &self.erlysusp())
                    .field("usbsusp", &self.usbsusp())
                    .field("usbrst", &self.usbrst())
                    .field("enumdone", &self.enumdone())
                    .field("isooutdrop", &self.isooutdrop())
                    .field("eopf", &self.eopf())
                    .field("rstrdoneint", &self.rstrdoneint())
                    .field("epmis", &self.epmis())
                    .field("iepint", &self.iepint())
                    .field("oepint", &self.oepint())
                    .field("incompisoin", &self.incompisoin())
                    .field("incomplp", &self.incomplp())
                    .field("fetsusp", &self.fetsusp())
                    .field("resetdet", &self.resetdet())
                    .field("prtint", &self.prtint())
                    .field("hchint", &self.hchint())
                    .field("lpmint", &self.lpmint())
                    .field("conidstschng", &self.conidstschng())
                    .field("disconnint", &self.disconnint())
                    .field("sessreqint", &self.sessreqint())
                    .field("wkupint", &self.wkupint())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gintsts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gintsts {{ curmod: {:?}, modemis: {=bool:?}, otgint: {=bool:?}, sof: {:?}, rxflvl: {=bool:?}, nptxfemp: {=bool:?}, ginnakeff: {=bool:?}, goutnakeff: {=bool:?}, erlysusp: {=bool:?}, usbsusp: {=bool:?}, usbrst: {=bool:?}, enumdone: {=bool:?}, isooutdrop: {=bool:?}, eopf: {=bool:?}, rstrdoneint: {=bool:?}, epmis: {=bool:?}, iepint: {=bool:?}, oepint: {=bool:?}, incompisoin: {=bool:?}, incomplp: {=bool:?}, fetsusp: {=bool:?}, resetdet: {=bool:?}, prtint: {=bool:?}, hchint: {=bool:?}, lpmint: {=bool:?}, conidstschng: {=bool:?}, disconnint: {=bool:?}, sessreqint: {=bool:?}, wkupint: {=bool:?} }}" , self . curmod () , self . modemis () , self . otgint () , self . sof () , self . rxflvl () , self . nptxfemp () , self . ginnakeff () , self . goutnakeff () , self . erlysusp () , self . usbsusp () , self . usbrst () , self . enumdone () , self . isooutdrop () , self . eopf () , self . rstrdoneint () , self . epmis () , self . iepint () , self . oepint () , self . incompisoin () , self . incomplp () , self . fetsusp () , self . resetdet () , self . prtint () , self . hchint () , self . lpmint () , self . conidstschng () , self . disconnint () , self . sessreqint () , self . wkupint ())
            }
        }
        #[doc = "LPM Config Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Glpmcfg(pub u32);
        impl Glpmcfg {
            #[doc = "LPM-Capable (LPMCap)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmcap(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LPM-Capable (LPMCap)"]
            #[inline(always)]
            pub const fn set_lpmcap(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode: Device only. LPM response programmed by application (AppL1Res)"]
            #[must_use]
            #[inline(always)]
            pub const fn appl1res(&self) -> super::vals::Appl1res {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Appl1res::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. LPM response programmed by application (AppL1Res)"]
            #[inline(always)]
            pub const fn set_appl1res(&mut self, val: super::vals::Appl1res) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Host-Initiated Resume Duration (HIRD)"]
            #[must_use]
            #[inline(always)]
            pub const fn hird(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x0f;
                val as u8
            }
            #[doc = "Host-Initiated Resume Duration (HIRD)"]
            #[inline(always)]
            pub const fn set_hird(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 2usize)) | (((val as u32) & 0x0f) << 2usize);
            }
            #[doc = "RemoteWakeEnable (bRemoteWake)"]
            #[must_use]
            #[inline(always)]
            pub const fn bremotewake(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "RemoteWakeEnable (bRemoteWake)"]
            #[inline(always)]
            pub const fn set_bremotewake(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable utmi_sleep_n (EnblSlpM)"]
            #[must_use]
            #[inline(always)]
            pub const fn enblslpm(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable utmi_sleep_n (EnblSlpM)"]
            #[inline(always)]
            pub const fn set_enblslpm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "BESL/HIRD Threshold (HIRD_Thres)"]
            #[must_use]
            #[inline(always)]
            pub const fn hirdthres(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "BESL/HIRD Threshold (HIRD_Thres)"]
            #[inline(always)]
            pub const fn set_hirdthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "LPM Response (CoreL1Res)"]
            #[must_use]
            #[inline(always)]
            pub const fn corel1res(&self) -> super::vals::Corel1res {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Corel1res::from_bits(val as u8)
            }
            #[doc = "LPM Response (CoreL1Res)"]
            #[inline(always)]
            pub const fn set_corel1res(&mut self, val: super::vals::Corel1res) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u32) & 0x03) << 13usize);
            }
            #[doc = "Port Sleep Status (SlpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn slpsts(&self) -> super::vals::Slpsts {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Slpsts::from_bits(val as u8)
            }
            #[doc = "Port Sleep Status (SlpSts)"]
            #[inline(always)]
            pub const fn set_slpsts(&mut self, val: super::vals::Slpsts) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Sleep State Resume OK (L1ResumeOK)"]
            #[must_use]
            #[inline(always)]
            pub const fn l1resumeok(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Sleep State Resume OK (L1ResumeOK)"]
            #[inline(always)]
            pub const fn set_l1resumeok(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "LPM Channel Index"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmchnlindx(&self) -> super::vals::Lpmchnlindx {
                let val = (self.0 >> 17usize) & 0x0f;
                super::vals::Lpmchnlindx::from_bits(val as u8)
            }
            #[doc = "LPM Channel Index"]
            #[inline(always)]
            pub const fn set_lpmchnlindx(&mut self, val: super::vals::Lpmchnlindx) {
                self.0 =
                    (self.0 & !(0x0f << 17usize)) | (((val.to_bits() as u32) & 0x0f) << 17usize);
            }
            #[doc = "LPM Retry Count (LPM_Retry_Cnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmretrycnt(&self) -> super::vals::Lpmretrycnt {
                let val = (self.0 >> 21usize) & 0x07;
                super::vals::Lpmretrycnt::from_bits(val as u8)
            }
            #[doc = "LPM Retry Count (LPM_Retry_Cnt)"]
            #[inline(always)]
            pub const fn set_lpmretrycnt(&mut self, val: super::vals::Lpmretrycnt) {
                self.0 =
                    (self.0 & !(0x07 << 21usize)) | (((val.to_bits() as u32) & 0x07) << 21usize);
            }
            #[doc = "Send LPM Transaction (SndLPM)"]
            #[must_use]
            #[inline(always)]
            pub const fn sndlpm(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Send LPM Transaction (SndLPM)"]
            #[inline(always)]
            pub const fn set_sndlpm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "LPM Retry Count Status (LPM_RetryCnt_Sts)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmretrycntsts(&self) -> super::vals::Lpmretrycntsts {
                let val = (self.0 >> 25usize) & 0x07;
                super::vals::Lpmretrycntsts::from_bits(val as u8)
            }
            #[doc = "LPM Retry Count Status (LPM_RetryCnt_Sts)"]
            #[inline(always)]
            pub const fn set_lpmretrycntsts(&mut self, val: super::vals::Lpmretrycntsts) {
                self.0 =
                    (self.0 & !(0x07 << 25usize)) | (((val.to_bits() as u32) & 0x07) << 25usize);
            }
            #[doc = "LPM Enable BESL (LPM_EnBESL)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmenbesl(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "LPM Enable BESL (LPM_EnBESL)"]
            #[inline(always)]
            pub const fn set_lpmenbesl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "LPM Restore Sleep Status (LPM_RestoreSlpSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn lpmrestoreslpsts(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "LPM Restore Sleep Status (LPM_RestoreSlpSts)"]
            #[inline(always)]
            pub const fn set_lpmrestoreslpsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Glpmcfg {
            #[inline(always)]
            fn default() -> Glpmcfg {
                Glpmcfg(0)
            }
        }
        impl core::fmt::Debug for Glpmcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Glpmcfg")
                    .field("lpmcap", &self.lpmcap())
                    .field("appl1res", &self.appl1res())
                    .field("hird", &self.hird())
                    .field("bremotewake", &self.bremotewake())
                    .field("enblslpm", &self.enblslpm())
                    .field("hirdthres", &self.hirdthres())
                    .field("corel1res", &self.corel1res())
                    .field("slpsts", &self.slpsts())
                    .field("l1resumeok", &self.l1resumeok())
                    .field("lpmchnlindx", &self.lpmchnlindx())
                    .field("lpmretrycnt", &self.lpmretrycnt())
                    .field("sndlpm", &self.sndlpm())
                    .field("lpmretrycntsts", &self.lpmretrycntsts())
                    .field("lpmenbesl", &self.lpmenbesl())
                    .field("lpmrestoreslpsts", &self.lpmrestoreslpsts())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Glpmcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Glpmcfg {{ lpmcap: {=bool:?}, appl1res: {:?}, hird: {=u8:?}, bremotewake: {=bool:?}, enblslpm: {=bool:?}, hirdthres: {=u8:?}, corel1res: {:?}, slpsts: {:?}, l1resumeok: {=bool:?}, lpmchnlindx: {:?}, lpmretrycnt: {:?}, sndlpm: {=bool:?}, lpmretrycntsts: {:?}, lpmenbesl: {=bool:?}, lpmrestoreslpsts: {=bool:?} }}" , self . lpmcap () , self . appl1res () , self . hird () , self . bremotewake () , self . enblslpm () , self . hirdthres () , self . corel1res () , self . slpsts () , self . l1resumeok () , self . lpmchnlindx () , self . lpmretrycnt () , self . sndlpm () , self . lpmretrycntsts () , self . lpmenbesl () , self . lpmrestoreslpsts ())
            }
        }
        #[doc = "Non-periodic Transmit FIFO Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gnptxfsiz(pub u32);
        impl Gnptxfsiz {
            #[doc = "Non-periodic Transmit RAM Start Address (NPTxFStAddr)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfstaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Non-periodic Transmit RAM Start Address (NPTxFStAddr)"]
            #[inline(always)]
            pub const fn set_nptxfstaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Mode: Host only. Non-periodic TxFIFO Depth (NPTxFDep)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfdep(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Mode: Host only. Non-periodic TxFIFO Depth (NPTxFDep)"]
            #[inline(always)]
            pub const fn set_nptxfdep(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Gnptxfsiz {
            #[inline(always)]
            fn default() -> Gnptxfsiz {
                Gnptxfsiz(0)
            }
        }
        impl core::fmt::Debug for Gnptxfsiz {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gnptxfsiz")
                    .field("nptxfstaddr", &self.nptxfstaddr())
                    .field("nptxfdep", &self.nptxfdep())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gnptxfsiz {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gnptxfsiz {{ nptxfstaddr: {=u16:?}, nptxfdep: {=u16:?} }}",
                    self.nptxfstaddr(),
                    self.nptxfdep()
                )
            }
        }
        #[doc = "Non-periodic Transmit FIFO/Queue Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gnptxsts(pub u32);
        impl Gnptxsts {
            #[doc = "Non-periodic TxFIFO Space Avail (NPTxFSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxfspcavail(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Non-periodic TxFIFO Space Avail (NPTxFSpcAvail)"]
            #[inline(always)]
            pub const fn set_nptxfspcavail(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Non-periodic Transmit Request Queue Space Available (NPTxQSpcAvail)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxqspcavail(&self) -> super::vals::Nptxqspcavail {
                let val = (self.0 >> 16usize) & 0xff;
                super::vals::Nptxqspcavail::from_bits(val as u8)
            }
            #[doc = "Non-periodic Transmit Request Queue Space Available (NPTxQSpcAvail)"]
            #[inline(always)]
            pub const fn set_nptxqspcavail(&mut self, val: super::vals::Nptxqspcavail) {
                self.0 =
                    (self.0 & !(0xff << 16usize)) | (((val.to_bits() as u32) & 0xff) << 16usize);
            }
            #[doc = "Top of the Non-periodic Transmit Request Queue (NPTxQTop)"]
            #[must_use]
            #[inline(always)]
            pub const fn nptxqtop(&self) -> super::vals::Nptxqtop {
                let val = (self.0 >> 24usize) & 0x7f;
                super::vals::Nptxqtop::from_bits(val as u8)
            }
            #[doc = "Top of the Non-periodic Transmit Request Queue (NPTxQTop)"]
            #[inline(always)]
            pub const fn set_nptxqtop(&mut self, val: super::vals::Nptxqtop) {
                self.0 =
                    (self.0 & !(0x7f << 24usize)) | (((val.to_bits() as u32) & 0x7f) << 24usize);
            }
        }
        impl Default for Gnptxsts {
            #[inline(always)]
            fn default() -> Gnptxsts {
                Gnptxsts(0)
            }
        }
        impl core::fmt::Debug for Gnptxsts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gnptxsts")
                    .field("nptxfspcavail", &self.nptxfspcavail())
                    .field("nptxqspcavail", &self.nptxqspcavail())
                    .field("nptxqtop", &self.nptxqtop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gnptxsts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Gnptxsts {{ nptxfspcavail: {=u16:?}, nptxqspcavail: {:?}, nptxqtop: {:?} }}",
                    self.nptxfspcavail(),
                    self.nptxqspcavail(),
                    self.nptxqtop()
                )
            }
        }
        #[doc = "Control and Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gotgctl(pub u32);
        impl Gotgctl {
            #[doc = "Mode: Host only. VBUS Valid Override Enable (VbvalidOvEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn vbvalidoven(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. VBUS Valid Override Enable (VbvalidOvEn)"]
            #[inline(always)]
            pub const fn set_vbvalidoven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Mode: Host only. VBUS Valid OverrideValue (VbvalidOvVal)"]
            #[must_use]
            #[inline(always)]
            pub const fn vbvalidovval(&self) -> super::vals::Vbvalidovval {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Vbvalidovval::from_bits(val as u8)
            }
            #[doc = "Mode: Host only. VBUS Valid OverrideValue (VbvalidOvVal)"]
            #[inline(always)]
            pub const fn set_vbvalidovval(&mut self, val: super::vals::Vbvalidovval) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Mode: Host only. A-Peripheral Session Valid Override Enable (AvalidOvEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn avalidoven(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. A-Peripheral Session Valid Override Enable (AvalidOvEn)"]
            #[inline(always)]
            pub const fn set_avalidoven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Mode: Host only. A-Peripheral Session Valid OverrideValue (AvalidOvVal)"]
            #[must_use]
            #[inline(always)]
            pub const fn avalidovval(&self) -> super::vals::Avalidovval {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Avalidovval::from_bits(val as u8)
            }
            #[doc = "Mode: Host only. A-Peripheral Session Valid OverrideValue (AvalidOvVal)"]
            #[inline(always)]
            pub const fn set_avalidovval(&mut self, val: super::vals::Avalidovval) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Mode: Device only. B-Peripheral Session Valid Override Value (BvalidOvEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn bvalidoven(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. B-Peripheral Session Valid Override Value (BvalidOvEn)"]
            #[inline(always)]
            pub const fn set_bvalidoven(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Mode: Device only. B-Peripheral Session Valid OverrideValue (BvalidOvVal)"]
            #[must_use]
            #[inline(always)]
            pub const fn bvalidovval(&self) -> super::vals::Bvalidovval {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Bvalidovval::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. B-Peripheral Session Valid OverrideValue (BvalidOvVal)"]
            #[inline(always)]
            pub const fn set_bvalidovval(&mut self, val: super::vals::Bvalidovval) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Mode: Host and Device. Debounce Filter Bypass"]
            #[must_use]
            #[inline(always)]
            pub const fn dbncefltrbypass(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Debounce Filter Bypass"]
            #[inline(always)]
            pub const fn set_dbncefltrbypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Mode: Host and Device. Connector ID Status (ConIDSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn conidsts(&self) -> super::vals::Conidsts {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Conidsts::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Connector ID Status (ConIDSts)"]
            #[inline(always)]
            pub const fn set_conidsts(&mut self, val: super::vals::Conidsts) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Mode: Host only. Long/Short Debounce Time (DbncTime)"]
            #[must_use]
            #[inline(always)]
            pub const fn dbnctime(&self) -> super::vals::Dbnctime {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Dbnctime::from_bits(val as u8)
            }
            #[doc = "Mode: Host only. Long/Short Debounce Time (DbncTime)"]
            #[inline(always)]
            pub const fn set_dbnctime(&mut self, val: super::vals::Dbnctime) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Mode: Host only. A-Session Valid (ASesVld)"]
            #[must_use]
            #[inline(always)]
            pub const fn asesvld(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. A-Session Valid (ASesVld)"]
            #[inline(always)]
            pub const fn set_asesvld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Mode: Device only. B-Session Valid (BSesVld)"]
            #[must_use]
            #[inline(always)]
            pub const fn bsesvld(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. B-Session Valid (BSesVld)"]
            #[inline(always)]
            pub const fn set_bsesvld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "OTG Version (OTGVer)"]
            #[must_use]
            #[inline(always)]
            pub const fn otgver(&self) -> super::vals::Otgver {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Otgver::from_bits(val as u8)
            }
            #[doc = "OTG Version (OTGVer)"]
            #[inline(always)]
            pub const fn set_otgver(&mut self, val: super::vals::Otgver) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Current Mode of Operation (CurMod)"]
            #[must_use]
            #[inline(always)]
            pub const fn curmod(&self) -> super::vals::GotgctlCurmod {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::GotgctlCurmod::from_bits(val as u8)
            }
            #[doc = "Current Mode of Operation (CurMod)"]
            #[inline(always)]
            pub const fn set_curmod(&mut self, val: super::vals::GotgctlCurmod) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "Mode: Host and Device. Multi Valued ID pin (MultValIdBC)"]
            #[must_use]
            #[inline(always)]
            pub const fn multvalidbc(&self) -> super::vals::GotgctlMultvalidbc {
                let val = (self.0 >> 22usize) & 0x1f;
                super::vals::GotgctlMultvalidbc::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Multi Valued ID pin (MultValIdBC)"]
            #[inline(always)]
            pub const fn set_multvalidbc(&mut self, val: super::vals::GotgctlMultvalidbc) {
                self.0 =
                    (self.0 & !(0x1f << 22usize)) | (((val.to_bits() as u32) & 0x1f) << 22usize);
            }
            #[doc = "Mode: Device Only. This bit when programmed to 1'b1 results in the core asserting chirp_on before sending an actual Chirp 'K' signal on USB. This bit is present only if OTG_BC_SUPPORT = 1.If OTG_BC_SUPPORT!=1, this bit is a reserved bit. Do not set this bit when core is operating in HSIC mode because HSIC always operates at High Speed and High speed chirp is not used"]
            #[must_use]
            #[inline(always)]
            pub const fn chirpen(&self) -> super::vals::Chirpen {
                let val = (self.0 >> 27usize) & 0x01;
                super::vals::Chirpen::from_bits(val as u8)
            }
            #[doc = "Mode: Device Only. This bit when programmed to 1'b1 results in the core asserting chirp_on before sending an actual Chirp 'K' signal on USB. This bit is present only if OTG_BC_SUPPORT = 1.If OTG_BC_SUPPORT!=1, this bit is a reserved bit. Do not set this bit when core is operating in HSIC mode because HSIC always operates at High Speed and High speed chirp is not used"]
            #[inline(always)]
            pub const fn set_chirpen(&mut self, val: super::vals::Chirpen) {
                self.0 =
                    (self.0 & !(0x01 << 27usize)) | (((val.to_bits() as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Gotgctl {
            #[inline(always)]
            fn default() -> Gotgctl {
                Gotgctl(0)
            }
        }
        impl core::fmt::Debug for Gotgctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gotgctl")
                    .field("vbvalidoven", &self.vbvalidoven())
                    .field("vbvalidovval", &self.vbvalidovval())
                    .field("avalidoven", &self.avalidoven())
                    .field("avalidovval", &self.avalidovval())
                    .field("bvalidoven", &self.bvalidoven())
                    .field("bvalidovval", &self.bvalidovval())
                    .field("dbncefltrbypass", &self.dbncefltrbypass())
                    .field("conidsts", &self.conidsts())
                    .field("dbnctime", &self.dbnctime())
                    .field("asesvld", &self.asesvld())
                    .field("bsesvld", &self.bsesvld())
                    .field("otgver", &self.otgver())
                    .field("curmod", &self.curmod())
                    .field("multvalidbc", &self.multvalidbc())
                    .field("chirpen", &self.chirpen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gotgctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gotgctl {{ vbvalidoven: {=bool:?}, vbvalidovval: {:?}, avalidoven: {=bool:?}, avalidovval: {:?}, bvalidoven: {=bool:?}, bvalidovval: {:?}, dbncefltrbypass: {=bool:?}, conidsts: {:?}, dbnctime: {:?}, asesvld: {=bool:?}, bsesvld: {=bool:?}, otgver: {:?}, curmod: {:?}, multvalidbc: {:?}, chirpen: {:?} }}" , self . vbvalidoven () , self . vbvalidovval () , self . avalidoven () , self . avalidovval () , self . bvalidoven () , self . bvalidovval () , self . dbncefltrbypass () , self . conidsts () , self . dbnctime () , self . asesvld () , self . bsesvld () , self . otgver () , self . curmod () , self . multvalidbc () , self . chirpen ())
            }
        }
        #[doc = "Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gotgint(pub u32);
        impl Gotgint {
            #[doc = "Mode: Host and Device. Session End Detected (SesEndDet)"]
            #[must_use]
            #[inline(always)]
            pub const fn sesenddet(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Session End Detected (SesEndDet)"]
            #[inline(always)]
            pub const fn set_sesenddet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Mode: Host and Device. Session Request Success Status Change (SesReqSucStsChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn sesreqsucstschng(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Session Request Success Status Change (SesReqSucStsChng)"]
            #[inline(always)]
            pub const fn set_sesreqsucstschng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Mode: Host and Device. Host Negotiation Success Status Change (HstNegSucStsChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn hstnegsucstschng(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Host Negotiation Success Status Change (HstNegSucStsChng)"]
            #[inline(always)]
            pub const fn set_hstnegsucstschng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Mode:Host and Device. Host Negotiation Detected (HstNegDet)"]
            #[must_use]
            #[inline(always)]
            pub const fn hstnegdet(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Mode:Host and Device. Host Negotiation Detected (HstNegDet)"]
            #[inline(always)]
            pub const fn set_hstnegdet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Mode: Host and Device. A-Device Timeout Change (ADevTOUTChg)"]
            #[must_use]
            #[inline(always)]
            pub const fn adevtoutchg(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. A-Device Timeout Change (ADevTOUTChg)"]
            #[inline(always)]
            pub const fn set_adevtoutchg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Mode: Host only. Debounce Done (DbnceDone)"]
            #[must_use]
            #[inline(always)]
            pub const fn dbncedone(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. Debounce Done (DbnceDone)"]
            #[inline(always)]
            pub const fn set_dbncedone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "This bit when set indicates that there is a change in the value of at least one ACA pin value."]
            #[must_use]
            #[inline(always)]
            pub const fn multvalipchng(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "This bit when set indicates that there is a change in the value of at least one ACA pin value."]
            #[inline(always)]
            pub const fn set_multvalipchng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Gotgint {
            #[inline(always)]
            fn default() -> Gotgint {
                Gotgint(0)
            }
        }
        impl core::fmt::Debug for Gotgint {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gotgint")
                    .field("sesenddet", &self.sesenddet())
                    .field("sesreqsucstschng", &self.sesreqsucstschng())
                    .field("hstnegsucstschng", &self.hstnegsucstschng())
                    .field("hstnegdet", &self.hstnegdet())
                    .field("adevtoutchg", &self.adevtoutchg())
                    .field("dbncedone", &self.dbncedone())
                    .field("multvalipchng", &self.multvalipchng())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gotgint {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gotgint {{ sesenddet: {=bool:?}, sesreqsucstschng: {=bool:?}, hstnegsucstschng: {=bool:?}, hstnegdet: {=bool:?}, adevtoutchg: {=bool:?}, dbncedone: {=bool:?}, multvalipchng: {=bool:?} }}" , self . sesenddet () , self . sesreqsucstschng () , self . hstnegsucstschng () , self . hstnegdet () , self . adevtoutchg () , self . dbncedone () , self . multvalipchng ())
            }
        }
        #[doc = "Global Power Down Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gpwrdn(pub u32);
        impl Gpwrdn {
            #[doc = "PMU Interrupt Select (PMUIntSel)"]
            #[must_use]
            #[inline(always)]
            pub const fn pmuintsel(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PMU Interrupt Select (PMUIntSel)"]
            #[inline(always)]
            pub const fn set_pmuintsel(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "PMU Active (PMUActv)"]
            #[must_use]
            #[inline(always)]
            pub const fn pmuactv(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "PMU Active (PMUActv)"]
            #[inline(always)]
            pub const fn set_pmuactv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Restore"]
            #[must_use]
            #[inline(always)]
            pub const fn restore(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Restore"]
            #[inline(always)]
            pub const fn set_restore(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Power Down Clamp (PwrDnClmp)"]
            #[must_use]
            #[inline(always)]
            pub const fn pwrdnclmp(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Power Down Clamp (PwrDnClmp)"]
            #[inline(always)]
            pub const fn set_pwrdnclmp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Power Down ResetN (PwrDnRst_n)"]
            #[must_use]
            #[inline(always)]
            pub const fn pwrdnrstn(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Power Down ResetN (PwrDnRst_n)"]
            #[inline(always)]
            pub const fn set_pwrdnrstn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Power Down Switch (PwrDnSwtch)"]
            #[must_use]
            #[inline(always)]
            pub const fn pwrdnswtch(&self) -> super::vals::Pwrdnswtch {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Pwrdnswtch::from_bits(val as u8)
            }
            #[doc = "Power Down Switch (PwrDnSwtch)"]
            #[inline(always)]
            pub const fn set_pwrdnswtch(&mut self, val: super::vals::Pwrdnswtch) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "DisableVBUS"]
            #[must_use]
            #[inline(always)]
            pub const fn disablevbus(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "DisableVBUS"]
            #[inline(always)]
            pub const fn set_disablevbus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Line State Change (LnStsChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn lnstschng(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Line State Change (LnStsChng)"]
            #[inline(always)]
            pub const fn set_lnstschng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "LineStageChangeMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn linestagechangemsk(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LineStageChangeMsk"]
            #[inline(always)]
            pub const fn set_linestagechangemsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "ResetDetected"]
            #[must_use]
            #[inline(always)]
            pub const fn resetdetected(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "ResetDetected"]
            #[inline(always)]
            pub const fn set_resetdetected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "ResetDetMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn resetdetmsk(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "ResetDetMsk"]
            #[inline(always)]
            pub const fn set_resetdetmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "DisconnectDetect"]
            #[must_use]
            #[inline(always)]
            pub const fn disconnectdetect(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "DisconnectDetect"]
            #[inline(always)]
            pub const fn set_disconnectdetect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "DisconnectDetectMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn disconnectdetectmsk(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "DisconnectDetectMsk"]
            #[inline(always)]
            pub const fn set_disconnectdetectmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "ConnectDet"]
            #[must_use]
            #[inline(always)]
            pub const fn connectdet(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "ConnectDet"]
            #[inline(always)]
            pub const fn set_connectdet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "ConnDetMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn conndetmsk(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "ConnDetMsk"]
            #[inline(always)]
            pub const fn set_conndetmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "SRPDetect"]
            #[must_use]
            #[inline(always)]
            pub const fn srpdetect(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "SRPDetect"]
            #[inline(always)]
            pub const fn set_srpdetect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "SRPDetectMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn srpdetectmsk(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "SRPDetectMsk"]
            #[inline(always)]
            pub const fn set_srpdetectmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Status Change Interrupt (StsChngInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn stschngint(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Status Change Interrupt (StsChngInt)"]
            #[inline(always)]
            pub const fn set_stschngint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "StsChngIntMsk"]
            #[must_use]
            #[inline(always)]
            pub const fn stschngintmsk(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "StsChngIntMsk"]
            #[inline(always)]
            pub const fn set_stschngintmsk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "LineState"]
            #[must_use]
            #[inline(always)]
            pub const fn linestate(&self) -> super::vals::Linestate {
                let val = (self.0 >> 19usize) & 0x03;
                super::vals::Linestate::from_bits(val as u8)
            }
            #[doc = "LineState"]
            #[inline(always)]
            pub const fn set_linestate(&mut self, val: super::vals::Linestate) {
                self.0 =
                    (self.0 & !(0x03 << 19usize)) | (((val.to_bits() as u32) & 0x03) << 19usize);
            }
            #[doc = "This bit indicates the status of the signal IDDIG. The application must read this bit after receiving GPWRDN.StsChngInt and decode based on the previous value stored by the application."]
            #[must_use]
            #[inline(always)]
            pub const fn iddig(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates the status of the signal IDDIG. The application must read this bit after receiving GPWRDN.StsChngInt and decode based on the previous value stored by the application."]
            #[inline(always)]
            pub const fn set_iddig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "B Session Valid (BSessVld)"]
            #[must_use]
            #[inline(always)]
            pub const fn bsessvld(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "B Session Valid (BSessVld)"]
            #[inline(always)]
            pub const fn set_bsessvld(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "MultValIdBC"]
            #[must_use]
            #[inline(always)]
            pub const fn multvalidbc(&self) -> super::vals::GpwrdnMultvalidbc {
                let val = (self.0 >> 24usize) & 0x1f;
                super::vals::GpwrdnMultvalidbc::from_bits(val as u8)
            }
            #[doc = "MultValIdBC"]
            #[inline(always)]
            pub const fn set_multvalidbc(&mut self, val: super::vals::GpwrdnMultvalidbc) {
                self.0 =
                    (self.0 & !(0x1f << 24usize)) | (((val.to_bits() as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for Gpwrdn {
            #[inline(always)]
            fn default() -> Gpwrdn {
                Gpwrdn(0)
            }
        }
        impl core::fmt::Debug for Gpwrdn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gpwrdn")
                    .field("pmuintsel", &self.pmuintsel())
                    .field("pmuactv", &self.pmuactv())
                    .field("restore", &self.restore())
                    .field("pwrdnclmp", &self.pwrdnclmp())
                    .field("pwrdnrstn", &self.pwrdnrstn())
                    .field("pwrdnswtch", &self.pwrdnswtch())
                    .field("disablevbus", &self.disablevbus())
                    .field("lnstschng", &self.lnstschng())
                    .field("linestagechangemsk", &self.linestagechangemsk())
                    .field("resetdetected", &self.resetdetected())
                    .field("resetdetmsk", &self.resetdetmsk())
                    .field("disconnectdetect", &self.disconnectdetect())
                    .field("disconnectdetectmsk", &self.disconnectdetectmsk())
                    .field("connectdet", &self.connectdet())
                    .field("conndetmsk", &self.conndetmsk())
                    .field("srpdetect", &self.srpdetect())
                    .field("srpdetectmsk", &self.srpdetectmsk())
                    .field("stschngint", &self.stschngint())
                    .field("stschngintmsk", &self.stschngintmsk())
                    .field("linestate", &self.linestate())
                    .field("iddig", &self.iddig())
                    .field("bsessvld", &self.bsessvld())
                    .field("multvalidbc", &self.multvalidbc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gpwrdn {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gpwrdn {{ pmuintsel: {=bool:?}, pmuactv: {=bool:?}, restore: {=bool:?}, pwrdnclmp: {=bool:?}, pwrdnrstn: {=bool:?}, pwrdnswtch: {:?}, disablevbus: {=bool:?}, lnstschng: {=bool:?}, linestagechangemsk: {=bool:?}, resetdetected: {=bool:?}, resetdetmsk: {=bool:?}, disconnectdetect: {=bool:?}, disconnectdetectmsk: {=bool:?}, connectdet: {=bool:?}, conndetmsk: {=bool:?}, srpdetect: {=bool:?}, srpdetectmsk: {=bool:?}, stschngint: {=bool:?}, stschngintmsk: {=bool:?}, linestate: {:?}, iddig: {=bool:?}, bsessvld: {=bool:?}, multvalidbc: {:?} }}" , self . pmuintsel () , self . pmuactv () , self . restore () , self . pwrdnclmp () , self . pwrdnrstn () , self . pwrdnswtch () , self . disablevbus () , self . lnstschng () , self . linestagechangemsk () , self . resetdetected () , self . resetdetmsk () , self . disconnectdetect () , self . disconnectdetectmsk () , self . connectdet () , self . conndetmsk () , self . srpdetect () , self . srpdetectmsk () , self . stschngint () , self . stschngintmsk () , self . linestate () , self . iddig () , self . bsessvld () , self . multvalidbc ())
            }
        }
        #[doc = "Reset Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Grstctl(pub u32);
        impl Grstctl {
            #[doc = "Mode: Host and Device. Core Soft Reset (CSftRst)"]
            #[must_use]
            #[inline(always)]
            pub const fn csftrst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Core Soft Reset (CSftRst)"]
            #[inline(always)]
            pub const fn set_csftrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Mode: Host and Device. PIU FS Dedicated Controller Soft Reset (PIUFSSftRst)"]
            #[must_use]
            #[inline(always)]
            pub const fn piufssftrst(&self) -> super::vals::Piufssftrst {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Piufssftrst::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. PIU FS Dedicated Controller Soft Reset (PIUFSSftRst)"]
            #[inline(always)]
            pub const fn set_piufssftrst(&mut self, val: super::vals::Piufssftrst) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Mode: Host only. Host Frame Counter Reset (FrmCntrRst)"]
            #[must_use]
            #[inline(always)]
            pub const fn frmcntrrst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host only. Host Frame Counter Reset (FrmCntrRst)"]
            #[inline(always)]
            pub const fn set_frmcntrrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Mode: Host and Device. RxFIFO Flush (RxFFlsh)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxfflsh(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. RxFIFO Flush (RxFFlsh)"]
            #[inline(always)]
            pub const fn set_rxfflsh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Mode: Host and Device. TxFIFO Flush (TxFFlsh)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfflsh(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. TxFIFO Flush (TxFFlsh)"]
            #[inline(always)]
            pub const fn set_txfflsh(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Mode: Host and Device. TxFIFO Number (TxFNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn txfnum(&self) -> super::vals::GrstctlTxfnum {
                let val = (self.0 >> 6usize) & 0x1f;
                super::vals::GrstctlTxfnum::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. TxFIFO Number (TxFNum)"]
            #[inline(always)]
            pub const fn set_txfnum(&mut self, val: super::vals::GrstctlTxfnum) {
                self.0 = (self.0 & !(0x1f << 6usize)) | (((val.to_bits() as u32) & 0x1f) << 6usize);
            }
            #[doc = "Mode: Host and Device. Core Soft Reset Done (CSftRstDone)"]
            #[must_use]
            #[inline(always)]
            pub const fn csftrstdone(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. Core Soft Reset Done (CSftRstDone)"]
            #[inline(always)]
            pub const fn set_csftrstdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Mode: Host and Device. DMA Request Signal (DMAReq)"]
            #[must_use]
            #[inline(always)]
            pub const fn dmareq(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. DMA Request Signal (DMAReq)"]
            #[inline(always)]
            pub const fn set_dmareq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Mode: Host and Device. AHB Master Idle (AHBIdle)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbidle(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. AHB Master Idle (AHBIdle)"]
            #[inline(always)]
            pub const fn set_ahbidle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Grstctl {
            #[inline(always)]
            fn default() -> Grstctl {
                Grstctl(0)
            }
        }
        impl core::fmt::Debug for Grstctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Grstctl")
                    .field("csftrst", &self.csftrst())
                    .field("piufssftrst", &self.piufssftrst())
                    .field("frmcntrrst", &self.frmcntrrst())
                    .field("rxfflsh", &self.rxfflsh())
                    .field("txfflsh", &self.txfflsh())
                    .field("txfnum", &self.txfnum())
                    .field("csftrstdone", &self.csftrstdone())
                    .field("dmareq", &self.dmareq())
                    .field("ahbidle", &self.ahbidle())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Grstctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Grstctl {{ csftrst: {=bool:?}, piufssftrst: {:?}, frmcntrrst: {=bool:?}, rxfflsh: {=bool:?}, txfflsh: {=bool:?}, txfnum: {:?}, csftrstdone: {=bool:?}, dmareq: {=bool:?}, ahbidle: {=bool:?} }}" , self . csftrst () , self . piufssftrst () , self . frmcntrrst () , self . rxfflsh () , self . txfflsh () , self . txfnum () , self . csftrstdone () , self . dmareq () , self . ahbidle ())
            }
        }
        #[doc = "Receive FIFO Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Grxfsiz(pub u32);
        impl Grxfsiz {
            #[doc = "Mode: Host and Device. RxFIFO Depth (RxFDep)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxfdep(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Mode: Host and Device. RxFIFO Depth (RxFDep)"]
            #[inline(always)]
            pub const fn set_rxfdep(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Grxfsiz {
            #[inline(always)]
            fn default() -> Grxfsiz {
                Grxfsiz(0)
            }
        }
        impl core::fmt::Debug for Grxfsiz {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Grxfsiz")
                    .field("rxfdep", &self.rxfdep())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Grxfsiz {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Grxfsiz {{ rxfdep: {=u16:?} }}", self.rxfdep())
            }
        }
        #[doc = "Receive Status Read/Pop Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Grxstsp(pub u32);
        impl Grxstsp {
            #[doc = "Channel Number (ChNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn chnum(&self) -> super::vals::GrxstspChnum {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::GrxstspChnum::from_bits(val as u8)
            }
            #[doc = "Channel Number (ChNum)"]
            #[inline(always)]
            pub const fn set_chnum(&mut self, val: super::vals::GrxstspChnum) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Byte Count (BCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x07ff;
                val as u16
            }
            #[doc = "Byte Count (BCnt)"]
            #[inline(always)]
            pub const fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 4usize)) | (((val as u32) & 0x07ff) << 4usize);
            }
            #[doc = "Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::GrxstspDpid {
                let val = (self.0 >> 15usize) & 0x03;
                super::vals::GrxstspDpid::from_bits(val as u8)
            }
            #[doc = "Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::GrxstspDpid) {
                self.0 =
                    (self.0 & !(0x03 << 15usize)) | (((val.to_bits() as u32) & 0x03) << 15usize);
            }
            #[doc = "Packet Status (PktSts) indicates the status of the received packet."]
            #[must_use]
            #[inline(always)]
            pub const fn pktsts(&self) -> super::vals::GrxstspPktsts {
                let val = (self.0 >> 17usize) & 0x0f;
                super::vals::GrxstspPktsts::from_bits(val as u8)
            }
            #[doc = "Packet Status (PktSts) indicates the status of the received packet."]
            #[inline(always)]
            pub const fn set_pktsts(&mut self, val: super::vals::GrxstspPktsts) {
                self.0 =
                    (self.0 & !(0x0f << 17usize)) | (((val.to_bits() as u32) & 0x0f) << 17usize);
            }
            #[doc = "Mode: Device only. Frame Number (FN)"]
            #[must_use]
            #[inline(always)]
            pub const fn fn_(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x0f;
                val as u8
            }
            #[doc = "Mode: Device only. Frame Number (FN)"]
            #[inline(always)]
            pub const fn set_fn_(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 21usize)) | (((val as u32) & 0x0f) << 21usize);
            }
        }
        impl Default for Grxstsp {
            #[inline(always)]
            fn default() -> Grxstsp {
                Grxstsp(0)
            }
        }
        impl core::fmt::Debug for Grxstsp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Grxstsp")
                    .field("chnum", &self.chnum())
                    .field("bcnt", &self.bcnt())
                    .field("dpid", &self.dpid())
                    .field("pktsts", &self.pktsts())
                    .field("fn_", &self.fn_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Grxstsp {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Grxstsp {{ chnum: {:?}, bcnt: {=u16:?}, dpid: {:?}, pktsts: {:?}, fn_: {=u8:?} }}" , self . chnum () , self . bcnt () , self . dpid () , self . pktsts () , self . fn_ ())
            }
        }
        #[doc = "Receive Status Debug Read Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Grxstsr(pub u32);
        impl Grxstsr {
            #[doc = "Channel Number (ChNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn chnum(&self) -> super::vals::GrxstsrChnum {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::GrxstsrChnum::from_bits(val as u8)
            }
            #[doc = "Channel Number (ChNum)"]
            #[inline(always)]
            pub const fn set_chnum(&mut self, val: super::vals::GrxstsrChnum) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Byte Count (BCnt)"]
            #[must_use]
            #[inline(always)]
            pub const fn bcnt(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x07ff;
                val as u16
            }
            #[doc = "Byte Count (BCnt)"]
            #[inline(always)]
            pub const fn set_bcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 4usize)) | (((val as u32) & 0x07ff) << 4usize);
            }
            #[doc = "Data PID (DPID)"]
            #[must_use]
            #[inline(always)]
            pub const fn dpid(&self) -> super::vals::GrxstsrDpid {
                let val = (self.0 >> 15usize) & 0x03;
                super::vals::GrxstsrDpid::from_bits(val as u8)
            }
            #[doc = "Data PID (DPID)"]
            #[inline(always)]
            pub const fn set_dpid(&mut self, val: super::vals::GrxstsrDpid) {
                self.0 =
                    (self.0 & !(0x03 << 15usize)) | (((val.to_bits() as u32) & 0x03) << 15usize);
            }
            #[doc = "Packet Status (PktSts) indicates the status of the received packet."]
            #[must_use]
            #[inline(always)]
            pub const fn pktsts(&self) -> super::vals::GrxstsrPktsts {
                let val = (self.0 >> 17usize) & 0x0f;
                super::vals::GrxstsrPktsts::from_bits(val as u8)
            }
            #[doc = "Packet Status (PktSts) indicates the status of the received packet."]
            #[inline(always)]
            pub const fn set_pktsts(&mut self, val: super::vals::GrxstsrPktsts) {
                self.0 =
                    (self.0 & !(0x0f << 17usize)) | (((val.to_bits() as u32) & 0x0f) << 17usize);
            }
            #[doc = "Mode: Device only. Frame Number (FN)"]
            #[must_use]
            #[inline(always)]
            pub const fn fn_(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x0f;
                val as u8
            }
            #[doc = "Mode: Device only. Frame Number (FN)"]
            #[inline(always)]
            pub const fn set_fn_(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 21usize)) | (((val as u32) & 0x0f) << 21usize);
            }
        }
        impl Default for Grxstsr {
            #[inline(always)]
            fn default() -> Grxstsr {
                Grxstsr(0)
            }
        }
        impl core::fmt::Debug for Grxstsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Grxstsr")
                    .field("chnum", &self.chnum())
                    .field("bcnt", &self.bcnt())
                    .field("dpid", &self.dpid())
                    .field("pktsts", &self.pktsts())
                    .field("fn_", &self.fn_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Grxstsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Grxstsr {{ chnum: {:?}, bcnt: {=u16:?}, dpid: {:?}, pktsts: {:?}, fn_: {=u8:?} }}" , self . chnum () , self . bcnt () , self . dpid () , self . pktsts () , self . fn_ ())
            }
        }
        #[doc = "Global STAR Fix Disable Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gstarfxdis(pub u32);
        impl Gstarfxdis {
            #[doc = "Disable the STAR fix added for Device controller to go back to low power mode when Host ignores Remote wakeup"]
            #[must_use]
            #[inline(always)]
            pub const fn hostignoresrmtwkupdis(&self) -> super::vals::Hostignoresrmtwkupdis {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hostignoresrmtwkupdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to go back to low power mode when Host ignores Remote wakeup"]
            #[inline(always)]
            pub const fn set_hostignoresrmtwkupdis(
                &mut self,
                val: super::vals::Hostignoresrmtwkupdis,
            ) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Disable the STAR fix added for Device controller to detect lineK and move to RESUMING state after the 50us pull-up delay ends"]
            #[must_use]
            #[inline(always)]
            pub const fn resumefrmchkbusdis(&self) -> super::vals::Resumefrmchkbusdis {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Resumefrmchkbusdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to detect lineK and move to RESUMING state after the 50us pull-up delay ends"]
            #[inline(always)]
            pub const fn set_resumefrmchkbusdis(&mut self, val: super::vals::Resumefrmchkbusdis) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Disable the STAR fix added for Device controller to reject DATA0 for the first Control OUT Data Phase and Control Status OUT Phase"]
            #[must_use]
            #[inline(always)]
            pub const fn ignorectloutdata0dis(&self) -> super::vals::Ignorectloutdata0dis {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Ignorectloutdata0dis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to reject DATA0 for the first Control OUT Data Phase and Control Status OUT Phase"]
            #[inline(always)]
            pub const fn set_ignorectloutdata0dis(
                &mut self,
                val: super::vals::Ignorectloutdata0dis,
            ) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to flag error for SSPLIT STALL/NYET"]
            #[must_use]
            #[inline(always)]
            pub const fn ssplitstallnyeterrdis(&self) -> super::vals::Ssplitstallnyeterrdis {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Ssplitstallnyeterrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to flag error for SSPLIT STALL/NYET"]
            #[inline(always)]
            pub const fn set_ssplitstallnyeterrdis(
                &mut self,
                val: super::vals::Ssplitstallnyeterrdis,
            ) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to accept DATA1 PID from device for ISOC Split transfers"]
            #[must_use]
            #[inline(always)]
            pub const fn acceptisocsplitdata1dis(&self) -> super::vals::Acceptisocsplitdata1dis {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Acceptisocsplitdata1dis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to accept DATA1 PID from device for ISOC Split transfers"]
            #[inline(always)]
            pub const fn set_acceptisocsplitdata1dis(
                &mut self,
                val: super::vals::Acceptisocsplitdata1dis,
            ) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to handle Faulty cable scenarios"]
            #[must_use]
            #[inline(always)]
            pub const fn handlefaultycabledis(&self) -> super::vals::Handlefaultycabledis {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Handlefaultycabledis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to handle Faulty cable scenarios"]
            #[inline(always)]
            pub const fn set_handlefaultycabledis(
                &mut self,
                val: super::vals::Handlefaultycabledis,
            ) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Disable the STAR fix added for Host controller LS mode IPG increment from 2 LS bit times to 3 LS bit times"]
            #[must_use]
            #[inline(always)]
            pub const fn lsipgincrdis(&self) -> super::vals::Lsipgincrdis {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Lsipgincrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller LS mode IPG increment from 2 LS bit times to 3 LS bit times"]
            #[inline(always)]
            pub const fn set_lsipgincrdis(&mut self, val: super::vals::Lsipgincrdis) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Disable the STAR fix added for Device controller to transition to IDLE state during FS device disconnect"]
            #[must_use]
            #[inline(always)]
            pub const fn fsdiscidledis(&self) -> super::vals::Fsdiscidledis {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Fsdiscidledis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to transition to IDLE state during FS device disconnect"]
            #[inline(always)]
            pub const fn set_fsdiscidledis(&mut self, val: super::vals::Fsdiscidledis) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Disable the STAR fix added for Device controller to not start Remote Wakeup signalling when USB resume has already started"]
            #[must_use]
            #[inline(always)]
            pub const fn concurrentrmtwkupusbresumedis(
                &self,
            ) -> super::vals::Concurrentrmtwkupusbresumedis {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Concurrentrmtwkupusbresumedis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to not start Remote Wakeup signalling when USB resume has already started"]
            #[inline(always)]
            pub const fn set_concurrentrmtwkupusbresumedis(
                &mut self,
                val: super::vals::Concurrentrmtwkupusbresumedis,
            ) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Disable the STAR fix added for Device controller to not hang when Remote Wakeup signalling clashes with Host resume"]
            #[must_use]
            #[inline(always)]
            pub const fn concurrentrmtwkupusbresumehibdis(
                &self,
            ) -> super::vals::Concurrentrmtwkupusbresumehibdis {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Concurrentrmtwkupusbresumehibdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Device controller to not hang when Remote Wakeup signalling clashes with Host resume"]
            #[inline(always)]
            pub const fn set_concurrentrmtwkupusbresumehibdis(
                &mut self,
                val: super::vals::Concurrentrmtwkupusbresumehibdis,
            ) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to wait for IPG duration to send next token after receiving NAK/STALL for previous IN token with FS/LS device"]
            #[must_use]
            #[inline(always)]
            pub const fn lsipgchkafternakstallforindis(
                &self,
            ) -> super::vals::Lsipgchkafternakstallforindis {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Lsipgchkafternakstallforindis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to wait for IPG duration to send next token after receiving NAK/STALL for previous IN token with FS/LS device"]
            #[inline(always)]
            pub const fn set_lsipgchkafternakstallforindis(
                &mut self,
                val: super::vals::Lsipgchkafternakstallforindis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to increase the gap between utmi_xcvrselect switching and utmi_txvalid assertion in LS/FS mode"]
            #[must_use]
            #[inline(always)]
            pub const fn phyiopxcvrseltxvldcorrdis(
                &self,
            ) -> super::vals::Phyiopxcvrseltxvldcorrdis {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Phyiopxcvrseltxvldcorrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to increase the gap between utmi_xcvrselect switching and utmi_txvalid assertion in LS/FS mode"]
            #[inline(always)]
            pub const fn set_phyiopxcvrseltxvldcorrdis(
                &mut self,
                val: super::vals::Phyiopxcvrseltxvldcorrdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to increase the preamble transceiver select switch delay to accommodate time taken for ULPI function control write"]
            #[must_use]
            #[inline(always)]
            pub const fn ulpixcvrselswitchcorrdis(&self) -> super::vals::Ulpixcvrselswitchcorrdis {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Ulpixcvrselswitchcorrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to increase the preamble transceiver select switch delay to accommodate time taken for ULPI function control write"]
            #[inline(always)]
            pub const fn set_ulpixcvrselswitchcorrdis(
                &mut self,
                val: super::vals::Ulpixcvrselswitchcorrdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Disable the STAR fix added for Host controller to report transaction error when DATA0 PID is received for CTRL STATUS IN transfer in DMA mode"]
            #[must_use]
            #[inline(always)]
            pub const fn xacterrdata0ctrlstsindis(&self) -> super::vals::Xacterrdata0ctrlstsindis {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Xacterrdata0ctrlstsindis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for Host controller to report transaction error when DATA0 PID is received for CTRL STATUS IN transfer in DMA mode"]
            #[inline(always)]
            pub const fn set_xacterrdata0ctrlstsindis(
                &mut self,
                val: super::vals::Xacterrdata0ctrlstsindis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface in Host mode."]
            #[must_use]
            #[inline(always)]
            pub const fn hostutmitxvldcorrdis(&self) -> super::vals::Hostutmitxvldcorrdis {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Hostutmitxvldcorrdis::from_bits(val as u8)
            }
            #[doc = "Disable the correction to OpMode/XcvrSel/TermSel on UTMI Interface in Host mode."]
            #[inline(always)]
            pub const fn set_hostutmitxvldcorrdis(
                &mut self,
                val: super::vals::Hostutmitxvldcorrdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Disable the STAR fix added for correcting Opmode and XcvrSel on UTMI Interface when reset is detected in suspend state."]
            #[must_use]
            #[inline(always)]
            pub const fn opmodexcvrselchirpencorrdis(
                &self,
            ) -> super::vals::Opmodexcvrselchirpencorrdis {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Opmodexcvrselchirpencorrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for correcting Opmode and XcvrSel on UTMI Interface when reset is detected in suspend state."]
            #[inline(always)]
            pub const fn set_opmodexcvrselchirpencorrdis(
                &mut self,
                val: super::vals::Opmodexcvrselchirpencorrdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Disable the STAR fix added for correcting Txvalid deassertion on UTMI Interface when soft disconnect is done."]
            #[must_use]
            #[inline(always)]
            pub const fn txvaliddeassertioncorrdis(
                &self,
            ) -> super::vals::Txvaliddeassertioncorrdis {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Txvaliddeassertioncorrdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for correcting Txvalid deassertion on UTMI Interface when soft disconnect is done."]
            #[inline(always)]
            pub const fn set_txvaliddeassertioncorrdis(
                &mut self,
                val: super::vals::Txvaliddeassertioncorrdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Disable the STAR fix added for correcting Host behavior when port is disabled."]
            #[must_use]
            #[inline(always)]
            pub const fn hostnoxferafterprtdisfixdis(
                &self,
            ) -> super::vals::Hostnoxferafterprtdisfixdis {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Hostnoxferafterprtdisfixdis::from_bits(val as u8)
            }
            #[doc = "Disable the STAR fix added for correcting Host behavior when port is disabled."]
            #[inline(always)]
            pub const fn set_hostnoxferafterprtdisfixdis(
                &mut self,
                val: super::vals::Hostnoxferafterprtdisfixdis,
            ) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Gstarfxdis {
            #[inline(always)]
            fn default() -> Gstarfxdis {
                Gstarfxdis(0)
            }
        }
        impl core::fmt::Debug for Gstarfxdis {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gstarfxdis")
                    .field("hostignoresrmtwkupdis", &self.hostignoresrmtwkupdis())
                    .field("resumefrmchkbusdis", &self.resumefrmchkbusdis())
                    .field("ignorectloutdata0dis", &self.ignorectloutdata0dis())
                    .field("ssplitstallnyeterrdis", &self.ssplitstallnyeterrdis())
                    .field("acceptisocsplitdata1dis", &self.acceptisocsplitdata1dis())
                    .field("handlefaultycabledis", &self.handlefaultycabledis())
                    .field("lsipgincrdis", &self.lsipgincrdis())
                    .field("fsdiscidledis", &self.fsdiscidledis())
                    .field(
                        "concurrentrmtwkupusbresumedis",
                        &self.concurrentrmtwkupusbresumedis(),
                    )
                    .field(
                        "concurrentrmtwkupusbresumehibdis",
                        &self.concurrentrmtwkupusbresumehibdis(),
                    )
                    .field(
                        "lsipgchkafternakstallforindis",
                        &self.lsipgchkafternakstallforindis(),
                    )
                    .field(
                        "phyiopxcvrseltxvldcorrdis",
                        &self.phyiopxcvrseltxvldcorrdis(),
                    )
                    .field("ulpixcvrselswitchcorrdis", &self.ulpixcvrselswitchcorrdis())
                    .field("xacterrdata0ctrlstsindis", &self.xacterrdata0ctrlstsindis())
                    .field("hostutmitxvldcorrdis", &self.hostutmitxvldcorrdis())
                    .field(
                        "opmodexcvrselchirpencorrdis",
                        &self.opmodexcvrselchirpencorrdis(),
                    )
                    .field(
                        "txvaliddeassertioncorrdis",
                        &self.txvaliddeassertioncorrdis(),
                    )
                    .field(
                        "hostnoxferafterprtdisfixdis",
                        &self.hostnoxferafterprtdisfixdis(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gstarfxdis {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gstarfxdis {{ hostignoresrmtwkupdis: {:?}, resumefrmchkbusdis: {:?}, ignorectloutdata0dis: {:?}, ssplitstallnyeterrdis: {:?}, acceptisocsplitdata1dis: {:?}, handlefaultycabledis: {:?}, lsipgincrdis: {:?}, fsdiscidledis: {:?}, concurrentrmtwkupusbresumedis: {:?}, concurrentrmtwkupusbresumehibdis: {:?}, lsipgchkafternakstallforindis: {:?}, phyiopxcvrseltxvldcorrdis: {:?}, ulpixcvrselswitchcorrdis: {:?}, xacterrdata0ctrlstsindis: {:?}, hostutmitxvldcorrdis: {:?}, opmodexcvrselchirpencorrdis: {:?}, txvaliddeassertioncorrdis: {:?}, hostnoxferafterprtdisfixdis: {:?} }}" , self . hostignoresrmtwkupdis () , self . resumefrmchkbusdis () , self . ignorectloutdata0dis () , self . ssplitstallnyeterrdis () , self . acceptisocsplitdata1dis () , self . handlefaultycabledis () , self . lsipgincrdis () , self . fsdiscidledis () , self . concurrentrmtwkupusbresumedis () , self . concurrentrmtwkupusbresumehibdis () , self . lsipgchkafternakstallforindis () , self . phyiopxcvrseltxvldcorrdis () , self . ulpixcvrselswitchcorrdis () , self . xacterrdata0ctrlstsindis () , self . hostutmitxvldcorrdis () , self . opmodexcvrselchirpencorrdis () , self . txvaliddeassertioncorrdis () , self . hostnoxferafterprtdisfixdis ())
            }
        }
        #[doc = "USB Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gusbcfg(pub u32);
        impl Gusbcfg {
            #[doc = "Mode: Host and Device. HS/FS Timeout Calibration (TOutCal)"]
            #[must_use]
            #[inline(always)]
            pub const fn toutcal(&self) -> super::vals::Toutcal {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Toutcal::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. HS/FS Timeout Calibration (TOutCal)"]
            #[inline(always)]
            pub const fn set_toutcal(&mut self, val: super::vals::Toutcal) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Mode: Host and Device. PHY Interface (PHYIf)"]
            #[must_use]
            #[inline(always)]
            pub const fn phyif(&self) -> super::vals::Phyif {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Phyif::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. PHY Interface (PHYIf)"]
            #[inline(always)]
            pub const fn set_phyif(&mut self, val: super::vals::Phyif) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Mode: Host and Device. ULPI or UTMI+ Select (ULPI_UTMI_Sel)"]
            #[must_use]
            #[inline(always)]
            pub const fn ulpiutmisel(&self) -> super::vals::Ulpiutmisel {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Ulpiutmisel::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. ULPI or UTMI+ Select (ULPI_UTMI_Sel)"]
            #[inline(always)]
            pub const fn set_ulpiutmisel(&mut self, val: super::vals::Ulpiutmisel) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Mode: Host and Device. Full-Speed Serial Interface Select (FSIntf)"]
            #[must_use]
            #[inline(always)]
            pub const fn fsintf(&self) -> super::vals::Fsintf {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Fsintf::from_bits(val as u8)
            }
            #[doc = "Mode: Host and Device. Full-Speed Serial Interface Select (FSIntf)"]
            #[inline(always)]
            pub const fn set_fsintf(&mut self, val: super::vals::Fsintf) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "PHYSel"]
            #[must_use]
            #[inline(always)]
            pub const fn physel(&self) -> super::vals::Physel {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Physel::from_bits(val as u8)
            }
            #[doc = "PHYSel"]
            #[inline(always)]
            pub const fn set_physel(&mut self, val: super::vals::Physel) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Mode: Device only. USB Turnaround Time (USBTrdTim)"]
            #[must_use]
            #[inline(always)]
            pub const fn usbtrdtim(&self) -> super::vals::Usbtrdtim {
                let val = (self.0 >> 10usize) & 0x0f;
                super::vals::Usbtrdtim::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. USB Turnaround Time (USBTrdTim)"]
            #[inline(always)]
            pub const fn set_usbtrdtim(&mut self, val: super::vals::Usbtrdtim) {
                self.0 =
                    (self.0 & !(0x0f << 10usize)) | (((val.to_bits() as u32) & 0x0f) << 10usize);
            }
            #[doc = "PHY Low-Power Clock Select (PhyLPwrClkSel)"]
            #[must_use]
            #[inline(always)]
            pub const fn phylpwrclksel(&self) -> super::vals::Phylpwrclksel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Phylpwrclksel::from_bits(val as u8)
            }
            #[doc = "PHY Low-Power Clock Select (PhyLPwrClkSel)"]
            #[inline(always)]
            pub const fn set_phylpwrclksel(&mut self, val: super::vals::Phylpwrclksel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Mode: Device only. TermSel DLine Pulsing Selection (TermSelDLPulse)"]
            #[must_use]
            #[inline(always)]
            pub const fn termseldlpulse(&self) -> super::vals::Termseldlpulse {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Termseldlpulse::from_bits(val as u8)
            }
            #[doc = "Mode: Device only. TermSel DLine Pulsing Selection (TermSelDLPulse)"]
            #[inline(always)]
            pub const fn set_termseldlpulse(&mut self, val: super::vals::Termseldlpulse) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "Mode: Host and Device. IC_USB-Capable (IC_USBCap)"]
            #[must_use]
            #[inline(always)]
            pub const fn icusbcap(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and Device. IC_USB-Capable (IC_USBCap)"]
            #[inline(always)]
            pub const fn set_icusbcap(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Mode: Device only. Tx End Delay (TxEndDelay)"]
            #[must_use]
            #[inline(always)]
            pub const fn txenddelay(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Device only. Tx End Delay (TxEndDelay)"]
            #[inline(always)]
            pub const fn set_txenddelay(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Mode: Host and device. Force Host Mode (ForceHstMode)"]
            #[must_use]
            #[inline(always)]
            pub const fn forcehstmode(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and device. Force Host Mode (ForceHstMode)"]
            #[inline(always)]
            pub const fn set_forcehstmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Mode:Host and device. Force Device Mode (ForceDevMode)"]
            #[must_use]
            #[inline(always)]
            pub const fn forcedevmode(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Mode:Host and device. Force Device Mode (ForceDevMode)"]
            #[inline(always)]
            pub const fn set_forcedevmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Mode: Host and device. Corrupt Tx packet (CorruptTxPkt)"]
            #[must_use]
            #[inline(always)]
            pub const fn corrupttxpkt(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Mode: Host and device. Corrupt Tx packet (CorruptTxPkt)"]
            #[inline(always)]
            pub const fn set_corrupttxpkt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Gusbcfg {
            #[inline(always)]
            fn default() -> Gusbcfg {
                Gusbcfg(0)
            }
        }
        impl core::fmt::Debug for Gusbcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gusbcfg")
                    .field("toutcal", &self.toutcal())
                    .field("phyif", &self.phyif())
                    .field("ulpiutmisel", &self.ulpiutmisel())
                    .field("fsintf", &self.fsintf())
                    .field("physel", &self.physel())
                    .field("usbtrdtim", &self.usbtrdtim())
                    .field("phylpwrclksel", &self.phylpwrclksel())
                    .field("termseldlpulse", &self.termseldlpulse())
                    .field("icusbcap", &self.icusbcap())
                    .field("txenddelay", &self.txenddelay())
                    .field("forcehstmode", &self.forcehstmode())
                    .field("forcedevmode", &self.forcedevmode())
                    .field("corrupttxpkt", &self.corrupttxpkt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gusbcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Gusbcfg {{ toutcal: {:?}, phyif: {:?}, ulpiutmisel: {:?}, fsintf: {:?}, physel: {:?}, usbtrdtim: {:?}, phylpwrclksel: {:?}, termseldlpulse: {:?}, icusbcap: {=bool:?}, txenddelay: {=bool:?}, forcehstmode: {=bool:?}, forcedevmode: {=bool:?}, corrupttxpkt: {=bool:?} }}" , self . toutcal () , self . phyif () , self . ulpiutmisel () , self . fsintf () , self . physel () , self . usbtrdtim () , self . phylpwrclksel () , self . termseldlpulse () , self . icusbcap () , self . txenddelay () , self . forcehstmode () , self . forcedevmode () , self . corrupttxpkt ())
            }
        }
        #[doc = "Host All Channels Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Haint(pub u32);
        impl Haint {
            #[must_use]
            #[inline(always)]
            pub const fn haint(&self) -> super::vals::Haint {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Haint::from_bits(val as u16)
            }
            #[inline(always)]
            pub const fn set_haint(&mut self, val: super::vals::Haint) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Haint {
            #[inline(always)]
            fn default() -> Haint {
                Haint(0)
            }
        }
        impl core::fmt::Debug for Haint {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Haint")
                    .field("haint", &self.haint())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Haint {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Haint {{ haint: {:?} }}", self.haint())
            }
        }
        #[doc = "Host All Channels Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Haintmsk(pub u32);
        impl Haintmsk {
            #[doc = "Channel Interrupt Mask (HAINTMsk)"]
            #[must_use]
            #[inline(always)]
            pub const fn haintmsk(&self) -> super::vals::Haintmsk {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Haintmsk::from_bits(val as u16)
            }
            #[doc = "Channel Interrupt Mask (HAINTMsk)"]
            #[inline(always)]
            pub const fn set_haintmsk(&mut self, val: super::vals::Haintmsk) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Haintmsk {
            #[inline(always)]
            fn default() -> Haintmsk {
                Haintmsk(0)
            }
        }
        impl core::fmt::Debug for Haintmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Haintmsk")
                    .field("haintmsk", &self.haintmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Haintmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Haintmsk {{ haintmsk: {:?} }}", self.haintmsk())
            }
        }
        #[doc = "Host Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hcfg(pub u32);
        impl Hcfg {
            #[doc = "FS/LS PHY Clock Select (FSLSPclkSel)"]
            #[must_use]
            #[inline(always)]
            pub const fn fslspclksel(&self) -> super::vals::Fslspclksel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Fslspclksel::from_bits(val as u8)
            }
            #[doc = "FS/LS PHY Clock Select (FSLSPclkSel)"]
            #[inline(always)]
            pub const fn set_fslspclksel(&mut self, val: super::vals::Fslspclksel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "FS- and LS-Only Support (FSLSSupp)"]
            #[must_use]
            #[inline(always)]
            pub const fn fslssupp(&self) -> super::vals::Fslssupp {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Fslssupp::from_bits(val as u8)
            }
            #[doc = "FS- and LS-Only Support (FSLSSupp)"]
            #[inline(always)]
            pub const fn set_fslssupp(&mut self, val: super::vals::Fslssupp) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable 32 KHz Suspend mode (Ena32KHzS)"]
            #[must_use]
            #[inline(always)]
            pub const fn ena32khzs(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32 KHz Suspend mode (Ena32KHzS)"]
            #[inline(always)]
            pub const fn set_ena32khzs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Resume Validation Period (ResValid)"]
            #[must_use]
            #[inline(always)]
            pub const fn resvalid(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Resume Validation Period (ResValid)"]
            #[inline(always)]
            pub const fn set_resvalid(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Mode Change Ready Timer Enable (ModeChTimEn)"]
            #[must_use]
            #[inline(always)]
            pub const fn modechtimen(&self) -> super::vals::Modechtimen {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Modechtimen::from_bits(val as u8)
            }
            #[doc = "Mode Change Ready Timer Enable (ModeChTimEn)"]
            #[inline(always)]
            pub const fn set_modechtimen(&mut self, val: super::vals::Modechtimen) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Hcfg {
            #[inline(always)]
            fn default() -> Hcfg {
                Hcfg(0)
            }
        }
        impl core::fmt::Debug for Hcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hcfg")
                    .field("fslspclksel", &self.fslspclksel())
                    .field("fslssupp", &self.fslssupp())
                    .field("ena32khzs", &self.ena32khzs())
                    .field("resvalid", &self.resvalid())
                    .field("modechtimen", &self.modechtimen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Hcfg {{ fslspclksel: {:?}, fslssupp: {:?}, ena32khzs: {=bool:?}, resvalid: {=u8:?}, modechtimen: {:?} }}" , self . fslspclksel () , self . fslssupp () , self . ena32khzs () , self . resvalid () , self . modechtimen ())
            }
        }
        #[doc = "Host Frame Interval Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfir(pub u32);
        impl Hfir {
            #[doc = "Frame Interval (FrInt)"]
            #[must_use]
            #[inline(always)]
            pub const fn frint(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Frame Interval (FrInt)"]
            #[inline(always)]
            pub const fn set_frint(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Reload Control (HFIRRldCtrl)"]
            #[must_use]
            #[inline(always)]
            pub const fn hfirrldctrl(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Reload Control (HFIRRldCtrl)"]
            #[inline(always)]
            pub const fn set_hfirrldctrl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Hfir {
            #[inline(always)]
            fn default() -> Hfir {
                Hfir(0)
            }
        }
        impl core::fmt::Debug for Hfir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfir")
                    .field("frint", &self.frint())
                    .field("hfirrldctrl", &self.hfirrldctrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfir {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hfir {{ frint: {=u16:?}, hfirrldctrl: {=bool:?} }}",
                    self.frint(),
                    self.hfirrldctrl()
                )
            }
        }
        #[doc = "Host Frame Number/Frame Time Remaining Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfnum(pub u32);
        impl Hfnum {
            #[doc = "Frame Number (FrNum)"]
            #[must_use]
            #[inline(always)]
            pub const fn frnum(&self) -> super::vals::Frnum {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Frnum::from_bits(val as u16)
            }
            #[doc = "Frame Number (FrNum)"]
            #[inline(always)]
            pub const fn set_frnum(&mut self, val: super::vals::Frnum) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
            #[doc = "Frame Time Remaining (FrRem)"]
            #[must_use]
            #[inline(always)]
            pub const fn frrem(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Frame Time Remaining (FrRem)"]
            #[inline(always)]
            pub const fn set_frrem(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Hfnum {
            #[inline(always)]
            fn default() -> Hfnum {
                Hfnum(0)
            }
        }
        impl core::fmt::Debug for Hfnum {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfnum")
                    .field("frnum", &self.frnum())
                    .field("frrem", &self.frrem())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfnum {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hfnum {{ frnum: {:?}, frrem: {=u16:?} }}",
                    self.frnum(),
                    self.frrem()
                )
            }
        }
        #[doc = "Host Port Control and Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hprt(pub u32);
        impl Hprt {
            #[doc = "Port Connect Status (PrtConnSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtconnsts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Port Connect Status (PrtConnSts)"]
            #[inline(always)]
            pub const fn set_prtconnsts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Port Connect Detected (PrtConnDet)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtconndet(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Port Connect Detected (PrtConnDet)"]
            #[inline(always)]
            pub const fn set_prtconndet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Port Enable (PrtEna)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtena(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Port Enable (PrtEna)"]
            #[inline(always)]
            pub const fn set_prtena(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Port Enable/Disable Change (PrtEnChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtenchng(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Port Enable/Disable Change (PrtEnChng)"]
            #[inline(always)]
            pub const fn set_prtenchng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Port Overcurrent Active (PrtOvrCurrAct)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtovrcurract(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Port Overcurrent Active (PrtOvrCurrAct)"]
            #[inline(always)]
            pub const fn set_prtovrcurract(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Port Overcurrent Change (PrtOvrCurrChng)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtovrcurrchng(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Port Overcurrent Change (PrtOvrCurrChng)"]
            #[inline(always)]
            pub const fn set_prtovrcurrchng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Port Resume (PrtRes)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtres(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Port Resume (PrtRes)"]
            #[inline(always)]
            pub const fn set_prtres(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Port Suspend (PrtSusp)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtsusp(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Port Suspend (PrtSusp)"]
            #[inline(always)]
            pub const fn set_prtsusp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Port Reset (PrtRst)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtrst(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Port Reset (PrtRst)"]
            #[inline(always)]
            pub const fn set_prtrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Port Line Status (PrtLnSts)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtlnsts(&self) -> super::vals::Prtlnsts {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Prtlnsts::from_bits(val as u8)
            }
            #[doc = "Port Line Status (PrtLnSts)"]
            #[inline(always)]
            pub const fn set_prtlnsts(&mut self, val: super::vals::Prtlnsts) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Port Power (PrtPwr)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtpwr(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Port Power (PrtPwr)"]
            #[inline(always)]
            pub const fn set_prtpwr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Port Test Control (PrtTstCtl)"]
            #[must_use]
            #[inline(always)]
            pub const fn prttstctl(&self) -> super::vals::Prttstctl {
                let val = (self.0 >> 13usize) & 0x0f;
                super::vals::Prttstctl::from_bits(val as u8)
            }
            #[doc = "Port Test Control (PrtTstCtl)"]
            #[inline(always)]
            pub const fn set_prttstctl(&mut self, val: super::vals::Prttstctl) {
                self.0 =
                    (self.0 & !(0x0f << 13usize)) | (((val.to_bits() as u32) & 0x0f) << 13usize);
            }
            #[doc = "Port Speed (PrtSpd)"]
            #[must_use]
            #[inline(always)]
            pub const fn prtspd(&self) -> super::vals::Prtspd {
                let val = (self.0 >> 17usize) & 0x03;
                super::vals::Prtspd::from_bits(val as u8)
            }
            #[doc = "Port Speed (PrtSpd)"]
            #[inline(always)]
            pub const fn set_prtspd(&mut self, val: super::vals::Prtspd) {
                self.0 =
                    (self.0 & !(0x03 << 17usize)) | (((val.to_bits() as u32) & 0x03) << 17usize);
            }
        }
        impl Default for Hprt {
            #[inline(always)]
            fn default() -> Hprt {
                Hprt(0)
            }
        }
        impl core::fmt::Debug for Hprt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hprt")
                    .field("prtconnsts", &self.prtconnsts())
                    .field("prtconndet", &self.prtconndet())
                    .field("prtena", &self.prtena())
                    .field("prtenchng", &self.prtenchng())
                    .field("prtovrcurract", &self.prtovrcurract())
                    .field("prtovrcurrchng", &self.prtovrcurrchng())
                    .field("prtres", &self.prtres())
                    .field("prtsusp", &self.prtsusp())
                    .field("prtrst", &self.prtrst())
                    .field("prtlnsts", &self.prtlnsts())
                    .field("prtpwr", &self.prtpwr())
                    .field("prttstctl", &self.prttstctl())
                    .field("prtspd", &self.prtspd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hprt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Hprt {{ prtconnsts: {=bool:?}, prtconndet: {=bool:?}, prtena: {=bool:?}, prtenchng: {=bool:?}, prtovrcurract: {=bool:?}, prtovrcurrchng: {=bool:?}, prtres: {=bool:?}, prtsusp: {=bool:?}, prtrst: {=bool:?}, prtlnsts: {:?}, prtpwr: {=bool:?}, prttstctl: {:?}, prtspd: {:?} }}" , self . prtconnsts () , self . prtconndet () , self . prtena () , self . prtenchng () , self . prtovrcurract () , self . prtovrcurrchng () , self . prtres () , self . prtsusp () , self . prtrst () , self . prtlnsts () , self . prtpwr () , self . prttstctl () , self . prtspd ())
            }
        }
        #[doc = "Host Periodic Transmit FIFO Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hptxfsiz(pub u32);
        impl Hptxfsiz {
            #[doc = "Host Periodic TxFIFO Start Address (PTxFStAddr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ptxfstaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Host Periodic TxFIFO Start Address (PTxFStAddr)"]
            #[inline(always)]
            pub const fn set_ptxfstaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Host Periodic TxFIFO Depth (PTxFSize)"]
            #[must_use]
            #[inline(always)]
            pub const fn ptxfsize(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x07ff;
                val as u16
            }
            #[doc = "Host Periodic TxFIFO Depth (PTxFSize)"]
            #[inline(always)]
            pub const fn set_ptxfsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 16usize)) | (((val as u32) & 0x07ff) << 16usize);
            }
        }
        impl Default for Hptxfsiz {
            #[inline(always)]
            fn default() -> Hptxfsiz {
                Hptxfsiz(0)
            }
        }
        impl core::fmt::Debug for Hptxfsiz {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hptxfsiz")
                    .field("ptxfstaddr", &self.ptxfstaddr())
                    .field("ptxfsize", &self.ptxfsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hptxfsiz {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hptxfsiz {{ ptxfstaddr: {=u16:?}, ptxfsize: {=u16:?} }}",
                    self.ptxfstaddr(),
                    self.ptxfsize()
                )
            }
        }
        #[doc = "Description cluster: Host Channel Interrupt Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Transfer Completed (XferCompl)"]
            #[must_use]
            #[inline(always)]
            pub const fn xfercompl(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transfer Completed (XferCompl)"]
            #[inline(always)]
            pub const fn set_xfercompl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Channel Halted (ChHltd)"]
            #[must_use]
            #[inline(always)]
            pub const fn chhltd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Channel Halted (ChHltd)"]
            #[inline(always)]
            pub const fn set_chhltd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "AHB Error (AHBErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn ahberr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "AHB Error (AHBErr)"]
            #[inline(always)]
            pub const fn set_ahberr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "STALL Response Received Interrupt (STALL)"]
            #[must_use]
            #[inline(always)]
            pub const fn stall(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "STALL Response Received Interrupt (STALL)"]
            #[inline(always)]
            pub const fn set_stall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "NAK Response Received Interrupt (NAK)"]
            #[must_use]
            #[inline(always)]
            pub const fn nak(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "NAK Response Received Interrupt (NAK)"]
            #[inline(always)]
            pub const fn set_nak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "ACK Response Received/Transmitted Interrupt (ACK)"]
            #[must_use]
            #[inline(always)]
            pub const fn ack(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "ACK Response Received/Transmitted Interrupt (ACK)"]
            #[inline(always)]
            pub const fn set_ack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "NYET Response Received Interrupt (NYET)"]
            #[must_use]
            #[inline(always)]
            pub const fn nyet(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "NYET Response Received Interrupt (NYET)"]
            #[inline(always)]
            pub const fn set_nyet(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Transaction Error (XactErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn xacterr(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Transaction Error (XactErr)"]
            #[inline(always)]
            pub const fn set_xacterr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Babble Error (BblErr)"]
            #[must_use]
            #[inline(always)]
            pub const fn bblerr(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Babble Error (BblErr)"]
            #[inline(always)]
            pub const fn set_bblerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Frame Overrun (FrmOvrun)."]
            #[must_use]
            #[inline(always)]
            pub const fn frmovrun(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Frame Overrun (FrmOvrun)."]
            #[inline(always)]
            pub const fn set_frmovrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn datatglerr(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_datatglerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("xfercompl", &self.xfercompl())
                    .field("chhltd", &self.chhltd())
                    .field("ahberr", &self.ahberr())
                    .field("stall", &self.stall())
                    .field("nak", &self.nak())
                    .field("ack", &self.ack())
                    .field("nyet", &self.nyet())
                    .field("xacterr", &self.xacterr())
                    .field("bblerr", &self.bblerr())
                    .field("frmovrun", &self.frmovrun())
                    .field("datatglerr", &self.datatglerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ xfercompl: {=bool:?}, chhltd: {=bool:?}, ahberr: {=bool:?}, stall: {=bool:?}, nak: {=bool:?}, ack: {=bool:?}, nyet: {=bool:?}, xacterr: {=bool:?}, bblerr: {=bool:?}, frmovrun: {=bool:?}, datatglerr: {=bool:?} }}" , self . xfercompl () , self . chhltd () , self . ahberr () , self . stall () , self . nak () , self . ack () , self . nyet () , self . xacterr () , self . bblerr () , self . frmovrun () , self . datatglerr ())
            }
        }
        #[doc = "Description cluster: Host Channel Interrupt Mask Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Intmsk(pub u32);
        impl Intmsk {
            #[must_use]
            #[inline(always)]
            pub const fn xfercomplmsk(&self) -> super::vals::IntmskXfercomplmsk {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IntmskXfercomplmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_xfercomplmsk(&mut self, val: super::vals::IntmskXfercomplmsk) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn chhltdmsk(&self) -> super::vals::Chhltdmsk {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Chhltdmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_chhltdmsk(&mut self, val: super::vals::Chhltdmsk) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn ahberrmsk(&self) -> super::vals::IntmskAhberrmsk {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::IntmskAhberrmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_ahberrmsk(&mut self, val: super::vals::IntmskAhberrmsk) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn stallmsk(&self) -> super::vals::Stallmsk {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Stallmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_stallmsk(&mut self, val: super::vals::Stallmsk) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn nakmsk(&self) -> super::vals::IntmskNakmsk {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::IntmskNakmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_nakmsk(&mut self, val: super::vals::IntmskNakmsk) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn ackmsk(&self) -> super::vals::Ackmsk {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Ackmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_ackmsk(&mut self, val: super::vals::Ackmsk) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn nyetmsk(&self) -> super::vals::IntmskNyetmsk {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::IntmskNyetmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_nyetmsk(&mut self, val: super::vals::IntmskNyetmsk) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn xacterrmsk(&self) -> super::vals::Xacterrmsk {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Xacterrmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_xacterrmsk(&mut self, val: super::vals::Xacterrmsk) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn bblerrmsk(&self) -> super::vals::Bblerrmsk {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Bblerrmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_bblerrmsk(&mut self, val: super::vals::Bblerrmsk) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn frmovrunmsk(&self) -> super::vals::Frmovrunmsk {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Frmovrunmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_frmovrunmsk(&mut self, val: super::vals::Frmovrunmsk) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn datatglerrmsk(&self) -> super::vals::Datatglerrmsk {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Datatglerrmsk::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_datatglerrmsk(&mut self, val: super::vals::Datatglerrmsk) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Intmsk {
            #[inline(always)]
            fn default() -> Intmsk {
                Intmsk(0)
            }
        }
        impl core::fmt::Debug for Intmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Intmsk")
                    .field("xfercomplmsk", &self.xfercomplmsk())
                    .field("chhltdmsk", &self.chhltdmsk())
                    .field("ahberrmsk", &self.ahberrmsk())
                    .field("stallmsk", &self.stallmsk())
                    .field("nakmsk", &self.nakmsk())
                    .field("ackmsk", &self.ackmsk())
                    .field("nyetmsk", &self.nyetmsk())
                    .field("xacterrmsk", &self.xacterrmsk())
                    .field("bblerrmsk", &self.bblerrmsk())
                    .field("frmovrunmsk", &self.frmovrunmsk())
                    .field("datatglerrmsk", &self.datatglerrmsk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Intmsk {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Intmsk {{ xfercomplmsk: {:?}, chhltdmsk: {:?}, ahberrmsk: {:?}, stallmsk: {:?}, nakmsk: {:?}, ackmsk: {:?}, nyetmsk: {:?}, xacterrmsk: {:?}, bblerrmsk: {:?}, frmovrunmsk: {:?}, datatglerrmsk: {:?} }}" , self . xfercomplmsk () , self . chhltdmsk () , self . ahberrmsk () , self . stallmsk () , self . nakmsk () , self . ackmsk () , self . nyetmsk () , self . xacterrmsk () , self . bblerrmsk () , self . frmovrunmsk () , self . datatglerrmsk ())
            }
        }
        #[doc = "Power and Clock Gating Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcgcctl(pub u32);
        impl Pcgcctl {
            #[doc = "Stop Pclk (StopPclk)"]
            #[must_use]
            #[inline(always)]
            pub const fn stoppclk(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Stop Pclk (StopPclk)"]
            #[inline(always)]
            pub const fn set_stoppclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Gate Hclk (GateHclk)"]
            #[must_use]
            #[inline(always)]
            pub const fn gatehclk(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Gate Hclk (GateHclk)"]
            #[inline(always)]
            pub const fn set_gatehclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Reset Power-Down Modules (RstPdwnModule)"]
            #[must_use]
            #[inline(always)]
            pub const fn rstpdwnmodule(&self) -> super::vals::Rstpdwnmodule {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Rstpdwnmodule::from_bits(val as u8)
            }
            #[doc = "Reset Power-Down Modules (RstPdwnModule)"]
            #[inline(always)]
            pub const fn set_rstpdwnmodule(&mut self, val: super::vals::Rstpdwnmodule) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable Sleep Clock Gating"]
            #[must_use]
            #[inline(always)]
            pub const fn enbll1gating(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Sleep Clock Gating"]
            #[inline(always)]
            pub const fn set_enbll1gating(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "PHY In Sleep"]
            #[must_use]
            #[inline(always)]
            pub const fn physleep(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "PHY In Sleep"]
            #[inline(always)]
            pub const fn set_physleep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "L1 Deep Sleep"]
            #[must_use]
            #[inline(always)]
            pub const fn l1suspended(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "L1 Deep Sleep"]
            #[inline(always)]
            pub const fn set_l1suspended(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Restore Mode (RestoreMode)"]
            #[must_use]
            #[inline(always)]
            pub const fn restoremode(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Restore Mode (RestoreMode)"]
            #[inline(always)]
            pub const fn set_restoremode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Essential Register Values Restored (EssRegRestored)"]
            #[must_use]
            #[inline(always)]
            pub const fn essregrestored(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Essential Register Values Restored (EssRegRestored)"]
            #[inline(always)]
            pub const fn set_essregrestored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Restore Value (RestoreValue)"]
            #[must_use]
            #[inline(always)]
            pub const fn restorevalue(&self) -> u32 {
                let val = (self.0 >> 14usize) & 0x0003_ffff;
                val as u32
            }
            #[doc = "Restore Value (RestoreValue)"]
            #[inline(always)]
            pub const fn set_restorevalue(&mut self, val: u32) {
                self.0 = (self.0 & !(0x0003_ffff << 14usize))
                    | (((val as u32) & 0x0003_ffff) << 14usize);
            }
        }
        impl Default for Pcgcctl {
            #[inline(always)]
            fn default() -> Pcgcctl {
                Pcgcctl(0)
            }
        }
        impl core::fmt::Debug for Pcgcctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcgcctl")
                    .field("stoppclk", &self.stoppclk())
                    .field("gatehclk", &self.gatehclk())
                    .field("rstpdwnmodule", &self.rstpdwnmodule())
                    .field("enbll1gating", &self.enbll1gating())
                    .field("physleep", &self.physleep())
                    .field("l1suspended", &self.l1suspended())
                    .field("restoremode", &self.restoremode())
                    .field("essregrestored", &self.essregrestored())
                    .field("restorevalue", &self.restorevalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcgcctl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcgcctl {{ stoppclk: {=bool:?}, gatehclk: {=bool:?}, rstpdwnmodule: {:?}, enbll1gating: {=bool:?}, physleep: {=bool:?}, l1suspended: {=bool:?}, restoremode: {=bool:?}, essregrestored: {=bool:?}, restorevalue: {=u32:?} }}" , self . stoppclk () , self . gatehclk () , self . rstpdwnmodule () , self . enbll1gating () , self . physleep () , self . l1suspended () , self . restoremode () , self . essregrestored () , self . restorevalue ())
            }
        }
        #[doc = "Description cluster: Host Channel Transfer Size Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsiz(pub u32);
        impl Tsiz {
            #[doc = "Non-Scatter/Gather DMA Mode:"]
            #[must_use]
            #[inline(always)]
            pub const fn xfersize(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0007_ffff;
                val as u32
            }
            #[doc = "Non-Scatter/Gather DMA Mode:"]
            #[inline(always)]
            pub const fn set_xfersize(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0007_ffff << 0usize)) | (((val as u32) & 0x0007_ffff) << 0usize);
            }
            #[doc = "Non-Scatter/Gather DMA Mode:"]
            #[must_use]
            #[inline(always)]
            pub const fn pktcnt(&self) -> u16 {
                let val = (self.0 >> 19usize) & 0x03ff;
                val as u16
            }
            #[doc = "Non-Scatter/Gather DMA Mode:"]
            #[inline(always)]
            pub const fn set_pktcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 19usize)) | (((val as u32) & 0x03ff) << 19usize);
            }
            #[doc = "PID (Pid)"]
            #[must_use]
            #[inline(always)]
            pub const fn pid(&self) -> super::vals::Pid {
                let val = (self.0 >> 29usize) & 0x03;
                super::vals::Pid::from_bits(val as u8)
            }
            #[doc = "PID (Pid)"]
            #[inline(always)]
            pub const fn set_pid(&mut self, val: super::vals::Pid) {
                self.0 =
                    (self.0 & !(0x03 << 29usize)) | (((val.to_bits() as u32) & 0x03) << 29usize);
            }
            #[doc = "Do Ping (DoPng)"]
            #[must_use]
            #[inline(always)]
            pub const fn dopng(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Do Ping (DoPng)"]
            #[inline(always)]
            pub const fn set_dopng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Tsiz {
            #[inline(always)]
            fn default() -> Tsiz {
                Tsiz(0)
            }
        }
        impl core::fmt::Debug for Tsiz {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsiz")
                    .field("xfersize", &self.xfersize())
                    .field("pktcnt", &self.pktcnt())
                    .field("pid", &self.pid())
                    .field("dopng", &self.dopng())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsiz {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tsiz {{ xfersize: {=u32:?}, pktcnt: {=u16:?}, pid: {:?}, dopng: {=bool:?} }}",
                    self.xfersize(),
                    self.pktcnt(),
                    self.pid(),
                    self.dopng()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Acceptisocsplitdata1dis {
            #[doc = "Transaction Error not reported when device sends DATA1 PID for ISOC Split"]
            ENABLE_FIX = 0x0,
            #[doc = "Transaction Error reported when device sends DATA1 PID for ISOC Split"]
            DISABLE_FIX = 0x01,
        }
        impl Acceptisocsplitdata1dis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Acceptisocsplitdata1dis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Acceptisocsplitdata1dis {
            #[inline(always)]
            fn from(val: u8) -> Acceptisocsplitdata1dis {
                Acceptisocsplitdata1dis::from_bits(val)
            }
        }
        impl From<Acceptisocsplitdata1dis> for u8 {
            #[inline(always)]
            fn from(val: Acceptisocsplitdata1dis) -> u8 {
                Acceptisocsplitdata1dis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackmsk {
            #[doc = "Mask ACK Response Received/Transmitted Interrupt"]
            MASK = 0x0,
            #[doc = "No ACK Response Received/Transmitted Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Ackmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackmsk {
            #[inline(always)]
            fn from(val: u8) -> Ackmsk {
                Ackmsk::from_bits(val)
            }
        }
        impl From<Ackmsk> for u8 {
            #[inline(always)]
            fn from(val: Ackmsk) -> u8 {
                Ackmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ahbsingle {
            #[doc = "The remaining data in the transfer is sent using INCR burst size"]
            INCRBURST = 0x0,
            #[doc = "The remaining data in the transfer is sent using Single burst size"]
            SINGLEBURST = 0x01,
        }
        impl Ahbsingle {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ahbsingle {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ahbsingle {
            #[inline(always)]
            fn from(val: u8) -> Ahbsingle {
                Ahbsingle::from_bits(val)
            }
        }
        impl From<Ahbsingle> for u8 {
            #[inline(always)]
            fn from(val: Ahbsingle) -> u8 {
                Ahbsingle::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ahbthrratio {
            #[doc = "AHB threshold = MAC threshold"]
            THRESZERO = 0x0,
            #[doc = "AHB threshold = MAC threshold /2"]
            THRESONE = 0x01,
            #[doc = "AHB threshold = MAC threshold /4"]
            THRESTWO = 0x02,
            #[doc = "AHB threshold = MAC threshold /8"]
            THRESTHREE = 0x03,
        }
        impl Ahbthrratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ahbthrratio {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ahbthrratio {
            #[inline(always)]
            fn from(val: u8) -> Ahbthrratio {
                Ahbthrratio::from_bits(val)
            }
        }
        impl From<Ahbthrratio> for u8 {
            #[inline(always)]
            fn from(val: Ahbthrratio) -> u8 {
                Ahbthrratio::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Appl1res {
            #[doc = "The core responds with a NYET when an error is detected in either of the LPM token packets due to corruption"]
            NYET_RESP = 0x0,
            #[doc = "The core responds with an ACK only on a successful LPM transaction"]
            ACK_RESP = 0x01,
        }
        impl Appl1res {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Appl1res {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Appl1res {
            #[inline(always)]
            fn from(val: u8) -> Appl1res {
                Appl1res::from_bits(val)
            }
        }
        impl From<Appl1res> for u8 {
            #[inline(always)]
            fn from(val: Appl1res) -> u8 {
                Appl1res::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Avalidovval {
            #[doc = "Avalid value is 1'b0 when GOTGCTL.AvalidOvEn =1"]
            VALUE0 = 0x0,
            #[doc = "Avalid value is 1'b1 when GOTGCTL.AvalidOvEn =1"]
            VALUE1 = 0x01,
        }
        impl Avalidovval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Avalidovval {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Avalidovval {
            #[inline(always)]
            fn from(val: u8) -> Avalidovval {
                Avalidovval::from_bits(val)
            }
        }
        impl From<Avalidovval> for u8 {
            #[inline(always)]
            fn from(val: Avalidovval) -> u8 {
                Avalidovval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bbleerrmsk {
            #[doc = "Mask Babble Error Interrupt"]
            MASK = 0x0,
            #[doc = "No Babble Error Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Bbleerrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bbleerrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bbleerrmsk {
            #[inline(always)]
            fn from(val: u8) -> Bbleerrmsk {
                Bbleerrmsk::from_bits(val)
            }
        }
        impl From<Bbleerrmsk> for u8 {
            #[inline(always)]
            fn from(val: Bbleerrmsk) -> u8 {
                Bbleerrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bblerrmsk {
            #[doc = "Mask Babble Error"]
            MASK = 0x0,
            #[doc = "No Babble Error Mask"]
            NOMASK = 0x01,
        }
        impl Bblerrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bblerrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bblerrmsk {
            #[inline(always)]
            fn from(val: u8) -> Bblerrmsk {
                Bblerrmsk::from_bits(val)
            }
        }
        impl From<Bblerrmsk> for u8 {
            #[inline(always)]
            fn from(val: Bblerrmsk) -> u8 {
                Bblerrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bvalidovval {
            #[doc = "Bvalid value when GOTGCTL.BvalidOvEn =1"]
            VALUE0 = 0x0,
            #[doc = "Bvalid value when GOTGCTL.BvalidOvEn =1"]
            VALUE1 = 0x01,
        }
        impl Bvalidovval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bvalidovval {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bvalidovval {
            #[inline(always)]
            fn from(val: u8) -> Bvalidovval {
                Bvalidovval::from_bits(val)
            }
        }
        impl From<Bvalidovval> for u8 {
            #[inline(always)]
            fn from(val: Bvalidovval) -> u8 {
                Bvalidovval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CharEptype {
            #[doc = "Control"]
            CTRL = 0x0,
            #[doc = "Isochronous"]
            ISOC = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERR = 0x03,
        }
        impl CharEptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CharEptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CharEptype {
            #[inline(always)]
            fn from(val: u8) -> CharEptype {
                CharEptype::from_bits(val)
            }
        }
        impl From<CharEptype> for u8 {
            #[inline(always)]
            fn from(val: CharEptype) -> u8 {
                CharEptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chhltdmsk {
            #[doc = "Channel Halted Mask"]
            MASK = 0x0,
            #[doc = "No Channel Halted Mask"]
            NOMASK = 0x01,
        }
        impl Chhltdmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chhltdmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chhltdmsk {
            #[inline(always)]
            fn from(val: u8) -> Chhltdmsk {
                Chhltdmsk::from_bits(val)
            }
        }
        impl From<Chhltdmsk> for u8 {
            #[inline(always)]
            fn from(val: Chhltdmsk) -> u8 {
                Chhltdmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Chirpen {
            #[doc = "The controller does not assert chirp_on before sending an actual Chirp 'K' signal on USB."]
            CHIRP_DISABLE = 0x0,
            #[doc = "The controller asserts chirp_on before sending an actual Chirp 'K' signal on USB."]
            CHIRP_ENABLE = 0x01,
        }
        impl Chirpen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Chirpen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Chirpen {
            #[inline(always)]
            fn from(val: u8) -> Chirpen {
                Chirpen::from_bits(val)
            }
        }
        impl From<Chirpen> for u8 {
            #[inline(always)]
            fn from(val: Chirpen) -> u8 {
                Chirpen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Concurrentrmtwkupusbresumedis {
            #[doc = "Device controller does not start remote wakeup signalling when host resume has already started"]
            ENABLE_FIX = 0x0,
            #[doc = "Device controller is allowed to start remote wakeup signalling when host resume has already started"]
            DISABLE_FIX = 0x01,
        }
        impl Concurrentrmtwkupusbresumedis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Concurrentrmtwkupusbresumedis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Concurrentrmtwkupusbresumedis {
            #[inline(always)]
            fn from(val: u8) -> Concurrentrmtwkupusbresumedis {
                Concurrentrmtwkupusbresumedis::from_bits(val)
            }
        }
        impl From<Concurrentrmtwkupusbresumedis> for u8 {
            #[inline(always)]
            fn from(val: Concurrentrmtwkupusbresumedis) -> u8 {
                Concurrentrmtwkupusbresumedis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Concurrentrmtwkupusbresumehibdis {
            #[doc = "Device controller does not hang when remote wakeup signalling clashes with host resume during Hibernation exit"]
            ENABLE_FIX = 0x0,
            #[doc = "Device controller hangs when remote wakeup signalling clashes with host resume during Hibernation exit"]
            DISABLE_FIX = 0x01,
        }
        impl Concurrentrmtwkupusbresumehibdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Concurrentrmtwkupusbresumehibdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Concurrentrmtwkupusbresumehibdis {
            #[inline(always)]
            fn from(val: u8) -> Concurrentrmtwkupusbresumehibdis {
                Concurrentrmtwkupusbresumehibdis::from_bits(val)
            }
        }
        impl From<Concurrentrmtwkupusbresumehibdis> for u8 {
            #[inline(always)]
            fn from(val: Concurrentrmtwkupusbresumehibdis) -> u8 {
                Concurrentrmtwkupusbresumehibdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Conidsts {
            #[doc = "The core is in A-Device mode."]
            MODEA = 0x0,
            #[doc = "The core is in B-Device mode."]
            MODEB = 0x01,
        }
        impl Conidsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Conidsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Conidsts {
            #[inline(always)]
            fn from(val: u8) -> Conidsts {
                Conidsts::from_bits(val)
            }
        }
        impl From<Conidsts> for u8 {
            #[inline(always)]
            fn from(val: Conidsts) -> u8 {
                Conidsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Conidstschngmsk {
            #[doc = "Connector ID Status Change Mask"]
            MASK = 0x0,
            #[doc = "No Connector ID Status Change Mask"]
            NOMASK = 0x01,
        }
        impl Conidstschngmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Conidstschngmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Conidstschngmsk {
            #[inline(always)]
            fn from(val: u8) -> Conidstschngmsk {
                Conidstschngmsk::from_bits(val)
            }
        }
        impl From<Conidstschngmsk> for u8 {
            #[inline(always)]
            fn from(val: Conidstschngmsk) -> u8 {
                Conidstschngmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Corel1res {
            #[doc = "ERROR : No handshake response"]
            LPMRESP1 = 0x0,
            #[doc = "STALL response"]
            LPMRESP2 = 0x01,
            #[doc = "NYET response"]
            LPMRESP3 = 0x02,
            #[doc = "ACK response"]
            LPMRESP4 = 0x03,
        }
        impl Corel1res {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Corel1res {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Corel1res {
            #[inline(always)]
            fn from(val: u8) -> Corel1res {
                Corel1res::from_bits(val)
            }
        }
        impl From<Corel1res> for u8 {
            #[inline(always)]
            fn from(val: Corel1res) -> u8 {
                Corel1res::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Datatglerrmsk {
            #[doc = "Mask Data Toggle Error"]
            MASK = 0x0,
            #[doc = "No Data Toggle Error Mask"]
            NOMASK = 0x01,
        }
        impl Datatglerrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Datatglerrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Datatglerrmsk {
            #[inline(always)]
            fn from(val: u8) -> Datatglerrmsk {
                Datatglerrmsk::from_bits(val)
            }
        }
        impl From<Datatglerrmsk> for u8 {
            #[inline(always)]
            fn from(val: Datatglerrmsk) -> u8 {
                Datatglerrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dbnctime {
            #[doc = "Long debounce time, used for physical connections (100 ms + 2.5 micro-sec)"]
            LONG = 0x0,
            #[doc = "Short debounce time, used for soft connections (2.5 micro-sec)"]
            SHORT = 0x01,
        }
        impl Dbnctime {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dbnctime {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dbnctime {
            #[inline(always)]
            fn from(val: u8) -> Dbnctime {
                Dbnctime::from_bits(val)
            }
        }
        impl From<Dbnctime> for u8 {
            #[inline(always)]
            fn from(val: Dbnctime) -> u8 {
                Dbnctime::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Descdma {
            #[doc = "Non Dynamic configuration"]
            CONFIG1 = 0x0,
            #[doc = "Dynamic configuration"]
            CONFIG2 = 0x01,
        }
        impl Descdma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Descdma {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Descdma {
            #[inline(always)]
            fn from(val: u8) -> Descdma {
                Descdma::from_bits(val)
            }
        }
        impl From<Descdma> for u8 {
            #[inline(always)]
            fn from(val: Descdma) -> u8 {
                Descdma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Devspd {
            #[doc = "High speed USB 2.0 PHY clock is 30 MHz or 60 MHz"]
            USBHS20 = 0x0,
            #[doc = "Full speed USB 2.0 PHY clock is 30 MHz or 60 MHz"]
            USBFS20 = 0x01,
            #[doc = "Low speed USB 1.1 transceiver clock is 6 MHz"]
            USBLS116 = 0x02,
            #[doc = "Full speed USB 1.1 transceiver clock is 48 MHz"]
            USBFS1148 = 0x03,
        }
        impl Devspd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Devspd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Devspd {
            #[inline(always)]
            fn from(val: u8) -> Devspd {
                Devspd::from_bits(val)
            }
        }
        impl From<Devspd> for u8 {
            #[inline(always)]
            fn from(val: Devspd) -> u8 {
                Devspd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl0Eptype {
            #[doc = "Endpoint Control 0"]
            ACTIVE = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Diepctl0Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl0Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl0Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl0Eptype {
                Diepctl0Eptype::from_bits(val)
            }
        }
        impl From<Diepctl0Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl0Eptype) -> u8 {
                Diepctl0Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl0Mps {
            #[doc = "64 bytes"]
            BYTES64 = 0x0,
            #[doc = "32 bytes"]
            BYTES32 = 0x01,
            #[doc = "16 bytes"]
            BYTES16 = 0x02,
            #[doc = "8 bytes"]
            BYTES8 = 0x03,
        }
        impl Diepctl0Mps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl0Mps {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl0Mps {
            #[inline(always)]
            fn from(val: u8) -> Diepctl0Mps {
                Diepctl0Mps::from_bits(val)
            }
        }
        impl From<Diepctl0Mps> for u8 {
            #[inline(always)]
            fn from(val: Diepctl0Mps) -> u8 {
                Diepctl0Mps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl0Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl0Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl0Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl0Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl0Txfnum {
                Diepctl0Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl0Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl0Txfnum) -> u8 {
                Diepctl0Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl10Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl10Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl10Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl10Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl10Dpid {
                Diepctl10Dpid::from_bits(val)
            }
        }
        impl From<Diepctl10Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl10Dpid) -> u8 {
                Diepctl10Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl10Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl10Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl10Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl10Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl10Eptype {
                Diepctl10Eptype::from_bits(val)
            }
        }
        impl From<Diepctl10Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl10Eptype) -> u8 {
                Diepctl10Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl10Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl10Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl10Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl10Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl10Naksts {
                Diepctl10Naksts::from_bits(val)
            }
        }
        impl From<Diepctl10Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl10Naksts) -> u8 {
                Diepctl10Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl10Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl10Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl10Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl10Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl10Txfnum {
                Diepctl10Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl10Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl10Txfnum) -> u8 {
                Diepctl10Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl11Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl11Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl11Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl11Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl11Dpid {
                Diepctl11Dpid::from_bits(val)
            }
        }
        impl From<Diepctl11Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl11Dpid) -> u8 {
                Diepctl11Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl11Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl11Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl11Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl11Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl11Eptype {
                Diepctl11Eptype::from_bits(val)
            }
        }
        impl From<Diepctl11Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl11Eptype) -> u8 {
                Diepctl11Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl11Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl11Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl11Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl11Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl11Naksts {
                Diepctl11Naksts::from_bits(val)
            }
        }
        impl From<Diepctl11Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl11Naksts) -> u8 {
                Diepctl11Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl11Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl11Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl11Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl11Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl11Txfnum {
                Diepctl11Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl11Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl11Txfnum) -> u8 {
                Diepctl11Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl1Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl1Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl1Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl1Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl1Dpid {
                Diepctl1Dpid::from_bits(val)
            }
        }
        impl From<Diepctl1Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl1Dpid) -> u8 {
                Diepctl1Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl1Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl1Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl1Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl1Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl1Eptype {
                Diepctl1Eptype::from_bits(val)
            }
        }
        impl From<Diepctl1Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl1Eptype) -> u8 {
                Diepctl1Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl1Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl1Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl1Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl1Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl1Naksts {
                Diepctl1Naksts::from_bits(val)
            }
        }
        impl From<Diepctl1Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl1Naksts) -> u8 {
                Diepctl1Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl1Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl1Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl1Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl1Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl1Txfnum {
                Diepctl1Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl1Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl1Txfnum) -> u8 {
                Diepctl1Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl2Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl2Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl2Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl2Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl2Dpid {
                Diepctl2Dpid::from_bits(val)
            }
        }
        impl From<Diepctl2Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl2Dpid) -> u8 {
                Diepctl2Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl2Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl2Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl2Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl2Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl2Eptype {
                Diepctl2Eptype::from_bits(val)
            }
        }
        impl From<Diepctl2Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl2Eptype) -> u8 {
                Diepctl2Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl2Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl2Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl2Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl2Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl2Naksts {
                Diepctl2Naksts::from_bits(val)
            }
        }
        impl From<Diepctl2Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl2Naksts) -> u8 {
                Diepctl2Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl2Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl2Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl2Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl2Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl2Txfnum {
                Diepctl2Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl2Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl2Txfnum) -> u8 {
                Diepctl2Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl3Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl3Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl3Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl3Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl3Dpid {
                Diepctl3Dpid::from_bits(val)
            }
        }
        impl From<Diepctl3Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl3Dpid) -> u8 {
                Diepctl3Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl3Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl3Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl3Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl3Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl3Eptype {
                Diepctl3Eptype::from_bits(val)
            }
        }
        impl From<Diepctl3Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl3Eptype) -> u8 {
                Diepctl3Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl3Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl3Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl3Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl3Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl3Naksts {
                Diepctl3Naksts::from_bits(val)
            }
        }
        impl From<Diepctl3Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl3Naksts) -> u8 {
                Diepctl3Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl3Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl3Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl3Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl3Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl3Txfnum {
                Diepctl3Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl3Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl3Txfnum) -> u8 {
                Diepctl3Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl4Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl4Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl4Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl4Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl4Dpid {
                Diepctl4Dpid::from_bits(val)
            }
        }
        impl From<Diepctl4Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl4Dpid) -> u8 {
                Diepctl4Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl4Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl4Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl4Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl4Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl4Eptype {
                Diepctl4Eptype::from_bits(val)
            }
        }
        impl From<Diepctl4Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl4Eptype) -> u8 {
                Diepctl4Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl4Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl4Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl4Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl4Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl4Naksts {
                Diepctl4Naksts::from_bits(val)
            }
        }
        impl From<Diepctl4Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl4Naksts) -> u8 {
                Diepctl4Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl4Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl4Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl4Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl4Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl4Txfnum {
                Diepctl4Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl4Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl4Txfnum) -> u8 {
                Diepctl4Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl5Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl5Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl5Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl5Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl5Dpid {
                Diepctl5Dpid::from_bits(val)
            }
        }
        impl From<Diepctl5Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl5Dpid) -> u8 {
                Diepctl5Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl5Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl5Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl5Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl5Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl5Eptype {
                Diepctl5Eptype::from_bits(val)
            }
        }
        impl From<Diepctl5Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl5Eptype) -> u8 {
                Diepctl5Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl5Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl5Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl5Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl5Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl5Naksts {
                Diepctl5Naksts::from_bits(val)
            }
        }
        impl From<Diepctl5Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl5Naksts) -> u8 {
                Diepctl5Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl5Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl5Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl5Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl5Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl5Txfnum {
                Diepctl5Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl5Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl5Txfnum) -> u8 {
                Diepctl5Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl6Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl6Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl6Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl6Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl6Dpid {
                Diepctl6Dpid::from_bits(val)
            }
        }
        impl From<Diepctl6Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl6Dpid) -> u8 {
                Diepctl6Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl6Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl6Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl6Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl6Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl6Eptype {
                Diepctl6Eptype::from_bits(val)
            }
        }
        impl From<Diepctl6Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl6Eptype) -> u8 {
                Diepctl6Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl6Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl6Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl6Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl6Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl6Naksts {
                Diepctl6Naksts::from_bits(val)
            }
        }
        impl From<Diepctl6Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl6Naksts) -> u8 {
                Diepctl6Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl6Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl6Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl6Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl6Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl6Txfnum {
                Diepctl6Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl6Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl6Txfnum) -> u8 {
                Diepctl6Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl7Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl7Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl7Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl7Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl7Dpid {
                Diepctl7Dpid::from_bits(val)
            }
        }
        impl From<Diepctl7Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl7Dpid) -> u8 {
                Diepctl7Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl7Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl7Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl7Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl7Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl7Eptype {
                Diepctl7Eptype::from_bits(val)
            }
        }
        impl From<Diepctl7Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl7Eptype) -> u8 {
                Diepctl7Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl7Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl7Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl7Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl7Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl7Naksts {
                Diepctl7Naksts::from_bits(val)
            }
        }
        impl From<Diepctl7Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl7Naksts) -> u8 {
                Diepctl7Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl7Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl7Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl7Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl7Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl7Txfnum {
                Diepctl7Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl7Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl7Txfnum) -> u8 {
                Diepctl7Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl8Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl8Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl8Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl8Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl8Dpid {
                Diepctl8Dpid::from_bits(val)
            }
        }
        impl From<Diepctl8Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl8Dpid) -> u8 {
                Diepctl8Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl8Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl8Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl8Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl8Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl8Eptype {
                Diepctl8Eptype::from_bits(val)
            }
        }
        impl From<Diepctl8Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl8Eptype) -> u8 {
                Diepctl8Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl8Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl8Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl8Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl8Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl8Naksts {
                Diepctl8Naksts::from_bits(val)
            }
        }
        impl From<Diepctl8Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl8Naksts) -> u8 {
                Diepctl8Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl8Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl8Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl8Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl8Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl8Txfnum {
                Diepctl8Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl8Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl8Txfnum) -> u8 {
                Diepctl8Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl9Dpid {
            #[doc = "DATA0 or Even Frame"]
            DATA0EVENFRM = 0x0,
            #[doc = "DATA1 or Odd Frame"]
            DATA1ODDFRM = 0x01,
        }
        impl Diepctl9Dpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl9Dpid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl9Dpid {
            #[inline(always)]
            fn from(val: u8) -> Diepctl9Dpid {
                Diepctl9Dpid::from_bits(val)
            }
        }
        impl From<Diepctl9Dpid> for u8 {
            #[inline(always)]
            fn from(val: Diepctl9Dpid) -> u8 {
                Diepctl9Dpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl9Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUP = 0x03,
        }
        impl Diepctl9Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl9Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl9Eptype {
            #[inline(always)]
            fn from(val: u8) -> Diepctl9Eptype {
                Diepctl9Eptype::from_bits(val)
            }
        }
        impl From<Diepctl9Eptype> for u8 {
            #[inline(always)]
            fn from(val: Diepctl9Eptype) -> u8 {
                Diepctl9Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl9Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Diepctl9Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl9Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl9Naksts {
            #[inline(always)]
            fn from(val: u8) -> Diepctl9Naksts {
                Diepctl9Naksts::from_bits(val)
            }
        }
        impl From<Diepctl9Naksts> for u8 {
            #[inline(always)]
            fn from(val: Diepctl9Naksts) -> u8 {
                Diepctl9Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Diepctl9Txfnum {
            #[doc = "Tx FIFO 0"]
            TXFIFO0 = 0x0,
            #[doc = "Tx FIFO 1"]
            TXFIFO1 = 0x01,
            #[doc = "Tx FIFO 2"]
            TXFIFO2 = 0x02,
            #[doc = "Tx FIFO 3"]
            TXFIFO3 = 0x03,
            #[doc = "Tx FIFO 4"]
            TXFIFO4 = 0x04,
            #[doc = "Tx FIFO 5"]
            TXFIFO5 = 0x05,
            #[doc = "Tx FIFO 6"]
            TXFIFO6 = 0x06,
            #[doc = "Tx FIFO 7"]
            TXFIFO7 = 0x07,
            #[doc = "Tx FIFO 8"]
            TXFIFO8 = 0x08,
            #[doc = "Tx FIFO 9"]
            TXFIFO9 = 0x09,
            #[doc = "Tx FIFO 10"]
            TXFIFO10 = 0x0a,
            #[doc = "Tx FIFO 11"]
            TXFIFO11 = 0x0b,
            #[doc = "Tx FIFO 12"]
            TXFIFO12 = 0x0c,
            #[doc = "Tx FIFO 13"]
            TXFIFO13 = 0x0d,
            #[doc = "Tx FIFO 14"]
            TXFIFO14 = 0x0e,
            #[doc = "Tx FIFO 15"]
            TXFIFO15 = 0x0f,
        }
        impl Diepctl9Txfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Diepctl9Txfnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Diepctl9Txfnum {
            #[inline(always)]
            fn from(val: u8) -> Diepctl9Txfnum {
                Diepctl9Txfnum::from_bits(val)
            }
        }
        impl From<Diepctl9Txfnum> for u8 {
            #[inline(always)]
            fn from(val: Diepctl9Txfnum) -> u8 {
                Diepctl9Txfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DiepmskAhberrmsk {
            #[doc = "Mask AHB Error Interrupt"]
            MASK = 0x0,
            #[doc = "No AHB Error Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DiepmskAhberrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DiepmskAhberrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DiepmskAhberrmsk {
            #[inline(always)]
            fn from(val: u8) -> DiepmskAhberrmsk {
                DiepmskAhberrmsk::from_bits(val)
            }
        }
        impl From<DiepmskAhberrmsk> for u8 {
            #[inline(always)]
            fn from(val: DiepmskAhberrmsk) -> u8 {
                DiepmskAhberrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DiepmskEpdisbldmsk {
            #[doc = "Mask Endpoint Disabled Interrupt"]
            MASK = 0x0,
            #[doc = "No Endpoint Disabled Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DiepmskEpdisbldmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DiepmskEpdisbldmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DiepmskEpdisbldmsk {
            #[inline(always)]
            fn from(val: u8) -> DiepmskEpdisbldmsk {
                DiepmskEpdisbldmsk::from_bits(val)
            }
        }
        impl From<DiepmskEpdisbldmsk> for u8 {
            #[inline(always)]
            fn from(val: DiepmskEpdisbldmsk) -> u8 {
                DiepmskEpdisbldmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DiepmskNakmsk {
            #[doc = "Mask NAK Interrupt"]
            MASK = 0x0,
            #[doc = "No Mask NAK Interrupt"]
            NOMASK = 0x01,
        }
        impl DiepmskNakmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DiepmskNakmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DiepmskNakmsk {
            #[inline(always)]
            fn from(val: u8) -> DiepmskNakmsk {
                DiepmskNakmsk::from_bits(val)
            }
        }
        impl From<DiepmskNakmsk> for u8 {
            #[inline(always)]
            fn from(val: DiepmskNakmsk) -> u8 {
                DiepmskNakmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DiepmskXfercomplmsk {
            #[doc = "Mask Transfer Completed Interrupt"]
            MASK = 0x0,
            #[doc = "No Transfer Completed Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DiepmskXfercomplmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DiepmskXfercomplmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DiepmskXfercomplmsk {
            #[inline(always)]
            fn from(val: u8) -> DiepmskXfercomplmsk {
                DiepmskXfercomplmsk::from_bits(val)
            }
        }
        impl From<DiepmskXfercomplmsk> for u8 {
            #[inline(always)]
            fn from(val: DiepmskXfercomplmsk) -> u8 {
                DiepmskXfercomplmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz10Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz10Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz10Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz10Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz10Mc {
                Dieptsiz10Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz10Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz10Mc) -> u8 {
                Dieptsiz10Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz11Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz11Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz11Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz11Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz11Mc {
                Dieptsiz11Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz11Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz11Mc) -> u8 {
                Dieptsiz11Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz1Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz1Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz1Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz1Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz1Mc {
                Dieptsiz1Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz1Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz1Mc) -> u8 {
                Dieptsiz1Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz2Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz2Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz2Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz2Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz2Mc {
                Dieptsiz2Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz2Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz2Mc) -> u8 {
                Dieptsiz2Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz3Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz3Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz3Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz3Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz3Mc {
                Dieptsiz3Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz3Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz3Mc) -> u8 {
                Dieptsiz3Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz4Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz4Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz4Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz4Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz4Mc {
                Dieptsiz4Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz4Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz4Mc) -> u8 {
                Dieptsiz4Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz5Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz5Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz5Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz5Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz5Mc {
                Dieptsiz5Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz5Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz5Mc) -> u8 {
                Dieptsiz5Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz6Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz6Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz6Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz6Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz6Mc {
                Dieptsiz6Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz6Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz6Mc) -> u8 {
                Dieptsiz6Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz7Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz7Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz7Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz7Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz7Mc {
                Dieptsiz7Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz7Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz7Mc) -> u8 {
                Dieptsiz7Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz8Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz8Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz8Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz8Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz8Mc {
                Dieptsiz8Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz8Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz8Mc) -> u8 {
                Dieptsiz8Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dieptsiz9Mc {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            PACKETONE = 0x01,
            #[doc = "2 packets"]
            PACKETTWO = 0x02,
            #[doc = "3 packets"]
            PACKETTHREE = 0x03,
        }
        impl Dieptsiz9Mc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dieptsiz9Mc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dieptsiz9Mc {
            #[inline(always)]
            fn from(val: u8) -> Dieptsiz9Mc {
                Dieptsiz9Mc::from_bits(val)
            }
        }
        impl From<Dieptsiz9Mc> for u8 {
            #[inline(always)]
            fn from(val: Dieptsiz9Mc) -> u8 {
                Dieptsiz9Mc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Disconnintmsk {
            #[doc = "Disconnect Detected Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Disconnect Detected Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Disconnintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Disconnintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Disconnintmsk {
            #[inline(always)]
            fn from(val: u8) -> Disconnintmsk {
                Disconnintmsk::from_bits(val)
            }
        }
        impl From<Disconnintmsk> for u8 {
            #[inline(always)]
            fn from(val: Disconnintmsk) -> u8 {
                Disconnintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dmaen {
            #[doc = "Core operates in Slave mode"]
            SLAVEMODE = 0x0,
            #[doc = "Core operates in a DMA mode"]
            DMAMODE = 0x01,
        }
        impl Dmaen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dmaen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dmaen {
            #[inline(always)]
            fn from(val: u8) -> Dmaen {
                Dmaen::from_bits(val)
            }
        }
        impl From<Dmaen> for u8 {
            #[inline(always)]
            fn from(val: Dmaen) -> u8 {
                Dmaen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl0Eptype {
            #[doc = "Endpoint Control 0"]
            ACTIVE = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Doepctl0Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl0Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl0Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl0Eptype {
                Doepctl0Eptype::from_bits(val)
            }
        }
        impl From<Doepctl0Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl0Eptype) -> u8 {
                Doepctl0Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl0Mps {
            #[doc = "64 bytes"]
            BYTE64 = 0x0,
            #[doc = "32 bytes"]
            BYTE32 = 0x01,
            #[doc = "16 bytes"]
            BYTE16 = 0x02,
            #[doc = "8 bytes"]
            BYTE8 = 0x03,
        }
        impl Doepctl0Mps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl0Mps {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl0Mps {
            #[inline(always)]
            fn from(val: u8) -> Doepctl0Mps {
                Doepctl0Mps::from_bits(val)
            }
        }
        impl From<Doepctl0Mps> for u8 {
            #[inline(always)]
            fn from(val: Doepctl0Mps) -> u8 {
                Doepctl0Mps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl12Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl12Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl12Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl12Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl12Eptype {
                Doepctl12Eptype::from_bits(val)
            }
        }
        impl From<Doepctl12Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl12Eptype) -> u8 {
                Doepctl12Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl12Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl12Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl12Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl12Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl12Naksts {
                Doepctl12Naksts::from_bits(val)
            }
        }
        impl From<Doepctl12Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl12Naksts) -> u8 {
                Doepctl12Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl13Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl13Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl13Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl13Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl13Eptype {
                Doepctl13Eptype::from_bits(val)
            }
        }
        impl From<Doepctl13Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl13Eptype) -> u8 {
                Doepctl13Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl13Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl13Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl13Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl13Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl13Naksts {
                Doepctl13Naksts::from_bits(val)
            }
        }
        impl From<Doepctl13Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl13Naksts) -> u8 {
                Doepctl13Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl14Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl14Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl14Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl14Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl14Eptype {
                Doepctl14Eptype::from_bits(val)
            }
        }
        impl From<Doepctl14Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl14Eptype) -> u8 {
                Doepctl14Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl14Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl14Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl14Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl14Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl14Naksts {
                Doepctl14Naksts::from_bits(val)
            }
        }
        impl From<Doepctl14Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl14Naksts) -> u8 {
                Doepctl14Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl15Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl15Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl15Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl15Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl15Eptype {
                Doepctl15Eptype::from_bits(val)
            }
        }
        impl From<Doepctl15Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl15Eptype) -> u8 {
                Doepctl15Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl15Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl15Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl15Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl15Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl15Naksts {
                Doepctl15Naksts::from_bits(val)
            }
        }
        impl From<Doepctl15Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl15Naksts) -> u8 {
                Doepctl15Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl1Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl1Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl1Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl1Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl1Eptype {
                Doepctl1Eptype::from_bits(val)
            }
        }
        impl From<Doepctl1Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl1Eptype) -> u8 {
                Doepctl1Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl1Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl1Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl1Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl1Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl1Naksts {
                Doepctl1Naksts::from_bits(val)
            }
        }
        impl From<Doepctl1Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl1Naksts) -> u8 {
                Doepctl1Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl2Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl2Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl2Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl2Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl2Eptype {
                Doepctl2Eptype::from_bits(val)
            }
        }
        impl From<Doepctl2Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl2Eptype) -> u8 {
                Doepctl2Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl2Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl2Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl2Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl2Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl2Naksts {
                Doepctl2Naksts::from_bits(val)
            }
        }
        impl From<Doepctl2Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl2Naksts) -> u8 {
                Doepctl2Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl3Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl3Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl3Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl3Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl3Eptype {
                Doepctl3Eptype::from_bits(val)
            }
        }
        impl From<Doepctl3Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl3Eptype) -> u8 {
                Doepctl3Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl3Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl3Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl3Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl3Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl3Naksts {
                Doepctl3Naksts::from_bits(val)
            }
        }
        impl From<Doepctl3Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl3Naksts) -> u8 {
                Doepctl3Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl4Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl4Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl4Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl4Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl4Eptype {
                Doepctl4Eptype::from_bits(val)
            }
        }
        impl From<Doepctl4Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl4Eptype) -> u8 {
                Doepctl4Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl4Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl4Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl4Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl4Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl4Naksts {
                Doepctl4Naksts::from_bits(val)
            }
        }
        impl From<Doepctl4Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl4Naksts) -> u8 {
                Doepctl4Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl5Eptype {
            #[doc = "Control"]
            CONTROL = 0x0,
            #[doc = "Isochronous"]
            ISOCHRONOUS = 0x01,
            #[doc = "Bulk"]
            BULK = 0x02,
            #[doc = "Interrupt"]
            INTERRUPT = 0x03,
        }
        impl Doepctl5Eptype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl5Eptype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl5Eptype {
            #[inline(always)]
            fn from(val: u8) -> Doepctl5Eptype {
                Doepctl5Eptype::from_bits(val)
            }
        }
        impl From<Doepctl5Eptype> for u8 {
            #[inline(always)]
            fn from(val: Doepctl5Eptype) -> u8 {
                Doepctl5Eptype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doepctl5Naksts {
            #[doc = "The core is transmitting non-NAK handshakes based on the FIFO status"]
            NONNAK = 0x0,
            #[doc = "The core is transmitting NAK handshakes on this endpoint"]
            NAK = 0x01,
        }
        impl Doepctl5Naksts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doepctl5Naksts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doepctl5Naksts {
            #[inline(always)]
            fn from(val: u8) -> Doepctl5Naksts {
                Doepctl5Naksts::from_bits(val)
            }
        }
        impl From<Doepctl5Naksts> for u8 {
            #[inline(always)]
            fn from(val: Doepctl5Naksts) -> u8 {
                Doepctl5Naksts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskAhberrmsk {
            #[doc = "Mask AHB Error Interrupt"]
            MASK = 0x0,
            #[doc = "No AHB Error Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskAhberrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskAhberrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskAhberrmsk {
            #[inline(always)]
            fn from(val: u8) -> DoepmskAhberrmsk {
                DoepmskAhberrmsk::from_bits(val)
            }
        }
        impl From<DoepmskAhberrmsk> for u8 {
            #[inline(always)]
            fn from(val: DoepmskAhberrmsk) -> u8 {
                DoepmskAhberrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskBack2backsetup {
            #[doc = "Mask Back-to-Back SETUP Packets Received Interrupt"]
            MASK = 0x0,
            #[doc = "No Back-to-Back SETUP Packets Received Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskBack2backsetup {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskBack2backsetup {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskBack2backsetup {
            #[inline(always)]
            fn from(val: u8) -> DoepmskBack2backsetup {
                DoepmskBack2backsetup::from_bits(val)
            }
        }
        impl From<DoepmskBack2backsetup> for u8 {
            #[inline(always)]
            fn from(val: DoepmskBack2backsetup) -> u8 {
                DoepmskBack2backsetup::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskEpdisbldmsk {
            #[doc = "Mask Endpoint Disabled Interrupt"]
            MASK = 0x0,
            #[doc = "No Endpoint Disabled Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskEpdisbldmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskEpdisbldmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskEpdisbldmsk {
            #[inline(always)]
            fn from(val: u8) -> DoepmskEpdisbldmsk {
                DoepmskEpdisbldmsk::from_bits(val)
            }
        }
        impl From<DoepmskEpdisbldmsk> for u8 {
            #[inline(always)]
            fn from(val: DoepmskEpdisbldmsk) -> u8 {
                DoepmskEpdisbldmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskNakmsk {
            #[doc = "Mask NAK Interrupt"]
            MASK = 0x0,
            #[doc = "No NAK Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskNakmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskNakmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskNakmsk {
            #[inline(always)]
            fn from(val: u8) -> DoepmskNakmsk {
                DoepmskNakmsk::from_bits(val)
            }
        }
        impl From<DoepmskNakmsk> for u8 {
            #[inline(always)]
            fn from(val: DoepmskNakmsk) -> u8 {
                DoepmskNakmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskNyetmsk {
            #[doc = "Mask NYET Interrupt"]
            MASK = 0x0,
            #[doc = "No NYET Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskNyetmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskNyetmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskNyetmsk {
            #[inline(always)]
            fn from(val: u8) -> DoepmskNyetmsk {
                DoepmskNyetmsk::from_bits(val)
            }
        }
        impl From<DoepmskNyetmsk> for u8 {
            #[inline(always)]
            fn from(val: DoepmskNyetmsk) -> u8 {
                DoepmskNyetmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoepmskXfercomplmsk {
            #[doc = "Mask Transfer Completed Interrupt"]
            MASK = 0x0,
            #[doc = "No Transfer Completed Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl DoepmskXfercomplmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoepmskXfercomplmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoepmskXfercomplmsk {
            #[inline(always)]
            fn from(val: u8) -> DoepmskXfercomplmsk {
                DoepmskXfercomplmsk::from_bits(val)
            }
        }
        impl From<DoepmskXfercomplmsk> for u8 {
            #[inline(always)]
            fn from(val: DoepmskXfercomplmsk) -> u8 {
                DoepmskXfercomplmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz12Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz12Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz12Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz12Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz12Rxdpid {
                Doeptsiz12Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz12Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz12Rxdpid) -> u8 {
                Doeptsiz12Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz13Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz13Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz13Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz13Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz13Rxdpid {
                Doeptsiz13Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz13Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz13Rxdpid) -> u8 {
                Doeptsiz13Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz14Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz14Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz14Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz14Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz14Rxdpid {
                Doeptsiz14Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz14Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz14Rxdpid) -> u8 {
                Doeptsiz14Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz15Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz15Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz15Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz15Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz15Rxdpid {
                Doeptsiz15Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz15Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz15Rxdpid) -> u8 {
                Doeptsiz15Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz1Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz1Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz1Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz1Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz1Rxdpid {
                Doeptsiz1Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz1Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz1Rxdpid) -> u8 {
                Doeptsiz1Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz2Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz2Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz2Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz2Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz2Rxdpid {
                Doeptsiz2Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz2Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz2Rxdpid) -> u8 {
                Doeptsiz2Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz3Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz3Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz3Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz3Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz3Rxdpid {
                Doeptsiz3Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz3Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz3Rxdpid) -> u8 {
                Doeptsiz3Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz4Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz4Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz4Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz4Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz4Rxdpid {
                Doeptsiz4Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz4Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz4Rxdpid) -> u8 {
                Doeptsiz4Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Doeptsiz5Rxdpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2 or 1 packet"]
            DATA2PACKET1 = 0x01,
            #[doc = "DATA1 or 2 packets"]
            DATA1PACKET2 = 0x02,
            #[doc = "MDATA or 3 packets"]
            MDATAPACKET3 = 0x03,
        }
        impl Doeptsiz5Rxdpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Doeptsiz5Rxdpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Doeptsiz5Rxdpid {
            #[inline(always)]
            fn from(val: u8) -> Doeptsiz5Rxdpid {
                Doeptsiz5Rxdpid::from_bits(val)
            }
        }
        impl From<Doeptsiz5Rxdpid> for u8 {
            #[inline(always)]
            fn from(val: Doeptsiz5Rxdpid) -> u8 {
                Doeptsiz5Rxdpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ec {
            _RESERVED_0 = 0x0,
            #[doc = "1 transaction"]
            TRANSONE = 0x01,
            #[doc = "2 transactions to be issued for this endpoint per microframe"]
            TRANSTWO = 0x02,
            #[doc = "3 transactions to be issued for this endpoint per microframe"]
            TRANSTHREE = 0x03,
        }
        impl Ec {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ec {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ec {
            #[inline(always)]
            fn from(val: u8) -> Ec {
                Ec::from_bits(val)
            }
        }
        impl From<Ec> for u8 {
            #[inline(always)]
            fn from(val: Ec) -> u8 {
                Ec::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enumdonemsk {
            #[doc = "Enumeration Done Mask"]
            MASK = 0x0,
            #[doc = "No Enumeration Done Mask"]
            NOMASK = 0x01,
        }
        impl Enumdonemsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enumdonemsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enumdonemsk {
            #[inline(always)]
            fn from(val: u8) -> Enumdonemsk {
                Enumdonemsk::from_bits(val)
            }
        }
        impl From<Enumdonemsk> for u8 {
            #[inline(always)]
            fn from(val: Enumdonemsk) -> u8 {
                Enumdonemsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enumspd {
            #[doc = "High speed (PHY clock is running at 30 or 60 MHz)"]
            HS3060 = 0x0,
            #[doc = "Full speed (PHY clock is running at 30 or 60 MHz)"]
            FS3060 = 0x01,
            #[doc = "Low speed (PHY clock is running at 6 MHz)"]
            LS6 = 0x02,
            #[doc = "Full speed (PHY clock is running at 48 MHz)"]
            FS48 = 0x03,
        }
        impl Enumspd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enumspd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enumspd {
            #[inline(always)]
            fn from(val: u8) -> Enumspd {
                Enumspd::from_bits(val)
            }
        }
        impl From<Enumspd> for u8 {
            #[inline(always)]
            fn from(val: Enumspd) -> u8 {
                Enumspd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eopfmsk {
            #[doc = "End of Periodic Frame Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No End of Periodic Frame Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Eopfmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eopfmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eopfmsk {
            #[inline(always)]
            fn from(val: u8) -> Eopfmsk {
                Eopfmsk::from_bits(val)
            }
        }
        impl From<Eopfmsk> for u8 {
            #[inline(always)]
            fn from(val: Eopfmsk) -> u8 {
                Eopfmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epdir {
            #[doc = "OUT Direction"]
            OUT = 0x0,
            #[doc = "IN Direction"]
            IN = 0x01,
        }
        impl Epdir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epdir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epdir {
            #[inline(always)]
            fn from(val: u8) -> Epdir {
                Epdir::from_bits(val)
            }
        }
        impl From<Epdir> for u8 {
            #[inline(always)]
            fn from(val: Epdir) -> u8 {
                Epdir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epmismsk {
            #[doc = "Endpoint Mismatch Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Endpoint Mismatch Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Epmismsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epmismsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epmismsk {
            #[inline(always)]
            fn from(val: u8) -> Epmismsk {
                Epmismsk::from_bits(val)
            }
        }
        impl From<Epmismsk> for u8 {
            #[inline(always)]
            fn from(val: Epmismsk) -> u8 {
                Epmismsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Epnum {
            #[doc = "End point 0"]
            ENDPT0 = 0x0,
            #[doc = "End point 1"]
            ENDPT1 = 0x01,
            #[doc = "End point 2"]
            ENDPT2 = 0x02,
            #[doc = "End point 3"]
            ENDPT3 = 0x03,
            #[doc = "End point 4"]
            ENDPT4 = 0x04,
            #[doc = "End point 5"]
            ENDPT5 = 0x05,
            #[doc = "End point 6"]
            ENDPT6 = 0x06,
            #[doc = "End point 7"]
            ENDPT7 = 0x07,
            #[doc = "End point 8"]
            ENDPT8 = 0x08,
            #[doc = "End point 9"]
            ENDPT9 = 0x09,
            #[doc = "End point 10"]
            ENDPT10 = 0x0a,
            #[doc = "End point 11"]
            ENDPT11 = 0x0b,
            #[doc = "End point 12"]
            ENDPT12 = 0x0c,
            #[doc = "End point 13"]
            ENDPT13 = 0x0d,
            #[doc = "End point 14"]
            ENDPT14 = 0x0e,
            #[doc = "End point 15"]
            ENDPT15 = 0x0f,
        }
        impl Epnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Epnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Epnum {
            #[inline(always)]
            fn from(val: u8) -> Epnum {
                Epnum::from_bits(val)
            }
        }
        impl From<Epnum> for u8 {
            #[inline(always)]
            fn from(val: Epnum) -> u8 {
                Epnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Erlysuspmsk {
            #[doc = "Early Suspend Mask"]
            MASK = 0x0,
            #[doc = "No Early Suspend Mask"]
            NOMASK = 0x01,
        }
        impl Erlysuspmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Erlysuspmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Erlysuspmsk {
            #[inline(always)]
            fn from(val: u8) -> Erlysuspmsk {
                Erlysuspmsk::from_bits(val)
            }
        }
        impl From<Erlysuspmsk> for u8 {
            #[inline(always)]
            fn from(val: Erlysuspmsk) -> u8 {
                Erlysuspmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fetsuspmsk {
            #[doc = "Data Fetch Suspended Mask"]
            MASK = 0x0,
            #[doc = "No Data Fetch Suspended Mask"]
            NOMASK = 0x01,
        }
        impl Fetsuspmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fetsuspmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fetsuspmsk {
            #[inline(always)]
            fn from(val: u8) -> Fetsuspmsk {
                Fetsuspmsk::from_bits(val)
            }
        }
        impl From<Fetsuspmsk> for u8 {
            #[inline(always)]
            fn from(val: Fetsuspmsk) -> u8 {
                Fetsuspmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Frmovrunmsk {
            #[doc = "Mask Overrun Mask"]
            MASK = 0x0,
            #[doc = "No Frame Overrun Mask"]
            NOMASK = 0x01,
        }
        impl Frmovrunmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Frmovrunmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Frmovrunmsk {
            #[inline(always)]
            fn from(val: u8) -> Frmovrunmsk {
                Frmovrunmsk::from_bits(val)
            }
        }
        impl From<Frmovrunmsk> for u8 {
            #[inline(always)]
            fn from(val: Frmovrunmsk) -> u8 {
                Frmovrunmsk::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frnum(u16);
        impl Frnum {
            #[doc = "No SOF is transmitted"]
            pub const INACTIVE: Self = Self(0x0);
            #[doc = "SOF is transmitted"]
            pub const ACTIVE: Self = Self(0x01);
        }
        impl Frnum {
            pub const fn from_bits(val: u16) -> Frnum {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Frnum {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("INACTIVE"),
                    0x01 => f.write_str("ACTIVE"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frnum {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "INACTIVE"),
                    0x01 => defmt::write!(f, "ACTIVE"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Frnum {
            #[inline(always)]
            fn from(val: u16) -> Frnum {
                Frnum::from_bits(val)
            }
        }
        impl From<Frnum> for u16 {
            #[inline(always)]
            fn from(val: Frnum) -> u16 {
                Frnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fsdiscidledis {
            #[doc = "Device controller transitions to IDLE state during FS device disconnect"]
            ENABLE_FIX = 0x0,
            #[doc = "Device controller does not transition to IDLE state during FS device disconnect"]
            DISABLE_FIX = 0x01,
        }
        impl Fsdiscidledis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fsdiscidledis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fsdiscidledis {
            #[inline(always)]
            fn from(val: u8) -> Fsdiscidledis {
                Fsdiscidledis::from_bits(val)
            }
        }
        impl From<Fsdiscidledis> for u8 {
            #[inline(always)]
            fn from(val: Fsdiscidledis) -> u8 {
                Fsdiscidledis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fsintf {
            #[doc = "6-pin unidirectional full-speed serial interface"]
            FS6PIN = 0x0,
            #[doc = "3-pin bidirectional full-speed serial interface"]
            FS3PIN = 0x01,
        }
        impl Fsintf {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fsintf {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fsintf {
            #[inline(always)]
            fn from(val: u8) -> Fsintf {
                Fsintf::from_bits(val)
            }
        }
        impl From<Fsintf> for u8 {
            #[inline(always)]
            fn from(val: Fsintf) -> u8 {
                Fsintf::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fslspclksel {
            #[doc = "PHY clock is running at 30/60 MHz"]
            CLK3060 = 0x0,
            #[doc = "PHY clock is running at 48 MHz"]
            CLK48 = 0x01,
            #[doc = "PHY clock is running at 6 MHz"]
            CLK6 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Fslspclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fslspclksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fslspclksel {
            #[inline(always)]
            fn from(val: u8) -> Fslspclksel {
                Fslspclksel::from_bits(val)
            }
        }
        impl From<Fslspclksel> for u8 {
            #[inline(always)]
            fn from(val: Fslspclksel) -> u8 {
                Fslspclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fslssupp {
            #[doc = "HS/FS/LS, based on the maximum speed supported by the connected device"]
            HSFSLS = 0x0,
            #[doc = "FS/LS-only, even if the connected device can support HS"]
            FSLS = 0x01,
        }
        impl Fslssupp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fslssupp {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fslssupp {
            #[inline(always)]
            fn from(val: u8) -> Fslssupp {
                Fslssupp::from_bits(val)
            }
        }
        impl From<Fslssupp> for u8 {
            #[inline(always)]
            fn from(val: Fslssupp) -> u8 {
                Fslssupp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fsphytype {
            #[doc = "Full-speed interface not supported"]
            NO_FS = 0x0,
            #[doc = "Dedicated full-speed interface is supported"]
            FS = 0x01,
            #[doc = "FS pins shared with UTMI+ pins is supported"]
            FSPLUSUTMI = 0x02,
            #[doc = "FS pins shared with ULPI pins is supported"]
            FSPLUSULPI = 0x03,
        }
        impl Fsphytype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fsphytype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fsphytype {
            #[inline(always)]
            fn from(val: u8) -> Fsphytype {
                Fsphytype::from_bits(val)
            }
        }
        impl From<Fsphytype> for u8 {
            #[inline(always)]
            fn from(val: Fsphytype) -> u8 {
                Fsphytype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ginnakeffmsk {
            #[doc = "Global Non-periodic IN NAK Effective Mask"]
            MASK = 0x0,
            #[doc = "No Global Non-periodic IN NAK Effective Mask"]
            NOMASK = 0x01,
        }
        impl Ginnakeffmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ginnakeffmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ginnakeffmsk {
            #[inline(always)]
            fn from(val: u8) -> Ginnakeffmsk {
                Ginnakeffmsk::from_bits(val)
            }
        }
        impl From<Ginnakeffmsk> for u8 {
            #[inline(always)]
            fn from(val: Ginnakeffmsk) -> u8 {
                Ginnakeffmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GintmskResetdetmsk {
            #[doc = "Reset detected Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Reset detected Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl GintmskResetdetmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GintmskResetdetmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GintmskResetdetmsk {
            #[inline(always)]
            fn from(val: u8) -> GintmskResetdetmsk {
                GintmskResetdetmsk::from_bits(val)
            }
        }
        impl From<GintmskResetdetmsk> for u8 {
            #[inline(always)]
            fn from(val: GintmskResetdetmsk) -> u8 {
                GintmskResetdetmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GintstsCurmod {
            #[doc = "Device mode"]
            DEVICE = 0x0,
            #[doc = "Host mode"]
            HOST = 0x01,
        }
        impl GintstsCurmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GintstsCurmod {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GintstsCurmod {
            #[inline(always)]
            fn from(val: u8) -> GintstsCurmod {
                GintstsCurmod::from_bits(val)
            }
        }
        impl From<GintstsCurmod> for u8 {
            #[inline(always)]
            fn from(val: GintstsCurmod) -> u8 {
                GintstsCurmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Glblintrmsk {
            #[doc = "Mask the interrupt assertion to the application"]
            MASK = 0x0,
            #[doc = "Unmask the interrupt assertion to the application."]
            NOMASK = 0x01,
        }
        impl Glblintrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Glblintrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Glblintrmsk {
            #[inline(always)]
            fn from(val: u8) -> Glblintrmsk {
                Glblintrmsk::from_bits(val)
            }
        }
        impl From<Glblintrmsk> for u8 {
            #[inline(always)]
            fn from(val: Glblintrmsk) -> u8 {
                Glblintrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GotgctlCurmod {
            #[doc = "Current mode is device mode."]
            DEVICEMODE = 0x0,
            #[doc = "Current mode is host mode."]
            HOSTMODE = 0x01,
        }
        impl GotgctlCurmod {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GotgctlCurmod {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GotgctlCurmod {
            #[inline(always)]
            fn from(val: u8) -> GotgctlCurmod {
                GotgctlCurmod::from_bits(val)
            }
        }
        impl From<GotgctlCurmod> for u8 {
            #[inline(always)]
            fn from(val: GotgctlCurmod) -> u8 {
                GotgctlCurmod::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GotgctlMultvalidbc {
            _RESERVED_0 = 0x0,
            #[doc = "B-Device connected to ACA. VBUS is on."]
            RID_C = 0x01,
            #[doc = "B-Device connected to ACA. VBUS is off."]
            RID_B = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "A-Device connected to ACA"]
            RID_A = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "A-Device not connected to ACA"]
            RID_GND = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "B-Device not connected to ACA"]
            RID_FLOAT = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl GotgctlMultvalidbc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GotgctlMultvalidbc {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GotgctlMultvalidbc {
            #[inline(always)]
            fn from(val: u8) -> GotgctlMultvalidbc {
                GotgctlMultvalidbc::from_bits(val)
            }
        }
        impl From<GotgctlMultvalidbc> for u8 {
            #[inline(always)]
            fn from(val: GotgctlMultvalidbc) -> u8 {
                GotgctlMultvalidbc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Goutnakeffmsk {
            #[doc = "Global OUT NAK Effective Mask"]
            MASK = 0x0,
            #[doc = "No Global OUT NAK Effective Mask"]
            NOMASK = 0x01,
        }
        impl Goutnakeffmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Goutnakeffmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Goutnakeffmsk {
            #[inline(always)]
            fn from(val: u8) -> Goutnakeffmsk {
                Goutnakeffmsk::from_bits(val)
            }
        }
        impl From<Goutnakeffmsk> for u8 {
            #[inline(always)]
            fn from(val: Goutnakeffmsk) -> u8 {
                Goutnakeffmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GpwrdnMultvalidbc {
            #[doc = "OTG device as B-device"]
            RID_0 = 0x0,
            #[doc = "OTG device as B-device, can connect"]
            RID_C = 0x01,
            #[doc = "OTG device as B-device, cannot connect"]
            RID_B = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "OTG device as A-device"]
            RID_A = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "ID_OTG pin is grounded"]
            RID_GND = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            #[doc = "OTG device as A-device, RID_A=1 and RID_GND=1"]
            RID_A_RID_GND = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "ID pull down when ID_OTG is floating"]
            RID_FLOAT = 0x10,
            #[doc = "OTG device as B-device, can connect, RID_C=1 and RID_FLOAT=1"]
            RID_C_RID_FLOAT = 0x11,
            #[doc = "OTG device as B-device, cannot connect, RID_B=1 and RID_FLOAT=1"]
            RID_B_RID_FLOAT = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            #[doc = "OTG device as A-device"]
            RID_1 = 0x1f,
        }
        impl GpwrdnMultvalidbc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GpwrdnMultvalidbc {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GpwrdnMultvalidbc {
            #[inline(always)]
            fn from(val: u8) -> GpwrdnMultvalidbc {
                GpwrdnMultvalidbc::from_bits(val)
            }
        }
        impl From<GpwrdnMultvalidbc> for u8 {
            #[inline(always)]
            fn from(val: GpwrdnMultvalidbc) -> u8 {
                GpwrdnMultvalidbc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrstctlTxfnum {
            #[doc = "-Periodic TxFIFO flush in host mode -Periodic TxFIFO 0 flush in device mode when in shared FIFO operation -TXFIFO 0 flush in device mode when in dedicated FIFO mode"]
            TXF0 = 0x0,
            #[doc = "-Periodic TxFIFO flush in host mode -Periodic TxFIFO 1 flush in device mode when in shared FIFO operation -TXFIFO 1 flush in device mode when in dedicated FIFO mode"]
            TXF1 = 0x01,
            #[doc = "-Periodic TxFIFO 2 flush in device mode when in shared FIFO operation -TXFIFO 2 flush in device mode when in dedicated FIFO mode"]
            TXF2 = 0x02,
            #[doc = "-Periodic TxFIFO 3 flush in device mode when in shared FIFO operation -TXFIFO 3 flush in device mode when in dedicated FIFO mode"]
            TXF3 = 0x03,
            #[doc = "-Periodic TxFIFO 4 flush in device mode when in shared FIFO operation -TXFIFO 4 flush in device mode when in dedicated FIFO mode"]
            TXF4 = 0x04,
            #[doc = "-Periodic TxFIFO 5 flush in device mode when in shared FIFO operation -TXFIFO 5 flush in device mode when in dedicated FIFO mode"]
            TXF5 = 0x05,
            #[doc = "-Periodic TxFIFO 6 flush in device mode when in shared FIFO operation -TXFIFO 6 flush in device mode when in dedicated FIFO mode"]
            TXF6 = 0x06,
            #[doc = "-Periodic TxFIFO 7 flush in device mode when in shared FIFO operation -TXFIFO 7 flush in device mode when in dedicated FIFO mode"]
            TXF7 = 0x07,
            #[doc = "-Periodic TxFIFO 8 flush in device mode when in shared FIFO operation -TXFIFO 8 flush in device mode when in dedicated FIFO mode"]
            TXF8 = 0x08,
            #[doc = "-Periodic TxFIFO 9 flush in device mode when in shared FIFO operation -TXFIFO 9 flush in device mode when in dedicated FIFO mode"]
            TXF9 = 0x09,
            #[doc = "-Periodic TxFIFO 10 flush in device mode when in shared FIFO operation -TXFIFO 10 flush in device mode when in dedicated FIFO mode"]
            TXF10 = 0x0a,
            #[doc = "-Periodic TxFIFO 11 flush in device mode when in shared FIFO operation -TXFIFO 11 flush in device mode when in dedicated FIFO mode"]
            TXF11 = 0x0b,
            #[doc = "-Periodic TxFIFO 12 flush in device mode when in shared FIFO operation -TXFIFO 12 flush in device mode when in dedicated FIFO mode"]
            TXF12 = 0x0c,
            #[doc = "-Periodic TxFIFO 13 flush in Device mode when in shared FIFO operation -TXFIFO 13 flush in device mode when in dedicated FIFO mode"]
            TXF13 = 0x0d,
            #[doc = "-Periodic TxFIFO 14 flush in Device mode when in shared FIFO operation -TXFIFO 14 flush in device mode when in dedicated FIFO mode"]
            TXF14 = 0x0e,
            #[doc = "-Periodic TxFIFO 15 flush in Device mode when in shared FIFO operation - TXFIFO 15 flush in device mode when in dedicated FIFO mode"]
            TXF15 = 0x0f,
            #[doc = "Flush all the transmit FIFOs in device or host mode"]
            TXF16 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl GrstctlTxfnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrstctlTxfnum {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrstctlTxfnum {
            #[inline(always)]
            fn from(val: u8) -> GrstctlTxfnum {
                GrstctlTxfnum::from_bits(val)
            }
        }
        impl From<GrstctlTxfnum> for u8 {
            #[inline(always)]
            fn from(val: GrstctlTxfnum) -> u8 {
                GrstctlTxfnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstspChnum {
            #[doc = "Channel or EndPoint 0"]
            CHEP0 = 0x0,
            #[doc = "Channel or EndPoint 1"]
            CHEP1 = 0x01,
            #[doc = "Channel or EndPoint 2"]
            CHEP2 = 0x02,
            #[doc = "Channel or EndPoint 3"]
            CHEP3 = 0x03,
            #[doc = "Channel or EndPoint 4"]
            CHEP4 = 0x04,
            #[doc = "Channel or EndPoint 5"]
            CHEP5 = 0x05,
            #[doc = "Channel or EndPoint 6"]
            CHEP6 = 0x06,
            #[doc = "Channel or EndPoint 7"]
            CHEP7 = 0x07,
            #[doc = "Channel or EndPoint 8"]
            CHEP8 = 0x08,
            #[doc = "Channel or EndPoint 9"]
            CHEP9 = 0x09,
            #[doc = "Channel or EndPoint 10"]
            CHEP10 = 0x0a,
            #[doc = "Channel or EndPoint 11"]
            CHEP11 = 0x0b,
            #[doc = "Channel or EndPoint 12"]
            CHEP12 = 0x0c,
            #[doc = "Channel or EndPoint 13"]
            CHEP13 = 0x0d,
            #[doc = "Channel or EndPoint 14"]
            CHEP14 = 0x0e,
            #[doc = "Channel or EndPoint 15"]
            CHEP15 = 0x0f,
        }
        impl GrxstspChnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstspChnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstspChnum {
            #[inline(always)]
            fn from(val: u8) -> GrxstspChnum {
                GrxstspChnum::from_bits(val)
            }
        }
        impl From<GrxstspChnum> for u8 {
            #[inline(always)]
            fn from(val: GrxstspChnum) -> u8 {
                GrxstspChnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstspDpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2"]
            DATA2 = 0x01,
            #[doc = "DATA1"]
            DATA1 = 0x02,
            #[doc = "MDATA"]
            MDATA = 0x03,
        }
        impl GrxstspDpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstspDpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstspDpid {
            #[inline(always)]
            fn from(val: u8) -> GrxstspDpid {
                GrxstspDpid::from_bits(val)
            }
        }
        impl From<GrxstspDpid> for u8 {
            #[inline(always)]
            fn from(val: GrxstspDpid) -> u8 {
                GrxstspDpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstspPktsts {
            _RESERVED_0 = 0x0,
            #[doc = "Global OUT NAK in device mode (triggers an interrupt)"]
            OUTNAK = 0x01,
            #[doc = "IN data packet received in host mode and OUT data packet received in device mode"]
            INOUTDPRX = 0x02,
            #[doc = "IN or OUT transfer completed in both host and device mode (triggers an interrupt)"]
            INOUTTRCOM = 0x03,
            #[doc = "SETUP transaction completed in device mode (triggers an interrupt)"]
            DSETUPCOM = 0x04,
            #[doc = "Data toggle error (triggers an interrupt) in host mode"]
            DTTOG = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl GrxstspPktsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstspPktsts {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstspPktsts {
            #[inline(always)]
            fn from(val: u8) -> GrxstspPktsts {
                GrxstspPktsts::from_bits(val)
            }
        }
        impl From<GrxstspPktsts> for u8 {
            #[inline(always)]
            fn from(val: GrxstspPktsts) -> u8 {
                GrxstspPktsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstsrChnum {
            #[doc = "Channel or EndPoint 0"]
            CHEP0 = 0x0,
            #[doc = "Channel or EndPoint 1"]
            CHEP1 = 0x01,
            #[doc = "Channel or EndPoint 2"]
            CHEP2 = 0x02,
            #[doc = "Channel or EndPoint 3"]
            CHEP3 = 0x03,
            #[doc = "Channel or EndPoint 4"]
            CHEP4 = 0x04,
            #[doc = "Channel or EndPoint 5"]
            CHEP5 = 0x05,
            #[doc = "Channel or EndPoint 6"]
            CHEP6 = 0x06,
            #[doc = "Channel or EndPoint 7"]
            CHEP7 = 0x07,
            #[doc = "Channel or EndPoint 8"]
            CHEP8 = 0x08,
            #[doc = "Channel or EndPoint 9"]
            CHEP9 = 0x09,
            #[doc = "Channel or EndPoint 10"]
            CHEP10 = 0x0a,
            #[doc = "Channel or EndPoint 11"]
            CHEP11 = 0x0b,
            #[doc = "Channel or EndPoint 12"]
            CHEP12 = 0x0c,
            #[doc = "Channel or EndPoint 13"]
            CHEP13 = 0x0d,
            #[doc = "Channel or EndPoint 14"]
            CHEP14 = 0x0e,
            #[doc = "Channel or EndPoint 15"]
            CHEP15 = 0x0f,
        }
        impl GrxstsrChnum {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstsrChnum {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstsrChnum {
            #[inline(always)]
            fn from(val: u8) -> GrxstsrChnum {
                GrxstsrChnum::from_bits(val)
            }
        }
        impl From<GrxstsrChnum> for u8 {
            #[inline(always)]
            fn from(val: GrxstsrChnum) -> u8 {
                GrxstsrChnum::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstsrDpid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2"]
            DATA2 = 0x01,
            #[doc = "DATA1"]
            DATA1 = 0x02,
            #[doc = "MDATA"]
            MDATA = 0x03,
        }
        impl GrxstsrDpid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstsrDpid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstsrDpid {
            #[inline(always)]
            fn from(val: u8) -> GrxstsrDpid {
                GrxstsrDpid::from_bits(val)
            }
        }
        impl From<GrxstsrDpid> for u8 {
            #[inline(always)]
            fn from(val: GrxstsrDpid) -> u8 {
                GrxstsrDpid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GrxstsrPktsts {
            _RESERVED_0 = 0x0,
            #[doc = "Global OUT NAK in device mode (triggers an interrupt)"]
            OUTNAK = 0x01,
            #[doc = "IN data packet received in host mode and OUT data packet received in device mode"]
            INOUTDPRX = 0x02,
            #[doc = "IN or OUT transfer completed in both host and device mode (triggers an interrupt)"]
            INOUTTRCOM = 0x03,
            #[doc = "SETUP transaction completed in device mode (triggers an interrupt)"]
            DSETUPCOM = 0x04,
            #[doc = "Data toggle error (triggers an interrupt) in host mode"]
            DTTOG = 0x05,
            #[doc = "SETUP data packet received in device mode"]
            DSETUPRX = 0x06,
            #[doc = "Channel halted in host mode (triggers an interrupt)"]
            CHHALT = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl GrxstsrPktsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GrxstsrPktsts {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GrxstsrPktsts {
            #[inline(always)]
            fn from(val: u8) -> GrxstsrPktsts {
                GrxstsrPktsts::from_bits(val)
            }
        }
        impl From<GrxstsrPktsts> for u8 {
            #[inline(always)]
            fn from(val: GrxstsrPktsts) -> u8 {
                GrxstsrPktsts::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Haint(u16);
        impl Haint {
            #[doc = "Not active"]
            pub const INACTIVE: Self = Self(0x0);
            #[doc = "Host Channel Interrupt"]
            pub const ACTIVE: Self = Self(0x01);
        }
        impl Haint {
            pub const fn from_bits(val: u16) -> Haint {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Haint {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("INACTIVE"),
                    0x01 => f.write_str("ACTIVE"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Haint {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "INACTIVE"),
                    0x01 => defmt::write!(f, "ACTIVE"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Haint {
            #[inline(always)]
            fn from(val: u16) -> Haint {
                Haint::from_bits(val)
            }
        }
        impl From<Haint> for u16 {
            #[inline(always)]
            fn from(val: Haint) -> u16 {
                Haint::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Haintmsk(u16);
        impl Haintmsk {
            #[doc = "Unmask Channel interrupt"]
            pub const UNMASK: Self = Self(0x0);
            #[doc = "Mask Channel interrupt"]
            pub const MASK: Self = Self(0x01);
        }
        impl Haintmsk {
            pub const fn from_bits(val: u16) -> Haintmsk {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Haintmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("UNMASK"),
                    0x01 => f.write_str("MASK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Haintmsk {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "UNMASK"),
                    0x01 => defmt::write!(f, "MASK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Haintmsk {
            #[inline(always)]
            fn from(val: u16) -> Haintmsk {
                Haintmsk::from_bits(val)
            }
        }
        impl From<Haintmsk> for u16 {
            #[inline(always)]
            fn from(val: Haintmsk) -> u16 {
                Haintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Handlefaultycabledis {
            #[doc = "Fix for handling faulty cable enabled"]
            ENABLE_FIX = 0x0,
            #[doc = "Fix for handling faulty cable disabled"]
            DISABLE_FIX = 0x01,
        }
        impl Handlefaultycabledis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Handlefaultycabledis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Handlefaultycabledis {
            #[inline(always)]
            fn from(val: u8) -> Handlefaultycabledis {
                Handlefaultycabledis::from_bits(val)
            }
        }
        impl From<Handlefaultycabledis> for u8 {
            #[inline(always)]
            fn from(val: Handlefaultycabledis) -> u8 {
                Handlefaultycabledis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hbstlen {
            #[doc = "1 word or single"]
            WORD1ORSINGLE = 0x0,
            #[doc = "4 words or INCR"]
            WORD4ORINCR = 0x01,
            #[doc = "8 words"]
            WORD8 = 0x02,
            #[doc = "16 words or INCR4"]
            WORD16ORINCR4 = 0x03,
            #[doc = "32 words"]
            WORD32 = 0x04,
            #[doc = "64 words or INCR8"]
            WORD64ORINCR8 = 0x05,
            #[doc = "128 words"]
            WORD128 = 0x06,
            #[doc = "256 words or INCR16"]
            WORD256ORINCR16 = 0x07,
            #[doc = "Others reserved"]
            WORDX = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Hbstlen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hbstlen {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hbstlen {
            #[inline(always)]
            fn from(val: u8) -> Hbstlen {
                Hbstlen::from_bits(val)
            }
        }
        impl From<Hbstlen> for u8 {
            #[inline(always)]
            fn from(val: Hbstlen) -> u8 {
                Hbstlen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hchintmsk {
            #[doc = "Host Channels Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Host Channels Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Hchintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hchintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hchintmsk {
            #[inline(always)]
            fn from(val: u8) -> Hchintmsk {
                Hchintmsk::from_bits(val)
            }
        }
        impl From<Hchintmsk> for u8 {
            #[inline(always)]
            fn from(val: Hchintmsk) -> u8 {
                Hchintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hostignoresrmtwkupdis {
            #[doc = "Device controller goes back into SUSPENDED state when host ignores Remote Wakeup"]
            ENABLE_FIX = 0x0,
            #[doc = "Device controller waits indefinitely without entering SUSPENDED state when host ignores the Remote Wakeup"]
            DISABLE_FIX = 0x01,
        }
        impl Hostignoresrmtwkupdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hostignoresrmtwkupdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hostignoresrmtwkupdis {
            #[inline(always)]
            fn from(val: u8) -> Hostignoresrmtwkupdis {
                Hostignoresrmtwkupdis::from_bits(val)
            }
        }
        impl From<Hostignoresrmtwkupdis> for u8 {
            #[inline(always)]
            fn from(val: Hostignoresrmtwkupdis) -> u8 {
                Hostignoresrmtwkupdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hostnoxferafterprtdisfixdis {
            #[doc = "Txvalid is not asserted when port is disabled"]
            ENABLE_FIX = 0x0,
            #[doc = "Txvalid can be asserted when port is disabled"]
            DISABLE_FIX = 0x01,
        }
        impl Hostnoxferafterprtdisfixdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hostnoxferafterprtdisfixdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hostnoxferafterprtdisfixdis {
            #[inline(always)]
            fn from(val: u8) -> Hostnoxferafterprtdisfixdis {
                Hostnoxferafterprtdisfixdis::from_bits(val)
            }
        }
        impl From<Hostnoxferafterprtdisfixdis> for u8 {
            #[inline(always)]
            fn from(val: Hostnoxferafterprtdisfixdis) -> u8 {
                Hostnoxferafterprtdisfixdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hostutmitxvldcorrdis {
            #[doc = "Opmode, XcvrSel, TermSel are changed by the Host Controller after TxValid goes LOW (1'b0)"]
            ENABLE_FIX = 0x0,
            #[doc = "Opmode, XcvrSel, TermSel are changed by the Host Controller without waiting for TxValid to go LOW (1'b0) during SOF transmission"]
            DISABLE_FIX = 0x01,
        }
        impl Hostutmitxvldcorrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hostutmitxvldcorrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hostutmitxvldcorrdis {
            #[inline(always)]
            fn from(val: u8) -> Hostutmitxvldcorrdis {
                Hostutmitxvldcorrdis::from_bits(val)
            }
        }
        impl From<Hostutmitxvldcorrdis> for u8 {
            #[inline(always)]
            fn from(val: Hostutmitxvldcorrdis) -> u8 {
                Hostutmitxvldcorrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hsphytype {
            #[doc = "High-Speed interface not supported"]
            NOHS = 0x0,
            #[doc = "High Speed Interface UTMI+ is supported"]
            UTMIPLUS = 0x01,
            #[doc = "High Speed Interface ULPI is supported"]
            ULPI = 0x02,
            #[doc = "High Speed Interfaces UTMI+ and ULPI is supported"]
            UTMIPUSULPI = 0x03,
        }
        impl Hsphytype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hsphytype {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hsphytype {
            #[inline(always)]
            fn from(val: u8) -> Hsphytype {
                Hsphytype::from_bits(val)
            }
        }
        impl From<Hsphytype> for u8 {
            #[inline(always)]
            fn from(val: Hsphytype) -> u8 {
                Hsphytype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Iepintmsk {
            #[doc = "IN Endpoints Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No IN Endpoints Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Iepintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Iepintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Iepintmsk {
            #[inline(always)]
            fn from(val: u8) -> Iepintmsk {
                Iepintmsk::from_bits(val)
            }
        }
        impl From<Iepintmsk> for u8 {
            #[inline(always)]
            fn from(val: Iepintmsk) -> u8 {
                Iepintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ignorectloutdata0dis {
            #[doc = "Transaction Error reported when host sends DATA0 PID"]
            ENABLE_FIX = 0x0,
            #[doc = "Transaction Error not reported when host sends DATA0 PID"]
            DISABLE_FIX = 0x01,
        }
        impl Ignorectloutdata0dis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ignorectloutdata0dis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ignorectloutdata0dis {
            #[inline(always)]
            fn from(val: u8) -> Ignorectloutdata0dis {
                Ignorectloutdata0dis::from_bits(val)
            }
        }
        impl From<Ignorectloutdata0dis> for u8 {
            #[inline(always)]
            fn from(val: Ignorectloutdata0dis) -> u8 {
                Ignorectloutdata0dis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Incomplpmsk {
            #[doc = "Host mode: Incomplete Periodic Transfer MaskDevice mode: Incomplete Isochronous OUT Transfer Mask"]
            MASK = 0x0,
            #[doc = "Host mode: No Incomplete Periodic Transfer MaskDevice mode: No Incomplete Isochronous OUT Transfer Mask"]
            NOMASK = 0x01,
        }
        impl Incomplpmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Incomplpmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Incomplpmsk {
            #[inline(always)]
            fn from(val: u8) -> Incomplpmsk {
                Incomplpmsk::from_bits(val)
            }
        }
        impl From<Incomplpmsk> for u8 {
            #[inline(always)]
            fn from(val: Incomplpmsk) -> u8 {
                Incomplpmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk0 {
            #[doc = "Mask IN Endpoint 0 Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk0 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk0 {
                Inepmsk0::from_bits(val)
            }
        }
        impl From<Inepmsk0> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk0) -> u8 {
                Inepmsk0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk1 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk1 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk1 {
                Inepmsk1::from_bits(val)
            }
        }
        impl From<Inepmsk1> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk1) -> u8 {
                Inepmsk1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk10 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk10 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk10 {
                Inepmsk10::from_bits(val)
            }
        }
        impl From<Inepmsk10> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk10) -> u8 {
                Inepmsk10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk11 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk11 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk11 {
                Inepmsk11::from_bits(val)
            }
        }
        impl From<Inepmsk11> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk11) -> u8 {
                Inepmsk11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk2 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk2 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk2 {
                Inepmsk2::from_bits(val)
            }
        }
        impl From<Inepmsk2> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk2) -> u8 {
                Inepmsk2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk3 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk3 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk3 {
                Inepmsk3::from_bits(val)
            }
        }
        impl From<Inepmsk3> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk3) -> u8 {
                Inepmsk3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk4 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk4 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk4 {
                Inepmsk4::from_bits(val)
            }
        }
        impl From<Inepmsk4> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk4) -> u8 {
                Inepmsk4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk5 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk5 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk5 {
                Inepmsk5::from_bits(val)
            }
        }
        impl From<Inepmsk5> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk5) -> u8 {
                Inepmsk5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk6 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk6 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk6 {
                Inepmsk6::from_bits(val)
            }
        }
        impl From<Inepmsk6> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk6) -> u8 {
                Inepmsk6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk7 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk7 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk7 {
                Inepmsk7::from_bits(val)
            }
        }
        impl From<Inepmsk7> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk7) -> u8 {
                Inepmsk7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk8 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk8 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk8 {
                Inepmsk8::from_bits(val)
            }
        }
        impl From<Inepmsk8> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk8) -> u8 {
                Inepmsk8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepmsk9 {
            #[doc = "Mask IN Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Inepmsk9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepmsk9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepmsk9 {
            #[inline(always)]
            fn from(val: u8) -> Inepmsk9 {
                Inepmsk9::from_bits(val)
            }
        }
        impl From<Inepmsk9> for u8 {
            #[inline(always)]
            fn from(val: Inepmsk9) -> u8 {
                Inepmsk9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Inepnakeffmsk {
            #[doc = "Mask IN Endpoint NAK Effective Interrupt"]
            MASK = 0x0,
            #[doc = "No IN Endpoint NAK Effective Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Inepnakeffmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Inepnakeffmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Inepnakeffmsk {
            #[inline(always)]
            fn from(val: u8) -> Inepnakeffmsk {
                Inepnakeffmsk::from_bits(val)
            }
        }
        impl From<Inepnakeffmsk> for u8 {
            #[inline(always)]
            fn from(val: Inepnakeffmsk) -> u8 {
                Inepnakeffmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ineps {
            #[doc = "1 IN Endpoint"]
            ENDPT1 = 0x0,
            #[doc = "2 IN Endpoints"]
            ENDPT2 = 0x01,
            #[doc = "3 IN Endpoints"]
            ENDPT3 = 0x02,
            #[doc = "4 IN Endpoints"]
            ENDPT4 = 0x03,
            #[doc = "5 IN Endpoints"]
            ENDPT5 = 0x04,
            #[doc = "6 IN Endpoints"]
            ENDPT6 = 0x05,
            #[doc = "7 IN Endpoints"]
            ENDPT7 = 0x06,
            #[doc = "8 IN Endpoints"]
            ENDPT8 = 0x07,
            #[doc = "9 IN Endpoints"]
            ENDPT9 = 0x08,
            #[doc = "10 IN Endpoints"]
            ENDPT10 = 0x09,
            #[doc = "11 IN Endpoints"]
            ENDPT11 = 0x0a,
            #[doc = "12 IN Endpoints"]
            ENDPT12 = 0x0b,
            #[doc = "13 IN Endpoints"]
            ENDPT13 = 0x0c,
            #[doc = "14 IN Endpoints"]
            ENDPT14 = 0x0d,
            #[doc = "15 IN Endpoints"]
            ENDPT15 = 0x0e,
            #[doc = "16 IN Endpoints"]
            ENDPT16 = 0x0f,
        }
        impl Ineps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ineps {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ineps {
            #[inline(always)]
            fn from(val: u8) -> Ineps {
                Ineps::from_bits(val)
            }
        }
        impl From<Ineps> for u8 {
            #[inline(always)]
            fn from(val: Ineps) -> u8 {
                Ineps::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ineptxfempmsk(u16);
        impl Ineptxfempmsk {
            #[doc = "Mask IN EP0 Tx FIFO Empty Interrupt"]
            pub const EP0_MASK: Self = Self(0x01);
            #[doc = "Mask IN EP1 Tx FIFO Empty Interrupt"]
            pub const EP1_MASK: Self = Self(0x02);
            #[doc = "Mask IN EP2 Tx FIFO Empty Interrupt"]
            pub const EP2_MASK: Self = Self(0x04);
            #[doc = "Mask IN EP3 Tx FIFO Empty Interrupt"]
            pub const EP3_MASK: Self = Self(0x08);
            #[doc = "Mask IN EP4 Tx FIFO Empty Interrupt"]
            pub const EP4_MASK: Self = Self(0x10);
            #[doc = "Mask IN EP5 Tx FIFO Empty Interrupt"]
            pub const EP5_MASK: Self = Self(0x20);
            #[doc = "Mask IN EP6 Tx FIFO Empty Interrupt"]
            pub const EP6_MASK: Self = Self(0x40);
            #[doc = "Mask IN EP7 Tx FIFO Empty Interrupt"]
            pub const EP7_MASK: Self = Self(0x80);
            #[doc = "Mask IN EP8 Tx FIFO Empty Interrupt"]
            pub const EP8_MASK: Self = Self(0x0100);
            #[doc = "Mask IN EP9 Tx FIFO Empty Interrupt"]
            pub const EP9_MASK: Self = Self(0x0200);
            #[doc = "Mask IN EP10 Tx FIFO Empty Interrupt"]
            pub const EP10_MASK: Self = Self(0x0400);
            #[doc = "Mask IN EP11 Tx FIFO Empty Interrupt"]
            pub const EP11_MASK: Self = Self(0x0800);
            #[doc = "Mask IN EP12 Tx FIFO Empty Interrupt"]
            pub const EP12_MASK: Self = Self(0x1000);
            #[doc = "Mask IN EP13 Tx FIFO Empty Interrupt"]
            pub const EP13_MASK: Self = Self(0x2000);
            #[doc = "Mask IN EP14 Tx FIFO Empty Interrupt"]
            pub const EP14_MASK: Self = Self(0x4000);
            #[doc = "Mask IN EP15 Tx FIFO Empty Interrupt"]
            pub const EP15_MASK: Self = Self(0x8000);
        }
        impl Ineptxfempmsk {
            pub const fn from_bits(val: u16) -> Ineptxfempmsk {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Ineptxfempmsk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("EP0_MASK"),
                    0x02 => f.write_str("EP1_MASK"),
                    0x04 => f.write_str("EP2_MASK"),
                    0x08 => f.write_str("EP3_MASK"),
                    0x10 => f.write_str("EP4_MASK"),
                    0x20 => f.write_str("EP5_MASK"),
                    0x40 => f.write_str("EP6_MASK"),
                    0x80 => f.write_str("EP7_MASK"),
                    0x0100 => f.write_str("EP8_MASK"),
                    0x0200 => f.write_str("EP9_MASK"),
                    0x0400 => f.write_str("EP10_MASK"),
                    0x0800 => f.write_str("EP11_MASK"),
                    0x1000 => f.write_str("EP12_MASK"),
                    0x2000 => f.write_str("EP13_MASK"),
                    0x4000 => f.write_str("EP14_MASK"),
                    0x8000 => f.write_str("EP15_MASK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ineptxfempmsk {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "EP0_MASK"),
                    0x02 => defmt::write!(f, "EP1_MASK"),
                    0x04 => defmt::write!(f, "EP2_MASK"),
                    0x08 => defmt::write!(f, "EP3_MASK"),
                    0x10 => defmt::write!(f, "EP4_MASK"),
                    0x20 => defmt::write!(f, "EP5_MASK"),
                    0x40 => defmt::write!(f, "EP6_MASK"),
                    0x80 => defmt::write!(f, "EP7_MASK"),
                    0x0100 => defmt::write!(f, "EP8_MASK"),
                    0x0200 => defmt::write!(f, "EP9_MASK"),
                    0x0400 => defmt::write!(f, "EP10_MASK"),
                    0x0800 => defmt::write!(f, "EP11_MASK"),
                    0x1000 => defmt::write!(f, "EP12_MASK"),
                    0x2000 => defmt::write!(f, "EP13_MASK"),
                    0x4000 => defmt::write!(f, "EP14_MASK"),
                    0x8000 => defmt::write!(f, "EP15_MASK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Ineptxfempmsk {
            #[inline(always)]
            fn from(val: u16) -> Ineptxfempmsk {
                Ineptxfempmsk::from_bits(val)
            }
        }
        impl From<Ineptxfempmsk> for u16 {
            #[inline(always)]
            fn from(val: Ineptxfempmsk) -> u16 {
                Ineptxfempmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Intknepmismsk {
            #[doc = "Mask IN Token received with EP Mismatch Interrupt"]
            MASK = 0x0,
            #[doc = "No Mask IN Token received with EP Mismatch Interrupt"]
            NOMASK = 0x01,
        }
        impl Intknepmismsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Intknepmismsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Intknepmismsk {
            #[inline(always)]
            fn from(val: u8) -> Intknepmismsk {
                Intknepmismsk::from_bits(val)
            }
        }
        impl From<Intknepmismsk> for u8 {
            #[inline(always)]
            fn from(val: Intknepmismsk) -> u8 {
                Intknepmismsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Intkntxfempmsk {
            #[doc = "Mask IN Token Received When TxFIFO Empty Interrupt"]
            MASK = 0x0,
            #[doc = "No IN Token Received When TxFIFO Empty Interrupt"]
            NOMASK = 0x01,
        }
        impl Intkntxfempmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Intkntxfempmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Intkntxfempmsk {
            #[inline(always)]
            fn from(val: u8) -> Intkntxfempmsk {
                Intkntxfempmsk::from_bits(val)
            }
        }
        impl From<Intkntxfempmsk> for u8 {
            #[inline(always)]
            fn from(val: Intkntxfempmsk) -> u8 {
                Intkntxfempmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntmskAhberrmsk {
            #[doc = "AHB Error Mask"]
            MASK = 0x0,
            #[doc = "No AHB Error Mask"]
            NOMASK = 0x01,
        }
        impl IntmskAhberrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntmskAhberrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntmskAhberrmsk {
            #[inline(always)]
            fn from(val: u8) -> IntmskAhberrmsk {
                IntmskAhberrmsk::from_bits(val)
            }
        }
        impl From<IntmskAhberrmsk> for u8 {
            #[inline(always)]
            fn from(val: IntmskAhberrmsk) -> u8 {
                IntmskAhberrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntmskNakmsk {
            #[doc = "Mask NAK Response Received Interrupt"]
            MASK = 0x0,
            #[doc = "No NAK Response Received Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl IntmskNakmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntmskNakmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntmskNakmsk {
            #[inline(always)]
            fn from(val: u8) -> IntmskNakmsk {
                IntmskNakmsk::from_bits(val)
            }
        }
        impl From<IntmskNakmsk> for u8 {
            #[inline(always)]
            fn from(val: IntmskNakmsk) -> u8 {
                IntmskNakmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntmskNyetmsk {
            #[doc = "Mask NYET Response Received Interrupt"]
            MASK = 0x0,
            #[doc = "No NYET Response Received Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl IntmskNyetmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntmskNyetmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntmskNyetmsk {
            #[inline(always)]
            fn from(val: u8) -> IntmskNyetmsk {
                IntmskNyetmsk::from_bits(val)
            }
        }
        impl From<IntmskNyetmsk> for u8 {
            #[inline(always)]
            fn from(val: IntmskNyetmsk) -> u8 {
                IntmskNyetmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntmskXfercomplmsk {
            #[doc = "Transfer Completed Mask"]
            MASK = 0x0,
            #[doc = "No Transfer Completed Mask"]
            NOMASK = 0x01,
        }
        impl IntmskXfercomplmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntmskXfercomplmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntmskXfercomplmsk {
            #[inline(always)]
            fn from(val: u8) -> IntmskXfercomplmsk {
                IntmskXfercomplmsk::from_bits(val)
            }
        }
        impl From<IntmskXfercomplmsk> for u8 {
            #[inline(always)]
            fn from(val: IntmskXfercomplmsk) -> u8 {
                IntmskXfercomplmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isooutdropmsk {
            #[doc = "Isochronous OUT Packet Dropped Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Isochronous OUT Packet Dropped Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Isooutdropmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isooutdropmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isooutdropmsk {
            #[inline(always)]
            fn from(val: u8) -> Isooutdropmsk {
                Isooutdropmsk::from_bits(val)
            }
        }
        impl From<Isooutdropmsk> for u8 {
            #[inline(always)]
            fn from(val: Isooutdropmsk) -> u8 {
                Isooutdropmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Linestate {
            #[doc = "Linestate on USB: DM = 0, DP = 0"]
            LS1 = 0x0,
            #[doc = "Linestate on USB: DM = 0, DP = 1"]
            LS2 = 0x01,
            #[doc = "Linestate on USB: DM = 1, DP = 0"]
            LS3 = 0x02,
            #[doc = "Linestate on USB: Not-defined"]
            LS4 = 0x03,
        }
        impl Linestate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Linestate {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Linestate {
            #[inline(always)]
            fn from(val: u8) -> Linestate {
                Linestate::from_bits(val)
            }
        }
        impl From<Linestate> for u8 {
            #[inline(always)]
            fn from(val: Linestate) -> u8 {
                Linestate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpmchnlindx {
            #[doc = "Channel 0"]
            CH0 = 0x0,
            #[doc = "Channel 1"]
            CH1 = 0x01,
            #[doc = "Channel 2"]
            CH2 = 0x02,
            #[doc = "Channel 3"]
            CH3 = 0x03,
            #[doc = "Channel 4"]
            CH4 = 0x04,
            #[doc = "Channel 5"]
            CH5 = 0x05,
            #[doc = "Channel 6"]
            CH6 = 0x06,
            #[doc = "Channel 7"]
            CH7 = 0x07,
            #[doc = "Channel 8"]
            CH8 = 0x08,
            #[doc = "Channel 9"]
            CH9 = 0x09,
            #[doc = "Channel 10"]
            CH10 = 0x0a,
            #[doc = "Channel 11"]
            CH11 = 0x0b,
            #[doc = "Channel 12"]
            CH12 = 0x0c,
            #[doc = "Channel 13"]
            CH13 = 0x0d,
            #[doc = "Channel 14"]
            CH14 = 0x0e,
            #[doc = "Channel15"]
            CH15 = 0x0f,
        }
        impl Lpmchnlindx {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpmchnlindx {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpmchnlindx {
            #[inline(always)]
            fn from(val: u8) -> Lpmchnlindx {
                Lpmchnlindx::from_bits(val)
            }
        }
        impl From<Lpmchnlindx> for u8 {
            #[inline(always)]
            fn from(val: Lpmchnlindx) -> u8 {
                Lpmchnlindx::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpmintmsk {
            #[doc = "LPM Transaction received interrupt Mask"]
            MASK = 0x0,
            #[doc = "No LPM Transaction received interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Lpmintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpmintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpmintmsk {
            #[inline(always)]
            fn from(val: u8) -> Lpmintmsk {
                Lpmintmsk::from_bits(val)
            }
        }
        impl From<Lpmintmsk> for u8 {
            #[inline(always)]
            fn from(val: Lpmintmsk) -> u8 {
                Lpmintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpmretrycnt {
            #[doc = "Zero LPM retries"]
            RETRY0 = 0x0,
            #[doc = "One LPM retry"]
            RETRY1 = 0x01,
            #[doc = "Two LPM retries"]
            RETRY2 = 0x02,
            #[doc = "Three LPM retries"]
            RETRY3 = 0x03,
            #[doc = "Four LPM retries"]
            RETRY4 = 0x04,
            #[doc = "Five LPM retries"]
            RETRY5 = 0x05,
            #[doc = "Six LPM retries"]
            RETRY6 = 0x06,
            #[doc = "Seven LPM retries"]
            RETRY7 = 0x07,
        }
        impl Lpmretrycnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpmretrycnt {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpmretrycnt {
            #[inline(always)]
            fn from(val: u8) -> Lpmretrycnt {
                Lpmretrycnt::from_bits(val)
            }
        }
        impl From<Lpmretrycnt> for u8 {
            #[inline(always)]
            fn from(val: Lpmretrycnt) -> u8 {
                Lpmretrycnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpmretrycntsts {
            #[doc = "Zero LPM retries remaining"]
            RETRY_REM0 = 0x0,
            #[doc = "One LPM retry remaining"]
            RETRY_REM1 = 0x01,
            #[doc = "Two LPM retries remaining"]
            RETRY_REM2 = 0x02,
            #[doc = "Three LPM retries remaining"]
            RETRY_REM3 = 0x03,
            #[doc = "Four LPM retries remaining"]
            RETRY_REM4 = 0x04,
            #[doc = "Five LPM retries remaining"]
            RETRY_REM5 = 0x05,
            #[doc = "Six LPM retries remaining"]
            RETRY_REM6 = 0x06,
            #[doc = "Seven LPM retries remaining"]
            RETRY_REM7 = 0x07,
        }
        impl Lpmretrycntsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpmretrycntsts {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpmretrycntsts {
            #[inline(always)]
            fn from(val: u8) -> Lpmretrycntsts {
                Lpmretrycntsts::from_bits(val)
            }
        }
        impl From<Lpmretrycntsts> for u8 {
            #[inline(always)]
            fn from(val: Lpmretrycntsts) -> u8 {
                Lpmretrycntsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lsipgchkafternakstallforindis {
            #[doc = "Host controller checks IPG after NAK/STALL for IN token"]
            ENABLE_FIX = 0x0,
            #[doc = "Host controller does not check IPG after NAK/STALL for IN token"]
            DISABLE_FIX = 0x01,
        }
        impl Lsipgchkafternakstallforindis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lsipgchkafternakstallforindis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lsipgchkafternakstallforindis {
            #[inline(always)]
            fn from(val: u8) -> Lsipgchkafternakstallforindis {
                Lsipgchkafternakstallforindis::from_bits(val)
            }
        }
        impl From<Lsipgchkafternakstallforindis> for u8 {
            #[inline(always)]
            fn from(val: Lsipgchkafternakstallforindis) -> u8 {
                Lsipgchkafternakstallforindis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lsipgincrdis {
            #[doc = "Host LS mode IPG is 3 LS bit times"]
            ENABLE_FIX = 0x0,
            #[doc = "Host LS mode IPG is 2 LS bit times"]
            DISABLE_FIX = 0x01,
        }
        impl Lsipgincrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lsipgincrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lsipgincrdis {
            #[inline(always)]
            fn from(val: u8) -> Lsipgincrdis {
                Lsipgincrdis::from_bits(val)
            }
        }
        impl From<Lsipgincrdis> for u8 {
            #[inline(always)]
            fn from(val: Lsipgincrdis) -> u8 {
                Lsipgincrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modechtimen {
            #[doc = "The Host core waits for either 200 PHY clock cycles or a linestate of SE0 at the end of resume to change the opmode from 0x2 to 0x0"]
            ENABLED = 0x0,
            #[doc = "The Host core waits only for a linestate of SE0 at the end of resume to change the opmode from 0x2 to 0x0"]
            DISABLED = 0x01,
        }
        impl Modechtimen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modechtimen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modechtimen {
            #[inline(always)]
            fn from(val: u8) -> Modechtimen {
                Modechtimen::from_bits(val)
            }
        }
        impl From<Modechtimen> for u8 {
            #[inline(always)]
            fn from(val: Modechtimen) -> u8 {
                Modechtimen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modemismsk {
            #[doc = "Mode Mismatch Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Mode Mismatch Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Modemismsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modemismsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modemismsk {
            #[inline(always)]
            fn from(val: u8) -> Modemismsk {
                Modemismsk::from_bits(val)
            }
        }
        impl From<Modemismsk> for u8 {
            #[inline(always)]
            fn from(val: Modemismsk) -> u8 {
                Modemismsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Notialldmawrit {
            #[doc = "Unspecified"]
            LASTTRANS = 0x0,
            #[doc = "The core asserts int_dma_req for all the DMA write transactions on the AHB interface along with int_dma_done, chep_last_transact and chep_number signal informations. The core waits for sys_dma_done signal for all the DMA write transactions in order to complete the transfer of a particular Channel/Endpoint"]
            ALLTRANS = 0x01,
        }
        impl Notialldmawrit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Notialldmawrit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Notialldmawrit {
            #[inline(always)]
            fn from(val: u8) -> Notialldmawrit {
                Notialldmawrit::from_bits(val)
            }
        }
        impl From<Notialldmawrit> for u8 {
            #[inline(always)]
            fn from(val: Notialldmawrit) -> u8 {
                Notialldmawrit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nptxfemplvl {
            #[doc = "DIEPINTn.TxFEmp interrupt indicates that the Non-Periodic TxFIFO is half empty or that the IN Endpoint TxFIFO is half empty."]
            HALFEMPTY = 0x0,
            #[doc = "GINTSTS.NPTxFEmp interrupt indicates that the Non-Periodic TxFIFO is completely empty or that the IN Endpoint TxFIFO is completely empty."]
            EMPTY = 0x01,
        }
        impl Nptxfemplvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nptxfemplvl {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nptxfemplvl {
            #[inline(always)]
            fn from(val: u8) -> Nptxfemplvl {
                Nptxfemplvl::from_bits(val)
            }
        }
        impl From<Nptxfemplvl> for u8 {
            #[inline(always)]
            fn from(val: Nptxfemplvl) -> u8 {
                Nptxfemplvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nptxfempmsk {
            #[doc = "Non-periodic TxFIFO Empty Mask"]
            MASK = 0x0,
            #[doc = "No Non-periodic TxFIFO Empty Mask"]
            NOMASK = 0x01,
        }
        impl Nptxfempmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nptxfempmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nptxfempmsk {
            #[inline(always)]
            fn from(val: u8) -> Nptxfempmsk {
                Nptxfempmsk::from_bits(val)
            }
        }
        impl From<Nptxfempmsk> for u8 {
            #[inline(always)]
            fn from(val: Nptxfempmsk) -> u8 {
                Nptxfempmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nptxqdepth {
            #[doc = "Queue size 2"]
            TWO = 0x0,
            #[doc = "Queue size 4"]
            FOUR = 0x01,
            #[doc = "Queue size 8"]
            EIGHT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nptxqdepth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nptxqdepth {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nptxqdepth {
            #[inline(always)]
            fn from(val: u8) -> Nptxqdepth {
                Nptxqdepth::from_bits(val)
            }
        }
        impl From<Nptxqdepth> for u8 {
            #[inline(always)]
            fn from(val: Nptxqdepth) -> u8 {
                Nptxqdepth::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Nptxqspcavail(u8);
        impl Nptxqspcavail {
            #[doc = "Non-periodic Transmit Request Queue is full"]
            pub const FULL: Self = Self(0x0);
            #[doc = "1 location available"]
            pub const QUE1: Self = Self(0x01);
            #[doc = "2 locations available"]
            pub const QUE2: Self = Self(0x02);
            #[doc = "3 locations available"]
            pub const QUE3: Self = Self(0x03);
            #[doc = "4 locations available"]
            pub const QUE4: Self = Self(0x04);
            #[doc = "5 locations available"]
            pub const QUE5: Self = Self(0x05);
            #[doc = "6 locations available"]
            pub const QUE6: Self = Self(0x06);
            #[doc = "7 locations available"]
            pub const QUE7: Self = Self(0x07);
            #[doc = "8 locations available"]
            pub const QUE8: Self = Self(0x08);
        }
        impl Nptxqspcavail {
            pub const fn from_bits(val: u8) -> Nptxqspcavail {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Nptxqspcavail {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("FULL"),
                    0x01 => f.write_str("QUE1"),
                    0x02 => f.write_str("QUE2"),
                    0x03 => f.write_str("QUE3"),
                    0x04 => f.write_str("QUE4"),
                    0x05 => f.write_str("QUE5"),
                    0x06 => f.write_str("QUE6"),
                    0x07 => f.write_str("QUE7"),
                    0x08 => f.write_str("QUE8"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nptxqspcavail {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "FULL"),
                    0x01 => defmt::write!(f, "QUE1"),
                    0x02 => defmt::write!(f, "QUE2"),
                    0x03 => defmt::write!(f, "QUE3"),
                    0x04 => defmt::write!(f, "QUE4"),
                    0x05 => defmt::write!(f, "QUE5"),
                    0x06 => defmt::write!(f, "QUE6"),
                    0x07 => defmt::write!(f, "QUE7"),
                    0x08 => defmt::write!(f, "QUE8"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Nptxqspcavail {
            #[inline(always)]
            fn from(val: u8) -> Nptxqspcavail {
                Nptxqspcavail::from_bits(val)
            }
        }
        impl From<Nptxqspcavail> for u8 {
            #[inline(always)]
            fn from(val: Nptxqspcavail) -> u8 {
                Nptxqspcavail::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Nptxqtop(u8);
        impl Nptxqtop {
            #[doc = "IN/OUT token"]
            pub const INOUTTK: Self = Self(0x0);
            #[doc = "Zero-length transmit packet (device IN/host OUT)"]
            pub const ZEROTX: Self = Self(0x01);
            #[doc = "PING/CSPLIT token"]
            pub const PINGCSPLIT: Self = Self(0x02);
            #[doc = "Channel halt command"]
            pub const CHNHALT: Self = Self(0x03);
        }
        impl Nptxqtop {
            pub const fn from_bits(val: u8) -> Nptxqtop {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Nptxqtop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("INOUTTK"),
                    0x01 => f.write_str("ZEROTX"),
                    0x02 => f.write_str("PINGCSPLIT"),
                    0x03 => f.write_str("CHNHALT"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nptxqtop {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "INOUTTK"),
                    0x01 => defmt::write!(f, "ZEROTX"),
                    0x02 => defmt::write!(f, "PINGCSPLIT"),
                    0x03 => defmt::write!(f, "CHNHALT"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Nptxqtop {
            #[inline(always)]
            fn from(val: u8) -> Nptxqtop {
                Nptxqtop::from_bits(val)
            }
        }
        impl From<Nptxqtop> for u8 {
            #[inline(always)]
            fn from(val: Nptxqtop) -> u8 {
                Nptxqtop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Numctleps {
            #[doc = "End point 0"]
            ENDPT0 = 0x0,
            #[doc = "End point 1"]
            ENDPT1 = 0x01,
            #[doc = "End point 2"]
            ENDPT2 = 0x02,
            #[doc = "End point 3"]
            ENDPT3 = 0x03,
            #[doc = "End point 4"]
            ENDPT4 = 0x04,
            #[doc = "End point 5"]
            ENDPT5 = 0x05,
            #[doc = "End point 6"]
            ENDPT6 = 0x06,
            #[doc = "End point 7"]
            ENDPT7 = 0x07,
            #[doc = "End point 8"]
            ENDPT8 = 0x08,
            #[doc = "End point 9"]
            ENDPT9 = 0x09,
            #[doc = "End point 10"]
            ENDPT10 = 0x0a,
            #[doc = "End point 11"]
            ENDPT11 = 0x0b,
            #[doc = "End point 12"]
            ENDPT12 = 0x0c,
            #[doc = "End point 13"]
            ENDPT13 = 0x0d,
            #[doc = "End point 14"]
            ENDPT14 = 0x0e,
            #[doc = "End point 15"]
            ENDPT15 = 0x0f,
        }
        impl Numctleps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Numctleps {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Numctleps {
            #[inline(always)]
            fn from(val: u8) -> Numctleps {
                Numctleps::from_bits(val)
            }
        }
        impl From<Numctleps> for u8 {
            #[inline(always)]
            fn from(val: Numctleps) -> u8 {
                Numctleps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Numdeveps {
            #[doc = "End point 0"]
            ENDPT0 = 0x0,
            #[doc = "End point 1"]
            ENDPT1 = 0x01,
            #[doc = "End point 2"]
            ENDPT2 = 0x02,
            #[doc = "End point 3"]
            ENDPT3 = 0x03,
            #[doc = "End point 4"]
            ENDPT4 = 0x04,
            #[doc = "End point 5"]
            ENDPT5 = 0x05,
            #[doc = "End point 6"]
            ENDPT6 = 0x06,
            #[doc = "End point 7"]
            ENDPT7 = 0x07,
            #[doc = "End point 8"]
            ENDPT8 = 0x08,
            #[doc = "End point 9"]
            ENDPT9 = 0x09,
            #[doc = "End point 10"]
            ENDPT10 = 0x0a,
            #[doc = "End point 11"]
            ENDPT11 = 0x0b,
            #[doc = "End point 12"]
            ENDPT12 = 0x0c,
            #[doc = "End point 13"]
            ENDPT13 = 0x0d,
            #[doc = "End point 14"]
            ENDPT14 = 0x0e,
            #[doc = "End point 15"]
            ENDPT15 = 0x0f,
        }
        impl Numdeveps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Numdeveps {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Numdeveps {
            #[inline(always)]
            fn from(val: u8) -> Numdeveps {
                Numdeveps::from_bits(val)
            }
        }
        impl From<Numdeveps> for u8 {
            #[inline(always)]
            fn from(val: Numdeveps) -> u8 {
                Numdeveps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Numdevperioeps {
            #[doc = "Number of Periodic IN EPs is 0"]
            VALUE0 = 0x0,
            #[doc = "Number of Periodic IN EPs is 1"]
            VALUE1 = 0x01,
            #[doc = "Number of Periodic IN EPs is 2"]
            VALUE2 = 0x02,
            #[doc = "Number of Periodic IN EPs is 3"]
            VALUE3 = 0x03,
            #[doc = "Number of Periodic IN EPs is 4"]
            VALUE4 = 0x04,
            #[doc = "Number of Periodic IN EPs is 5"]
            VALUE5 = 0x05,
            #[doc = "Number of Periodic IN EPs is 6"]
            VALUE6 = 0x06,
            #[doc = "Number of Periodic IN EPs is 7"]
            VALUE7 = 0x07,
            #[doc = "Number of Periodic IN EPs is 8"]
            VALUE8 = 0x08,
            #[doc = "Number of Periodic IN EPs is 9"]
            VALUE9 = 0x09,
            #[doc = "Number of Periodic IN EPs is 10"]
            VALUE10 = 0x0a,
            #[doc = "Number of Periodic IN EPs is 11"]
            VALUE11 = 0x0b,
            #[doc = "Number of Periodic IN EPs is 12"]
            VALUE12 = 0x0c,
            #[doc = "Number of Periodic IN EPs is 13"]
            VALUE13 = 0x0d,
            #[doc = "Number of Periodic IN EPs is 14"]
            VALUE14 = 0x0e,
            #[doc = "Number of Periodic IN EPs is 15"]
            VALUE15 = 0x0f,
        }
        impl Numdevperioeps {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Numdevperioeps {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Numdevperioeps {
            #[inline(always)]
            fn from(val: u8) -> Numdevperioeps {
                Numdevperioeps::from_bits(val)
            }
        }
        impl From<Numdevperioeps> for u8 {
            #[inline(always)]
            fn from(val: Numdevperioeps) -> u8 {
                Numdevperioeps::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Numhstchnl {
            #[doc = "Host Channel 1"]
            HOSTCH0 = 0x0,
            #[doc = "Host Channel 2"]
            HOSTCH1 = 0x01,
            #[doc = "Host Channel 3"]
            HOSTCH2 = 0x02,
            #[doc = "Host Channel 4"]
            HOSTCH3 = 0x03,
            #[doc = "Host Channel 5"]
            HOSTCH4 = 0x04,
            #[doc = "Host Channel 6"]
            HOSTCH5 = 0x05,
            #[doc = "Host Channel 7"]
            HOSTCH6 = 0x06,
            #[doc = "Host Channel 8"]
            HOSTCH7 = 0x07,
            #[doc = "Host Channel 9"]
            HOSTCH8 = 0x08,
            #[doc = "Host Channel 10"]
            HOSTCH9 = 0x09,
            #[doc = "Host Channel 11"]
            HOSTCH10 = 0x0a,
            #[doc = "Host Channel 12"]
            HOSTCH11 = 0x0b,
            #[doc = "Host Channel 13"]
            HOSTCH12 = 0x0c,
            #[doc = "Host Channel 14"]
            HOSTCH13 = 0x0d,
            #[doc = "Host Channel 15"]
            HOSTCH14 = 0x0e,
            #[doc = "Host Channel 16"]
            HOSTCH15 = 0x0f,
        }
        impl Numhstchnl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Numhstchnl {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Numhstchnl {
            #[inline(always)]
            fn from(val: u8) -> Numhstchnl {
                Numhstchnl::from_bits(val)
            }
        }
        impl From<Numhstchnl> for u8 {
            #[inline(always)]
            fn from(val: Numhstchnl) -> u8 {
                Numhstchnl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nzstsouthshk {
            #[doc = "Send the received OUT packet to the application (zero-length or non-zero length) and send a handshake based on NAK and STALL bits for the endpoint in the Devce Endpoint Control Register"]
            SENDOUT = 0x0,
            #[doc = "Send a STALL handshake on a nonzero-length status OUT transaction and do not send the received OUT packet to the application"]
            SENDSTALL = 0x01,
        }
        impl Nzstsouthshk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nzstsouthshk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nzstsouthshk {
            #[inline(always)]
            fn from(val: u8) -> Nzstsouthshk {
                Nzstsouthshk::from_bits(val)
            }
        }
        impl From<Nzstsouthshk> for u8 {
            #[inline(always)]
            fn from(val: Nzstsouthshk) -> u8 {
                Nzstsouthshk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oddfrm {
            #[doc = "Even Frame Transfer"]
            EFRAME = 0x0,
            #[doc = "Odd Frame Transfer"]
            OFRAME = 0x01,
        }
        impl Oddfrm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oddfrm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oddfrm {
            #[inline(always)]
            fn from(val: u8) -> Oddfrm {
                Oddfrm::from_bits(val)
            }
        }
        impl From<Oddfrm> for u8 {
            #[inline(always)]
            fn from(val: Oddfrm) -> u8 {
                Oddfrm::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oepintmsk {
            #[doc = "OUT Endpoints Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No OUT Endpoints Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Oepintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oepintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oepintmsk {
            #[inline(always)]
            fn from(val: u8) -> Oepintmsk {
                Oepintmsk::from_bits(val)
            }
        }
        impl From<Oepintmsk> for u8 {
            #[inline(always)]
            fn from(val: Oepintmsk) -> u8 {
                Oepintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opmodexcvrselchirpencorrdis {
            #[doc = "Valid Combination of Opmode and XcvrSel is driven when reset is detected in suspend state"]
            ENABLE_FIX = 0x0,
            #[doc = "Invalid Combination of Opmode and XcvrSel is driven when reset is detected in suspend state"]
            DISABLE_FIX = 0x01,
        }
        impl Opmodexcvrselchirpencorrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opmodexcvrselchirpencorrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opmodexcvrselchirpencorrdis {
            #[inline(always)]
            fn from(val: u8) -> Opmodexcvrselchirpencorrdis {
                Opmodexcvrselchirpencorrdis::from_bits(val)
            }
        }
        impl From<Opmodexcvrselchirpencorrdis> for u8 {
            #[inline(always)]
            fn from(val: Opmodexcvrselchirpencorrdis) -> u8 {
                Opmodexcvrselchirpencorrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Otgarch {
            #[doc = "Slave Mode"]
            SLAVEMODE = 0x0,
            #[doc = "External DMA Mode"]
            EXTERNALDMA = 0x01,
            #[doc = "Internal DMA Mode"]
            INTERNALDMA = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Otgarch {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Otgarch {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Otgarch {
            #[inline(always)]
            fn from(val: u8) -> Otgarch {
                Otgarch::from_bits(val)
            }
        }
        impl From<Otgarch> for u8 {
            #[inline(always)]
            fn from(val: Otgarch) -> u8 {
                Otgarch::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Otgintmsk {
            #[doc = "OTG Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No OTG Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Otgintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Otgintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Otgintmsk {
            #[inline(always)]
            fn from(val: u8) -> Otgintmsk {
                Otgintmsk::from_bits(val)
            }
        }
        impl From<Otgintmsk> for u8 {
            #[inline(always)]
            fn from(val: Otgintmsk) -> u8 {
                Otgintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Otgmode {
            #[doc = "HNP- and SRP-Capable OTG (Host and Device)"]
            HNPSRP = 0x0,
            #[doc = "SRP-Capable OTG (Host and Device)"]
            SRPOTG = 0x01,
            #[doc = "Non-HNP and Non-SRP Capable OTG (Host and Device)"]
            NHNPNSRP = 0x02,
            #[doc = "SRP-Capable Device"]
            SRPCAPD = 0x03,
            #[doc = "Non-OTG Device"]
            NONOTGD = 0x04,
            #[doc = "SRP-Capable Host"]
            SRPCAPH = 0x05,
            #[doc = "Non-OTG Host"]
            NONOTGH = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Otgmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Otgmode {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Otgmode {
            #[inline(always)]
            fn from(val: u8) -> Otgmode {
                Otgmode::from_bits(val)
            }
        }
        impl From<Otgmode> for u8 {
            #[inline(always)]
            fn from(val: Otgmode) -> u8 {
                Otgmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Otgver {
            #[doc = "Supports OTG Version 1.3"]
            VER13 = 0x0,
            #[doc = "Supports OTG Version 2.0"]
            VER20 = 0x01,
        }
        impl Otgver {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Otgver {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Otgver {
            #[inline(always)]
            fn from(val: u8) -> Otgver {
                Otgver::from_bits(val)
            }
        }
        impl From<Otgver> for u8 {
            #[inline(always)]
            fn from(val: Otgver) -> u8 {
                Otgver::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk0 {
            #[doc = "Mask OUT Endpoint 0 Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk0 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk0 {
                Outepmsk0::from_bits(val)
            }
        }
        impl From<Outepmsk0> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk0) -> u8 {
                Outepmsk0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk1 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk1 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk1 {
                Outepmsk1::from_bits(val)
            }
        }
        impl From<Outepmsk1> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk1) -> u8 {
                Outepmsk1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk12 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk12 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk12 {
                Outepmsk12::from_bits(val)
            }
        }
        impl From<Outepmsk12> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk12) -> u8 {
                Outepmsk12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk13 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk13 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk13 {
                Outepmsk13::from_bits(val)
            }
        }
        impl From<Outepmsk13> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk13) -> u8 {
                Outepmsk13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk14 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk14 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk14 {
                Outepmsk14::from_bits(val)
            }
        }
        impl From<Outepmsk14> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk14) -> u8 {
                Outepmsk14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk15 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk15 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk15 {
                Outepmsk15::from_bits(val)
            }
        }
        impl From<Outepmsk15> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk15) -> u8 {
                Outepmsk15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk2 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk2 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk2 {
                Outepmsk2::from_bits(val)
            }
        }
        impl From<Outepmsk2> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk2) -> u8 {
                Outepmsk2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk3 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk3 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk3 {
                Outepmsk3::from_bits(val)
            }
        }
        impl From<Outepmsk3> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk3) -> u8 {
                Outepmsk3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk4 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk4 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk4 {
                Outepmsk4::from_bits(val)
            }
        }
        impl From<Outepmsk4> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk4) -> u8 {
                Outepmsk4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outepmsk5 {
            #[doc = "Mask OUT Endpoint Interrupt"]
            MASK = 0x0,
            #[doc = "No Interrupt mask"]
            NOMASK = 0x01,
        }
        impl Outepmsk5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outepmsk5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outepmsk5 {
            #[inline(always)]
            fn from(val: u8) -> Outepmsk5 {
                Outepmsk5::from_bits(val)
            }
        }
        impl From<Outepmsk5> for u8 {
            #[inline(always)]
            fn from(val: Outepmsk5) -> u8 {
                Outepmsk5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outpkterrmsk {
            #[doc = "Mask OUT Packet Error Interrupt"]
            MASK = 0x0,
            #[doc = "No OUT Packet Error Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Outpkterrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outpkterrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outpkterrmsk {
            #[inline(always)]
            fn from(val: u8) -> Outpkterrmsk {
                Outpkterrmsk::from_bits(val)
            }
        }
        impl From<Outpkterrmsk> for u8 {
            #[inline(always)]
            fn from(val: Outpkterrmsk) -> u8 {
                Outpkterrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outtknepdismsk {
            #[doc = "Mask OUT Token Received when Endpoint Disabled Interrupt"]
            MASK = 0x0,
            #[doc = "No OUT Token Received when Endpoint Disabled Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Outtknepdismsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outtknepdismsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outtknepdismsk {
            #[inline(always)]
            fn from(val: u8) -> Outtknepdismsk {
                Outtknepdismsk::from_bits(val)
            }
        }
        impl From<Outtknepdismsk> for u8 {
            #[inline(always)]
            fn from(val: Outtknepdismsk) -> u8 {
                Outtknepdismsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perfrint {
            #[doc = "80 percent of the (micro)Frame interval"]
            EOPF80 = 0x0,
            #[doc = "85 percent of the (micro)Frame interval"]
            EOPF85 = 0x01,
            #[doc = "90 percent of the (micro)Frame interval"]
            EOPF90 = 0x02,
            #[doc = "95 percent of the (micro)Frame interval"]
            EOPF95 = 0x03,
        }
        impl Perfrint {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perfrint {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perfrint {
            #[inline(always)]
            fn from(val: u8) -> Perfrint {
                Perfrint::from_bits(val)
            }
        }
        impl From<Perfrint> for u8 {
            #[inline(always)]
            fn from(val: Perfrint) -> u8 {
                Perfrint::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Perschintvl {
            #[doc = "25 percent of (micro)Frame"]
            MF25 = 0x0,
            #[doc = "50 percent of (micro)Frame"]
            MF50 = 0x01,
            #[doc = "75 percent of (micro)Frame"]
            MF75 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Perschintvl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Perschintvl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Perschintvl {
            #[inline(always)]
            fn from(val: u8) -> Perschintvl {
                Perschintvl::from_bits(val)
            }
        }
        impl From<Perschintvl> for u8 {
            #[inline(always)]
            fn from(val: Perschintvl) -> u8 {
                Perschintvl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Phydatawidth {
            #[doc = "8 bits"]
            WIDTH1 = 0x0,
            #[doc = "16 bits"]
            WIDTH2 = 0x01,
            #[doc = "8/16 bits, software selectable"]
            WIDTH3 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Phydatawidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Phydatawidth {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Phydatawidth {
            #[inline(always)]
            fn from(val: u8) -> Phydatawidth {
                Phydatawidth::from_bits(val)
            }
        }
        impl From<Phydatawidth> for u8 {
            #[inline(always)]
            fn from(val: Phydatawidth) -> u8 {
                Phydatawidth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Phyif {
            #[doc = "PHY 8bit Mode"]
            BITS8 = 0x0,
            #[doc = "PHY 16bit Mode"]
            BITS16 = 0x01,
        }
        impl Phyif {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Phyif {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Phyif {
            #[inline(always)]
            fn from(val: u8) -> Phyif {
                Phyif::from_bits(val)
            }
        }
        impl From<Phyif> for u8 {
            #[inline(always)]
            fn from(val: Phyif) -> u8 {
                Phyif::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Phyiopxcvrseltxvldcorrdis {
            #[doc = "Host controller asserts utmi_txvalid at least 2 utmi_clk cycles after utmi_xcvrselect switching"]
            ENABLE_FIX = 0x0,
            #[doc = "Host controller can assert utmi_txvalid after 1 utmi_clk cycle of utmi_xcvrselect switching"]
            DISABLE_FIX = 0x01,
        }
        impl Phyiopxcvrseltxvldcorrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Phyiopxcvrseltxvldcorrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Phyiopxcvrseltxvldcorrdis {
            #[inline(always)]
            fn from(val: u8) -> Phyiopxcvrseltxvldcorrdis {
                Phyiopxcvrseltxvldcorrdis::from_bits(val)
            }
        }
        impl From<Phyiopxcvrseltxvldcorrdis> for u8 {
            #[inline(always)]
            fn from(val: Phyiopxcvrseltxvldcorrdis) -> u8 {
                Phyiopxcvrseltxvldcorrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Phylpwrclksel {
            #[doc = "480-MHz Internal PLL clock"]
            INTPLLCLK = 0x0,
            #[doc = "48-MHz External Clock"]
            EXTCLK = 0x01,
        }
        impl Phylpwrclksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Phylpwrclksel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Phylpwrclksel {
            #[inline(always)]
            fn from(val: u8) -> Phylpwrclksel {
                Phylpwrclksel::from_bits(val)
            }
        }
        impl From<Phylpwrclksel> for u8 {
            #[inline(always)]
            fn from(val: Phylpwrclksel) -> u8 {
                Phylpwrclksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Physel {
            #[doc = "USB 2.0 high-speed UTMI+ or ULPI PHY is selected"]
            USB20 = 0x0,
            #[doc = "USB 1.1 full-speed serial transceiver is selected"]
            USB11 = 0x01,
        }
        impl Physel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Physel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Physel {
            #[inline(always)]
            fn from(val: u8) -> Physel {
                Physel::from_bits(val)
            }
        }
        impl From<Physel> for u8 {
            #[inline(always)]
            fn from(val: Physel) -> u8 {
                Physel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pid {
            #[doc = "DATA0"]
            DATA0 = 0x0,
            #[doc = "DATA2"]
            DATA2 = 0x01,
            #[doc = "DATA1"]
            DATA1 = 0x02,
            #[doc = "MDATA (non-control)/SETUP (control)"]
            MDATA = 0x03,
        }
        impl Pid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pid {
            #[inline(always)]
            fn from(val: u8) -> Pid {
                Pid::from_bits(val)
            }
        }
        impl From<Pid> for u8 {
            #[inline(always)]
            fn from(val: Pid) -> u8 {
                Pid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Piufssftrst {
            #[doc = "No Reset"]
            RESET_INACTIVE = 0x0,
            #[doc = "PIU FS Dedicated Controller Soft Reset"]
            RESET_ACTIVE = 0x01,
        }
        impl Piufssftrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Piufssftrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Piufssftrst {
            #[inline(always)]
            fn from(val: u8) -> Piufssftrst {
                Piufssftrst::from_bits(val)
            }
        }
        impl From<Piufssftrst> for u8 {
            #[inline(always)]
            fn from(val: Piufssftrst) -> u8 {
                Piufssftrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pktsizewidth {
            #[doc = "Width of Packet Size Counter 4"]
            BITS4 = 0x0,
            #[doc = "Width of Packet Size Counter 5"]
            BITS5 = 0x01,
            #[doc = "Width of Packet Size Counter 6"]
            BITS6 = 0x02,
            #[doc = "Width of Packet Size Counter 7"]
            BITS7 = 0x03,
            #[doc = "Width of Packet Size Counter 8"]
            BITS8 = 0x04,
            #[doc = "Width of Packet Size Counter 9"]
            BITS9 = 0x05,
            #[doc = "Width of Packet Size Counter 10"]
            BITS10 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Pktsizewidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pktsizewidth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pktsizewidth {
            #[inline(always)]
            fn from(val: u8) -> Pktsizewidth {
                Pktsizewidth::from_bits(val)
            }
        }
        impl From<Pktsizewidth> for u8 {
            #[inline(always)]
            fn from(val: Pktsizewidth) -> u8 {
                Pktsizewidth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prtintmsk {
            #[doc = "Host Port Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Host Port Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Prtintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prtintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prtintmsk {
            #[inline(always)]
            fn from(val: u8) -> Prtintmsk {
                Prtintmsk::from_bits(val)
            }
        }
        impl From<Prtintmsk> for u8 {
            #[inline(always)]
            fn from(val: Prtintmsk) -> u8 {
                Prtintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prtlnsts {
            _RESERVED_0 = 0x0,
            #[doc = "Logic level of D+"]
            PLUSD = 0x01,
            #[doc = "Logic level of D-"]
            MINUSD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Prtlnsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prtlnsts {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prtlnsts {
            #[inline(always)]
            fn from(val: u8) -> Prtlnsts {
                Prtlnsts::from_bits(val)
            }
        }
        impl From<Prtlnsts> for u8 {
            #[inline(always)]
            fn from(val: Prtlnsts) -> u8 {
                Prtlnsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prtspd {
            #[doc = "High speed"]
            HIGHSPD = 0x0,
            #[doc = "Full speed"]
            FULLSPD = 0x01,
            #[doc = "Low speed"]
            LOWSPD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Prtspd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prtspd {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prtspd {
            #[inline(always)]
            fn from(val: u8) -> Prtspd {
                Prtspd::from_bits(val)
            }
        }
        impl From<Prtspd> for u8 {
            #[inline(always)]
            fn from(val: Prtspd) -> u8 {
                Prtspd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prttstctl {
            #[doc = "Test mode disabled"]
            DISABLED = 0x0,
            #[doc = "Test_J mode"]
            TESTJ = 0x01,
            #[doc = "Test_K mode"]
            TESTK = 0x02,
            #[doc = "Test_SE0_NAK mode"]
            TESTSN = 0x03,
            #[doc = "Test_Packet mode"]
            TESTPM = 0x04,
            #[doc = "Test_force_Enable"]
            TESTFENB = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Prttstctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prttstctl {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prttstctl {
            #[inline(always)]
            fn from(val: u8) -> Prttstctl {
                Prttstctl::from_bits(val)
            }
        }
        impl From<Prttstctl> for u8 {
            #[inline(always)]
            fn from(val: Prttstctl) -> u8 {
                Prttstctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ptxqdepth {
            #[doc = "Queue Depth 2"]
            QUE2 = 0x0,
            #[doc = "Queue Depth 4"]
            QUE4 = 0x01,
            #[doc = "Queue Depth 8"]
            QUE8 = 0x02,
            #[doc = "Queue Depth 16"]
            QUE16 = 0x03,
        }
        impl Ptxqdepth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ptxqdepth {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ptxqdepth {
            #[inline(always)]
            fn from(val: u8) -> Ptxqdepth {
                Ptxqdepth::from_bits(val)
            }
        }
        impl From<Ptxqdepth> for u8 {
            #[inline(always)]
            fn from(val: Ptxqdepth) -> u8 {
                Ptxqdepth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pwrdnswtch {
            #[doc = "The controller is in ON state"]
            ON = 0x0,
            #[doc = "The controller is in OFF state"]
            OFF = 0x01,
        }
        impl Pwrdnswtch {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pwrdnswtch {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pwrdnswtch {
            #[inline(always)]
            fn from(val: u8) -> Pwrdnswtch {
                Pwrdnswtch::from_bits(val)
            }
        }
        impl From<Pwrdnswtch> for u8 {
            #[inline(always)]
            fn from(val: Pwrdnswtch) -> u8 {
                Pwrdnswtch::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resumefrmchkbusdis {
            #[doc = "Device controller detects line K and resumes"]
            ENABLE_FIX = 0x0,
            #[doc = "Device controller does not detect line K and resume"]
            DISABLE_FIX = 0x01,
        }
        impl Resumefrmchkbusdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resumefrmchkbusdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resumefrmchkbusdis {
            #[inline(always)]
            fn from(val: u8) -> Resumefrmchkbusdis {
                Resumefrmchkbusdis::from_bits(val)
            }
        }
        impl From<Resumefrmchkbusdis> for u8 {
            #[inline(always)]
            fn from(val: Resumefrmchkbusdis) -> u8 {
                Resumefrmchkbusdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rmtwkupsig {
            #[doc = "Core does not send Remote Wakeup Signaling"]
            DISABLEDRMWKUP = 0x0,
            #[doc = "Core sends Remote Wakeup Signaling"]
            ENABLERMWKUP = 0x01,
        }
        impl Rmtwkupsig {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rmtwkupsig {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rmtwkupsig {
            #[inline(always)]
            fn from(val: u8) -> Rmtwkupsig {
                Rmtwkupsig::from_bits(val)
            }
        }
        impl From<Rmtwkupsig> for u8 {
            #[inline(always)]
            fn from(val: Rmtwkupsig) -> u8 {
                Rmtwkupsig::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstpdwnmodule {
            #[doc = "Power is turned on"]
            ON = 0x0,
            #[doc = "Power is turned off"]
            OFF = 0x01,
        }
        impl Rstpdwnmodule {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstpdwnmodule {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstpdwnmodule {
            #[inline(always)]
            fn from(val: u8) -> Rstpdwnmodule {
                Rstpdwnmodule::from_bits(val)
            }
        }
        impl From<Rstpdwnmodule> for u8 {
            #[inline(always)]
            fn from(val: Rstpdwnmodule) -> u8 {
                Rstpdwnmodule::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rstrdoneintmsk {
            #[doc = "Restore Done Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Restore Done Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Rstrdoneintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rstrdoneintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rstrdoneintmsk {
            #[inline(always)]
            fn from(val: u8) -> Rstrdoneintmsk {
                Rstrdoneintmsk::from_bits(val)
            }
        }
        impl From<Rstrdoneintmsk> for u8 {
            #[inline(always)]
            fn from(val: Rstrdoneintmsk) -> u8 {
                Rstrdoneintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rsttype {
            #[doc = "Asynchronous reset is used in the core"]
            ASYNCRST = 0x0,
            #[doc = "Synchronous reset is used in the core"]
            SYNCRST = 0x01,
        }
        impl Rsttype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rsttype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rsttype {
            #[inline(always)]
            fn from(val: u8) -> Rsttype {
                Rsttype::from_bits(val)
            }
        }
        impl From<Rsttype> for u8 {
            #[inline(always)]
            fn from(val: Rsttype) -> u8 {
                Rsttype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rxflvlmsk {
            #[doc = "Receive FIFO Non-Empty Mask"]
            MASK = 0x0,
            #[doc = "No Receive FIFO Non-Empty Mask"]
            NOMASK = 0x01,
        }
        impl Rxflvlmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rxflvlmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rxflvlmsk {
            #[inline(always)]
            fn from(val: u8) -> Rxflvlmsk {
                Rxflvlmsk::from_bits(val)
            }
        }
        impl From<Rxflvlmsk> for u8 {
            #[inline(always)]
            fn from(val: Rxflvlmsk) -> u8 {
                Rxflvlmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sessreqintmsk {
            #[doc = "Session Request or New Session Detected Interrupt Mask"]
            MASK = 0x0,
            #[doc = "No Session Request or New Session Detected Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Sessreqintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sessreqintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sessreqintmsk {
            #[inline(always)]
            fn from(val: u8) -> Sessreqintmsk {
                Sessreqintmsk::from_bits(val)
            }
        }
        impl From<Sessreqintmsk> for u8 {
            #[inline(always)]
            fn from(val: Sessreqintmsk) -> u8 {
                Sessreqintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Setupmsk {
            #[doc = "Mask SETUP Phase Done Interrupt"]
            MASK = 0x0,
            #[doc = "No SETUP Phase Done Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Setupmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Setupmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Setupmsk {
            #[inline(always)]
            fn from(val: u8) -> Setupmsk {
                Setupmsk::from_bits(val)
            }
        }
        impl From<Setupmsk> for u8 {
            #[inline(always)]
            fn from(val: Setupmsk) -> u8 {
                Setupmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Singpnt {
            #[doc = "Multi-point application (hub and split support)"]
            MULTIPOINT = 0x0,
            #[doc = "Single-point application (no hub and split support)"]
            SINGLEPOINT = 0x01,
        }
        impl Singpnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Singpnt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Singpnt {
            #[inline(always)]
            fn from(val: u8) -> Singpnt {
                Singpnt::from_bits(val)
            }
        }
        impl From<Singpnt> for u8 {
            #[inline(always)]
            fn from(val: Singpnt) -> u8 {
                Singpnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Slpsts {
            #[doc = "In Host or Device mode, this bit indicates core is not in L1"]
            CORE_NOT_IN_L1 = 0x0,
            #[doc = "In Host mode, this bit indicates the core transitions to Sleep state as a successful LPM transaction. In Device mode, the core enters the Sleep state when an ACK response is sent to an LPM transaction"]
            CORE_IN_L1 = 0x01,
        }
        impl Slpsts {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Slpsts {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Slpsts {
            #[inline(always)]
            fn from(val: u8) -> Slpsts {
                Slpsts::from_bits(val)
            }
        }
        impl From<Slpsts> for u8 {
            #[inline(always)]
            fn from(val: Slpsts) -> u8 {
                Slpsts::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sof {
            #[doc = "No Start of Frame"]
            INTACTIVE = 0x0,
            #[doc = "Start of Frame"]
            ACTIVE = 0x01,
        }
        impl Sof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sof {
            #[inline(always)]
            fn from(val: u8) -> Sof {
                Sof::from_bits(val)
            }
        }
        impl From<Sof> for u8 {
            #[inline(always)]
            fn from(val: Sof) -> u8 {
                Sof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sofmsk {
            #[doc = "Start of Frame Mask"]
            MASK = 0x0,
            #[doc = "No Start of Frame Mask"]
            NOMASK = 0x01,
        }
        impl Sofmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sofmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sofmsk {
            #[inline(always)]
            fn from(val: u8) -> Sofmsk {
                Sofmsk::from_bits(val)
            }
        }
        impl From<Sofmsk> for u8 {
            #[inline(always)]
            fn from(val: Sofmsk) -> u8 {
                Sofmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssplitstallnyeterrdis {
            #[doc = "Transaction Error reported when device sends STALL/NYET for SSPLIT"]
            ENABLE_FIX = 0x0,
            #[doc = "Transaction Error not reported when device sends STALL/NYET for SSPLIT"]
            DISABLE_FIX = 0x01,
        }
        impl Ssplitstallnyeterrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssplitstallnyeterrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssplitstallnyeterrdis {
            #[inline(always)]
            fn from(val: u8) -> Ssplitstallnyeterrdis {
                Ssplitstallnyeterrdis::from_bits(val)
            }
        }
        impl From<Ssplitstallnyeterrdis> for u8 {
            #[inline(always)]
            fn from(val: Ssplitstallnyeterrdis) -> u8 {
                Ssplitstallnyeterrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stallmsk {
            #[doc = "Mask STALL Response Received Interrupt"]
            MASK = 0x0,
            #[doc = "No STALL Response Received Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Stallmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stallmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stallmsk {
            #[inline(always)]
            fn from(val: u8) -> Stallmsk {
                Stallmsk::from_bits(val)
            }
        }
        impl From<Stallmsk> for u8 {
            #[inline(always)]
            fn from(val: Stallmsk) -> u8 {
                Stallmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stsphsercvdmsk {
            #[doc = "Status Phase Received Mask"]
            MASK = 0x0,
            #[doc = "No Status Phase Received Mask"]
            NOMASK = 0x01,
        }
        impl Stsphsercvdmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stsphsercvdmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stsphsercvdmsk {
            #[inline(always)]
            fn from(val: u8) -> Stsphsercvdmsk {
                Stsphsercvdmsk::from_bits(val)
            }
        }
        impl From<Stsphsercvdmsk> for u8 {
            #[inline(always)]
            fn from(val: Stsphsercvdmsk) -> u8 {
                Stsphsercvdmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Supcnt {
            _RESERVED_0 = 0x0,
            #[doc = "1 packet"]
            ONEPACKET = 0x01,
            #[doc = "2 packets"]
            TWOPACKET = 0x02,
            #[doc = "3 packets"]
            THREEPACKET = 0x03,
        }
        impl Supcnt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Supcnt {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Supcnt {
            #[inline(always)]
            fn from(val: u8) -> Supcnt {
                Supcnt::from_bits(val)
            }
        }
        impl From<Supcnt> for u8 {
            #[inline(always)]
            fn from(val: Supcnt) -> u8 {
                Supcnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Termseldlpulse {
            #[doc = "Data line pulsing using utmi_txvalid"]
            TXVALID = 0x0,
            #[doc = "Data line pulsing using utmi_termsel"]
            TERMSEL = 0x01,
        }
        impl Termseldlpulse {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Termseldlpulse {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Termseldlpulse {
            #[inline(always)]
            fn from(val: u8) -> Termseldlpulse {
                Termseldlpulse::from_bits(val)
            }
        }
        impl From<Termseldlpulse> for u8 {
            #[inline(always)]
            fn from(val: Termseldlpulse) -> u8 {
                Termseldlpulse::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Timeoutmsk {
            #[doc = "Mask Timeout Condition Interrupt"]
            MASK = 0x0,
            #[doc = "No Timeout Condition Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Timeoutmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Timeoutmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Timeoutmsk {
            #[inline(always)]
            fn from(val: u8) -> Timeoutmsk {
                Timeoutmsk::from_bits(val)
            }
        }
        impl From<Timeoutmsk> for u8 {
            #[inline(always)]
            fn from(val: Timeoutmsk) -> u8 {
                Timeoutmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Toutcal {
            #[doc = "Add 0 PHY clocks"]
            ZERO = 0x0,
            #[doc = "Add 1 PHY clocks"]
            ONE = 0x01,
            #[doc = "Add 2 PHY clocks"]
            TWO = 0x02,
            #[doc = "Add 3 PHY clocks"]
            THREE = 0x03,
            #[doc = "Add 4 PHY clocks"]
            FOUR = 0x04,
            #[doc = "Add 5 PHY clocks"]
            FIVE = 0x05,
            #[doc = "Add 6 PHY clocks"]
            SIX = 0x06,
            #[doc = "Add 7 PHY clocks"]
            SEVEN = 0x07,
        }
        impl Toutcal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Toutcal {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Toutcal {
            #[inline(always)]
            fn from(val: u8) -> Toutcal {
                Toutcal::from_bits(val)
            }
        }
        impl From<Toutcal> for u8 {
            #[inline(always)]
            fn from(val: Toutcal) -> u8 {
                Toutcal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tstctl {
            #[doc = "Test mode disabled"]
            DISABLED = 0x0,
            #[doc = "Test_J mode"]
            TESTJ = 0x01,
            #[doc = "Test_K mode"]
            TESTK = 0x02,
            #[doc = "Test_SE0_NAK mode"]
            TESTSN = 0x03,
            #[doc = "Test_Packet mode"]
            TESTPM = 0x04,
            #[doc = "Test_force_Enable"]
            TESTFE = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tstctl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tstctl {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tstctl {
            #[inline(always)]
            fn from(val: u8) -> Tstctl {
                Tstctl::from_bits(val)
            }
        }
        impl From<Tstctl> for u8 {
            #[inline(always)]
            fn from(val: Tstctl) -> u8 {
                Tstctl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txfifoundrnmsk {
            #[doc = "Mask Fifo Underrun Interrupt"]
            MASK = 0x0,
            #[doc = "No Fifo Underrun Interrupt Mask"]
            NOMASK = 0x01,
        }
        impl Txfifoundrnmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txfifoundrnmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txfifoundrnmsk {
            #[inline(always)]
            fn from(val: u8) -> Txfifoundrnmsk {
                Txfifoundrnmsk::from_bits(val)
            }
        }
        impl From<Txfifoundrnmsk> for u8 {
            #[inline(always)]
            fn from(val: Txfifoundrnmsk) -> u8 {
                Txfifoundrnmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Txvaliddeassertioncorrdis {
            #[doc = "Txvalid is deasserted during soft disconnect after receiving Txready from the PHY"]
            ENABLE_FIX = 0x0,
            #[doc = "Txvalid is deasserted during soft disconnect without waiting for Txready from the PHY"]
            DISABLE_FIX = 0x01,
        }
        impl Txvaliddeassertioncorrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Txvaliddeassertioncorrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Txvaliddeassertioncorrdis {
            #[inline(always)]
            fn from(val: u8) -> Txvaliddeassertioncorrdis {
                Txvaliddeassertioncorrdis::from_bits(val)
            }
        }
        impl From<Txvaliddeassertioncorrdis> for u8 {
            #[inline(always)]
            fn from(val: Txvaliddeassertioncorrdis) -> u8 {
                Txvaliddeassertioncorrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulpiutmisel {
            #[doc = "UTMI+ Interface"]
            UTMI = 0x0,
            #[doc = "ULPI Interface"]
            ULPI = 0x01,
        }
        impl Ulpiutmisel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulpiutmisel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulpiutmisel {
            #[inline(always)]
            fn from(val: u8) -> Ulpiutmisel {
                Ulpiutmisel::from_bits(val)
            }
        }
        impl From<Ulpiutmisel> for u8 {
            #[inline(always)]
            fn from(val: Ulpiutmisel) -> u8 {
                Ulpiutmisel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ulpixcvrselswitchcorrdis {
            #[doc = "Host controller waits for previous functional register update to complete before switching the transceiver select again or asserting txvalid"]
            ENABLE_FIX = 0x0,
            #[doc = "Host controller does not wait for the previous functional register update to complete before switching the transceiver select again or asserting txvalid"]
            DISABLE_FIX = 0x01,
        }
        impl Ulpixcvrselswitchcorrdis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ulpixcvrselswitchcorrdis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ulpixcvrselswitchcorrdis {
            #[inline(always)]
            fn from(val: u8) -> Ulpixcvrselswitchcorrdis {
                Ulpixcvrselswitchcorrdis::from_bits(val)
            }
        }
        impl From<Ulpixcvrselswitchcorrdis> for u8 {
            #[inline(always)]
            fn from(val: Ulpixcvrselswitchcorrdis) -> u8 {
                Ulpixcvrselswitchcorrdis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usbrstmsk {
            #[doc = "USB Reset Mask"]
            MASK = 0x0,
            #[doc = "No USB Reset Mask"]
            NOMASK = 0x01,
        }
        impl Usbrstmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usbrstmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usbrstmsk {
            #[inline(always)]
            fn from(val: u8) -> Usbrstmsk {
                Usbrstmsk::from_bits(val)
            }
        }
        impl From<Usbrstmsk> for u8 {
            #[inline(always)]
            fn from(val: Usbrstmsk) -> u8 {
                Usbrstmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usbsuspmsk {
            #[doc = "USB Suspend Mask"]
            MASK = 0x0,
            #[doc = "No USB Suspend Mask"]
            NOMASK = 0x01,
        }
        impl Usbsuspmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usbsuspmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usbsuspmsk {
            #[inline(always)]
            fn from(val: u8) -> Usbsuspmsk {
                Usbsuspmsk::from_bits(val)
            }
        }
        impl From<Usbsuspmsk> for u8 {
            #[inline(always)]
            fn from(val: Usbsuspmsk) -> u8 {
                Usbsuspmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Usbtrdtim {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            #[doc = "MAC interface is 16-bit UTMI+."]
            TURNTIME16BIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "MAC interface is 8-bit UTMI+."]
            TURNTIME8BIT = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Usbtrdtim {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Usbtrdtim {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Usbtrdtim {
            #[inline(always)]
            fn from(val: u8) -> Usbtrdtim {
                Usbtrdtim::from_bits(val)
            }
        }
        impl From<Usbtrdtim> for u8 {
            #[inline(always)]
            fn from(val: Usbtrdtim) -> u8 {
                Usbtrdtim::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vbvalidovval {
            #[doc = "vbusvalid value when GOTGCTL.VbvalidOvEn = 1"]
            SET0 = 0x0,
            #[doc = "vbusvalid value when GOTGCTL.VbvalidOvEn is 1"]
            SET1 = 0x01,
        }
        impl Vbvalidovval {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vbvalidovval {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vbvalidovval {
            #[inline(always)]
            fn from(val: u8) -> Vbvalidovval {
                Vbvalidovval::from_bits(val)
            }
        }
        impl From<Vbvalidovval> for u8 {
            #[inline(always)]
            fn from(val: Vbvalidovval) -> u8 {
                Vbvalidovval::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wkupintmsk {
            #[doc = "Resume or Remote Wakeup Detected Interrupt Mask"]
            MASK = 0x0,
            #[doc = "Unmask Resume Remote Wakeup Detected Interrupt"]
            NOMASK = 0x01,
        }
        impl Wkupintmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wkupintmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wkupintmsk {
            #[inline(always)]
            fn from(val: u8) -> Wkupintmsk {
                Wkupintmsk::from_bits(val)
            }
        }
        impl From<Wkupintmsk> for u8 {
            #[inline(always)]
            fn from(val: Wkupintmsk) -> u8 {
                Wkupintmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Xacterrdata0ctrlstsindis {
            #[doc = "Host controller reports transaction error when DATA0 PID is received for CTRL STATUS IN transfer in DMA mode"]
            ENABLE_FIX = 0x0,
            #[doc = "Host controller retries the transfer when DATA0 PID is received for CTRL STATUS IN transfer in DMA mode"]
            DISABLE_FIX = 0x01,
        }
        impl Xacterrdata0ctrlstsindis {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Xacterrdata0ctrlstsindis {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Xacterrdata0ctrlstsindis {
            #[inline(always)]
            fn from(val: u8) -> Xacterrdata0ctrlstsindis {
                Xacterrdata0ctrlstsindis::from_bits(val)
            }
        }
        impl From<Xacterrdata0ctrlstsindis> for u8 {
            #[inline(always)]
            fn from(val: Xacterrdata0ctrlstsindis) -> u8 {
                Xacterrdata0ctrlstsindis::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Xacterrmsk {
            #[doc = "Mask Transaction Error"]
            MASK = 0x0,
            #[doc = "No Transaction Error Mask"]
            NOMASK = 0x01,
        }
        impl Xacterrmsk {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Xacterrmsk {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Xacterrmsk {
            #[inline(always)]
            fn from(val: u8) -> Xacterrmsk {
                Xacterrmsk::from_bits(val)
            }
        }
        impl From<Xacterrmsk> for u8 {
            #[inline(always)]
            fn from(val: Xacterrmsk) -> u8 {
                Xacterrmsk::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Xfersizewidth {
            #[doc = "Width of Transfer Size Counter 11 bits"]
            WIDTH11 = 0x0,
            #[doc = "Width of Transfer Size Counter 12 bits"]
            WIDTH12 = 0x01,
            #[doc = "Width of Transfer Size Counter 13 bits"]
            WIDTH13 = 0x02,
            #[doc = "Width of Transfer Size Counter 14 bits"]
            WIDTH14 = 0x03,
            #[doc = "Width of Transfer Size Counter 15 bits"]
            WIDTH15 = 0x04,
            #[doc = "Width of Transfer Size Counter 16 bits"]
            WIDTH16 = 0x05,
            #[doc = "Width of Transfer Size Counter 17 bits"]
            WIDTH17 = 0x06,
            #[doc = "Width of Transfer Size Counter 18 bits"]
            WIDTH18 = 0x07,
            #[doc = "Width of Transfer Size Counter 19 bits"]
            WIDTH19 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Xfersizewidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Xfersizewidth {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Xfersizewidth {
            #[inline(always)]
            fn from(val: u8) -> Xfersizewidth {
                Xfersizewidth::from_bits(val)
            }
        }
        impl From<Xfersizewidth> for u8 {
            #[inline(always)]
            fn from(val: Xfersizewidth) -> u8 {
                Xfersizewidth::to_bits(val)
            }
        }
    }
}
pub mod vpr {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Debugif {
        ptr: *mut u8,
    }
    unsafe impl Send for Debugif {}
    unsafe impl Sync for Debugif {}
    impl Debugif {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Abstract Data 0. Read/write data for argument 0"]
        #[inline(always)]
        pub const fn data0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Abstract Data 1. Read/write data for argument 1"]
        #[inline(always)]
        pub const fn data1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Debug Module Control"]
        #[inline(always)]
        pub const fn dmcontrol(self) -> crate::common::Reg<regs::Dmcontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize) as _) }
        }
        #[doc = "Debug Module Status"]
        #[inline(always)]
        pub const fn dmstatus(self) -> crate::common::Reg<regs::Dmstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
        #[doc = "Hart Information"]
        #[inline(always)]
        pub const fn hartinfo(self) -> crate::common::Reg<regs::Hartinfo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x48usize) as _) }
        }
        #[doc = "Halt Summary 1"]
        #[inline(always)]
        pub const fn haltsum1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x4cusize) as _) }
        }
        #[doc = "Hart Array Window Select"]
        #[inline(always)]
        pub const fn hawindowsel(self) -> crate::common::Reg<regs::Hawindowsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x50usize) as _) }
        }
        #[doc = "Hart Array Window"]
        #[inline(always)]
        pub const fn hawindow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x54usize) as _) }
        }
        #[doc = "Abstract Control and Status"]
        #[inline(always)]
        pub const fn abstractcs(self) -> crate::common::Reg<regs::Abstractcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x58usize) as _) }
        }
        #[doc = "Abstract command"]
        #[inline(always)]
        pub const fn abstractcmd(self) -> crate::common::Reg<regs::Abstractcmd, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x5cusize) as _) }
        }
        #[doc = "Abstract Command Autoexec"]
        #[inline(always)]
        pub const fn abstractauto(
            self,
        ) -> crate::common::Reg<regs::Abstractauto, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize) as _) }
        }
        #[doc = "Description collection: Configuration String Pointer \\[n\\]"]
        #[inline(always)]
        pub const fn confstrptr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x64usize + n * 4usize) as _)
            }
        }
        #[doc = "Next Debug Module"]
        #[inline(always)]
        pub const fn nextdm(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x74usize) as _) }
        }
        #[doc = "Description collection: Program Buffer \\[n\\]"]
        #[inline(always)]
        pub const fn progbuf(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Authentication Data"]
        #[inline(always)]
        pub const fn authdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xc0usize) as _) }
        }
        #[doc = "Halt Summary 2"]
        #[inline(always)]
        pub const fn haltsum2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xd0usize) as _) }
        }
        #[doc = "Halt Summary 3"]
        #[inline(always)]
        pub const fn haltsum3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xd4usize) as _) }
        }
        #[doc = "System Bus Addres 127:96"]
        #[inline(always)]
        pub const fn sbaddress3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xdcusize) as _) }
        }
        #[doc = "System Bus Access Control and Status"]
        #[inline(always)]
        pub const fn sbcs(self) -> crate::common::Reg<regs::Sbcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe0usize) as _) }
        }
        #[doc = "System Bus Addres 31:0"]
        #[inline(always)]
        pub const fn sbaddress0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe4usize) as _) }
        }
        #[doc = "System Bus Addres 63:32"]
        #[inline(always)]
        pub const fn sbaddress1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe8usize) as _) }
        }
        #[doc = "System Bus Addres 95:64"]
        #[inline(always)]
        pub const fn sbaddress2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xecusize) as _) }
        }
        #[doc = "System Bus Data 31:0"]
        #[inline(always)]
        pub const fn sbdata0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xf0usize) as _) }
        }
        #[doc = "System Bus Data 63:32"]
        #[inline(always)]
        pub const fn sbdata1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xf4usize) as _) }
        }
        #[doc = "System Bus Data 95:64"]
        #[inline(always)]
        pub const fn sbdata2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xf8usize) as _) }
        }
        #[doc = "System Bus Data 127:96"]
        #[inline(always)]
        pub const fn sbdata3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xfcusize) as _) }
        }
        #[doc = "Halt summary 0"]
        #[inline(always)]
        pub const fn haltsum0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
    }
    #[doc = "VPR peripheral registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vpr {
        ptr: *mut u8,
    }
    unsafe impl Send for Vpr {}
    unsafe impl Sync for Vpr {}
    impl Vpr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: VPR task \\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task TASKS_TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: VPR event \\[n\\] register"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event EVENTS_TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn debugif(self) -> Debugif {
            unsafe { Debugif::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "State of the CPU after a core reset"]
        #[inline(always)]
        pub const fn cpurun(self) -> crate::common::Reg<regs::Cpurun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0800usize) as _) }
        }
        #[doc = "VPR state information."]
        #[inline(always)]
        pub const fn vprstatus(self) -> crate::common::Reg<regs::Vprstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0804usize) as _) }
        }
        #[doc = "Initial value of the PC at CPU start."]
        #[inline(always)]
        pub const fn initpc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0808usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Abstract Command Autoexec"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractauto(pub u32);
        impl Abstractauto {
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[must_use]
            #[inline(always)]
            pub const fn autoexecdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn set_autoexecdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[must_use]
            #[inline(always)]
            pub const fn autoexecprogbuf(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn set_autoexecprogbuf(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Abstractauto {
            #[inline(always)]
            fn default() -> Abstractauto {
                Abstractauto(0)
            }
        }
        impl core::fmt::Debug for Abstractauto {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractauto")
                    .field("autoexecdata", &self.autoexecdata())
                    .field("autoexecprogbuf", &self.autoexecprogbuf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractauto {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Abstractauto {{ autoexecdata: {=u16:?}, autoexecprogbuf: {=u16:?} }}",
                    self.autoexecdata(),
                    self.autoexecprogbuf()
                )
            }
        }
        #[doc = "Abstract command"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcmd(pub u32);
        impl Abstractcmd {
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[must_use]
            #[inline(always)]
            pub const fn control(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[inline(always)]
            pub const fn set_control(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[must_use]
            #[inline(always)]
            pub const fn cmdtype(&self) -> super::vals::Cmdtype {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::Cmdtype::from_bits(val as u8)
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[inline(always)]
            pub const fn set_cmdtype(&mut self, val: super::vals::Cmdtype) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Abstractcmd {
            #[inline(always)]
            fn default() -> Abstractcmd {
                Abstractcmd(0)
            }
        }
        impl core::fmt::Debug for Abstractcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcmd")
                    .field("control", &self.control())
                    .field("cmdtype", &self.cmdtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Abstractcmd {{ control: {=u32:?}, cmdtype: {:?} }}",
                    self.control(),
                    self.cmdtype()
                )
            }
        }
        #[doc = "Abstract Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcs(pub u32);
        impl Abstractcs {
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[must_use]
            #[inline(always)]
            pub const fn datacount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[inline(always)]
            pub const fn set_datacount(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Command error when the abstract command fails."]
            #[must_use]
            #[inline(always)]
            pub const fn cmderr(&self) -> super::vals::Cmderr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cmderr::from_bits(val as u8)
            }
            #[doc = "Command error when the abstract command fails."]
            #[inline(always)]
            pub const fn set_cmderr(&mut self, val: super::vals::Cmderr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Abstract command execution status."]
            #[must_use]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Abstract command execution status."]
            #[inline(always)]
            pub const fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[must_use]
            #[inline(always)]
            pub const fn progbufsize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[inline(always)]
            pub const fn set_progbufsize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for Abstractcs {
            #[inline(always)]
            fn default() -> Abstractcs {
                Abstractcs(0)
            }
        }
        impl core::fmt::Debug for Abstractcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcs")
                    .field("datacount", &self.datacount())
                    .field("cmderr", &self.cmderr())
                    .field("busy", &self.busy())
                    .field("progbufsize", &self.progbufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Abstractcs {{ datacount: {=u8:?}, cmderr: {:?}, busy: {=bool:?}, progbufsize: {=u8:?} }}" , self . datacount () , self . cmderr () , self . busy () , self . progbufsize ())
            }
        }
        #[doc = "State of the CPU after a core reset"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cpurun(pub u32);
        impl Cpurun {
            #[doc = "Controls CPU running state after a core reset."]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::CpurunEn {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CpurunEn::from_bits(val as u8)
            }
            #[doc = "Controls CPU running state after a core reset."]
            #[inline(always)]
            pub const fn set_en(&mut self, val: super::vals::CpurunEn) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Cpurun {
            #[inline(always)]
            fn default() -> Cpurun {
                Cpurun(0)
            }
        }
        impl core::fmt::Debug for Cpurun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cpurun").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cpurun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cpurun {{ en: {:?} }}", self.en())
            }
        }
        #[doc = "Debug Module Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmcontrol(pub u32);
        impl Dmcontrol {
            #[doc = "Reset signal for the debug module."]
            #[must_use]
            #[inline(always)]
            pub const fn dmactive(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal for the debug module."]
            #[inline(always)]
            pub const fn set_dmactive(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[must_use]
            #[inline(always)]
            pub const fn ndmreset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[inline(always)]
            pub const fn set_ndmreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Clear the halt on reset request."]
            #[must_use]
            #[inline(always)]
            pub const fn clrresethaltreq(&self) -> super::vals::Clrresethaltreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clrresethaltreq::from_bits(val as u8)
            }
            #[doc = "Clear the halt on reset request."]
            #[inline(always)]
            pub const fn set_clrresethaltreq(&mut self, val: super::vals::Clrresethaltreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set the halt on reset request."]
            #[must_use]
            #[inline(always)]
            pub const fn setresethaltreq(&self) -> super::vals::Setresethaltreq {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Setresethaltreq::from_bits(val as u8)
            }
            #[doc = "Set the halt on reset request."]
            #[inline(always)]
            pub const fn set_setresethaltreq(&mut self, val: super::vals::Setresethaltreq) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "The high 10 bits of hartsel."]
            #[must_use]
            #[inline(always)]
            pub const fn hartselhi(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "The high 10 bits of hartsel."]
            #[inline(always)]
            pub const fn set_hartselhi(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u32) & 0x03ff) << 6usize);
            }
            #[doc = "The low 10 bits of hartsel."]
            #[must_use]
            #[inline(always)]
            pub const fn hartsello(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "The low 10 bits of hartsel."]
            #[inline(always)]
            pub const fn set_hartsello(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
            #[doc = "Definition of currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn hasel(&self) -> super::vals::Hasel {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Hasel::from_bits(val as u8)
            }
            #[doc = "Definition of currently selected harts."]
            #[inline(always)]
            pub const fn set_hasel(&mut self, val: super::vals::Hasel) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Clear the havereset."]
            #[must_use]
            #[inline(always)]
            pub const fn ackhavereset(&self) -> super::vals::Ackhavereset {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Ackhavereset::from_bits(val as u8)
            }
            #[doc = "Clear the havereset."]
            #[inline(always)]
            pub const fn set_ackhavereset(&mut self, val: super::vals::Ackhavereset) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Reset harts."]
            #[must_use]
            #[inline(always)]
            pub const fn hartreset(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Reset harts."]
            #[inline(always)]
            pub const fn set_hartreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Resume currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn resumereq(&self) -> super::vals::Resumereq {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Resumereq::from_bits(val as u8)
            }
            #[doc = "Resume currently selected harts."]
            #[inline(always)]
            pub const fn set_resumereq(&mut self, val: super::vals::Resumereq) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Halt currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn haltreq(&self) -> super::vals::Haltreq {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Haltreq::from_bits(val as u8)
            }
            #[doc = "Halt currently selected harts."]
            #[inline(always)]
            pub const fn set_haltreq(&mut self, val: super::vals::Haltreq) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dmcontrol {
            #[inline(always)]
            fn default() -> Dmcontrol {
                Dmcontrol(0)
            }
        }
        impl core::fmt::Debug for Dmcontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmcontrol")
                    .field("dmactive", &self.dmactive())
                    .field("ndmreset", &self.ndmreset())
                    .field("clrresethaltreq", &self.clrresethaltreq())
                    .field("setresethaltreq", &self.setresethaltreq())
                    .field("hartselhi", &self.hartselhi())
                    .field("hartsello", &self.hartsello())
                    .field("hasel", &self.hasel())
                    .field("ackhavereset", &self.ackhavereset())
                    .field("hartreset", &self.hartreset())
                    .field("resumereq", &self.resumereq())
                    .field("haltreq", &self.haltreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmcontrol {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dmcontrol {{ dmactive: {=bool:?}, ndmreset: {=bool:?}, clrresethaltreq: {:?}, setresethaltreq: {:?}, hartselhi: {=u16:?}, hartsello: {=u16:?}, hasel: {:?}, ackhavereset: {:?}, hartreset: {=bool:?}, resumereq: {:?}, haltreq: {:?} }}" , self . dmactive () , self . ndmreset () , self . clrresethaltreq () , self . setresethaltreq () , self . hartselhi () , self . hartsello () , self . hasel () , self . ackhavereset () , self . hartreset () , self . resumereq () , self . haltreq ())
            }
        }
        #[doc = "Debug Module Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmstatus(pub u32);
        impl Dmstatus {
            #[doc = "Version of the debug module."]
            #[must_use]
            #[inline(always)]
            pub const fn version(&self) -> super::vals::Version {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Version::from_bits(val as u8)
            }
            #[doc = "Version of the debug module."]
            #[inline(always)]
            pub const fn set_version(&mut self, val: super::vals::Version) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Configuration string."]
            #[must_use]
            #[inline(always)]
            pub const fn confstrptrvalid(&self) -> super::vals::Confstrptrvalid {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Confstrptrvalid::from_bits(val as u8)
            }
            #[doc = "Configuration string."]
            #[inline(always)]
            pub const fn set_confstrptrvalid(&mut self, val: super::vals::Confstrptrvalid) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Halt-on-reset support status."]
            #[must_use]
            #[inline(always)]
            pub const fn hasresethaltreq(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Halt-on-reset support status."]
            #[inline(always)]
            pub const fn set_hasresethaltreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Authentication busy status."]
            #[must_use]
            #[inline(always)]
            pub const fn authbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication busy status."]
            #[inline(always)]
            pub const fn set_authbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Authentication status."]
            #[must_use]
            #[inline(always)]
            pub const fn authenticated(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication status."]
            #[inline(always)]
            pub const fn set_authenticated(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Any currently selected harts halted status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyhalted(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts halted status."]
            #[inline(always)]
            pub const fn set_anyhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "All currently selected harts halted status."]
            #[must_use]
            #[inline(always)]
            pub const fn allhalted(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts halted status."]
            #[inline(always)]
            pub const fn set_allhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Any currently selected harts running status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyrunning(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts running status."]
            #[inline(always)]
            pub const fn set_anyrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "All currently selected harts running status."]
            #[must_use]
            #[inline(always)]
            pub const fn allrunning(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts running status."]
            #[inline(always)]
            pub const fn set_allrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyunavail(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn set_anyunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "All currently selected harts unavailable status."]
            #[must_use]
            #[inline(always)]
            pub const fn allunavail(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn set_allunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[must_use]
            #[inline(always)]
            pub const fn anynonexistent(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn set_anynonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[must_use]
            #[inline(always)]
            pub const fn allnonexistent(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn set_allnonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[must_use]
            #[inline(always)]
            pub const fn anyresumeack(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[inline(always)]
            pub const fn set_anyresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[must_use]
            #[inline(always)]
            pub const fn allresumeack(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[inline(always)]
            pub const fn set_allresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[must_use]
            #[inline(always)]
            pub const fn anyhavereset(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[inline(always)]
            pub const fn set_anyhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[must_use]
            #[inline(always)]
            pub const fn allhavereset(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[inline(always)]
            pub const fn set_allhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn impebreak(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[inline(always)]
            pub const fn set_impebreak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Dmstatus {
            #[inline(always)]
            fn default() -> Dmstatus {
                Dmstatus(0)
            }
        }
        impl core::fmt::Debug for Dmstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmstatus")
                    .field("version", &self.version())
                    .field("confstrptrvalid", &self.confstrptrvalid())
                    .field("hasresethaltreq", &self.hasresethaltreq())
                    .field("authbusy", &self.authbusy())
                    .field("authenticated", &self.authenticated())
                    .field("anyhalted", &self.anyhalted())
                    .field("allhalted", &self.allhalted())
                    .field("anyrunning", &self.anyrunning())
                    .field("allrunning", &self.allrunning())
                    .field("anyunavail", &self.anyunavail())
                    .field("allunavail", &self.allunavail())
                    .field("anynonexistent", &self.anynonexistent())
                    .field("allnonexistent", &self.allnonexistent())
                    .field("anyresumeack", &self.anyresumeack())
                    .field("allresumeack", &self.allresumeack())
                    .field("anyhavereset", &self.anyhavereset())
                    .field("allhavereset", &self.allhavereset())
                    .field("impebreak", &self.impebreak())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dmstatus {{ version: {:?}, confstrptrvalid: {:?}, hasresethaltreq: {=bool:?}, authbusy: {=bool:?}, authenticated: {=bool:?}, anyhalted: {=bool:?}, allhalted: {=bool:?}, anyrunning: {=bool:?}, allrunning: {=bool:?}, anyunavail: {=bool:?}, allunavail: {=bool:?}, anynonexistent: {=bool:?}, allnonexistent: {=bool:?}, anyresumeack: {=bool:?}, allresumeack: {=bool:?}, anyhavereset: {=bool:?}, allhavereset: {=bool:?}, impebreak: {=bool:?} }}" , self . version () , self . confstrptrvalid () , self . hasresethaltreq () , self . authbusy () , self . authenticated () , self . anyhalted () , self . allhalted () , self . anyrunning () , self . allrunning () , self . anyunavail () , self . allunavail () , self . anynonexistent () , self . allnonexistent () , self . anyresumeack () , self . allresumeack () , self . anyhavereset () , self . allhavereset () , self . impebreak ())
            }
        }
        #[doc = "Hart Information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hartinfo(pub u32);
        impl Hartinfo {
            #[doc = "Data Address"]
            #[must_use]
            #[inline(always)]
            pub const fn dataaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Data Address"]
            #[inline(always)]
            pub const fn set_dataaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Data Size"]
            #[must_use]
            #[inline(always)]
            pub const fn datasize(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Data Size"]
            #[inline(always)]
            pub const fn set_datasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Data Access"]
            #[must_use]
            #[inline(always)]
            pub const fn dataaccess(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data Access"]
            #[inline(always)]
            pub const fn set_dataaccess(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Number of dscratch registers"]
            #[must_use]
            #[inline(always)]
            pub const fn nscratch(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of dscratch registers"]
            #[inline(always)]
            pub const fn set_nscratch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for Hartinfo {
            #[inline(always)]
            fn default() -> Hartinfo {
                Hartinfo(0)
            }
        }
        impl core::fmt::Debug for Hartinfo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hartinfo")
                    .field("dataaddr", &self.dataaddr())
                    .field("datasize", &self.datasize())
                    .field("dataaccess", &self.dataaccess())
                    .field("nscratch", &self.nscratch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hartinfo {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Hartinfo {{ dataaddr: {=u16:?}, datasize: {=u8:?}, dataaccess: {=bool:?}, nscratch: {=u8:?} }}" , self . dataaddr () , self . datasize () , self . dataaccess () , self . nscratch ())
            }
        }
        #[doc = "Hart Array Window Select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hawindowsel(pub u32);
        impl Hawindowsel {
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[must_use]
            #[inline(always)]
            pub const fn hawindowsel(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[inline(always)]
            pub const fn set_hawindowsel(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Hawindowsel {
            #[inline(always)]
            fn default() -> Hawindowsel {
                Hawindowsel(0)
            }
        }
        impl core::fmt::Debug for Hawindowsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hawindowsel")
                    .field("hawindowsel", &self.hawindowsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hawindowsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hawindowsel {{ hawindowsel: {=u16:?} }}",
                    self.hawindowsel()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[inline(always)]
            pub const fn set_triggered16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[inline(always)]
            pub const fn set_triggered17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[inline(always)]
            pub const fn set_triggered18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[inline(always)]
            pub const fn set_triggered19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[inline(always)]
            pub const fn set_triggered20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[inline(always)]
            pub const fn set_triggered21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[inline(always)]
            pub const fn set_triggered22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered16", &self.triggered16())
                    .field("triggered17", &self.triggered17())
                    .field("triggered18", &self.triggered18())
                    .field("triggered19", &self.triggered19())
                    .field("triggered20", &self.triggered20())
                    .field("triggered21", &self.triggered21())
                    .field("triggered22", &self.triggered22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ triggered16: {=bool:?}, triggered17: {=bool:?}, triggered18: {=bool:?}, triggered19: {=bool:?}, triggered20: {=bool:?}, triggered21: {=bool:?}, triggered22: {=bool:?} }}" , self . triggered16 () , self . triggered17 () , self . triggered18 () , self . triggered19 () , self . triggered20 () , self . triggered21 () , self . triggered22 ())
            }
        }
        #[doc = "System Bus Access Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbcs(pub u32);
        impl Sbcs {
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess8(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess16(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess32(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess64(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess64(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess128(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess128(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[must_use]
            #[inline(always)]
            pub const fn sbasize(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x7f;
                val as u8
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[inline(always)]
            pub const fn set_sbasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 5usize)) | (((val as u32) & 0x7f) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sberror(&self) -> super::vals::Sberror {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Sberror::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sberror(&mut self, val: super::vals::Sberror) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbreadondata(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbreadondata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbautoincrement(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbautoincrement(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess(&self) -> super::vals::Sbaccess {
                let val = (self.0 >> 17usize) & 0x07;
                super::vals::Sbaccess::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sbaccess(&mut self, val: super::vals::Sbaccess) {
                self.0 =
                    (self.0 & !(0x07 << 17usize)) | (((val.to_bits() as u32) & 0x07) << 17usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbreadonaddr(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbreadonaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbbusy(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbbusyerror(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbbusyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbversion(&self) -> super::vals::Sbversion {
                let val = (self.0 >> 29usize) & 0x07;
                super::vals::Sbversion::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sbversion(&mut self, val: super::vals::Sbversion) {
                self.0 =
                    (self.0 & !(0x07 << 29usize)) | (((val.to_bits() as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Sbcs {
            #[inline(always)]
            fn default() -> Sbcs {
                Sbcs(0)
            }
        }
        impl core::fmt::Debug for Sbcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbcs")
                    .field("sbaccess8", &self.sbaccess8())
                    .field("sbaccess16", &self.sbaccess16())
                    .field("sbaccess32", &self.sbaccess32())
                    .field("sbaccess64", &self.sbaccess64())
                    .field("sbaccess128", &self.sbaccess128())
                    .field("sbasize", &self.sbasize())
                    .field("sberror", &self.sberror())
                    .field("sbreadondata", &self.sbreadondata())
                    .field("sbautoincrement", &self.sbautoincrement())
                    .field("sbaccess", &self.sbaccess())
                    .field("sbreadonaddr", &self.sbreadonaddr())
                    .field("sbbusy", &self.sbbusy())
                    .field("sbbusyerror", &self.sbbusyerror())
                    .field("sbversion", &self.sbversion())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbcs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sbcs {{ sbaccess8: {=bool:?}, sbaccess16: {=bool:?}, sbaccess32: {=bool:?}, sbaccess64: {=bool:?}, sbaccess128: {=bool:?}, sbasize: {=u8:?}, sberror: {:?}, sbreadondata: {=bool:?}, sbautoincrement: {=bool:?}, sbaccess: {:?}, sbreadonaddr: {=bool:?}, sbbusy: {=bool:?}, sbbusyerror: {=bool:?}, sbversion: {:?} }}" , self . sbaccess8 () , self . sbaccess16 () , self . sbaccess32 () , self . sbaccess64 () , self . sbaccess128 () , self . sbasize () , self . sberror () , self . sbreadondata () , self . sbautoincrement () , self . sbaccess () , self . sbreadonaddr () , self . sbbusy () , self . sbbusyerror () , self . sbversion ())
            }
        }
        #[doc = "VPR state information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Vprstatus(pub u32);
        impl Vprstatus {
            #[must_use]
            #[inline(always)]
            pub const fn cpustatus(&self) -> super::vals::Cpustatus {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Cpustatus::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_cpustatus(&mut self, val: super::vals::Cpustatus) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Mirrors the ENABLERTPERIPH bit in the NORDIC.VPRNORDICCTRL CSR"]
            #[must_use]
            #[inline(always)]
            pub const fn rtpenabled(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Mirrors the ENABLERTPERIPH bit in the NORDIC.VPRNORDICCTRL CSR"]
            #[inline(always)]
            pub const fn set_rtpenabled(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Stalled waiting for real-time peripheral blocking CSR access, for example WAIT, OUTB with dirty status"]
            #[must_use]
            #[inline(always)]
            pub const fn rtpstall(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Stalled waiting for real-time peripheral blocking CSR access, for example WAIT, OUTB with dirty status"]
            #[inline(always)]
            pub const fn set_rtpstall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Vprstatus {
            #[inline(always)]
            fn default() -> Vprstatus {
                Vprstatus(0)
            }
        }
        impl core::fmt::Debug for Vprstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vprstatus")
                    .field("cpustatus", &self.cpustatus())
                    .field("rtpenabled", &self.rtpenabled())
                    .field("rtpstall", &self.rtpstall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Vprstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Vprstatus {{ cpustatus: {:?}, rtpenabled: {=bool:?}, rtpstall: {=bool:?} }}",
                    self.cpustatus(),
                    self.rtpenabled(),
                    self.rtpstall()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackhavereset {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the havereset for selected harts."]
            CLEAR = 0x01,
        }
        impl Ackhavereset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackhavereset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackhavereset {
            #[inline(always)]
            fn from(val: u8) -> Ackhavereset {
                Ackhavereset::from_bits(val)
            }
        }
        impl From<Ackhavereset> for u8 {
            #[inline(always)]
            fn from(val: Ackhavereset) -> u8 {
                Ackhavereset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clrresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Clrresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clrresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clrresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Clrresethaltreq {
                Clrresethaltreq::from_bits(val)
            }
        }
        impl From<Clrresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Clrresethaltreq) -> u8 {
                Clrresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmderr {
            #[doc = "No error."]
            NO_ERROR = 0x0,
            #[doc = "An abstract command was executing while command, abstractcs, or abstractauto was written, or when one of the data or progbuf registers was read or written. This status is only written if cmderr contains 0"]
            BUSY = 0x01,
            #[doc = "The requested command is notsupported, regardless of whether the hart is running or not."]
            NOT_SUPPORTED = 0x02,
            #[doc = "An exception occurred while executing the command (e.g. while executing theProgram Buffer)."]
            EXCEPTION = 0x03,
            #[doc = "The abstract command couldn't execute because the hart wasn't in the required state (running/halted). or unavailable."]
            HALT_RESUME = 0x04,
            #[doc = "The abstract command failed due to abus error (e.g. alignment, access size, or timeout)."]
            BUS = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "The command failed for another reason."]
            OTHER = 0x07,
        }
        impl Cmderr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmderr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmderr {
            #[inline(always)]
            fn from(val: u8) -> Cmderr {
                Cmderr::from_bits(val)
            }
        }
        impl From<Cmderr> for u8 {
            #[inline(always)]
            fn from(val: Cmderr) -> u8 {
                Cmderr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Cmdtype(u8);
        impl Cmdtype {
            #[doc = "Register Access Command"]
            pub const REGACCESS: Self = Self(0x0);
            #[doc = "Quick Access Command"]
            pub const QUICKACCESS: Self = Self(0x01);
            #[doc = "Memory Access Command"]
            pub const MEMACCESS: Self = Self(0x02);
        }
        impl Cmdtype {
            pub const fn from_bits(val: u8) -> Cmdtype {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Cmdtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("REGACCESS"),
                    0x01 => f.write_str("QUICKACCESS"),
                    0x02 => f.write_str("MEMACCESS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdtype {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "REGACCESS"),
                    0x01 => defmt::write!(f, "QUICKACCESS"),
                    0x02 => defmt::write!(f, "MEMACCESS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Cmdtype {
            #[inline(always)]
            fn from(val: u8) -> Cmdtype {
                Cmdtype::from_bits(val)
            }
        }
        impl From<Cmdtype> for u8 {
            #[inline(always)]
            fn from(val: Cmdtype) -> u8 {
                Cmdtype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Confstrptrvalid {
            #[doc = "The confstrptr0..confstrptr3 holds information which is not relevant to the configuration string."]
            NOT_RELEVANT = 0x0,
            #[doc = "The confstrptr0..confstrptr3 holds the address of the configuration string."]
            ADDRESS = 0x01,
        }
        impl Confstrptrvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Confstrptrvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Confstrptrvalid {
            #[inline(always)]
            fn from(val: u8) -> Confstrptrvalid {
                Confstrptrvalid::from_bits(val)
            }
        }
        impl From<Confstrptrvalid> for u8 {
            #[inline(always)]
            fn from(val: Confstrptrvalid) -> u8 {
                Confstrptrvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpurunEn {
            #[doc = "CPU stopped. If this is the CPU state after a core reset, setting this bit will change the CPU state to CPU running."]
            STOPPED = 0x0,
            #[doc = "CPU running. If this is the CPU state after a core reset, clearing this bit will change the CPU state to CPU stopped after a core reset."]
            RUNNING = 0x01,
        }
        impl CpurunEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CpurunEn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CpurunEn {
            #[inline(always)]
            fn from(val: u8) -> CpurunEn {
                CpurunEn::from_bits(val)
            }
        }
        impl From<CpurunEn> for u8 {
            #[inline(always)]
            fn from(val: CpurunEn) -> u8 {
                CpurunEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpustatus {
            #[doc = "WAITING (not yet started)"]
            WAITING = 0x0,
            #[doc = "RUNNING"]
            RUNNING = 0x01,
            #[doc = "SLEEPING"]
            SLEEPING = 0x02,
            #[doc = "INTERRUPT (in handler)"]
            INTERRUPT = 0x03,
            #[doc = "EXCEPTION/TRAP (in handler)"]
            EXCEPTION_TRAP = 0x04,
            #[doc = "ONGOING_RESET"]
            ONGOING_RESET = 0x05,
            #[doc = "HALTED"]
            HALTED = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            #[doc = "ERROR (lockup, needs debugging or reset)"]
            ERROR = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cpustatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpustatus {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpustatus {
            #[inline(always)]
            fn from(val: u8) -> Cpustatus {
                Cpustatus::from_bits(val)
            }
        }
        impl From<Cpustatus> for u8 {
            #[inline(always)]
            fn from(val: Cpustatus) -> u8 {
                Cpustatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Haltreq {
            #[doc = "Clears halt request bit for all currently selected harts."]
            CLEAR = 0x0,
            #[doc = "Currently selected harts halted."]
            HALT = 0x01,
        }
        impl Haltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Haltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Haltreq {
            #[inline(always)]
            fn from(val: u8) -> Haltreq {
                Haltreq::from_bits(val)
            }
        }
        impl From<Haltreq> for u8 {
            #[inline(always)]
            fn from(val: Haltreq) -> u8 {
                Haltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hasel {
            #[doc = "Single hart selected."]
            SINGLE = 0x0,
            #[doc = "Multiple harts selected"]
            MULTIPLE = 0x01,
        }
        impl Hasel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hasel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hasel {
            #[inline(always)]
            fn from(val: u8) -> Hasel {
                Hasel::from_bits(val)
            }
        }
        impl From<Hasel> for u8 {
            #[inline(always)]
            fn from(val: Hasel) -> u8 {
                Hasel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resumereq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Currently selected harts resumed."]
            RESUMED = 0x01,
        }
        impl Resumereq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resumereq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resumereq {
            #[inline(always)]
            fn from(val: u8) -> Resumereq {
                Resumereq::from_bits(val)
            }
        }
        impl From<Resumereq> for u8 {
            #[inline(always)]
            fn from(val: Resumereq) -> u8 {
                Resumereq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbaccess {
            #[doc = "8-bit."]
            SIZE8 = 0x0,
            #[doc = "16-bit."]
            SIZE16 = 0x01,
            #[doc = "32-bit."]
            SIZE32 = 0x02,
            #[doc = "64-bit."]
            SIZE64 = 0x03,
            #[doc = "128-bit."]
            SIZE128 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbaccess {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbaccess {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbaccess {
            #[inline(always)]
            fn from(val: u8) -> Sbaccess {
                Sbaccess::from_bits(val)
            }
        }
        impl From<Sbaccess> for u8 {
            #[inline(always)]
            fn from(val: Sbaccess) -> u8 {
                Sbaccess::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sberror {
            #[doc = "There was no bus error."]
            NORMAL = 0x0,
            #[doc = "There was a timeout."]
            TIMEOUT = 0x01,
            #[doc = "A bad address was accessed."]
            ADDRESS = 0x02,
            #[doc = "There was an alignment error."]
            ALIGNMENT = 0x03,
            #[doc = "An access of unsupported size was requested."]
            SIZE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Other."]
            OTHER = 0x07,
        }
        impl Sberror {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sberror {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sberror {
            #[inline(always)]
            fn from(val: u8) -> Sberror {
                Sberror::from_bits(val)
            }
        }
        impl From<Sberror> for u8 {
            #[inline(always)]
            fn from(val: Sberror) -> u8 {
                Sberror::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbversion {
            #[doc = "The System Bus interface conforms to mainline drafts of thia RISC-V External Debug Support spec older than 1 January, 2018."]
            VERSION0 = 0x0,
            #[doc = "The System Bus interface conforms to RISC-V External Debug Support version 0.14.0-DRAFT. Other values are reserved for future versions."]
            VERSION1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbversion {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbversion {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbversion {
            #[inline(always)]
            fn from(val: u8) -> Sbversion {
                Sbversion::from_bits(val)
            }
        }
        impl From<Sbversion> for u8 {
            #[inline(always)]
            fn from(val: Sbversion) -> u8 {
                Sbversion::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Setresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Sets the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Setresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Setresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Setresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Setresethaltreq {
                Setresethaltreq::from_bits(val)
            }
        }
        impl From<Setresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Setresethaltreq) -> u8 {
                Setresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Version {
            #[doc = "Debug module not present."]
            NOT_PRESENT = 0x0,
            #[doc = "There is a Debug Module and it conforms to version 0.11 of this specifcation."]
            V011 = 0x01,
            #[doc = "There is a Debug Module and it conforms to version 0.13 of this specifcation."]
            V013 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "There is a Debug Module but it does not conform to any available version of the spec."]
            NON_CONFORM = 0x0f,
        }
        impl Version {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Version {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Version {
            #[inline(always)]
            fn from(val: u8) -> Version {
                Version::from_bits(val)
            }
        }
        impl From<Version> for u8 {
            #[inline(always)]
            fn from(val: Version) -> u8 {
                Version::to_bits(val)
            }
        }
    }
}
pub mod vregusb {
    #[doc = "VREGUSB peripheral 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregusb {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregusb {}
    unsafe impl Sync for Vregusb {}
    impl Vregusb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable and start VREGUSB so that it can detect VBUS"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop and disable VREGUSB"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "VBUS detected"]
        #[inline(always)]
        pub const fn events_vbusdetected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "VBUS removed"]
        #[inline(always)]
        pub const fn events_vbusremoved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event VBUSDETECTED"]
            #[must_use]
            #[inline(always)]
            pub const fn vbusdetected(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event VBUSDETECTED"]
            #[inline(always)]
            pub const fn set_vbusdetected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event VBUSREMOVED"]
            #[must_use]
            #[inline(always)]
            pub const fn vbusremoved(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event VBUSREMOVED"]
            #[inline(always)]
            pub const fn set_vbusremoved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("vbusdetected", &self.vbusdetected())
                    .field("vbusremoved", &self.vbusremoved())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ vbusdetected: {=bool:?}, vbusremoved: {=bool:?} }}",
                    self.vbusdetected(),
                    self.vbusremoved()
                )
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start WDT"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop WDT"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Watchdog timeout"]
        #[inline(always)]
        pub const fn events_timeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Watchdog stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event TIMEOUT"]
        #[inline(always)]
        pub const fn publish_timeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn nmienset(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0324usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn nmienclr(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0328usize) as _) }
        }
        #[doc = "Run status"]
        #[inline(always)]
        pub const fn runstatus(self) -> crate::common::Reg<regs::Runstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Request status"]
        #[inline(always)]
        pub const fn reqstatus(self) -> crate::common::Reg<regs::Reqstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Counter reload value"]
        #[inline(always)]
        pub const fn crv(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Enable register for reload request registers"]
        #[inline(always)]
        pub const fn rren(self) -> crate::common::Reg<regs::Rren, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Task stop enable"]
        #[inline(always)]
        pub const fn tsen(self) -> crate::common::Reg<regs::Tsen, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Description collection: Reload request n"]
        #[inline(always)]
        pub const fn rr(self, n: usize) -> crate::common::Reg<regs::Rr, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0600usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[must_use]
            #[inline(always)]
            pub const fn sleep(&self) -> super::vals::Sleep {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleep::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[inline(always)]
            pub const fn set_sleep(&mut self, val: super::vals::Sleep) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[must_use]
            #[inline(always)]
            pub const fn halt(&self) -> super::vals::Halt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Halt::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[inline(always)]
            pub const fn set_halt(&mut self, val: super::vals::Halt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Allow stopping WDT"]
            #[must_use]
            #[inline(always)]
            pub const fn stopen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn set_stopen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("sleep", &self.sleep())
                    .field("halt", &self.halt())
                    .field("stopen", &self.stopen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ sleep: {:?}, halt: {:?}, stopen: {=bool:?} }}",
                    self.sleep(),
                    self.halt(),
                    self.stopen()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ timeout: {=bool:?}, stopped: {=bool:?} }}",
                    self.timeout(),
                    self.stopped()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmi(pub u32);
        impl Nmi {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Nmi {
            #[inline(always)]
            fn default() -> Nmi {
                Nmi(0)
            }
        }
        impl core::fmt::Debug for Nmi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmi")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmi {{ timeout: {=bool:?}, stopped: {=bool:?} }}",
                    self.timeout(),
                    self.stopped()
                )
            }
        }
        #[doc = "Request status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reqstatus(pub u32);
        impl Reqstatus {
            #[doc = "Request status for RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Request status for RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Reqstatus {
            #[inline(always)]
            fn default() -> Reqstatus {
                Reqstatus(0)
            }
        }
        impl core::fmt::Debug for Reqstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reqstatus")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reqstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Reqstatus {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Description collection: Reload request n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rr(pub u32);
        impl Rr {
            #[doc = "Reload request register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self) -> super::vals::Rr {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rr::from_bits(val as u32)
            }
            #[doc = "Reload request register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, val: super::vals::Rr) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rr {
            #[inline(always)]
            fn default() -> Rr {
                Rr(0)
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rr").field("rr", &self.rr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rr {{ rr: {:?} }}", self.rr())
            }
        }
        #[doc = "Enable register for reload request registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rren(pub u32);
        impl Rren {
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Rren {
            #[inline(always)]
            fn default() -> Rren {
                Rren(0)
            }
        }
        impl core::fmt::Debug for Rren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rren")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rren {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rren {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Run status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Runstatus(pub u32);
        impl Runstatus {
            #[doc = "Indicates whether or not WDT is running"]
            #[must_use]
            #[inline(always)]
            pub const fn runstatuswdt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether or not WDT is running"]
            #[inline(always)]
            pub const fn set_runstatuswdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Runstatus {
            #[inline(always)]
            fn default() -> Runstatus {
                Runstatus(0)
            }
        }
        impl core::fmt::Debug for Runstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Runstatus")
                    .field("runstatuswdt", &self.runstatuswdt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Runstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Runstatus {{ runstatuswdt: {=bool:?} }}",
                    self.runstatuswdt()
                )
            }
        }
        #[doc = "Task stop enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsen(pub u32);
        impl Tsen {
            #[doc = "Allow stopping WDT"]
            #[must_use]
            #[inline(always)]
            pub const fn tsen(&self) -> super::vals::Tsen {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Tsen::from_bits(val as u32)
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn set_tsen(&mut self, val: super::vals::Tsen) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Tsen {
            #[inline(always)]
            fn default() -> Tsen {
                Tsen(0)
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsen").field("tsen", &self.tsen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tsen {{ tsen: {:?} }}", self.tsen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Halt {
            #[doc = "Pause WDT while the CPU is halted by the debugger"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is halted by the debugger"]
            RUN = 0x01,
        }
        impl Halt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Halt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Halt {
            #[inline(always)]
            fn from(val: u8) -> Halt {
                Halt::from_bits(val)
            }
        }
        impl From<Halt> for u8 {
            #[inline(always)]
            fn from(val: Halt) -> u8 {
                Halt::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rr(u32);
        impl Rr {
            #[doc = "Value to request a reload of the watchdog timer"]
            pub const RELOAD: Self = Self(0x6e52_4635);
        }
        impl Rr {
            pub const fn from_bits(val: u32) -> Rr {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("RELOAD"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "RELOAD"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rr {
            #[inline(always)]
            fn from(val: u32) -> Rr {
                Rr::from_bits(val)
            }
        }
        impl From<Rr> for u32 {
            #[inline(always)]
            fn from(val: Rr) -> u32 {
                Rr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleep {
            #[doc = "Pause WDT while the CPU is sleeping"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is sleeping"]
            RUN = 0x01,
        }
        impl Sleep {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleep {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleep {
            #[inline(always)]
            fn from(val: u8) -> Sleep {
                Sleep::from_bits(val)
            }
        }
        impl From<Sleep> for u8 {
            #[inline(always)]
            fn from(val: Sleep) -> u8 {
                Sleep::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tsen(u32);
        impl Tsen {
            #[doc = "Value to allow stopping WDT"]
            pub const ENABLE: Self = Self(0x6e52_4635);
        }
        impl Tsen {
            pub const fn from_bits(val: u32) -> Tsen {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("ENABLE"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "ENABLE"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Tsen {
            #[inline(always)]
            fn from(val: u32) -> Tsen {
                Tsen::from_bits(val)
            }
        }
        impl From<Tsen> for u32 {
            #[inline(always)]
            fn from(val: Tsen) -> u32 {
                Tsen::to_bits(val)
            }
        }
    }
}
