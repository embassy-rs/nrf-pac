#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (0f1a0f5 2025-12-10))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "3 - SPU"]
    SPU = 3,
    #[doc = "5 - CLOCK_POWER"]
    CLOCK_POWER = 5,
    #[doc = "8 - SERIAL0"]
    SERIAL0 = 8,
    #[doc = "9 - SERIAL1"]
    SERIAL1 = 9,
    #[doc = "10 - SERIAL2"]
    SERIAL2 = 10,
    #[doc = "11 - SERIAL3"]
    SERIAL3 = 11,
    #[doc = "13 - GPIOTE0"]
    GPIOTE0 = 13,
    #[doc = "14 - SAADC"]
    SAADC = 14,
    #[doc = "15 - TIMER0"]
    TIMER0 = 15,
    #[doc = "16 - TIMER1"]
    TIMER1 = 16,
    #[doc = "17 - TIMER2"]
    TIMER2 = 17,
    #[doc = "20 - RTC0"]
    RTC0 = 20,
    #[doc = "21 - RTC1"]
    RTC1 = 21,
    #[doc = "24 - WDT"]
    WDT = 24,
    #[doc = "27 - EGU0"]
    EGU0 = 27,
    #[doc = "28 - EGU1"]
    EGU1 = 28,
    #[doc = "29 - EGU2"]
    EGU2 = 29,
    #[doc = "30 - EGU3"]
    EGU3 = 30,
    #[doc = "31 - EGU4"]
    EGU4 = 31,
    #[doc = "32 - EGU5"]
    EGU5 = 32,
    #[doc = "33 - PWM0"]
    PWM0 = 33,
    #[doc = "34 - PWM1"]
    PWM1 = 34,
    #[doc = "35 - PWM2"]
    PWM2 = 35,
    #[doc = "36 - PWM3"]
    PWM3 = 36,
    #[doc = "38 - PDM"]
    PDM = 38,
    #[doc = "40 - I2S"]
    I2S = 40,
    #[doc = "42 - IPC"]
    IPC = 42,
    #[doc = "44 - FPU"]
    FPU = 44,
    #[doc = "49 - GPIOTE1"]
    GPIOTE1 = 49,
    #[doc = "57 - KMU"]
    KMU = 57,
    #[doc = "64 - CRYPTOCELL"]
    CRYPTOCELL = 64,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    unsafe extern "C" {
        fn SPU();
        fn CLOCK_POWER();
        fn SERIAL0();
        fn SERIAL1();
        fn SERIAL2();
        fn SERIAL3();
        fn GPIOTE0();
        fn SAADC();
        fn TIMER0();
        fn TIMER1();
        fn TIMER2();
        fn RTC0();
        fn RTC1();
        fn WDT();
        fn EGU0();
        fn EGU1();
        fn EGU2();
        fn EGU3();
        fn EGU4();
        fn EGU5();
        fn PWM0();
        fn PWM1();
        fn PWM2();
        fn PWM3();
        fn PDM();
        fn I2S();
        fn IPC();
        fn FPU();
        fn GPIOTE1();
        fn KMU();
        fn CRYPTOCELL();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[unsafe(link_section = ".vector_table.interrupts")]
    #[unsafe(no_mangle)]
    pub static __INTERRUPTS: [Vector; 65] = [
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU },
        Vector { _reserved: 0 },
        Vector {
            _handler: CLOCK_POWER,
        },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL0 },
        Vector { _handler: SERIAL1 },
        Vector { _handler: SERIAL2 },
        Vector { _handler: SERIAL3 },
        Vector { _reserved: 0 },
        Vector { _handler: GPIOTE0 },
        Vector { _handler: SAADC },
        Vector { _handler: TIMER0 },
        Vector { _handler: TIMER1 },
        Vector { _handler: TIMER2 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: RTC0 },
        Vector { _handler: RTC1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: WDT },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: EGU0 },
        Vector { _handler: EGU1 },
        Vector { _handler: EGU2 },
        Vector { _handler: EGU3 },
        Vector { _handler: EGU4 },
        Vector { _handler: EGU5 },
        Vector { _handler: PWM0 },
        Vector { _handler: PWM1 },
        Vector { _handler: PWM2 },
        Vector { _handler: PWM3 },
        Vector { _reserved: 0 },
        Vector { _handler: PDM },
        Vector { _reserved: 0 },
        Vector { _handler: I2S },
        Vector { _reserved: 0 },
        Vector { _handler: IPC },
        Vector { _reserved: 0 },
        Vector { _handler: FPU },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: GPIOTE1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: KMU },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: CRYPTOCELL,
        },
    ];
}
#[doc = "Factory Information Configuration Registers"]
pub const FICR_S: ficr::Ficr = unsafe { ficr::Ficr::from_ptr(0x00ff_0000usize as _) };
#[doc = "User information configuration registers User information configuration registers"]
pub const UICR_S: uicr::Uicr = unsafe { uicr::Uicr::from_ptr(0x00ff_8000usize as _) };
#[doc = "Voltage regulators control 0"]
pub const REGULATORS_NS: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x4000_4000usize as _) };
#[doc = "Clock management 0"]
pub const CLOCK_NS: clock::Clock = unsafe { clock::Clock::from_ptr(0x4000_5000usize as _) };
#[doc = "Power control 0"]
pub const POWER_NS: power::Power = unsafe { power::Power::from_ptr(0x4000_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub const SPIM0_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4000_8000usize as _) };
#[doc = "SPI Slave 0"]
pub const SPIS0_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4000_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub const TWIM0_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4000_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub const TWIS0_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4000_8000usize as _) };
#[doc = "UART with EasyDMA 0"]
pub const UARTE0_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4000_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub const SPIM1_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4000_9000usize as _) };
#[doc = "SPI Slave 2"]
pub const SPIS1_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4000_9000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub const TWIM1_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4000_9000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub const TWIS1_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4000_9000usize as _) };
#[doc = "UART with EasyDMA 2"]
pub const UARTE1_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4000_9000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub const SPIM2_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4000_a000usize as _) };
#[doc = "SPI Slave 4"]
pub const SPIS2_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4000_a000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub const TWIM2_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4000_a000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub const TWIS2_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4000_a000usize as _) };
#[doc = "UART with EasyDMA 4"]
pub const UARTE2_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4000_a000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub const SPIM3_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4000_b000usize as _) };
#[doc = "SPI Slave 6"]
pub const SPIS3_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4000_b000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub const TWIM3_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4000_b000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub const TWIS3_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4000_b000usize as _) };
#[doc = "UART with EasyDMA 6"]
pub const UARTE3_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4000_b000usize as _) };
#[doc = "Analog to Digital Converter 0"]
pub const SAADC_NS: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x4000_e000usize as _) };
#[doc = "Timer/Counter 0"]
pub const TIMER0_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4000_f000usize as _) };
#[doc = "Timer/Counter 2"]
pub const TIMER1_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4001_0000usize as _) };
#[doc = "Timer/Counter 4"]
pub const TIMER2_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4001_1000usize as _) };
#[doc = "Real-time counter 0"]
pub const RTC0_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4001_4000usize as _) };
#[doc = "Real-time counter 2"]
pub const RTC1_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4001_5000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub const DPPIC_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4001_7000usize as _) };
#[doc = "Watchdog Timer 0"]
pub const WDT_NS: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4001_8000usize as _) };
#[doc = "Event generator unit 0"]
pub const EGU0_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4001_b000usize as _) };
#[doc = "Event generator unit 2"]
pub const EGU1_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4001_c000usize as _) };
#[doc = "Event generator unit 4"]
pub const EGU2_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4001_d000usize as _) };
#[doc = "Event generator unit 6"]
pub const EGU3_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4001_e000usize as _) };
#[doc = "Event generator unit 8"]
pub const EGU4_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4001_f000usize as _) };
#[doc = "Event generator unit 10"]
pub const EGU5_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4002_0000usize as _) };
#[doc = "Pulse width modulation unit 0"]
pub const PWM0_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x4002_1000usize as _) };
#[doc = "Pulse width modulation unit 2"]
pub const PWM1_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x4002_2000usize as _) };
#[doc = "Pulse width modulation unit 4"]
pub const PWM2_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x4002_3000usize as _) };
#[doc = "Pulse width modulation unit 6"]
pub const PWM3_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x4002_4000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub const PDM_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x4002_6000usize as _) };
#[doc = "Inter-IC Sound 0"]
pub const I2S_NS: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x4002_8000usize as _) };
#[doc = "Interprocessor communication 0"]
pub const IPC_NS: ipc::Ipc = unsafe { ipc::Ipc::from_ptr(0x4002_a000usize as _) };
#[doc = "FPU"]
pub const FPU_NS: fpu::Fpu = unsafe { fpu::Fpu::from_ptr(0x4002_c000usize as _) };
#[doc = "GPIO Tasks and Events 1"]
pub const GPIOTE1_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x4003_1000usize as _) };
#[doc = "Key management unit 0"]
pub const KMU_NS: kmu::Kmu = unsafe { kmu::Kmu::from_ptr(0x4003_9000usize as _) };
#[doc = "Non-volatile memory controller 0"]
pub const NVMC_NS: nvmc::Nvmc = unsafe { nvmc::Nvmc::from_ptr(0x4003_9000usize as _) };
#[doc = "Volatile Memory controller 0"]
pub const VMC_NS: vmc::Vmc = unsafe { vmc::Vmc::from_ptr(0x4003_a000usize as _) };
#[doc = "GPIO Port 0"]
pub const P0_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4084_2500usize as _) };
#[doc = "System protection unit"]
pub const SPU_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5000_3000usize as _) };
#[doc = "Voltage regulators control 1"]
pub const REGULATORS_S: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x5000_4000usize as _) };
#[doc = "Clock management 1"]
pub const CLOCK_S: clock::Clock = unsafe { clock::Clock::from_ptr(0x5000_5000usize as _) };
#[doc = "Power control 1"]
pub const POWER_S: power::Power = unsafe { power::Power::from_ptr(0x5000_5000usize as _) };
#[doc = "Control access port"]
pub const CTRL_AP_PERI_S: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x5000_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub const SPIM0_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5000_8000usize as _) };
#[doc = "SPI Slave 1"]
pub const SPIS0_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5000_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub const TWIM0_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5000_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub const TWIS0_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5000_8000usize as _) };
#[doc = "UART with EasyDMA 1"]
pub const UARTE0_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5000_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub const SPIM1_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5000_9000usize as _) };
#[doc = "SPI Slave 3"]
pub const SPIS1_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5000_9000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub const TWIM1_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5000_9000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub const TWIS1_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5000_9000usize as _) };
#[doc = "UART with EasyDMA 3"]
pub const UARTE1_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5000_9000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub const SPIM2_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5000_a000usize as _) };
#[doc = "SPI Slave 5"]
pub const SPIS2_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5000_a000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub const TWIM2_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5000_a000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub const TWIS2_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5000_a000usize as _) };
#[doc = "UART with EasyDMA 5"]
pub const UARTE2_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5000_a000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub const SPIM3_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5000_b000usize as _) };
#[doc = "SPI Slave 7"]
pub const SPIS3_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5000_b000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub const TWIM3_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5000_b000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub const TWIS3_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5000_b000usize as _) };
#[doc = "UART with EasyDMA 7"]
pub const UARTE3_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5000_b000usize as _) };
#[doc = "GPIO Tasks and Events 0"]
pub const GPIOTE0_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x5000_d000usize as _) };
#[doc = "Analog to Digital Converter 1"]
pub const SAADC_S: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x5000_e000usize as _) };
#[doc = "Timer/Counter 1"]
pub const TIMER0_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5000_f000usize as _) };
#[doc = "Timer/Counter 3"]
pub const TIMER1_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5001_0000usize as _) };
#[doc = "Timer/Counter 5"]
pub const TIMER2_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5001_1000usize as _) };
#[doc = "Real-time counter 1"]
pub const RTC0_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5001_4000usize as _) };
#[doc = "Real-time counter 3"]
pub const RTC1_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5001_5000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub const DPPIC_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5001_7000usize as _) };
#[doc = "Watchdog Timer 1"]
pub const WDT_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5001_8000usize as _) };
#[doc = "Event generator unit 1"]
pub const EGU0_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5001_b000usize as _) };
#[doc = "Event generator unit 3"]
pub const EGU1_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5001_c000usize as _) };
#[doc = "Event generator unit 5"]
pub const EGU2_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5001_d000usize as _) };
#[doc = "Event generator unit 7"]
pub const EGU3_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5001_e000usize as _) };
#[doc = "Event generator unit 9"]
pub const EGU4_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5001_f000usize as _) };
#[doc = "Event generator unit 11"]
pub const EGU5_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5002_0000usize as _) };
#[doc = "Pulse width modulation unit 1"]
pub const PWM0_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x5002_1000usize as _) };
#[doc = "Pulse width modulation unit 3"]
pub const PWM1_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x5002_2000usize as _) };
#[doc = "Pulse width modulation unit 5"]
pub const PWM2_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x5002_3000usize as _) };
#[doc = "Pulse width modulation unit 7"]
pub const PWM3_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x5002_4000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub const PDM_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x5002_6000usize as _) };
#[doc = "Inter-IC Sound 1"]
pub const I2S_S: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x5002_8000usize as _) };
#[doc = "Interprocessor communication 1"]
pub const IPC_S: ipc::Ipc = unsafe { ipc::Ipc::from_ptr(0x5002_a000usize as _) };
#[doc = "Key management unit 1"]
pub const KMU_S: kmu::Kmu = unsafe { kmu::Kmu::from_ptr(0x5003_9000usize as _) };
#[doc = "Non-volatile memory controller 1"]
pub const NVMC_S: nvmc::Nvmc = unsafe { nvmc::Nvmc::from_ptr(0x5003_9000usize as _) };
#[doc = "Volatile Memory controller 1"]
pub const VMC_S: vmc::Vmc = unsafe { vmc::Vmc::from_ptr(0x5003_a000usize as _) };
#[doc = "CRYPTOCELL register interface"]
pub const CRYPTOCELL_S: cryptocell::Cryptocell =
    unsafe { cryptocell::Cryptocell::from_ptr(0x5084_0000usize as _) };
#[doc = "CRYPTOCELL AES engine"]
pub const CC_AES_S: cc_aes::CcAes = unsafe { cc_aes::CcAes::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL AHB interface"]
pub const CC_AHB_S: cc_ahb::CcAhb = unsafe { cc_ahb::CcAhb::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL CHACHA engine"]
pub const CC_CHACHA_S: cc_chacha::CcChacha =
    unsafe { cc_chacha::CcChacha::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL CTL interface"]
pub const CC_CTL_S: cc_ctl::CcCtl = unsafe { cc_ctl::CcCtl::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL Data IN interface"]
pub const CC_DIN_S: cc_din::CcDin = unsafe { cc_din::CcDin::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL Data OUT interface"]
pub const CC_DOUT_S: cc_dout::CcDout = unsafe { cc_dout::CcDout::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL HASH engine"]
pub const CC_HASH_S: cc_hash::CcHash = unsafe { cc_hash::CcHash::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL HOST register interface"]
pub const CC_HOST_RGF_S: cc_host_rgf::CcHostRgf =
    unsafe { cc_host_rgf::CcHostRgf::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL MISC interface"]
pub const CC_MISC_S: cc_misc::CcMisc = unsafe { cc_misc::CcMisc::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL PKA engine"]
pub const CC_PKA_S: cc_pka::CcPka = unsafe { cc_pka::CcPka::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL RNG engine"]
pub const CC_RNG_S: cc_rng::CcRng = unsafe { cc_rng::CcRng::from_ptr(0x5084_1000usize as _) };
#[doc = "CRYPTOCELL RNG SRAM interface"]
pub const CC_RNG_SRAM_S: cc_rng_sram::CcRngSram =
    unsafe { cc_rng_sram::CcRngSram::from_ptr(0x5084_1000usize as _) };
#[doc = "GPIO Port 1"]
pub const P0_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5084_2500usize as _) };
#[doc = "Embedded Trace Macrocell"]
pub const ETM_NS: etm::Etm = unsafe { etm::Etm::from_ptr(0xe004_1000usize as _) };
#[doc = "Embedded Trace Buffer"]
pub const ETB_NS: etb::Etb = unsafe { etb::Etb::from_ptr(0xe005_1000usize as _) };
#[doc = "Trace Port Interface Unit"]
pub const TPIU_NS: tpiu::Tpiu = unsafe { tpiu::Tpiu::from_ptr(0xe005_4000usize as _) };
#[doc = "ATB Replicator module"]
pub const ATBREPLICATOR_NS: atbreplicator::Atbreplicator =
    unsafe { atbreplicator::Atbreplicator::from_ptr(0xe005_8000usize as _) };
#[doc = "ATB funnel module 0"]
pub const ATBFUNNEL1_NS: atbfunnel::Atbfunnel =
    unsafe { atbfunnel::Atbfunnel::from_ptr(0xe005_a000usize as _) };
#[doc = "ATB funnel module 1"]
pub const ATBFUNNEL2_NS: atbfunnel::Atbfunnel =
    unsafe { atbfunnel::Atbfunnel::from_ptr(0xe005_b000usize as _) };
#[doc = "Trace and debug control"]
pub const TAD_S: tad::Tad = unsafe { tad::Tad::from_ptr(0xe008_0000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod atbfunnel {
    #[doc = "ATB funnel module 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Atbfunnel {
        ptr: *mut u8,
    }
    unsafe impl Send for Atbfunnel {}
    unsafe impl Sync for Atbfunnel {}
    impl Atbfunnel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The IDFILTER0 register enables the programming of ID filtering for master port 0."]
        #[inline(always)]
        pub const fn ctrlreg(self) -> crate::common::Reg<regs::Ctrlreg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "The Priority_Ctrl_Reg register defines the order in which inputs are selected. Each 3-bit field is a priority for each particular slave interface."]
        #[inline(always)]
        pub const fn priorityctrlreg(
            self,
        ) -> crate::common::Reg<regs::Priorityctrlreg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "The ITATBDATA0 register performs different functions depending on whether the access is a read or a write."]
        #[inline(always)]
        pub const fn itatbdata0(self) -> crate::common::Reg<regs::Itatbdata0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0eecusize) as _) }
        }
        #[doc = "The ITATBCTR2 register performs different functions depending on whether the access is a read or a write."]
        #[inline(always)]
        pub const fn itatbctr2(self) -> crate::common::Reg<regs::Itatbctr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef0usize) as _) }
        }
        #[doc = "The ITATBCTR1 register performs different functions depending on whether the access is a read or a write."]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef4usize) as _) }
        }
        #[doc = "The ITATBCTR0 register performs different functions depending on whether the access is a read or a write."]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef8usize) as _) }
        }
        #[doc = "The ITCTRL register enables the component to switch from a functional mode, which is the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for the purposes of integration testing and topology detection."]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa0usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa4usize) as _) }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<regs::Lar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb0usize) as _) }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb8usize) as _) }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fc8usize) as _) }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fccusize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fd0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe4usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe8usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fecusize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff0usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff4usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff8usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Authstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "Read or clear claim bit 0."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimclrBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimclrBit0::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimclrBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Read or clear claim bit 1."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimclrBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimclrBit1::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimclrBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Read or clear claim bit 2."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimclrBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimclrBit2::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimclrBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Read or clear claim bit 3."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimclrBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimclrBit3::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimclrBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimclr {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimsetBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimsetBit0::from_bits(val as u8)
            }
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimsetBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimsetBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimsetBit1::from_bits(val as u8)
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimsetBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimsetBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimsetBit2::from_bits(val as u8)
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimsetBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimsetBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimsetBit3::from_bits(val as u8)
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimsetBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimset {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "The IDFILTER0 register enables the programming of ID filtering for master port 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctrlreg(pub u32);
        impl Ctrlreg {
            #[doc = "Enable slave port 0."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 0."]
            #[inline(always)]
            pub const fn set_ens_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable slave port 1."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 1."]
            #[inline(always)]
            pub const fn set_ens_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable slave port 2."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 2."]
            #[inline(always)]
            pub const fn set_ens_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable slave port 3."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 3."]
            #[inline(always)]
            pub const fn set_ens_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable slave port 4."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 4."]
            #[inline(always)]
            pub const fn set_ens_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable slave port 5."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 5."]
            #[inline(always)]
            pub const fn set_ens_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable slave port 6."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 6."]
            #[inline(always)]
            pub const fn set_ens_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable slave port 7."]
            #[must_use]
            #[inline(always)]
            pub const fn ens_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable slave port 7."]
            #[inline(always)]
            pub const fn set_ens_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Hold Time. The formatting scheme can become inefficient when fast switching occurs, and you can use this setting to minimize switching. When a source has nothing to transmit, then another source is selected irrespective of the minimum number of transactions. The ATB funnel holds for the minimum hold time and one additional transaction. The actual hold time is the register value plus 1. The maximum value that can be entered is 0b1110 and this equates to 15 transactions. 0b1111 is reserved."]
            #[must_use]
            #[inline(always)]
            pub const fn ht(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Hold Time. The formatting scheme can become inefficient when fast switching occurs, and you can use this setting to minimize switching. When a source has nothing to transmit, then another source is selected irrespective of the minimum number of transactions. The ATB funnel holds for the minimum hold time and one additional transaction. The actual hold time is the register value plus 1. The maximum value that can be entered is 0b1110 and this equates to 15 transactions. 0b1111 is reserved."]
            #[inline(always)]
            pub const fn set_ht(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Ctrlreg {
            #[inline(always)]
            fn default() -> Ctrlreg {
                Ctrlreg(0)
            }
        }
        impl core::fmt::Debug for Ctrlreg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctrlreg")
                    .field("ens_0", &self.ens_0())
                    .field("ens_1", &self.ens_1())
                    .field("ens_2", &self.ens_2())
                    .field("ens_3", &self.ens_3())
                    .field("ens_4", &self.ens_4())
                    .field("ens_5", &self.ens_5())
                    .field("ens_6", &self.ens_6())
                    .field("ens_7", &self.ens_7())
                    .field("ht", &self.ht())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctrlreg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ctrlreg {{ ens_0: {=bool:?}, ens_1: {=bool:?}, ens_2: {=bool:?}, ens_3: {=bool:?}, ens_4: {=bool:?}, ens_5: {=bool:?}, ens_6: {=bool:?}, ens_7: {=bool:?}, ht: {=u8:?} }}" , self . ens_0 () , self . ens_1 () , self . ens_2 () , self . ens_3 () , self . ens_4 () , self . ens_5 () , self . ens_6 () , self . ens_7 () , self . ht ())
            }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "Indicates the number of input ports connected. 0x0 and 0x1 are illegal values."]
            #[must_use]
            #[inline(always)]
            pub const fn portcount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Indicates the number of input ports connected. 0x0 and 0x1 are illegal values."]
            #[inline(always)]
            pub const fn set_portcount(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("portcount", &self.portcount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Devid {{ portcount: {=u8:?} }}", self.portcount())
            }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "The ITATBCTR0 register performs different functions depending on whether the access is a read or a write."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "A read returns the value of the atvalids\\[n\\] signal, where the value of the CTRLREG at 0x000 defines n. A write outputs the value to atvalidm."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> super::vals::Atvalid {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atvalid::from_bits(val as u8)
            }
            #[doc = "A read returns the value of the atvalids\\[n\\] signal, where the value of the CTRLREG at 0x000 defines n. A write outputs the value to atvalidm."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: super::vals::Atvalid) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read returns the value of the afreadys\\[n\\] signal, where the value of the Ctrl_Reg at 0x000 defines n. A write outputs the value to afreadym."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> super::vals::Afready {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Afready::from_bits(val as u8)
            }
            #[doc = "A read returns the value of the afreadys\\[n\\] signal, where the value of the Ctrl_Reg at 0x000 defines n. A write outputs the value to afreadym."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: super::vals::Afready) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "A read returns the value of the atbytess\\[n\\] signal, where the value of the Ctrl_Reg at 0x000 defines n. A write outputs the value to atbytesm."]
            #[must_use]
            #[inline(always)]
            pub const fn atbytes(&self) -> super::vals::Atbytes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Atbytes::from_bits(val as u8)
            }
            #[doc = "A read returns the value of the atbytess\\[n\\] signal, where the value of the Ctrl_Reg at 0x000 defines n. A write outputs the value to atbytesm."]
            #[inline(always)]
            pub const fn set_atbytes(&mut self, val: super::vals::Atbytes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .field("atbytes", &self.atbytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr0 {{ atvalid: {:?}, afready: {:?}, atbytes: {:?} }}",
                    self.atvalid(),
                    self.afready(),
                    self.atbytes()
                )
            }
        }
        #[doc = "The ITATBCTR1 register performs different functions depending on whether the access is a read or a write."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "A read returns the value of the atids\\[n\\] signals, where the value of the Control Register at 0x000 defines n. A write outputs the value to the atidm port."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalidm0(&self) -> super::vals::Atvalidm0 {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Atvalidm0::from_bits(val as u8)
            }
            #[doc = "A read returns the value of the atids\\[n\\] signals, where the value of the Control Register at 0x000 defines n. A write outputs the value to the atidm port."]
            #[inline(always)]
            pub const fn set_atvalidm0(&mut self, val: super::vals::Atvalidm0) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atvalidm0", &self.atvalidm0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itatbctr1 {{ atvalidm0: {:?} }}", self.atvalidm0())
            }
        }
        #[doc = "The ITATBCTR2 register performs different functions depending on whether the access is a read or a write."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr2(pub u32);
        impl Itatbctr2 {
            #[doc = "A read access returns the value of atreadym. A write access outputs the data to afvalids\\[n\\], where the value of the CTRLREG at 0x000 defines n."]
            #[must_use]
            #[inline(always)]
            pub const fn atready(&self) -> super::vals::Atready {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atready::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of atreadym. A write access outputs the data to afvalids\\[n\\], where the value of the CTRLREG at 0x000 defines n."]
            #[inline(always)]
            pub const fn set_atready(&mut self, val: super::vals::Atready) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read access returns the value of afvalidm. A write access outputs the data to atreadys\\[n\\], where the value of the CTRLREG at 0x000 defines n."]
            #[must_use]
            #[inline(always)]
            pub const fn afvalid(&self) -> super::vals::Afvalid {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Afvalid::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of afvalidm. A write access outputs the data to atreadys\\[n\\], where the value of the CTRLREG at 0x000 defines n."]
            #[inline(always)]
            pub const fn set_afvalid(&mut self, val: super::vals::Afvalid) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itatbctr2 {
            #[inline(always)]
            fn default() -> Itatbctr2 {
                Itatbctr2(0)
            }
        }
        impl core::fmt::Debug for Itatbctr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr2")
                    .field("atready", &self.atready())
                    .field("afvalid", &self.afvalid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr2 {{ atready: {:?}, afvalid: {:?} }}",
                    self.atready(),
                    self.afvalid()
                )
            }
        }
        #[doc = "The ITATBDATA0 register performs different functions depending on whether the access is a read or a write."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbdata0(pub u32);
        impl Itatbdata0 {
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_0(&self) -> super::vals::Atdata0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atdata0::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_0(&mut self, val: super::vals::Atdata0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_1(&self) -> super::vals::Atdata1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Atdata1::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_1(&mut self, val: super::vals::Atdata1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_2(&self) -> super::vals::Atdata2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Atdata2::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_2(&mut self, val: super::vals::Atdata2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_3(&self) -> super::vals::Atdata3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atdata3::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_3(&mut self, val: super::vals::Atdata3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_4(&self) -> super::vals::Atdata4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Atdata4::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_4(&mut self, val: super::vals::Atdata4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_5(&self) -> super::vals::Atdata5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Atdata5::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_5(&mut self, val: super::vals::Atdata5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_6(&self) -> super::vals::Atdata6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Atdata6::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_6(&mut self, val: super::vals::Atdata6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_7(&self) -> super::vals::Atdata7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Atdata7::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_7(&mut self, val: super::vals::Atdata7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_8(&self) -> super::vals::Atdata8 {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Atdata8::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_8(&mut self, val: super::vals::Atdata8) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_9(&self) -> super::vals::Atdata9 {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Atdata9::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_9(&mut self, val: super::vals::Atdata9) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_10(&self) -> super::vals::Atdata10 {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Atdata10::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_10(&mut self, val: super::vals::Atdata10) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_11(&self) -> super::vals::Atdata11 {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Atdata11::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_11(&mut self, val: super::vals::Atdata11) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_12(&self) -> super::vals::Atdata12 {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Atdata12::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_12(&mut self, val: super::vals::Atdata12) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_13(&self) -> super::vals::Atdata13 {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Atdata13::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_13(&mut self, val: super::vals::Atdata13) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_14(&self) -> super::vals::Atdata14 {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Atdata14::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_14(&mut self, val: super::vals::Atdata14) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_15(&self) -> super::vals::Atdata15 {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Atdata15::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_15(&mut self, val: super::vals::Atdata15) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_16(&self) -> super::vals::Atdata16 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Atdata16::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_16(&mut self, val: super::vals::Atdata16) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Itatbdata0 {
            #[inline(always)]
            fn default() -> Itatbdata0 {
                Itatbdata0(0)
            }
        }
        impl core::fmt::Debug for Itatbdata0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbdata0")
                    .field("atdata_0", &self.atdata_0())
                    .field("atdata_1", &self.atdata_1())
                    .field("atdata_2", &self.atdata_2())
                    .field("atdata_3", &self.atdata_3())
                    .field("atdata_4", &self.atdata_4())
                    .field("atdata_5", &self.atdata_5())
                    .field("atdata_6", &self.atdata_6())
                    .field("atdata_7", &self.atdata_7())
                    .field("atdata_8", &self.atdata_8())
                    .field("atdata_9", &self.atdata_9())
                    .field("atdata_10", &self.atdata_10())
                    .field("atdata_11", &self.atdata_11())
                    .field("atdata_12", &self.atdata_12())
                    .field("atdata_13", &self.atdata_13())
                    .field("atdata_14", &self.atdata_14())
                    .field("atdata_15", &self.atdata_15())
                    .field("atdata_16", &self.atdata_16())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbdata0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Itatbdata0 {{ atdata_0: {:?}, atdata_1: {:?}, atdata_2: {:?}, atdata_3: {:?}, atdata_4: {:?}, atdata_5: {:?}, atdata_6: {:?}, atdata_7: {:?}, atdata_8: {:?}, atdata_9: {:?}, atdata_10: {:?}, atdata_11: {:?}, atdata_12: {:?}, atdata_13: {:?}, atdata_14: {:?}, atdata_15: {:?}, atdata_16: {:?} }}" , self . atdata_0 () , self . atdata_1 () , self . atdata_2 () , self . atdata_3 () , self . atdata_4 () , self . atdata_5 () , self . atdata_6 () , self . atdata_7 () , self . atdata_8 () , self . atdata_9 () , self . atdata_10 () , self . atdata_11 () , self . atdata_12 () , self . atdata_13 () , self . atdata_14 () , self . atdata_15 () , self . atdata_16 ())
            }
        }
        #[doc = "The ITCTRL register enables the component to switch from a functional mode, which is the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for the purposes of integration testing and topology detection."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Integration Mode Enable."]
            #[must_use]
            #[inline(always)]
            pub const fn ime(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Integration Mode Enable."]
            #[inline(always)]
            pub const fn set_ime(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl").field("ime", &self.ime()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itctrl {{ ime: {=bool:?} }}", self.ime())
            }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lar(pub u32);
        impl Lar {
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[must_use]
            #[inline(always)]
            pub const fn access(&self) -> super::vals::Access {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Access::from_bits(val as u32)
            }
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub const fn set_access(&mut self, val: super::vals::Access) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Lar {
            #[inline(always)]
            fn default() -> Lar {
                Lar(0)
            }
        }
        impl core::fmt::Debug for Lar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lar")
                    .field("access", &self.access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lar {{ access: {:?} }}", self.access())
            }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub const fn set_present(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock."]
            #[must_use]
            #[inline(always)]
            pub const fn locked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub const fn set_locked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::Type) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("present", &self.present())
                    .field("locked", &self.locked())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ present: {=bool:?}, locked: {=bool:?}, type_: {:?} }}",
                    self.present(),
                    self.locked(),
                    self.type_()
                )
            }
        }
        #[doc = "The Priority_Ctrl_Reg register defines the order in which inputs are selected. Each 3-bit field is a priority for each particular slave interface."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Priorityctrlreg(pub u32);
        impl Priorityctrlreg {
            #[doc = "Priority value of port number 0."]
            #[must_use]
            #[inline(always)]
            pub const fn priport0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 0."]
            #[inline(always)]
            pub const fn set_priport0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Priority value of port number 1."]
            #[must_use]
            #[inline(always)]
            pub const fn priport1(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 1."]
            #[inline(always)]
            pub const fn set_priport1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 3usize)) | (((val as u32) & 0x07) << 3usize);
            }
            #[doc = "Priority value of port number 2."]
            #[must_use]
            #[inline(always)]
            pub const fn priport2(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 2."]
            #[inline(always)]
            pub const fn set_priport2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val as u32) & 0x07) << 6usize);
            }
            #[doc = "Priority value of port number 3."]
            #[must_use]
            #[inline(always)]
            pub const fn priport3(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 3."]
            #[inline(always)]
            pub const fn set_priport3(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 9usize)) | (((val as u32) & 0x07) << 9usize);
            }
            #[doc = "Priority value of port number 4."]
            #[must_use]
            #[inline(always)]
            pub const fn priport4(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 4."]
            #[inline(always)]
            pub const fn set_priport4(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize);
            }
            #[doc = "Priority value of port number 5."]
            #[must_use]
            #[inline(always)]
            pub const fn priport5(&self) -> u8 {
                let val = (self.0 >> 15usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 5."]
            #[inline(always)]
            pub const fn set_priport5(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 15usize)) | (((val as u32) & 0x07) << 15usize);
            }
            #[doc = "Priority value of port number 6."]
            #[must_use]
            #[inline(always)]
            pub const fn priport6(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 6."]
            #[inline(always)]
            pub const fn set_priport6(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 18usize)) | (((val as u32) & 0x07) << 18usize);
            }
            #[doc = "Priority value of port number 7."]
            #[must_use]
            #[inline(always)]
            pub const fn priport7(&self) -> u8 {
                let val = (self.0 >> 21usize) & 0x07;
                val as u8
            }
            #[doc = "Priority value of port number 7."]
            #[inline(always)]
            pub const fn set_priport7(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 21usize)) | (((val as u32) & 0x07) << 21usize);
            }
        }
        impl Default for Priorityctrlreg {
            #[inline(always)]
            fn default() -> Priorityctrlreg {
                Priorityctrlreg(0)
            }
        }
        impl core::fmt::Debug for Priorityctrlreg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Priorityctrlreg")
                    .field("priport0", &self.priport0())
                    .field("priport1", &self.priport1())
                    .field("priport2", &self.priport2())
                    .field("priport3", &self.priport3())
                    .field("priport4", &self.priport4())
                    .field("priport5", &self.priport5())
                    .field("priport6", &self.priport6())
                    .field("priport7", &self.priport7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Priorityctrlreg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Priorityctrlreg {{ priport0: {=u8:?}, priport1: {=u8:?}, priport2: {=u8:?}, priport3: {=u8:?}, priport4: {=u8:?}, priport5: {=u8:?}, priport6: {=u8:?}, priport7: {=u8:?} }}" , self . priport0 () , self . priport1 () , self . priport2 () , self . priport3 () , self . priport4 () , self . priport5 () , self . priport6 () , self . priport7 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Access(u32);
        impl Access {
            #[doc = "Unlock register interface."]
            pub const UN_LOCK: Self = Self(0xc5ac_ce55);
        }
        impl Access {
            pub const fn from_bits(val: u32) -> Access {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Access {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xc5ac_ce55 => f.write_str("UN_LOCK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Access {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xc5ac_ce55 => defmt::write!(f, "UN_LOCK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Access {
            #[inline(always)]
            fn from(val: u32) -> Access {
                Access::from_bits(val)
            }
        }
        impl From<Access> for u32 {
            #[inline(always)]
            fn from(val: Access) -> u32 {
                Access::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afready {
            #[inline(always)]
            fn from(val: u8) -> Afready {
                Afready::from_bits(val)
            }
        }
        impl From<Afready> for u8 {
            #[inline(always)]
            fn from(val: Afready) -> u8 {
                Afready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afvalid {
            #[inline(always)]
            fn from(val: u8) -> Afvalid {
                Afvalid::from_bits(val)
            }
        }
        impl From<Afvalid> for u8 {
            #[inline(always)]
            fn from(val: Afvalid) -> u8 {
                Afvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atbytes {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Atbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atbytes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atbytes {
            #[inline(always)]
            fn from(val: u8) -> Atbytes {
                Atbytes::from_bits(val)
            }
        }
        impl From<Atbytes> for u8 {
            #[inline(always)]
            fn from(val: Atbytes) -> u8 {
                Atbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata0 {
            #[inline(always)]
            fn from(val: u8) -> Atdata0 {
                Atdata0::from_bits(val)
            }
        }
        impl From<Atdata0> for u8 {
            #[inline(always)]
            fn from(val: Atdata0) -> u8 {
                Atdata0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata1 {
            #[inline(always)]
            fn from(val: u8) -> Atdata1 {
                Atdata1::from_bits(val)
            }
        }
        impl From<Atdata1> for u8 {
            #[inline(always)]
            fn from(val: Atdata1) -> u8 {
                Atdata1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata10 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata10 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata10 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata10 {
            #[inline(always)]
            fn from(val: u8) -> Atdata10 {
                Atdata10::from_bits(val)
            }
        }
        impl From<Atdata10> for u8 {
            #[inline(always)]
            fn from(val: Atdata10) -> u8 {
                Atdata10::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata11 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata11 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata11 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata11 {
            #[inline(always)]
            fn from(val: u8) -> Atdata11 {
                Atdata11::from_bits(val)
            }
        }
        impl From<Atdata11> for u8 {
            #[inline(always)]
            fn from(val: Atdata11) -> u8 {
                Atdata11::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata12 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata12 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata12 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata12 {
            #[inline(always)]
            fn from(val: u8) -> Atdata12 {
                Atdata12::from_bits(val)
            }
        }
        impl From<Atdata12> for u8 {
            #[inline(always)]
            fn from(val: Atdata12) -> u8 {
                Atdata12::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata13 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata13 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata13 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata13 {
            #[inline(always)]
            fn from(val: u8) -> Atdata13 {
                Atdata13::from_bits(val)
            }
        }
        impl From<Atdata13> for u8 {
            #[inline(always)]
            fn from(val: Atdata13) -> u8 {
                Atdata13::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata14 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata14 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata14 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata14 {
            #[inline(always)]
            fn from(val: u8) -> Atdata14 {
                Atdata14::from_bits(val)
            }
        }
        impl From<Atdata14> for u8 {
            #[inline(always)]
            fn from(val: Atdata14) -> u8 {
                Atdata14::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata15 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata15 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata15 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata15 {
            #[inline(always)]
            fn from(val: u8) -> Atdata15 {
                Atdata15::from_bits(val)
            }
        }
        impl From<Atdata15> for u8 {
            #[inline(always)]
            fn from(val: Atdata15) -> u8 {
                Atdata15::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata16 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata16 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata16 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata16 {
            #[inline(always)]
            fn from(val: u8) -> Atdata16 {
                Atdata16::from_bits(val)
            }
        }
        impl From<Atdata16> for u8 {
            #[inline(always)]
            fn from(val: Atdata16) -> u8 {
                Atdata16::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata2 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata2 {
            #[inline(always)]
            fn from(val: u8) -> Atdata2 {
                Atdata2::from_bits(val)
            }
        }
        impl From<Atdata2> for u8 {
            #[inline(always)]
            fn from(val: Atdata2) -> u8 {
                Atdata2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata3 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata3 {
            #[inline(always)]
            fn from(val: u8) -> Atdata3 {
                Atdata3::from_bits(val)
            }
        }
        impl From<Atdata3> for u8 {
            #[inline(always)]
            fn from(val: Atdata3) -> u8 {
                Atdata3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata4 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata4 {
            #[inline(always)]
            fn from(val: u8) -> Atdata4 {
                Atdata4::from_bits(val)
            }
        }
        impl From<Atdata4> for u8 {
            #[inline(always)]
            fn from(val: Atdata4) -> u8 {
                Atdata4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata5 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata5 {
            #[inline(always)]
            fn from(val: u8) -> Atdata5 {
                Atdata5::from_bits(val)
            }
        }
        impl From<Atdata5> for u8 {
            #[inline(always)]
            fn from(val: Atdata5) -> u8 {
                Atdata5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata6 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata6 {
            #[inline(always)]
            fn from(val: u8) -> Atdata6 {
                Atdata6::from_bits(val)
            }
        }
        impl From<Atdata6> for u8 {
            #[inline(always)]
            fn from(val: Atdata6) -> u8 {
                Atdata6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata7 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata7 {
            #[inline(always)]
            fn from(val: u8) -> Atdata7 {
                Atdata7::from_bits(val)
            }
        }
        impl From<Atdata7> for u8 {
            #[inline(always)]
            fn from(val: Atdata7) -> u8 {
                Atdata7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata8 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata8 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata8 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata8 {
            #[inline(always)]
            fn from(val: u8) -> Atdata8 {
                Atdata8::from_bits(val)
            }
        }
        impl From<Atdata8> for u8 {
            #[inline(always)]
            fn from(val: Atdata8) -> u8 {
                Atdata8::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata9 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata9 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata9 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata9 {
            #[inline(always)]
            fn from(val: u8) -> Atdata9 {
                Atdata9::from_bits(val)
            }
        }
        impl From<Atdata9> for u8 {
            #[inline(always)]
            fn from(val: Atdata9) -> u8 {
                Atdata9::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atready {
            #[inline(always)]
            fn from(val: u8) -> Atready {
                Atready::from_bits(val)
            }
        }
        impl From<Atready> for u8 {
            #[inline(always)]
            fn from(val: Atready) -> u8 {
                Atready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalid {
            #[inline(always)]
            fn from(val: u8) -> Atvalid {
                Atvalid::from_bits(val)
            }
        }
        impl From<Atvalid> for u8 {
            #[inline(always)]
            fn from(val: Atvalid) -> u8 {
                Atvalid::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Atvalidm0(u8);
        impl Atvalidm0 {
            #[doc = "Pin is logic 0."]
            pub const LOW: Self = Self(0x0);
            #[doc = "Pin is logic 1."]
            pub const HIGH: Self = Self(0x01);
        }
        impl Atvalidm0 {
            pub const fn from_bits(val: u8) -> Atvalidm0 {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Atvalidm0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("LOW"),
                    0x01 => f.write_str("HIGH"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Atvalidm0 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "LOW"),
                    0x01 => defmt::write!(f, "HIGH"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Atvalidm0 {
            #[inline(always)]
            fn from(val: u8) -> Atvalidm0 {
                Atvalidm0::from_bits(val)
            }
        }
        impl From<Atvalidm0> for u8 {
            #[inline(always)]
            fn from(val: Atvalidm0) -> u8 {
                Atvalidm0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit0 {
            #[doc = "Claim bit 0 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit0 {
                ClaimclrBit0::from_bits(val)
            }
        }
        impl From<ClaimclrBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit0) -> u8 {
                ClaimclrBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit1 {
            #[doc = "Claim bit 1 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit1 {
                ClaimclrBit1::from_bits(val)
            }
        }
        impl From<ClaimclrBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit1) -> u8 {
                ClaimclrBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit2 {
            #[doc = "Claim bit 2 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit2 {
                ClaimclrBit2::from_bits(val)
            }
        }
        impl From<ClaimclrBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit2) -> u8 {
                ClaimclrBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit3 {
            #[doc = "Claim bit 3 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit3 {
                ClaimclrBit3::from_bits(val)
            }
        }
        impl From<ClaimclrBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit3) -> u8 {
                ClaimclrBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit0 {
            #[doc = "Claim bit 0 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 0 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit0 {
                ClaimsetBit0::from_bits(val)
            }
        }
        impl From<ClaimsetBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit0) -> u8 {
                ClaimsetBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit1 {
            #[doc = "Claim bit 1 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 1 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit1 {
                ClaimsetBit1::from_bits(val)
            }
        }
        impl From<ClaimsetBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit1) -> u8 {
                ClaimsetBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit2 {
            #[doc = "Claim bit 2 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 2 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit2 {
                ClaimsetBit2::from_bits(val)
            }
        }
        impl From<ClaimsetBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit2) -> u8 {
                ClaimsetBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit3 {
            #[doc = "Claim bit 3 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 3 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit3 {
                ClaimsetBit3::from_bits(val)
            }
        }
        impl From<ClaimsetBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit3) -> u8 {
                ClaimsetBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Indicates that this component has ATB inputs and outputs."]
            INPUT_OUTPUT_DEVICE = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "This component arbitrates ATB inputs mapping to ATB outputs."]
            REPLICATOR = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            #[doc = "This component implements a 32-bit Lock Access Register."]
            BITS32 = 0x0,
            #[doc = "This component implements an 8-bit Lock Access Register."]
            BITS8 = 0x01,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
    }
}
pub mod atbreplicator {
    #[doc = "ATB Replicator module"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Atbreplicator {
        ptr: *mut u8,
    }
    unsafe impl Send for Atbreplicator {}
    unsafe impl Sync for Atbreplicator {}
    impl Atbreplicator {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The IDFILTER0 register enables the programming of ID filtering for master port 0."]
        #[inline(always)]
        pub const fn idfilter0(self) -> crate::common::Reg<regs::Idfilter0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "The IDFILTER1 register enables the programming of ID filtering for master port 1."]
        #[inline(always)]
        pub const fn idfilter1(self) -> crate::common::Reg<regs::Idfilter1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "The ITATBCTR1 register returns the value of the atreadym0, atreadym1, and atvalids inputs in integration mode."]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef8usize) as _) }
        }
        #[doc = "The ITATBCTR0 register controls the value of the atvalidm0, atvalidm1, and atreadys outputs in integration mode."]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0efcusize) as _) }
        }
        #[doc = "The ITCTRL register enables the component to switch from a functional mode, which is the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for the purposes of integration testing and topology detection."]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa0usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa4usize) as _) }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<regs::Lar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb0usize) as _) }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb8usize) as _) }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fc8usize) as _) }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fccusize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fd0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe4usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe8usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fecusize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff0usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff4usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff8usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Authstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "Read or clear claim bit 0."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimclrBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimclrBit0::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimclrBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Read or clear claim bit 1."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimclrBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimclrBit1::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimclrBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Read or clear claim bit 2."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimclrBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimclrBit2::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimclrBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Read or clear claim bit 3."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimclrBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimclrBit3::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimclrBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimclr {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimsetBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimsetBit0::from_bits(val as u8)
            }
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimsetBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimsetBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimsetBit1::from_bits(val as u8)
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimsetBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimsetBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimsetBit2::from_bits(val as u8)
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimsetBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimsetBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimsetBit3::from_bits(val as u8)
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimsetBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimset {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "Indicates the number of master ports implemented."]
            #[must_use]
            #[inline(always)]
            pub const fn portnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Indicates the number of master ports implemented."]
            #[inline(always)]
            pub const fn set_portnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("portnum", &self.portnum())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Devid {{ portnum: {=u8:?} }}", self.portnum())
            }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "The IDFILTER0 register enables the programming of ID filtering for master port 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idfilter0(pub u32);
        impl Idfilter0 {
            #[doc = "Enable or disable ID filtering for IDs 0x00_0x0F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_00_0f(&self) -> super::vals::Id0000f {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Id0000f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x00_0x0F."]
            #[inline(always)]
            pub const fn set_id0_00_0f(&mut self, val: super::vals::Id0000f) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x10_0x1F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_10_1f(&self) -> super::vals::Id0101f {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Id0101f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x10_0x1F."]
            #[inline(always)]
            pub const fn set_id0_10_1f(&mut self, val: super::vals::Id0101f) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x20_0x2F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_20_2f(&self) -> super::vals::Id0202f {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Id0202f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x20_0x2F."]
            #[inline(always)]
            pub const fn set_id0_20_2f(&mut self, val: super::vals::Id0202f) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x30_0x3F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_30_3f(&self) -> super::vals::Id0303f {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Id0303f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x30_0x3F."]
            #[inline(always)]
            pub const fn set_id0_30_3f(&mut self, val: super::vals::Id0303f) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x40_0x4F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_40_4f(&self) -> super::vals::Id0404f {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Id0404f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x40_0x4F."]
            #[inline(always)]
            pub const fn set_id0_40_4f(&mut self, val: super::vals::Id0404f) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x50_0x5F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_50_5f(&self) -> super::vals::Id0505f {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Id0505f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x50_0x5F."]
            #[inline(always)]
            pub const fn set_id0_50_5f(&mut self, val: super::vals::Id0505f) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x60_0x6F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_60_6f(&self) -> super::vals::Id0606f {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Id0606f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x60_0x6F."]
            #[inline(always)]
            pub const fn set_id0_60_6f(&mut self, val: super::vals::Id0606f) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x70_0x7F."]
            #[must_use]
            #[inline(always)]
            pub const fn id0_70_7f(&self) -> super::vals::Id0707f {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Id0707f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x70_0x7F."]
            #[inline(always)]
            pub const fn set_id0_70_7f(&mut self, val: super::vals::Id0707f) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Idfilter0 {
            #[inline(always)]
            fn default() -> Idfilter0 {
                Idfilter0(0)
            }
        }
        impl core::fmt::Debug for Idfilter0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idfilter0")
                    .field("id0_00_0f", &self.id0_00_0f())
                    .field("id0_10_1f", &self.id0_10_1f())
                    .field("id0_20_2f", &self.id0_20_2f())
                    .field("id0_30_3f", &self.id0_30_3f())
                    .field("id0_40_4f", &self.id0_40_4f())
                    .field("id0_50_5f", &self.id0_50_5f())
                    .field("id0_60_6f", &self.id0_60_6f())
                    .field("id0_70_7f", &self.id0_70_7f())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idfilter0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Idfilter0 {{ id0_00_0f: {:?}, id0_10_1f: {:?}, id0_20_2f: {:?}, id0_30_3f: {:?}, id0_40_4f: {:?}, id0_50_5f: {:?}, id0_60_6f: {:?}, id0_70_7f: {:?} }}" , self . id0_00_0f () , self . id0_10_1f () , self . id0_20_2f () , self . id0_30_3f () , self . id0_40_4f () , self . id0_50_5f () , self . id0_60_6f () , self . id0_70_7f ())
            }
        }
        #[doc = "The IDFILTER1 register enables the programming of ID filtering for master port 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idfilter1(pub u32);
        impl Idfilter1 {
            #[doc = "Enable or disable ID filtering for IDs 0x00_0x0F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_00_0f(&self) -> super::vals::Id1000f {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Id1000f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x00_0x0F."]
            #[inline(always)]
            pub const fn set_id1_00_0f(&mut self, val: super::vals::Id1000f) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x10_0x1F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_10_1f(&self) -> super::vals::Id1101f {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Id1101f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x10_0x1F."]
            #[inline(always)]
            pub const fn set_id1_10_1f(&mut self, val: super::vals::Id1101f) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x20_0x2F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_20_2f(&self) -> super::vals::Id1202f {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Id1202f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x20_0x2F."]
            #[inline(always)]
            pub const fn set_id1_20_2f(&mut self, val: super::vals::Id1202f) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x30_0x3F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_30_3f(&self) -> super::vals::Id1303f {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Id1303f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x30_0x3F."]
            #[inline(always)]
            pub const fn set_id1_30_3f(&mut self, val: super::vals::Id1303f) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x40_0x4F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_40_4f(&self) -> super::vals::Id1404f {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Id1404f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x40_0x4F."]
            #[inline(always)]
            pub const fn set_id1_40_4f(&mut self, val: super::vals::Id1404f) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x50_0x5F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_50_5f(&self) -> super::vals::Id1505f {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Id1505f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x50_0x5F."]
            #[inline(always)]
            pub const fn set_id1_50_5f(&mut self, val: super::vals::Id1505f) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x60_0x6F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_60_6f(&self) -> super::vals::Id1606f {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Id1606f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x60_0x6F."]
            #[inline(always)]
            pub const fn set_id1_60_6f(&mut self, val: super::vals::Id1606f) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable ID filtering for IDs 0x70_0x7F."]
            #[must_use]
            #[inline(always)]
            pub const fn id1_70_7f(&self) -> super::vals::Id1707f {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Id1707f::from_bits(val as u8)
            }
            #[doc = "Enable or disable ID filtering for IDs 0x70_0x7F."]
            #[inline(always)]
            pub const fn set_id1_70_7f(&mut self, val: super::vals::Id1707f) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Idfilter1 {
            #[inline(always)]
            fn default() -> Idfilter1 {
                Idfilter1(0)
            }
        }
        impl core::fmt::Debug for Idfilter1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idfilter1")
                    .field("id1_00_0f", &self.id1_00_0f())
                    .field("id1_10_1f", &self.id1_10_1f())
                    .field("id1_20_2f", &self.id1_20_2f())
                    .field("id1_30_3f", &self.id1_30_3f())
                    .field("id1_40_4f", &self.id1_40_4f())
                    .field("id1_50_5f", &self.id1_50_5f())
                    .field("id1_60_6f", &self.id1_60_6f())
                    .field("id1_70_7f", &self.id1_70_7f())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idfilter1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Idfilter1 {{ id1_00_0f: {:?}, id1_10_1f: {:?}, id1_20_2f: {:?}, id1_30_3f: {:?}, id1_40_4f: {:?}, id1_50_5f: {:?}, id1_60_6f: {:?}, id1_70_7f: {:?} }}" , self . id1_00_0f () , self . id1_10_1f () , self . id1_20_2f () , self . id1_30_3f () , self . id1_40_4f () , self . id1_50_5f () , self . id1_60_6f () , self . id1_70_7f ())
            }
        }
        #[doc = "The ITATBCTR0 register controls the value of the atvalidm0, atvalidm1, and atreadys outputs in integration mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "Sets the value of the atvalidm0 output."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalidm0(&self) -> super::vals::Atvalidm0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atvalidm0::from_bits(val as u8)
            }
            #[doc = "Sets the value of the atvalidm0 output."]
            #[inline(always)]
            pub const fn set_atvalidm0(&mut self, val: super::vals::Atvalidm0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of the atvalidm1 output."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalidm1(&self) -> super::vals::Atvalidm1 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Atvalidm1::from_bits(val as u8)
            }
            #[doc = "Sets the value of the atvalidm1 output."]
            #[inline(always)]
            pub const fn set_atvalidm1(&mut self, val: super::vals::Atvalidm1) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Sets the value of the atreadys output."]
            #[must_use]
            #[inline(always)]
            pub const fn atreadys(&self) -> super::vals::Atreadys {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atreadys::from_bits(val as u8)
            }
            #[doc = "Sets the value of the atreadys output."]
            #[inline(always)]
            pub const fn set_atreadys(&mut self, val: super::vals::Atreadys) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalidm0", &self.atvalidm0())
                    .field("atvalidm1", &self.atvalidm1())
                    .field("atreadys", &self.atreadys())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr0 {{ atvalidm0: {:?}, atvalidm1: {:?}, atreadys: {:?} }}",
                    self.atvalidm0(),
                    self.atvalidm1(),
                    self.atreadys()
                )
            }
        }
        #[doc = "The ITATBCTR1 register returns the value of the atreadym0, atreadym1, and atvalids inputs in integration mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "Reads the value of the atreadym0 input."]
            #[must_use]
            #[inline(always)]
            pub const fn atreadym0(&self) -> super::vals::Atreadym0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atreadym0::from_bits(val as u8)
            }
            #[doc = "Reads the value of the atreadym0 input."]
            #[inline(always)]
            pub const fn set_atreadym0(&mut self, val: super::vals::Atreadym0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of the atreadym1 input."]
            #[must_use]
            #[inline(always)]
            pub const fn atreadym1(&self) -> super::vals::Atreadym1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Atreadym1::from_bits(val as u8)
            }
            #[doc = "Reads the value of the atreadym1 input."]
            #[inline(always)]
            pub const fn set_atreadym1(&mut self, val: super::vals::Atreadym1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Reads the value of the atvalids input."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalids(&self) -> super::vals::Atvalids {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atvalids::from_bits(val as u8)
            }
            #[doc = "Reads the value of the atvalids input."]
            #[inline(always)]
            pub const fn set_atvalids(&mut self, val: super::vals::Atvalids) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atreadym0", &self.atreadym0())
                    .field("atreadym1", &self.atreadym1())
                    .field("atvalids", &self.atvalids())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr1 {{ atreadym0: {:?}, atreadym1: {:?}, atvalids: {:?} }}",
                    self.atreadym0(),
                    self.atreadym1(),
                    self.atvalids()
                )
            }
        }
        #[doc = "The ITCTRL register enables the component to switch from a functional mode, which is the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for the purposes of integration testing and topology detection."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Integration Mode Enable."]
            #[must_use]
            #[inline(always)]
            pub const fn ime(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Integration Mode Enable."]
            #[inline(always)]
            pub const fn set_ime(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl").field("ime", &self.ime()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itctrl {{ ime: {=bool:?} }}", self.ime())
            }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lar(pub u32);
        impl Lar {
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[must_use]
            #[inline(always)]
            pub const fn access(&self) -> super::vals::Access {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Access::from_bits(val as u32)
            }
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub const fn set_access(&mut self, val: super::vals::Access) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Lar {
            #[inline(always)]
            fn default() -> Lar {
                Lar(0)
            }
        }
        impl core::fmt::Debug for Lar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lar")
                    .field("access", &self.access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lar {{ access: {:?} }}", self.access())
            }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub const fn set_present(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock."]
            #[must_use]
            #[inline(always)]
            pub const fn locked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub const fn set_locked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::Type) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("present", &self.present())
                    .field("locked", &self.locked())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ present: {=bool:?}, locked: {=bool:?}, type_: {:?} }}",
                    self.present(),
                    self.locked(),
                    self.type_()
                )
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Access(u32);
        impl Access {
            #[doc = "Unlock register interface."]
            pub const UN_LOCK: Self = Self(0xc5ac_ce55);
        }
        impl Access {
            pub const fn from_bits(val: u32) -> Access {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Access {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xc5ac_ce55 => f.write_str("UN_LOCK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Access {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xc5ac_ce55 => defmt::write!(f, "UN_LOCK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Access {
            #[inline(always)]
            fn from(val: u32) -> Access {
                Access::from_bits(val)
            }
        }
        impl From<Access> for u32 {
            #[inline(always)]
            fn from(val: Access) -> u32 {
                Access::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atreadym0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atreadym0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atreadym0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atreadym0 {
            #[inline(always)]
            fn from(val: u8) -> Atreadym0 {
                Atreadym0::from_bits(val)
            }
        }
        impl From<Atreadym0> for u8 {
            #[inline(always)]
            fn from(val: Atreadym0) -> u8 {
                Atreadym0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atreadym1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atreadym1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atreadym1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atreadym1 {
            #[inline(always)]
            fn from(val: u8) -> Atreadym1 {
                Atreadym1::from_bits(val)
            }
        }
        impl From<Atreadym1> for u8 {
            #[inline(always)]
            fn from(val: Atreadym1) -> u8 {
                Atreadym1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atreadys {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atreadys {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atreadys {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atreadys {
            #[inline(always)]
            fn from(val: u8) -> Atreadys {
                Atreadys::from_bits(val)
            }
        }
        impl From<Atreadys> for u8 {
            #[inline(always)]
            fn from(val: Atreadys) -> u8 {
                Atreadys::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalidm0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalidm0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalidm0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalidm0 {
            #[inline(always)]
            fn from(val: u8) -> Atvalidm0 {
                Atvalidm0::from_bits(val)
            }
        }
        impl From<Atvalidm0> for u8 {
            #[inline(always)]
            fn from(val: Atvalidm0) -> u8 {
                Atvalidm0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalidm1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalidm1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalidm1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalidm1 {
            #[inline(always)]
            fn from(val: u8) -> Atvalidm1 {
                Atvalidm1::from_bits(val)
            }
        }
        impl From<Atvalidm1> for u8 {
            #[inline(always)]
            fn from(val: Atvalidm1) -> u8 {
                Atvalidm1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalids {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalids {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalids {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalids {
            #[inline(always)]
            fn from(val: u8) -> Atvalids {
                Atvalids::from_bits(val)
            }
        }
        impl From<Atvalids> for u8 {
            #[inline(always)]
            fn from(val: Atvalids) -> u8 {
                Atvalids::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit0 {
            #[doc = "Claim bit 0 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit0 {
                ClaimclrBit0::from_bits(val)
            }
        }
        impl From<ClaimclrBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit0) -> u8 {
                ClaimclrBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit1 {
            #[doc = "Claim bit 1 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit1 {
                ClaimclrBit1::from_bits(val)
            }
        }
        impl From<ClaimclrBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit1) -> u8 {
                ClaimclrBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit2 {
            #[doc = "Claim bit 2 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit2 {
                ClaimclrBit2::from_bits(val)
            }
        }
        impl From<ClaimclrBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit2) -> u8 {
                ClaimclrBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit3 {
            #[doc = "Claim bit 3 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit3 {
                ClaimclrBit3::from_bits(val)
            }
        }
        impl From<ClaimclrBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit3) -> u8 {
                ClaimclrBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit0 {
            #[doc = "Claim bit 0 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 0 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit0 {
                ClaimsetBit0::from_bits(val)
            }
        }
        impl From<ClaimsetBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit0) -> u8 {
                ClaimsetBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit1 {
            #[doc = "Claim bit 1 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 1 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit1 {
                ClaimsetBit1::from_bits(val)
            }
        }
        impl From<ClaimsetBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit1) -> u8 {
                ClaimsetBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit2 {
            #[doc = "Claim bit 2 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 2 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit2 {
                ClaimsetBit2::from_bits(val)
            }
        }
        impl From<ClaimsetBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit2) -> u8 {
                ClaimsetBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit3 {
            #[doc = "Claim bit 3 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 3 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit3 {
                ClaimsetBit3::from_bits(val)
            }
        }
        impl From<ClaimsetBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit3) -> u8 {
                ClaimsetBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0000f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0000f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0000f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0000f {
            #[inline(always)]
            fn from(val: u8) -> Id0000f {
                Id0000f::from_bits(val)
            }
        }
        impl From<Id0000f> for u8 {
            #[inline(always)]
            fn from(val: Id0000f) -> u8 {
                Id0000f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0101f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0101f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0101f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0101f {
            #[inline(always)]
            fn from(val: u8) -> Id0101f {
                Id0101f::from_bits(val)
            }
        }
        impl From<Id0101f> for u8 {
            #[inline(always)]
            fn from(val: Id0101f) -> u8 {
                Id0101f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0202f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0202f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0202f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0202f {
            #[inline(always)]
            fn from(val: u8) -> Id0202f {
                Id0202f::from_bits(val)
            }
        }
        impl From<Id0202f> for u8 {
            #[inline(always)]
            fn from(val: Id0202f) -> u8 {
                Id0202f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0303f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0303f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0303f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0303f {
            #[inline(always)]
            fn from(val: u8) -> Id0303f {
                Id0303f::from_bits(val)
            }
        }
        impl From<Id0303f> for u8 {
            #[inline(always)]
            fn from(val: Id0303f) -> u8 {
                Id0303f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0404f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0404f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0404f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0404f {
            #[inline(always)]
            fn from(val: u8) -> Id0404f {
                Id0404f::from_bits(val)
            }
        }
        impl From<Id0404f> for u8 {
            #[inline(always)]
            fn from(val: Id0404f) -> u8 {
                Id0404f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0505f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0505f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0505f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0505f {
            #[inline(always)]
            fn from(val: u8) -> Id0505f {
                Id0505f::from_bits(val)
            }
        }
        impl From<Id0505f> for u8 {
            #[inline(always)]
            fn from(val: Id0505f) -> u8 {
                Id0505f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0606f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0606f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0606f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0606f {
            #[inline(always)]
            fn from(val: u8) -> Id0606f {
                Id0606f::from_bits(val)
            }
        }
        impl From<Id0606f> for u8 {
            #[inline(always)]
            fn from(val: Id0606f) -> u8 {
                Id0606f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id0707f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 0."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id0707f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id0707f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id0707f {
            #[inline(always)]
            fn from(val: u8) -> Id0707f {
                Id0707f::from_bits(val)
            }
        }
        impl From<Id0707f> for u8 {
            #[inline(always)]
            fn from(val: Id0707f) -> u8 {
                Id0707f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1000f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1000f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1000f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1000f {
            #[inline(always)]
            fn from(val: u8) -> Id1000f {
                Id1000f::from_bits(val)
            }
        }
        impl From<Id1000f> for u8 {
            #[inline(always)]
            fn from(val: Id1000f) -> u8 {
                Id1000f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1101f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1101f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1101f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1101f {
            #[inline(always)]
            fn from(val: u8) -> Id1101f {
                Id1101f::from_bits(val)
            }
        }
        impl From<Id1101f> for u8 {
            #[inline(always)]
            fn from(val: Id1101f) -> u8 {
                Id1101f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1202f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1202f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1202f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1202f {
            #[inline(always)]
            fn from(val: u8) -> Id1202f {
                Id1202f::from_bits(val)
            }
        }
        impl From<Id1202f> for u8 {
            #[inline(always)]
            fn from(val: Id1202f) -> u8 {
                Id1202f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1303f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1303f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1303f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1303f {
            #[inline(always)]
            fn from(val: u8) -> Id1303f {
                Id1303f::from_bits(val)
            }
        }
        impl From<Id1303f> for u8 {
            #[inline(always)]
            fn from(val: Id1303f) -> u8 {
                Id1303f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1404f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1404f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1404f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1404f {
            #[inline(always)]
            fn from(val: u8) -> Id1404f {
                Id1404f::from_bits(val)
            }
        }
        impl From<Id1404f> for u8 {
            #[inline(always)]
            fn from(val: Id1404f) -> u8 {
                Id1404f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1505f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1505f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1505f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1505f {
            #[inline(always)]
            fn from(val: u8) -> Id1505f {
                Id1505f::from_bits(val)
            }
        }
        impl From<Id1505f> for u8 {
            #[inline(always)]
            fn from(val: Id1505f) -> u8 {
                Id1505f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1606f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1606f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1606f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1606f {
            #[inline(always)]
            fn from(val: u8) -> Id1606f {
                Id1606f::from_bits(val)
            }
        }
        impl From<Id1606f> for u8 {
            #[inline(always)]
            fn from(val: Id1606f) -> u8 {
                Id1606f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Id1707f {
            #[doc = "Transactions with these IDs are passed on to ATB master port 1."]
            NOT_FILTERED = 0x0,
            #[doc = "Transactions with these IDs are discarded by the replicator."]
            SELECTED = 0x01,
        }
        impl Id1707f {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Id1707f {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Id1707f {
            #[inline(always)]
            fn from(val: u8) -> Id1707f {
                Id1707f::from_bits(val)
            }
        }
        impl From<Id1707f> for u8 {
            #[inline(always)]
            fn from(val: Id1707f) -> u8 {
                Id1707f::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Indicates that this component has ATB inputs and outputs."]
            INPUT_OUTPUT_DEVICE = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Indicates that this component replicates trace from a single source to multiple targets."]
            REPLICATOR = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            #[doc = "This component implements a 32-bit Lock Access Register."]
            BITS32 = 0x0,
            #[doc = "This component implements an 8-bit Lock Access Register."]
            BITS8 = 0x01,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
    }
}
pub mod cc_aes {
    #[doc = "CRYPTOCELL AES engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcAes {
        ptr: *mut u8,
    }
    unsafe impl Send for CcAes {}
    unsafe impl Sync for CcAes {}
    impl CcAes {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: AES key value to use. The initial AES_KEY_0\\[0\\] register holds the least significant bits \\[31:0\\] of the key value."]
        #[inline(always)]
        pub const fn aes_key_0(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: AES Initialization Vector (IV) to use. The initial AES_IV_0\\[0\\] register holds the least significant bits \\[31:0\\] of the IV."]
        #[inline(always)]
        pub const fn aes_iv_0(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: AES counter (CTR) to use. The initial AES_CTR\\[0\\] register holds the least significant bits \\[31:0\\] of the CTR."]
        #[inline(always)]
        pub const fn aes_ctr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0460usize + n * 4usize) as _)
            }
        }
        #[doc = "Status register for AES engine activity."]
        #[inline(always)]
        pub const fn aes_busy(self) -> crate::common::Reg<regs::AesBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0470usize) as _) }
        }
        #[doc = "Writing to this address trigger sampling of the HW key to the AES_KEY_0 register"]
        #[inline(always)]
        pub const fn aes_sk(self) -> crate::common::Reg<regs::AesSk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0478usize) as _) }
        }
        #[doc = "Writing to this address triggers the AES engine to generate K1 and K2 for AES-CMAC operations."]
        #[inline(always)]
        pub const fn aes_cmac_init(
            self,
        ) -> crate::common::Reg<regs::AesCmacInit, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x047cusize) as _) }
        }
        #[doc = "This register should be set with the amount of remaining bytes until the end of the current AES operation."]
        #[inline(always)]
        pub const fn aes_remaining_bytes(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04bcusize) as _) }
        }
        #[doc = "Control the AES engine behavior."]
        #[inline(always)]
        pub const fn aes_control(self) -> crate::common::Reg<regs::AesControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04c0usize) as _) }
        }
        #[doc = "Hardware configuration of the AES engine. Reset value holds the supported features."]
        #[inline(always)]
        pub const fn aes_hw_flags(self) -> crate::common::Reg<regs::AesHwFlags, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04c8usize) as _) }
        }
        #[doc = "This register enables the AES CTR no increment mode in which the counter mode is not incremented between two blocks"]
        #[inline(always)]
        pub const fn aes_ctr_no_increment(
            self,
        ) -> crate::common::Reg<regs::AesCtrNoIncrement, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04d8usize) as _) }
        }
        #[doc = "Reset the AES engine."]
        #[inline(always)]
        pub const fn aes_sw_reset(self) -> crate::common::Reg<regs::AesSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04f4usize) as _) }
        }
        #[doc = "Writing to this address triggers the AES engine to perform a CMAC operation with size 0. The CMAC result can be read from the AES_IV_0 register."]
        #[inline(always)]
        pub const fn aes_cmac_size0_kick(
            self,
        ) -> crate::common::Reg<regs::AesCmacSize0Kick, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status register for AES engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesBusy(pub u32);
        impl AesBusy {
            #[doc = "AES engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "AES engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesBusy {
            #[inline(always)]
            fn default() -> AesBusy {
                AesBusy(0)
            }
        }
        impl core::fmt::Debug for AesBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Writing to this address triggers the AES engine to generate K1 and K2 for AES-CMAC operations."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesCmacInit(pub u32);
        impl AesCmacInit {
            #[doc = "Generate K1 and K2 for the AES-CMAC operations."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generate K1 and K2 for the AES-CMAC operations."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesCmacInit {
            #[inline(always)]
            fn default() -> AesCmacInit {
                AesCmacInit(0)
            }
        }
        impl core::fmt::Debug for AesCmacInit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesCmacInit")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesCmacInit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesCmacInit {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Writing to this address triggers the AES engine to perform a CMAC operation with size 0. The CMAC result can be read from the AES_IV_0 register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesCmacSize0Kick(pub u32);
        impl AesCmacSize0Kick {
            #[doc = "Force AES CMAC operation with size 0."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Force AES CMAC operation with size 0."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesCmacSize0Kick {
            #[inline(always)]
            fn default() -> AesCmacSize0Kick {
                AesCmacSize0Kick(0)
            }
        }
        impl core::fmt::Debug for AesCmacSize0Kick {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesCmacSize0Kick")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesCmacSize0Kick {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesCmacSize0Kick {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Control the AES engine behavior."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesControl(pub u32);
        impl AesControl {
            #[doc = "Set AES encrypt or decrypt mode in non-tunneling operations."]
            #[must_use]
            #[inline(always)]
            pub const fn dec_key0(&self) -> super::vals::DecKey0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DecKey0::from_bits(val as u8)
            }
            #[doc = "Set AES encrypt or decrypt mode in non-tunneling operations."]
            #[inline(always)]
            pub const fn set_dec_key0(&mut self, val: super::vals::DecKey0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set the AES mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mode_key0(&self) -> super::vals::ModeKey0 {
                let val = (self.0 >> 2usize) & 0x07;
                super::vals::ModeKey0::from_bits(val as u8)
            }
            #[doc = "Set the AES mode."]
            #[inline(always)]
            pub const fn set_mode_key0(&mut self, val: super::vals::ModeKey0) {
                self.0 = (self.0 & !(0x07 << 2usize)) | (((val.to_bits() as u32) & 0x07) << 2usize);
            }
            #[doc = "Set the AES key length."]
            #[must_use]
            #[inline(always)]
            pub const fn nk_key0(&self) -> super::vals::NkKey0 {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::NkKey0::from_bits(val as u8)
            }
            #[doc = "Set the AES key length."]
            #[inline(always)]
            pub const fn set_nk_key0(&mut self, val: super::vals::NkKey0) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "This field determines the value that is written to AES_KEY_0, when AES_SK is kicked."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_xor_cryptokey(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "This field determines the value that is written to AES_KEY_0, when AES_SK is kicked."]
            #[inline(always)]
            pub const fn set_aes_xor_cryptokey(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Using direct access and not the DIN-DOUT DMA interface"]
            #[must_use]
            #[inline(always)]
            pub const fn direct_access(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Using direct access and not the DIN-DOUT DMA interface"]
            #[inline(always)]
            pub const fn set_direct_access(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for AesControl {
            #[inline(always)]
            fn default() -> AesControl {
                AesControl(0)
            }
        }
        impl core::fmt::Debug for AesControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesControl")
                    .field("dec_key0", &self.dec_key0())
                    .field("mode_key0", &self.mode_key0())
                    .field("nk_key0", &self.nk_key0())
                    .field("aes_xor_cryptokey", &self.aes_xor_cryptokey())
                    .field("direct_access", &self.direct_access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesControl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AesControl {{ dec_key0: {:?}, mode_key0: {:?}, nk_key0: {:?}, aes_xor_cryptokey: {=bool:?}, direct_access: {=bool:?} }}" , self . dec_key0 () , self . mode_key0 () , self . nk_key0 () , self . aes_xor_cryptokey () , self . direct_access ())
            }
        }
        #[doc = "This register enables the AES CTR no increment mode in which the counter mode is not incremented between two blocks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesCtrNoIncrement(pub u32);
        impl AesCtrNoIncrement {
            #[doc = "This field enables the AES CTR no increment mode in which the counter mode is not incremented between two blocks"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This field enables the AES CTR no increment mode in which the counter mode is not incremented between two blocks"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesCtrNoIncrement {
            #[inline(always)]
            fn default() -> AesCtrNoIncrement {
                AesCtrNoIncrement(0)
            }
        }
        impl core::fmt::Debug for AesCtrNoIncrement {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesCtrNoIncrement")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesCtrNoIncrement {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AesCtrNoIncrement {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Hardware configuration of the AES engine. Reset value holds the supported features."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesHwFlags(pub u32);
        impl AesHwFlags {
            #[doc = "If this flag is set, the engine support 192 bits and 256 bits key size."]
            #[must_use]
            #[inline(always)]
            pub const fn support_256_192_key(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support 192 bits and 256 bits key size."]
            #[inline(always)]
            pub const fn set_support_256_192_key(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "If this flag is set, the engine support AES_LARGE_RKEK."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_large_rkek(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support AES_LARGE_RKEK."]
            #[inline(always)]
            pub const fn set_aes_large_rkek(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this flag is set, the engine support DPA countermeasures."]
            #[must_use]
            #[inline(always)]
            pub const fn dpa_cntrmsr_exist(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support DPA countermeasures."]
            #[inline(always)]
            pub const fn set_dpa_cntrmsr_exist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "If this flag is set, the engine support AES CTR mode."]
            #[must_use]
            #[inline(always)]
            pub const fn ctr_exist(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support AES CTR mode."]
            #[inline(always)]
            pub const fn set_ctr_exist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "If this flag is set, the engine only support encrypt operations."]
            #[must_use]
            #[inline(always)]
            pub const fn only_encrypt(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine only support encrypt operations."]
            #[inline(always)]
            pub const fn set_only_encrypt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "If this flag is set, the engine uses SBOX tables."]
            #[must_use]
            #[inline(always)]
            pub const fn use_sbox_table(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine uses SBOX tables."]
            #[inline(always)]
            pub const fn set_use_sbox_table(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this flag is set, the engine uses 5 SBOX where each AES round takes 4 cycles."]
            #[must_use]
            #[inline(always)]
            pub const fn use_5_sboxes(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine uses 5 SBOX where each AES round takes 4 cycles."]
            #[inline(always)]
            pub const fn set_use_5_sboxes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "If this flag is set, the engine contains the PREV_IV register for faster AES XCBC MAC calculation."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_support_prev_iv(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine contains the PREV_IV register for faster AES XCBC MAC calculation."]
            #[inline(always)]
            pub const fn set_aes_support_prev_iv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "If this flag is set, the engine support tunneling operations."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_tunnel_exist(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support tunneling operations."]
            #[inline(always)]
            pub const fn set_aes_tunnel_exist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this flag is set, the engine support a second register set for tunneling operations."]
            #[must_use]
            #[inline(always)]
            pub const fn second_regs_set_exist(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support a second register set for tunneling operations."]
            #[inline(always)]
            pub const fn set_second_regs_set_exist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this flag is set, the engine support DFA countermeasures."]
            #[must_use]
            #[inline(always)]
            pub const fn dfa_cntrmsr_exist(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine support DFA countermeasures."]
            #[inline(always)]
            pub const fn set_dfa_cntrmsr_exist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for AesHwFlags {
            #[inline(always)]
            fn default() -> AesHwFlags {
                AesHwFlags(0)
            }
        }
        impl core::fmt::Debug for AesHwFlags {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesHwFlags")
                    .field("support_256_192_key", &self.support_256_192_key())
                    .field("aes_large_rkek", &self.aes_large_rkek())
                    .field("dpa_cntrmsr_exist", &self.dpa_cntrmsr_exist())
                    .field("ctr_exist", &self.ctr_exist())
                    .field("only_encrypt", &self.only_encrypt())
                    .field("use_sbox_table", &self.use_sbox_table())
                    .field("use_5_sboxes", &self.use_5_sboxes())
                    .field("aes_support_prev_iv", &self.aes_support_prev_iv())
                    .field("aes_tunnel_exist", &self.aes_tunnel_exist())
                    .field("second_regs_set_exist", &self.second_regs_set_exist())
                    .field("dfa_cntrmsr_exist", &self.dfa_cntrmsr_exist())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesHwFlags {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "AesHwFlags {{ support_256_192_key: {=bool:?}, aes_large_rkek: {=bool:?}, dpa_cntrmsr_exist: {=bool:?}, ctr_exist: {=bool:?}, only_encrypt: {=bool:?}, use_sbox_table: {=bool:?}, use_5_sboxes: {=bool:?}, aes_support_prev_iv: {=bool:?}, aes_tunnel_exist: {=bool:?}, second_regs_set_exist: {=bool:?}, dfa_cntrmsr_exist: {=bool:?} }}" , self . support_256_192_key () , self . aes_large_rkek () , self . dpa_cntrmsr_exist () , self . ctr_exist () , self . only_encrypt () , self . use_sbox_table () , self . use_5_sboxes () , self . aes_support_prev_iv () , self . aes_tunnel_exist () , self . second_regs_set_exist () , self . dfa_cntrmsr_exist ())
            }
        }
        #[doc = "Writing to this address trigger sampling of the HW key to the AES_KEY_0 register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesSk(pub u32);
        impl AesSk {
            #[doc = "Sample HW key to AES_KEY_0 registers."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_sk(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Sample HW key to AES_KEY_0 registers."]
            #[inline(always)]
            pub const fn set_aes_sk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesSk {
            #[inline(always)]
            fn default() -> AesSk {
                AesSk(0)
            }
        }
        impl core::fmt::Debug for AesSk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesSk")
                    .field("aes_sk", &self.aes_sk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesSk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesSk {{ aes_sk: {=bool:?} }}", self.aes_sk())
            }
        }
        #[doc = "Reset the AES engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesSwReset(pub u32);
        impl AesSwReset {
            #[doc = "Writing any value to this address resets the AES engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the AES engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesSwReset {
            #[inline(always)]
            fn default() -> AesSwReset {
                AesSwReset(0)
            }
        }
        impl core::fmt::Debug for AesSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DecKey0 {
            #[doc = "Perform AES encryption"]
            ENCRYPT = 0x0,
            #[doc = "Perform AES decryption"]
            DECRYPT = 0x01,
        }
        impl DecKey0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DecKey0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DecKey0 {
            #[inline(always)]
            fn from(val: u8) -> DecKey0 {
                DecKey0::from_bits(val)
            }
        }
        impl From<DecKey0> for u8 {
            #[inline(always)]
            fn from(val: DecKey0) -> u8 {
                DecKey0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ModeKey0 {
            #[doc = "Electronic codebook mode"]
            ECB = 0x0,
            #[doc = "Cipher block chaining mode"]
            CBC = 0x01,
            #[doc = "Counter mode"]
            CTR = 0x02,
            #[doc = "Cipher Block Chaining Message Authentication Code"]
            CBC_MAC = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Cipher-based Message Authentication Code"]
            CMAC = 0x07,
        }
        impl ModeKey0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ModeKey0 {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ModeKey0 {
            #[inline(always)]
            fn from(val: u8) -> ModeKey0 {
                ModeKey0::from_bits(val)
            }
        }
        impl From<ModeKey0> for u8 {
            #[inline(always)]
            fn from(val: ModeKey0) -> u8 {
                ModeKey0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NkKey0 {
            #[doc = "128 bits key length"]
            _128BITS = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl NkKey0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NkKey0 {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NkKey0 {
            #[inline(always)]
            fn from(val: u8) -> NkKey0 {
                NkKey0::from_bits(val)
            }
        }
        impl From<NkKey0> for u8 {
            #[inline(always)]
            fn from(val: NkKey0) -> u8 {
                NkKey0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "AES engine is idle"]
            IDLE = 0x0,
            #[doc = "AES engine is busy"]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
    }
}
pub mod cc_ahb {
    #[doc = "CRYPTOCELL AHB interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcAhb {
        ptr: *mut u8,
    }
    unsafe impl Send for CcAhb {}
    unsafe impl Sync for CcAhb {}
    impl CcAhb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register forces the AHB transactions from CRYPTOCELL master to be always singles."]
        #[inline(always)]
        pub const fn ahbm_singles(
            self,
        ) -> crate::common::Reg<regs::AhbmSingles, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b00usize) as _) }
        }
        #[doc = "This register holds the AHB HPROT value"]
        #[inline(always)]
        pub const fn ahbm_hprot(self) -> crate::common::Reg<regs::AhbmHprot, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b04usize) as _) }
        }
        #[doc = "This register holds AHB HMASTLOCK value"]
        #[inline(always)]
        pub const fn ahbm_hmastlock(
            self,
        ) -> crate::common::Reg<regs::AhbmHmastlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b08usize) as _) }
        }
        #[doc = "This register holds AHB HNONSEC value"]
        #[inline(always)]
        pub const fn ahbm_hnonsec(
            self,
        ) -> crate::common::Reg<regs::AhbmHnonsec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0b0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register holds AHB HMASTLOCK value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AhbmHmastlock(pub u32);
        impl AhbmHmastlock {
            #[doc = "The AHB HMASTLOCK value."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_hmastlock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The AHB HMASTLOCK value."]
            #[inline(always)]
            pub const fn set_ahb_hmastlock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AhbmHmastlock {
            #[inline(always)]
            fn default() -> AhbmHmastlock {
                AhbmHmastlock(0)
            }
        }
        impl core::fmt::Debug for AhbmHmastlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AhbmHmastlock")
                    .field("ahb_hmastlock", &self.ahb_hmastlock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AhbmHmastlock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AhbmHmastlock {{ ahb_hmastlock: {=bool:?} }}",
                    self.ahb_hmastlock()
                )
            }
        }
        #[doc = "This register holds AHB HNONSEC value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AhbmHnonsec(pub u32);
        impl AhbmHnonsec {
            #[doc = "The AHB HNONSEC value for write transaction."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_write_hnonsec(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The AHB HNONSEC value for write transaction."]
            #[inline(always)]
            pub const fn set_ahb_write_hnonsec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The AHB HNONSEC value for read transaction."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_read_hnonsec(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The AHB HNONSEC value for read transaction."]
            #[inline(always)]
            pub const fn set_ahb_read_hnonsec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for AhbmHnonsec {
            #[inline(always)]
            fn default() -> AhbmHnonsec {
                AhbmHnonsec(0)
            }
        }
        impl core::fmt::Debug for AhbmHnonsec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AhbmHnonsec")
                    .field("ahb_write_hnonsec", &self.ahb_write_hnonsec())
                    .field("ahb_read_hnonsec", &self.ahb_read_hnonsec())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AhbmHnonsec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AhbmHnonsec {{ ahb_write_hnonsec: {=bool:?}, ahb_read_hnonsec: {=bool:?} }}",
                    self.ahb_write_hnonsec(),
                    self.ahb_read_hnonsec()
                )
            }
        }
        #[doc = "This register holds the AHB HPROT value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AhbmHprot(pub u32);
        impl AhbmHprot {
            #[doc = "The AHB HPROT value"]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_hprot(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The AHB HPROT value"]
            #[inline(always)]
            pub const fn set_ahb_hprot(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for AhbmHprot {
            #[inline(always)]
            fn default() -> AhbmHprot {
                AhbmHprot(0)
            }
        }
        impl core::fmt::Debug for AhbmHprot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AhbmHprot")
                    .field("ahb_hprot", &self.ahb_hprot())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AhbmHprot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AhbmHprot {{ ahb_hprot: {=u8:?} }}", self.ahb_hprot())
            }
        }
        #[doc = "This register forces the AHB transactions from CRYPTOCELL master to be always singles."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AhbmSingles(pub u32);
        impl AhbmSingles {
            #[doc = "Force AHB singles"]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_singles(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Force AHB singles"]
            #[inline(always)]
            pub const fn set_ahb_singles(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AhbmSingles {
            #[inline(always)]
            fn default() -> AhbmSingles {
                AhbmSingles(0)
            }
        }
        impl core::fmt::Debug for AhbmSingles {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AhbmSingles")
                    .field("ahb_singles", &self.ahb_singles())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AhbmSingles {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AhbmSingles {{ ahb_singles: {=bool:?} }}",
                    self.ahb_singles()
                )
            }
        }
    }
}
pub mod cc_chacha {
    #[doc = "CRYPTOCELL CHACHA engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcChacha {
        ptr: *mut u8,
    }
    unsafe impl Send for CcChacha {}
    unsafe impl Sync for CcChacha {}
    impl CcChacha {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control the CHACHA engine behavior."]
        #[inline(always)]
        pub const fn chacha_control(
            self,
        ) -> crate::common::Reg<regs::ChachaControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0380usize) as _) }
        }
        #[doc = "CHACHA engine HW version"]
        #[inline(always)]
        pub const fn chacha_version(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0384usize) as _) }
        }
        #[doc = "Description collection: CHACHA key value to use. The initial CHACHA_KEY\\[0\\] register holds the least significant bits \\[31:0\\] of the key value."]
        #[inline(always)]
        pub const fn chacha_key(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0388usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: CHACHA Initialization Vector (IV) to use. The IV is also known as the nonce."]
        #[inline(always)]
        pub const fn chacha_iv(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03a8usize + n * 4usize) as _)
            }
        }
        #[doc = "Status register for CHACHA engine activity."]
        #[inline(always)]
        pub const fn chacha_busy(self) -> crate::common::Reg<regs::ChachaBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03b0usize) as _) }
        }
        #[doc = "Hardware configuration of the CHACHA engine. Reset value holds the supported features."]
        #[inline(always)]
        pub const fn chacha_hw_flags(
            self,
        ) -> crate::common::Reg<regs::ChachaHwFlags, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03b4usize) as _) }
        }
        #[doc = "Store the LSB value of the block counter, in order to support suspend/resume of operation"]
        #[inline(always)]
        pub const fn chacha_block_cnt_lsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03b8usize) as _) }
        }
        #[doc = "Store the MSB value of the block counter, in order to support suspend/resume of operation"]
        #[inline(always)]
        pub const fn chacha_block_cnt_msb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03bcusize) as _) }
        }
        #[doc = "Reset the CHACHA engine."]
        #[inline(always)]
        pub const fn chacha_sw_reset(
            self,
        ) -> crate::common::Reg<regs::ChachaSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03c0usize) as _) }
        }
        #[doc = "Description collection: The auto-generated key to use in Poly1305 MAC calculation. The initial CHACHA_POLY1305_KEY\\[0\\] register holds the least significant bits \\[31:0\\] of the key value."]
        #[inline(always)]
        pub const fn chacha_poly1305_key(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03c4usize + n * 4usize) as _)
            }
        }
        #[doc = "CHACHA engine data order configuration."]
        #[inline(always)]
        pub const fn chacha_endianness(
            self,
        ) -> crate::common::Reg<regs::ChachaEndianness, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03e4usize) as _) }
        }
        #[doc = "Debug register for the CHACHA engine"]
        #[inline(always)]
        pub const fn chacha_debug(self) -> crate::common::Reg<regs::ChachaDebug, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x03e8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status register for CHACHA engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaBusy(pub u32);
        impl ChachaBusy {
            #[doc = "CHACHA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "CHACHA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ChachaBusy {
            #[inline(always)]
            fn default() -> ChachaBusy {
                ChachaBusy(0)
            }
        }
        impl core::fmt::Debug for ChachaBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChachaBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Control the CHACHA engine behavior."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaControl(pub u32);
        impl ChachaControl {
            #[doc = "Run engine in ChaCha or Salsa mode"]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_or_salsa(&self) -> super::vals::ChachaOrSalsa {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ChachaOrSalsa::from_bits(val as u8)
            }
            #[doc = "Run engine in ChaCha or Salsa mode"]
            #[inline(always)]
            pub const fn set_chacha_or_salsa(&mut self, val: super::vals::ChachaOrSalsa) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Perform initialization for a new message"]
            #[must_use]
            #[inline(always)]
            pub const fn init(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Perform initialization for a new message"]
            #[inline(always)]
            pub const fn set_init(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Generate the key to use in Poly1305 message authentication code calculation."]
            #[must_use]
            #[inline(always)]
            pub const fn gen_key_poly1305(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Generate the key to use in Poly1305 message authentication code calculation."]
            #[inline(always)]
            pub const fn set_gen_key_poly1305(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Key length selection."]
            #[must_use]
            #[inline(always)]
            pub const fn key_len(&self) -> super::vals::KeyLen {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::KeyLen::from_bits(val as u8)
            }
            #[doc = "Key length selection."]
            #[inline(always)]
            pub const fn set_key_len(&mut self, val: super::vals::KeyLen) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Set number of permutation rounds, default value is 20."]
            #[must_use]
            #[inline(always)]
            pub const fn num_of_rounds(&self) -> super::vals::NumOfRounds {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::NumOfRounds::from_bits(val as u8)
            }
            #[doc = "Set number of permutation rounds, default value is 20."]
            #[inline(always)]
            pub const fn set_num_of_rounds(&mut self, val: super::vals::NumOfRounds) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Reset block counter for new messages"]
            #[must_use]
            #[inline(always)]
            pub const fn reset_block_cnt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Reset block counter for new messages"]
            #[inline(always)]
            pub const fn set_reset_block_cnt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Use 96 bits Initialization Vector (IV)"]
            #[must_use]
            #[inline(always)]
            pub const fn use_iv_96bit(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Use 96 bits Initialization Vector (IV)"]
            #[inline(always)]
            pub const fn set_use_iv_96bit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
        }
        impl Default for ChachaControl {
            #[inline(always)]
            fn default() -> ChachaControl {
                ChachaControl(0)
            }
        }
        impl core::fmt::Debug for ChachaControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaControl")
                    .field("chacha_or_salsa", &self.chacha_or_salsa())
                    .field("init", &self.init())
                    .field("gen_key_poly1305", &self.gen_key_poly1305())
                    .field("key_len", &self.key_len())
                    .field("num_of_rounds", &self.num_of_rounds())
                    .field("reset_block_cnt", &self.reset_block_cnt())
                    .field("use_iv_96bit", &self.use_iv_96bit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaControl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ChachaControl {{ chacha_or_salsa: {:?}, init: {=bool:?}, gen_key_poly1305: {=bool:?}, key_len: {:?}, num_of_rounds: {:?}, reset_block_cnt: {=bool:?}, use_iv_96bit: {=bool:?} }}" , self . chacha_or_salsa () , self . init () , self . gen_key_poly1305 () , self . key_len () , self . num_of_rounds () , self . reset_block_cnt () , self . use_iv_96bit ())
            }
        }
        #[doc = "Debug register for the CHACHA engine"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaDebug(pub u32);
        impl ChachaDebug {
            #[doc = "Reflects the debug state of the CHACHA FSM."]
            #[must_use]
            #[inline(always)]
            pub const fn fsm_state(&self) -> super::vals::FsmState {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::FsmState::from_bits(val as u8)
            }
            #[doc = "Reflects the debug state of the CHACHA FSM."]
            #[inline(always)]
            pub const fn set_fsm_state(&mut self, val: super::vals::FsmState) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for ChachaDebug {
            #[inline(always)]
            fn default() -> ChachaDebug {
                ChachaDebug(0)
            }
        }
        impl core::fmt::Debug for ChachaDebug {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaDebug")
                    .field("fsm_state", &self.fsm_state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaDebug {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChachaDebug {{ fsm_state: {:?} }}", self.fsm_state())
            }
        }
        #[doc = "CHACHA engine data order configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaEndianness(pub u32);
        impl ChachaEndianness {
            #[doc = "Change the word order of the input data."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_din_word_order(&self) -> super::vals::ChachaDinWordOrder {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ChachaDinWordOrder::from_bits(val as u8)
            }
            #[doc = "Change the word order of the input data."]
            #[inline(always)]
            pub const fn set_chacha_din_word_order(
                &mut self,
                val: super::vals::ChachaDinWordOrder,
            ) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Change the byte order of the input data."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_din_byte_order(&self) -> super::vals::ChachaDinByteOrder {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ChachaDinByteOrder::from_bits(val as u8)
            }
            #[doc = "Change the byte order of the input data."]
            #[inline(always)]
            pub const fn set_chacha_din_byte_order(
                &mut self,
                val: super::vals::ChachaDinByteOrder,
            ) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Change the quarter of a matrix order in the engine."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_core_matrix_lbe_order(
                &self,
            ) -> super::vals::ChachaCoreMatrixLbeOrder {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ChachaCoreMatrixLbeOrder::from_bits(val as u8)
            }
            #[doc = "Change the quarter of a matrix order in the engine."]
            #[inline(always)]
            pub const fn set_chacha_core_matrix_lbe_order(
                &mut self,
                val: super::vals::ChachaCoreMatrixLbeOrder,
            ) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Change the word order of the output data."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_dout_word_order(&self) -> super::vals::ChachaDoutWordOrder {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ChachaDoutWordOrder::from_bits(val as u8)
            }
            #[doc = "Change the word order of the output data."]
            #[inline(always)]
            pub const fn set_chacha_dout_word_order(
                &mut self,
                val: super::vals::ChachaDoutWordOrder,
            ) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Change the byte order of the output data."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_dout_byte_order(&self) -> super::vals::ChachaDoutByteOrder {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ChachaDoutByteOrder::from_bits(val as u8)
            }
            #[doc = "Change the byte order of the output data."]
            #[inline(always)]
            pub const fn set_chacha_dout_byte_order(
                &mut self,
                val: super::vals::ChachaDoutByteOrder,
            ) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for ChachaEndianness {
            #[inline(always)]
            fn default() -> ChachaEndianness {
                ChachaEndianness(0)
            }
        }
        impl core::fmt::Debug for ChachaEndianness {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaEndianness")
                    .field("chacha_din_word_order", &self.chacha_din_word_order())
                    .field("chacha_din_byte_order", &self.chacha_din_byte_order())
                    .field(
                        "chacha_core_matrix_lbe_order",
                        &self.chacha_core_matrix_lbe_order(),
                    )
                    .field("chacha_dout_word_order", &self.chacha_dout_word_order())
                    .field("chacha_dout_byte_order", &self.chacha_dout_byte_order())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaEndianness {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ChachaEndianness {{ chacha_din_word_order: {:?}, chacha_din_byte_order: {:?}, chacha_core_matrix_lbe_order: {:?}, chacha_dout_word_order: {:?}, chacha_dout_byte_order: {:?} }}" , self . chacha_din_word_order () , self . chacha_din_byte_order () , self . chacha_core_matrix_lbe_order () , self . chacha_dout_word_order () , self . chacha_dout_byte_order ())
            }
        }
        #[doc = "Hardware configuration of the CHACHA engine. Reset value holds the supported features."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaHwFlags(pub u32);
        impl ChachaHwFlags {
            #[doc = "If this flag is set, the engine include ChaCha support"]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_exists(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include ChaCha support"]
            #[inline(always)]
            pub const fn set_chacha_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "If this flag is set, the engine include Salsa support"]
            #[must_use]
            #[inline(always)]
            pub const fn salsa_exists(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include Salsa support"]
            #[inline(always)]
            pub const fn set_salsa_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this flag is set, the next matrix calculated when the current one is written to data output path."]
            #[must_use]
            #[inline(always)]
            pub const fn fast_chacha(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the next matrix calculated when the current one is written to data output path."]
            #[inline(always)]
            pub const fn set_fast_chacha(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for ChachaHwFlags {
            #[inline(always)]
            fn default() -> ChachaHwFlags {
                ChachaHwFlags(0)
            }
        }
        impl core::fmt::Debug for ChachaHwFlags {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaHwFlags")
                    .field("chacha_exists", &self.chacha_exists())
                    .field("salsa_exists", &self.salsa_exists())
                    .field("fast_chacha", &self.fast_chacha())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaHwFlags {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ChachaHwFlags {{ chacha_exists: {=bool:?}, salsa_exists: {=bool:?}, fast_chacha: {=bool:?} }}" , self . chacha_exists () , self . salsa_exists () , self . fast_chacha ())
            }
        }
        #[doc = "Reset the CHACHA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaSwReset(pub u32);
        impl ChachaSwReset {
            #[doc = "Writing any value to this address resets the CHACHA engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the CHACHA engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ChachaSwReset {
            #[inline(always)]
            fn default() -> ChachaSwReset {
                ChachaSwReset(0)
            }
        }
        impl core::fmt::Debug for ChachaSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChachaSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaCoreMatrixLbeOrder {
            #[doc = "Use default quarter of matrix order, where quarters are ordered as follows: q0, q1, q2, q3. Each quarter represents a 128-bits section of the matrix."]
            DEFAULT = 0x0,
            #[doc = "Reverse the order of matrix quarters, where quarters are re-ordered as follows: q3, q2, q1, q0. Each quarter represents a 128-bits section of the matrix."]
            REVERSE = 0x01,
        }
        impl ChachaCoreMatrixLbeOrder {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaCoreMatrixLbeOrder {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaCoreMatrixLbeOrder {
            #[inline(always)]
            fn from(val: u8) -> ChachaCoreMatrixLbeOrder {
                ChachaCoreMatrixLbeOrder::from_bits(val)
            }
        }
        impl From<ChachaCoreMatrixLbeOrder> for u8 {
            #[inline(always)]
            fn from(val: ChachaCoreMatrixLbeOrder) -> u8 {
                ChachaCoreMatrixLbeOrder::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaDinByteOrder {
            #[doc = "Use default byte order within each input word, where bytes are ordered as follows: B0, B1, B2, B3."]
            DEFAULT = 0x0,
            #[doc = "Reverse the byte order within each input word, where bytes are re-ordered as follows: B3, B2, B1, B0."]
            REVERSE = 0x01,
        }
        impl ChachaDinByteOrder {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaDinByteOrder {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaDinByteOrder {
            #[inline(always)]
            fn from(val: u8) -> ChachaDinByteOrder {
                ChachaDinByteOrder::from_bits(val)
            }
        }
        impl From<ChachaDinByteOrder> for u8 {
            #[inline(always)]
            fn from(val: ChachaDinByteOrder) -> u8 {
                ChachaDinByteOrder::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaDinWordOrder {
            #[doc = "Use default word order for 128-bits input, where words are ordered as follows: w0, w1, w2, w3."]
            DEFAULT = 0x0,
            #[doc = "Reverses the word order for 128-bits input, where words are re-ordered as follows: w3, w2, w1, w0."]
            REVERSE = 0x01,
        }
        impl ChachaDinWordOrder {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaDinWordOrder {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaDinWordOrder {
            #[inline(always)]
            fn from(val: u8) -> ChachaDinWordOrder {
                ChachaDinWordOrder::from_bits(val)
            }
        }
        impl From<ChachaDinWordOrder> for u8 {
            #[inline(always)]
            fn from(val: ChachaDinWordOrder) -> u8 {
                ChachaDinWordOrder::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaDoutByteOrder {
            #[doc = "Use default byte order within each output word, where bytes are ordered as follows: B0, B1, B2, B3."]
            DEFAULT = 0x0,
            #[doc = "Reverse the byte order within each output word, where bytes are re-ordered as follows: B3, B2, B1, B0."]
            REVERSE = 0x01,
        }
        impl ChachaDoutByteOrder {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaDoutByteOrder {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaDoutByteOrder {
            #[inline(always)]
            fn from(val: u8) -> ChachaDoutByteOrder {
                ChachaDoutByteOrder::from_bits(val)
            }
        }
        impl From<ChachaDoutByteOrder> for u8 {
            #[inline(always)]
            fn from(val: ChachaDoutByteOrder) -> u8 {
                ChachaDoutByteOrder::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaDoutWordOrder {
            #[doc = "Uses default word order for 128-bits output, where words are ordered as follows: w0, w1, w2, w3."]
            DEFAULT = 0x0,
            #[doc = "Reverse the word order for 128-bits output, where words are re-ordered as follows: w3, w2, w1, w0."]
            REVERSE = 0x01,
        }
        impl ChachaDoutWordOrder {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaDoutWordOrder {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaDoutWordOrder {
            #[inline(always)]
            fn from(val: u8) -> ChachaDoutWordOrder {
                ChachaDoutWordOrder::from_bits(val)
            }
        }
        impl From<ChachaDoutWordOrder> for u8 {
            #[inline(always)]
            fn from(val: ChachaDoutWordOrder) -> u8 {
                ChachaDoutWordOrder::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ChachaOrSalsa {
            #[doc = "Run engine in ChaCha mode"]
            CHA_CHA = 0x0,
            #[doc = "Run engine in Salsa mode"]
            SALSA = 0x01,
        }
        impl ChachaOrSalsa {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ChachaOrSalsa {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ChachaOrSalsa {
            #[inline(always)]
            fn from(val: u8) -> ChachaOrSalsa {
                ChachaOrSalsa::from_bits(val)
            }
        }
        impl From<ChachaOrSalsa> for u8 {
            #[inline(always)]
            fn from(val: ChachaOrSalsa) -> u8 {
                ChachaOrSalsa::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FsmState {
            #[doc = "CHACHA FSM is in idle state"]
            IDLE_STATE = 0x0,
            #[doc = "CHACHA FSM is in init state"]
            INIT_STATE = 0x01,
            #[doc = "CHACHA FSM is in rounds state"]
            ROUNDS_STATE = 0x02,
            #[doc = "CHACHA FSM is in final state"]
            FINAL_STATE = 0x03,
        }
        impl FsmState {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FsmState {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FsmState {
            #[inline(always)]
            fn from(val: u8) -> FsmState {
                FsmState::from_bits(val)
            }
        }
        impl From<FsmState> for u8 {
            #[inline(always)]
            fn from(val: FsmState) -> u8 {
                FsmState::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum KeyLen {
            #[doc = "Use 256 bits key length"]
            _256BITS = 0x0,
            #[doc = "Use 128 bits key length"]
            _128BITS = 0x01,
        }
        impl KeyLen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> KeyLen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for KeyLen {
            #[inline(always)]
            fn from(val: u8) -> KeyLen {
                KeyLen::from_bits(val)
            }
        }
        impl From<KeyLen> for u8 {
            #[inline(always)]
            fn from(val: KeyLen) -> u8 {
                KeyLen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NumOfRounds {
            #[doc = "Use 20 rounds of rotation (default)"]
            DEFAULT = 0x0,
            #[doc = "Use 12 rounds of rotation"]
            _12ROUNDS = 0x01,
            #[doc = "Use 8 rounds of rotation"]
            _8ROUNDS = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl NumOfRounds {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NumOfRounds {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NumOfRounds {
            #[inline(always)]
            fn from(val: u8) -> NumOfRounds {
                NumOfRounds::from_bits(val)
            }
        }
        impl From<NumOfRounds> for u8 {
            #[inline(always)]
            fn from(val: NumOfRounds) -> u8 {
                NumOfRounds::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "CHACHA engine is idle"]
            IDLE = 0x0,
            #[doc = "CHACHA engine is busy"]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
    }
}
pub mod cc_ctl {
    #[doc = "CRYPTOCELL CTL interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcCtl {
        ptr: *mut u8,
    }
    unsafe impl Send for CcCtl {}
    unsafe impl Sync for CcCtl {}
    impl CcCtl {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Defines the cryptographic flow."]
        #[inline(always)]
        pub const fn crypto_ctl(self) -> crate::common::Reg<regs::CryptoCtl, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0900usize) as _) }
        }
        #[doc = "Status register for cryptographic cores engine activity."]
        #[inline(always)]
        pub const fn crypto_busy(self) -> crate::common::Reg<regs::CryptoBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0910usize) as _) }
        }
        #[doc = "Status register for HASH engine activity."]
        #[inline(always)]
        pub const fn hash_busy(self) -> crate::common::Reg<regs::HashBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x091cusize) as _) }
        }
        #[doc = "A general-purpose read/write register."]
        #[inline(always)]
        pub const fn context_id(self) -> crate::common::Reg<regs::ContextId, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0930usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "A general-purpose read/write register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ContextId(pub u32);
        impl ContextId {
            #[doc = "Context ID"]
            #[must_use]
            #[inline(always)]
            pub const fn context_id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Context ID"]
            #[inline(always)]
            pub const fn set_context_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for ContextId {
            #[inline(always)]
            fn default() -> ContextId {
                ContextId(0)
            }
        }
        impl core::fmt::Debug for ContextId {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ContextId")
                    .field("context_id", &self.context_id())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ContextId {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ContextId {{ context_id: {=u8:?} }}", self.context_id())
            }
        }
        #[doc = "Status register for cryptographic cores engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptoBusy(pub u32);
        impl CryptoBusy {
            #[doc = "Cryptographic core engines status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::CryptoBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CryptoBusyStatus::from_bits(val as u8)
            }
            #[doc = "Cryptographic core engines status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::CryptoBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CryptoBusy {
            #[inline(always)]
            fn default() -> CryptoBusy {
                CryptoBusy(0)
            }
        }
        impl core::fmt::Debug for CryptoBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptoBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptoBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CryptoBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Defines the cryptographic flow."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptoCtl(pub u32);
        impl CryptoCtl {
            #[doc = "Configure the cryptographic engine mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Configure the cryptographic engine mode."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for CryptoCtl {
            #[inline(always)]
            fn default() -> CryptoCtl {
                CryptoCtl(0)
            }
        }
        impl core::fmt::Debug for CryptoCtl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptoCtl")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptoCtl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CryptoCtl {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Status register for HASH engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashBusy(pub u32);
        impl HashBusy {
            #[doc = "Hash engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::HashBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::HashBusyStatus::from_bits(val as u8)
            }
            #[doc = "Hash engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::HashBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashBusy {
            #[inline(always)]
            fn default() -> HashBusy {
                HashBusy(0)
            }
        }
        impl core::fmt::Debug for HashBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashBusy {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CryptoBusyStatus {
            #[doc = "Cryptographic core engines are idle"]
            IDLE = 0x0,
            #[doc = "Cryptographic core engines are busy"]
            BUSY = 0x01,
        }
        impl CryptoBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CryptoBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CryptoBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> CryptoBusyStatus {
                CryptoBusyStatus::from_bits(val)
            }
        }
        impl From<CryptoBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: CryptoBusyStatus) -> u8 {
                CryptoBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HashBusyStatus {
            #[doc = "HASH engine is idle"]
            IDLE = 0x0,
            #[doc = "HASH engine is busy"]
            BUSY = 0x01,
        }
        impl HashBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> HashBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for HashBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> HashBusyStatus {
                HashBusyStatus::from_bits(val)
            }
        }
        impl From<HashBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: HashBusyStatus) -> u8 {
                HashBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Bypass cryptographic engine"]
            BYPASS = 0x0,
            #[doc = "Use AES engine"]
            AESACTIVE = 0x01,
            #[doc = "Pipe AES engine output to HASH engine input"]
            AESTO_HASH_ACTIVE = 0x02,
            #[doc = "Process input using both AES and HASH engine in parallell"]
            AESAND_HASH_ACTIVE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Use HASH engine"]
            HASH_ACTIVE = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "Calculate AES MAC and bypass"]
            AESMACAND_BYPASS_ACTIVE = 0x09,
            #[doc = "Pipe AES engine output to HASH engine input. The resulting digest output is piped to DOUT buffer."]
            AESTO_HASH_AND_DOUTACTIVE = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "Use CHACHA engine"]
            CHA_CHA_ACTIVE = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod cc_din {
    #[doc = "CRYPTOCELL Data IN interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcDin {
        ptr: *mut u8,
    }
    unsafe impl Send for CcDin {}
    unsafe impl Sync for CcDin {}
    impl CcDin {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Used by CPU to write data directly to the DIN buffer, which is then sent to the cryptographic engines for processing."]
        #[inline(always)]
        pub const fn din_buffer(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c00usize) as _) }
        }
        #[doc = "Status register for DIN DMA engine activity when accessing memory."]
        #[inline(always)]
        pub const fn din_dma_mem_busy(
            self,
        ) -> crate::common::Reg<regs::DinDmaMemBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c20usize) as _) }
        }
        #[doc = "Data source address in memory."]
        #[inline(always)]
        pub const fn src_mem_addr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c28usize) as _) }
        }
        #[doc = "The number of bytes to be read from memory. Writing to this register triggers the DMA operation."]
        #[inline(always)]
        pub const fn src_mem_size(self) -> crate::common::Reg<regs::SrcMemSize, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c2cusize) as _) }
        }
        #[doc = "Data source address in RNG SRAM."]
        #[inline(always)]
        pub const fn src_sram_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c30usize) as _) }
        }
        #[doc = "The number of bytes to be read from RNG SRAM. Writing to this register triggers the DMA operation."]
        #[inline(always)]
        pub const fn src_sram_size(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c34usize) as _) }
        }
        #[doc = "Status register for DIN DMA engine activity when accessing RNG SRAM."]
        #[inline(always)]
        pub const fn din_dma_sram_busy(
            self,
        ) -> crate::common::Reg<regs::DinDmaSramBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c38usize) as _) }
        }
        #[doc = "Configure the endianness of DIN DMA transactions towards RNG SRAM."]
        #[inline(always)]
        pub const fn din_dma_sram_endianness(
            self,
        ) -> crate::common::Reg<regs::DinDmaSramEndianness, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c3cusize) as _) }
        }
        #[doc = "Reset the DIN DMA engine."]
        #[inline(always)]
        pub const fn din_sw_reset(self) -> crate::common::Reg<regs::DinSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c44usize) as _) }
        }
        #[doc = "Specifies the number of bytes the CPU will write to the DIN_BUFFER, ensuring the cryptographic engine processes the correct amount of data."]
        #[inline(always)]
        pub const fn din_cpu_data(self) -> crate::common::Reg<regs::DinCpuData, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c48usize) as _) }
        }
        #[doc = "Indicates that the next CPU write to the DIN_BUFFER is the last in the sequence. This is needed only when the data size is NOT modulo 4 (e.g. HASH padding)."]
        #[inline(always)]
        pub const fn din_write_align(
            self,
        ) -> crate::common::Reg<regs::DinWriteAlign, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c4cusize) as _) }
        }
        #[doc = "Register indicating if DIN FIFO is empty and if more data can be accepted."]
        #[inline(always)]
        pub const fn din_fifo_empty(
            self,
        ) -> crate::common::Reg<regs::DinFifoEmpty, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c50usize) as _) }
        }
        #[doc = "Reset the DIN FIFO, effectively clearing the FIFO for new data."]
        #[inline(always)]
        pub const fn din_fifo_reset(
            self,
        ) -> crate::common::Reg<regs::DinFifoReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c58usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Specifies the number of bytes the CPU will write to the DIN_BUFFER, ensuring the cryptographic engine processes the correct amount of data."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinCpuData(pub u32);
        impl DinCpuData {
            #[doc = "When using CPU direct write to the DIN_BUFFER, the size of input data in bytes should be written to this register."]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "When using CPU direct write to the DIN_BUFFER, the size of input data in bytes should be written to this register."]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for DinCpuData {
            #[inline(always)]
            fn default() -> DinCpuData {
                DinCpuData(0)
            }
        }
        impl core::fmt::Debug for DinCpuData {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinCpuData")
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinCpuData {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinCpuData {{ size: {=u16:?} }}", self.size())
            }
        }
        #[doc = "Status register for DIN DMA engine activity when accessing memory."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinDmaMemBusy(pub u32);
        impl DinDmaMemBusy {
            #[doc = "DIN memory DMA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::DinDmaMemBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DinDmaMemBusyStatus::from_bits(val as u8)
            }
            #[doc = "DIN memory DMA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::DinDmaMemBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinDmaMemBusy {
            #[inline(always)]
            fn default() -> DinDmaMemBusy {
                DinDmaMemBusy(0)
            }
        }
        impl core::fmt::Debug for DinDmaMemBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinDmaMemBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinDmaMemBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinDmaMemBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Status register for DIN DMA engine activity when accessing RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinDmaSramBusy(pub u32);
        impl DinDmaSramBusy {
            #[doc = "DIN RNG SRAM DMA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::DinDmaSramBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DinDmaSramBusyStatus::from_bits(val as u8)
            }
            #[doc = "DIN RNG SRAM DMA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::DinDmaSramBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinDmaSramBusy {
            #[inline(always)]
            fn default() -> DinDmaSramBusy {
                DinDmaSramBusy(0)
            }
        }
        impl core::fmt::Debug for DinDmaSramBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinDmaSramBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinDmaSramBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinDmaSramBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Configure the endianness of DIN DMA transactions towards RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinDmaSramEndianness(pub u32);
        impl DinDmaSramEndianness {
            #[doc = "Endianness of DIN DMA transactions towards RNG SRAM. The default value is little-endian."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Endianness of DIN DMA transactions towards RNG SRAM. The default value is little-endian."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinDmaSramEndianness {
            #[inline(always)]
            fn default() -> DinDmaSramEndianness {
                DinDmaSramEndianness(0)
            }
        }
        impl core::fmt::Debug for DinDmaSramEndianness {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinDmaSramEndianness")
                    .field("endian", &self.endian())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinDmaSramEndianness {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinDmaSramEndianness {{ endian: {:?} }}", self.endian())
            }
        }
        #[doc = "Register indicating if DIN FIFO is empty and if more data can be accepted."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinFifoEmpty(pub u32);
        impl DinFifoEmpty {
            #[doc = "DIN FIFO status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DIN FIFO status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinFifoEmpty {
            #[inline(always)]
            fn default() -> DinFifoEmpty {
                DinFifoEmpty(0)
            }
        }
        impl core::fmt::Debug for DinFifoEmpty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinFifoEmpty")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinFifoEmpty {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinFifoEmpty {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Reset the DIN FIFO, effectively clearing the FIFO for new data."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinFifoReset(pub u32);
        impl DinFifoReset {
            #[doc = "Writing any value to this address resets the DIN FIFO."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the DIN FIFO."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinFifoReset {
            #[inline(always)]
            fn default() -> DinFifoReset {
                DinFifoReset(0)
            }
        }
        impl core::fmt::Debug for DinFifoReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinFifoReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinFifoReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinFifoReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "Reset the DIN DMA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinSwReset(pub u32);
        impl DinSwReset {
            #[doc = "Writing any value to this address resets the DIN DMA engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the DIN DMA engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinSwReset {
            #[inline(always)]
            fn default() -> DinSwReset {
                DinSwReset(0)
            }
        }
        impl core::fmt::Debug for DinSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "Indicates that the next CPU write to the DIN_BUFFER is the last in the sequence. This is needed only when the data size is NOT modulo 4 (e.g. HASH padding)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DinWriteAlign(pub u32);
        impl DinWriteAlign {
            #[doc = "Next CPU write to the DIN_BUFFER is the last word."]
            #[must_use]
            #[inline(always)]
            pub const fn last(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Next CPU write to the DIN_BUFFER is the last word."]
            #[inline(always)]
            pub const fn set_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DinWriteAlign {
            #[inline(always)]
            fn default() -> DinWriteAlign {
                DinWriteAlign(0)
            }
        }
        impl core::fmt::Debug for DinWriteAlign {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DinWriteAlign")
                    .field("last", &self.last())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DinWriteAlign {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DinWriteAlign {{ last: {=bool:?} }}", self.last())
            }
        }
        #[doc = "The number of bytes to be read from memory. Writing to this register triggers the DMA operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SrcMemSize(pub u32);
        impl SrcMemSize {
            #[doc = "Total number of bytes to read from memory."]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "Total number of bytes to read from memory."]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x3fff_ffff << 0usize)) | (((val as u32) & 0x3fff_ffff) << 0usize);
            }
            #[doc = "This field is reserved"]
            #[must_use]
            #[inline(always)]
            pub const fn first(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "This field is reserved"]
            #[inline(always)]
            pub const fn set_first(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "This field is reserved"]
            #[must_use]
            #[inline(always)]
            pub const fn last(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This field is reserved"]
            #[inline(always)]
            pub const fn set_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for SrcMemSize {
            #[inline(always)]
            fn default() -> SrcMemSize {
                SrcMemSize(0)
            }
        }
        impl core::fmt::Debug for SrcMemSize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SrcMemSize")
                    .field("size", &self.size())
                    .field("first", &self.first())
                    .field("last", &self.last())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SrcMemSize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SrcMemSize {{ size: {=u32:?}, first: {=bool:?}, last: {=bool:?} }}",
                    self.size(),
                    self.first(),
                    self.last()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DinDmaMemBusyStatus {
            #[doc = "DIN memory DMA engine is idle"]
            IDLE = 0x0,
            #[doc = "DIN memory DMA engine is busy"]
            BUSY = 0x01,
        }
        impl DinDmaMemBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DinDmaMemBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DinDmaMemBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> DinDmaMemBusyStatus {
                DinDmaMemBusyStatus::from_bits(val)
            }
        }
        impl From<DinDmaMemBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: DinDmaMemBusyStatus) -> u8 {
                DinDmaMemBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DinDmaSramBusyStatus {
            #[doc = "DIN RNG SRAM DMA engine is idle"]
            IDLE = 0x0,
            #[doc = "DIN RNG SRAM DMA engine is busy"]
            BUSY = 0x01,
        }
        impl DinDmaSramBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DinDmaSramBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DinDmaSramBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> DinDmaSramBusyStatus {
                DinDmaSramBusyStatus::from_bits(val)
            }
        }
        impl From<DinDmaSramBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: DinDmaSramBusyStatus) -> u8 {
                DinDmaSramBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Use little-endian format for RNG SRAM DMA transactions"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Use big-endian format for RNG SRAM DMA transactions"]
            BIG_ENDIAN = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
    }
}
pub mod cc_dout {
    #[doc = "CRYPTOCELL Data OUT interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcDout {
        ptr: *mut u8,
    }
    unsafe impl Send for CcDout {}
    unsafe impl Sync for CcDout {}
    impl CcDout {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Cryptographic results directly accessible by the CPU."]
        #[inline(always)]
        pub const fn dout_buffer(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0c00usize) as _) }
        }
        #[doc = "Status register for DOUT DMA engine activity when accessing memory."]
        #[inline(always)]
        pub const fn dout_dma_mem_busy(
            self,
        ) -> crate::common::Reg<regs::DoutDmaMemBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d20usize) as _) }
        }
        #[doc = "Data destination address in memory."]
        #[inline(always)]
        pub const fn dst_mem_addr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d28usize) as _) }
        }
        #[doc = "The number of bytes to be written to memory."]
        #[inline(always)]
        pub const fn dst_mem_size(self) -> crate::common::Reg<regs::DstMemSize, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d2cusize) as _) }
        }
        #[doc = "Data destination address in RNG SRAM."]
        #[inline(always)]
        pub const fn dst_sram_addr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d30usize) as _) }
        }
        #[doc = "The number of bytes to be written to RNG SRAM."]
        #[inline(always)]
        pub const fn dst_sram_size(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d34usize) as _) }
        }
        #[doc = "Status register for DOUT DMA engine activity when accessing RNG SRAM."]
        #[inline(always)]
        pub const fn dout_dma_sram_busy(
            self,
        ) -> crate::common::Reg<regs::DoutDmaSramBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d38usize) as _) }
        }
        #[doc = "Configure the endianness of DOUT DMA transactions towards RNG SRAM."]
        #[inline(always)]
        pub const fn dout_dma_sram_endianness(
            self,
        ) -> crate::common::Reg<regs::DoutDmaSramEndianness, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d3cusize) as _) }
        }
        #[doc = "Indication that the next CPU read from the DOUT_BUFFER is the last in the sequence. This is needed only when the data size is NOT modulo 4 (e.g. HASH padding)."]
        #[inline(always)]
        pub const fn dout_read_align(
            self,
        ) -> crate::common::Reg<regs::DoutReadAlign, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d44usize) as _) }
        }
        #[doc = "Register indicating if DOUT FIFO is empty or if more data will come."]
        #[inline(always)]
        pub const fn dout_fifo_empty(
            self,
        ) -> crate::common::Reg<regs::DoutFifoEmpty, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d50usize) as _) }
        }
        #[doc = "Reset the DOUT DMA engine."]
        #[inline(always)]
        pub const fn dout_sw_reset(
            self,
        ) -> crate::common::Reg<regs::DoutSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0d58usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status register for DOUT DMA engine activity when accessing memory."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutDmaMemBusy(pub u32);
        impl DoutDmaMemBusy {
            #[doc = "DOUT memory DMA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::DoutDmaMemBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DoutDmaMemBusyStatus::from_bits(val as u8)
            }
            #[doc = "DOUT memory DMA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::DoutDmaMemBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutDmaMemBusy {
            #[inline(always)]
            fn default() -> DoutDmaMemBusy {
                DoutDmaMemBusy(0)
            }
        }
        impl core::fmt::Debug for DoutDmaMemBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutDmaMemBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutDmaMemBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutDmaMemBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Status register for DOUT DMA engine activity when accessing RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutDmaSramBusy(pub u32);
        impl DoutDmaSramBusy {
            #[doc = "DOUT RNG SRAM DMA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::DoutDmaSramBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DoutDmaSramBusyStatus::from_bits(val as u8)
            }
            #[doc = "DOUT RNG SRAM DMA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::DoutDmaSramBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutDmaSramBusy {
            #[inline(always)]
            fn default() -> DoutDmaSramBusy {
                DoutDmaSramBusy(0)
            }
        }
        impl core::fmt::Debug for DoutDmaSramBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutDmaSramBusy")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutDmaSramBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutDmaSramBusy {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Configure the endianness of DOUT DMA transactions towards RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutDmaSramEndianness(pub u32);
        impl DoutDmaSramEndianness {
            #[doc = "Endianness of DOUT DMA transactions towards RNG SRAM. The default value is little-endian."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Endianness of DOUT DMA transactions towards RNG SRAM. The default value is little-endian."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutDmaSramEndianness {
            #[inline(always)]
            fn default() -> DoutDmaSramEndianness {
                DoutDmaSramEndianness(0)
            }
        }
        impl core::fmt::Debug for DoutDmaSramEndianness {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutDmaSramEndianness")
                    .field("endian", &self.endian())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutDmaSramEndianness {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutDmaSramEndianness {{ endian: {:?} }}", self.endian())
            }
        }
        #[doc = "Register indicating if DOUT FIFO is empty or if more data will come."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutFifoEmpty(pub u32);
        impl DoutFifoEmpty {
            #[doc = "DOUT FIFO status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "DOUT FIFO status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutFifoEmpty {
            #[inline(always)]
            fn default() -> DoutFifoEmpty {
                DoutFifoEmpty(0)
            }
        }
        impl core::fmt::Debug for DoutFifoEmpty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutFifoEmpty")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutFifoEmpty {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutFifoEmpty {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Indication that the next CPU read from the DOUT_BUFFER is the last in the sequence. This is needed only when the data size is NOT modulo 4 (e.g. HASH padding)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutReadAlign(pub u32);
        impl DoutReadAlign {
            #[doc = "Next CPU read from the DOUT_BUFFER is the last word, and the remaining read aligned content can be flushed."]
            #[must_use]
            #[inline(always)]
            pub const fn last(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Next CPU read from the DOUT_BUFFER is the last word, and the remaining read aligned content can be flushed."]
            #[inline(always)]
            pub const fn set_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutReadAlign {
            #[inline(always)]
            fn default() -> DoutReadAlign {
                DoutReadAlign(0)
            }
        }
        impl core::fmt::Debug for DoutReadAlign {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutReadAlign")
                    .field("last", &self.last())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutReadAlign {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutReadAlign {{ last: {=bool:?} }}", self.last())
            }
        }
        #[doc = "Reset the DOUT DMA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DoutSwReset(pub u32);
        impl DoutSwReset {
            #[doc = "Writing any value to this address resets the DOUT DMA engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the DOUT DMA engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DoutSwReset {
            #[inline(always)]
            fn default() -> DoutSwReset {
                DoutSwReset(0)
            }
        }
        impl core::fmt::Debug for DoutSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DoutSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DoutSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DoutSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "The number of bytes to be written to memory."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DstMemSize(pub u32);
        impl DstMemSize {
            #[doc = "Total number of bytes to write to memory."]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x3fff_ffff;
                val as u32
            }
            #[doc = "Total number of bytes to write to memory."]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x3fff_ffff << 0usize)) | (((val as u32) & 0x3fff_ffff) << 0usize);
            }
            #[doc = "This field is reserved"]
            #[must_use]
            #[inline(always)]
            pub const fn first(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "This field is reserved"]
            #[inline(always)]
            pub const fn set_first(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "This field is reserved"]
            #[must_use]
            #[inline(always)]
            pub const fn last(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "This field is reserved"]
            #[inline(always)]
            pub const fn set_last(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for DstMemSize {
            #[inline(always)]
            fn default() -> DstMemSize {
                DstMemSize(0)
            }
        }
        impl core::fmt::Debug for DstMemSize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DstMemSize")
                    .field("size", &self.size())
                    .field("first", &self.first())
                    .field("last", &self.last())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DstMemSize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DstMemSize {{ size: {=u32:?}, first: {=bool:?}, last: {=bool:?} }}",
                    self.size(),
                    self.first(),
                    self.last()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutDmaMemBusyStatus {
            #[doc = "DOUT memory DMA engine is idle"]
            IDLE = 0x0,
            #[doc = "DOUT memory DMA engine is busy"]
            BUSY = 0x01,
        }
        impl DoutDmaMemBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutDmaMemBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutDmaMemBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> DoutDmaMemBusyStatus {
                DoutDmaMemBusyStatus::from_bits(val)
            }
        }
        impl From<DoutDmaMemBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: DoutDmaMemBusyStatus) -> u8 {
                DoutDmaMemBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutDmaSramBusyStatus {
            #[doc = "DOUT RNG SRAM DMA engine is idle"]
            IDLE = 0x0,
            #[doc = "DOUT RNG SRAM DMA engine is busy"]
            BUSY = 0x01,
        }
        impl DoutDmaSramBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutDmaSramBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutDmaSramBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> DoutDmaSramBusyStatus {
                DoutDmaSramBusyStatus::from_bits(val)
            }
        }
        impl From<DoutDmaSramBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: DoutDmaSramBusyStatus) -> u8 {
                DoutDmaSramBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Use little-endian format for RNG SRAM DMA transactions"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Use big-endian format for RNG SRAM DMA transactions"]
            BIG_ENDIAN = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
    }
}
pub mod cc_hash {
    #[doc = "CRYPTOCELL HASH engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcHash {
        ptr: *mut u8,
    }
    unsafe impl Send for CcHash {}
    unsafe impl Sync for CcHash {}
    impl CcHash {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: HASH_H value registers. The initial HASH_H\\[0\\] register holds the least significant bits \\[31:0\\] of the value."]
        #[inline(always)]
        pub const fn hash_h(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0640usize + n * 4usize) as _)
            }
        }
        #[doc = "Configure the HASH engine to automatically pad data at the end of the DMA transfer to complete the digest operation."]
        #[inline(always)]
        pub const fn hash_pad_auto(
            self,
        ) -> crate::common::Reg<regs::HashPadAuto, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0684usize) as _) }
        }
        #[doc = "Configure HASH engine initial state registers."]
        #[inline(always)]
        pub const fn hash_init_state(
            self,
        ) -> crate::common::Reg<regs::HashInitState, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0694usize) as _) }
        }
        #[doc = "HASH engine HW version"]
        #[inline(always)]
        pub const fn hash_version(self) -> crate::common::Reg<regs::HashVersion, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07b0usize) as _) }
        }
        #[doc = "Control the HASH engine behavior."]
        #[inline(always)]
        pub const fn hash_control(
            self,
        ) -> crate::common::Reg<regs::HashControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07c0usize) as _) }
        }
        #[doc = "Enable the hardware padding feature of the HASH engine."]
        #[inline(always)]
        pub const fn hash_pad(self) -> crate::common::Reg<regs::HashPad, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07c4usize) as _) }
        }
        #[doc = "Force the hardware padding operation to trigger if the input data length is zero bytes."]
        #[inline(always)]
        pub const fn hash_pad_force(
            self,
        ) -> crate::common::Reg<regs::HashPadForce, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07c8usize) as _) }
        }
        #[doc = "Bits \\[31:0\\] of the number of bytes that have been digested so far."]
        #[inline(always)]
        pub const fn hash_cur_len_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07ccusize) as _) }
        }
        #[doc = "Bits \\[63:32\\] of the number of bytes that have been digested so far."]
        #[inline(always)]
        pub const fn hash_cur_len_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07d0usize) as _) }
        }
        #[doc = "Hardware configuration of the HASH engine. Reset value holds the supported features."]
        #[inline(always)]
        pub const fn hash_hw_flags(
            self,
        ) -> crate::common::Reg<regs::HashHwFlags, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07dcusize) as _) }
        }
        #[doc = "Reset the HASH engine."]
        #[inline(always)]
        pub const fn hash_sw_reset(
            self,
        ) -> crate::common::Reg<regs::HashSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07e4usize) as _) }
        }
        #[doc = "Configure the endianness of HASH data and padding generation."]
        #[inline(always)]
        pub const fn hash_endianness(
            self,
        ) -> crate::common::Reg<regs::HashEndianness, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x07e8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control the HASH engine behavior."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashControl(pub u32);
        impl HashControl {
            #[doc = "Select HASH mode to execute"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Select HASH mode to execute"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for HashControl {
            #[inline(always)]
            fn default() -> HashControl {
                HashControl(0)
            }
        }
        impl core::fmt::Debug for HashControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashControl")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashControl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashControl {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Configure the endianness of HASH data and padding generation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashEndianness(pub u32);
        impl HashEndianness {
            #[doc = "Endianness of HASH data and padding generation. The default value is little-endian."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Endianness of HASH data and padding generation. The default value is little-endian."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashEndianness {
            #[inline(always)]
            fn default() -> HashEndianness {
                HashEndianness(0)
            }
        }
        impl core::fmt::Debug for HashEndianness {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashEndianness")
                    .field("endian", &self.endian())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashEndianness {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashEndianness {{ endian: {:?} }}", self.endian())
            }
        }
        #[doc = "Hardware configuration of the HASH engine. Reset value holds the supported features."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashHwFlags(pub u32);
        impl HashHwFlags {
            #[doc = "Indicates the number of concurrent words the hash is using to compute signature."]
            #[must_use]
            #[inline(always)]
            pub const fn cw(&self) -> super::vals::Cw {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Cw::from_bits(val as u8)
            }
            #[doc = "Indicates the number of concurrent words the hash is using to compute signature."]
            #[inline(always)]
            pub const fn set_cw(&mut self, val: super::vals::Cw) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Indicate if Hi adders are present for each Hi value or 1 adder is shared for all Hi."]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self) -> super::vals::Ch {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Ch::from_bits(val as u8)
            }
            #[doc = "Indicate if Hi adders are present for each Hi value or 1 adder is shared for all Hi."]
            #[inline(always)]
            pub const fn set_ch(&mut self, val: super::vals::Ch) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Determine the granularity of word size."]
            #[must_use]
            #[inline(always)]
            pub const fn dw(&self) -> super::vals::Dw {
                let val = (self.0 >> 8usize) & 0x0f;
                super::vals::Dw::from_bits(val as u8)
            }
            #[doc = "Determine the granularity of word size."]
            #[inline(always)]
            pub const fn set_dw(&mut self, val: super::vals::Dw) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u32) & 0x0f) << 8usize);
            }
            #[doc = "If this flag is set, the engine include SHA-512 support."]
            #[must_use]
            #[inline(always)]
            pub const fn sha_512_exists(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include SHA-512 support."]
            #[inline(always)]
            pub const fn set_sha_512_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this flag is set, the engine include pad block support."]
            #[must_use]
            #[inline(always)]
            pub const fn pad_exists(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include pad block support."]
            #[inline(always)]
            pub const fn set_pad_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "If this flag is set, the engine include MD5 support."]
            #[must_use]
            #[inline(always)]
            pub const fn md5_exists(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include MD5 support."]
            #[inline(always)]
            pub const fn set_md5_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "If this flag is set, the engine include HMAC support."]
            #[must_use]
            #[inline(always)]
            pub const fn hmac_exists(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include HMAC support."]
            #[inline(always)]
            pub const fn set_hmac_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "If this flag is set, the engine include SHA-256 support."]
            #[must_use]
            #[inline(always)]
            pub const fn sha_256_exists(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include SHA-256 support."]
            #[inline(always)]
            pub const fn set_sha_256_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "If this flag is set, the engine include compare digest logic."]
            #[must_use]
            #[inline(always)]
            pub const fn hash_compare_exists(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include compare digest logic."]
            #[inline(always)]
            pub const fn set_hash_compare_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "If this flag is set, the engine include HASH to DOUT support."]
            #[must_use]
            #[inline(always)]
            pub const fn dump_hash_to_dout_exists(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include HASH to DOUT support."]
            #[inline(always)]
            pub const fn set_dump_hash_to_dout_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for HashHwFlags {
            #[inline(always)]
            fn default() -> HashHwFlags {
                HashHwFlags(0)
            }
        }
        impl core::fmt::Debug for HashHwFlags {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashHwFlags")
                    .field("cw", &self.cw())
                    .field("ch", &self.ch())
                    .field("dw", &self.dw())
                    .field("sha_512_exists", &self.sha_512_exists())
                    .field("pad_exists", &self.pad_exists())
                    .field("md5_exists", &self.md5_exists())
                    .field("hmac_exists", &self.hmac_exists())
                    .field("sha_256_exists", &self.sha_256_exists())
                    .field("hash_compare_exists", &self.hash_compare_exists())
                    .field("dump_hash_to_dout_exists", &self.dump_hash_to_dout_exists())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashHwFlags {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HashHwFlags {{ cw: {:?}, ch: {:?}, dw: {:?}, sha_512_exists: {=bool:?}, pad_exists: {=bool:?}, md5_exists: {=bool:?}, hmac_exists: {=bool:?}, sha_256_exists: {=bool:?}, hash_compare_exists: {=bool:?}, dump_hash_to_dout_exists: {=bool:?} }}" , self . cw () , self . ch () , self . dw () , self . sha_512_exists () , self . pad_exists () , self . md5_exists () , self . hmac_exists () , self . sha_256_exists () , self . hash_compare_exists () , self . dump_hash_to_dout_exists ())
            }
        }
        #[doc = "Configure HASH engine initial state registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashInitState(pub u32);
        impl HashInitState {
            #[doc = "Enable loading of data to initial state registers. Digest/IV for HASH/AES_MAC."]
            #[must_use]
            #[inline(always)]
            pub const fn load(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable loading of data to initial state registers. Digest/IV for HASH/AES_MAC."]
            #[inline(always)]
            pub const fn set_load(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashInitState {
            #[inline(always)]
            fn default() -> HashInitState {
                HashInitState(0)
            }
        }
        impl core::fmt::Debug for HashInitState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashInitState")
                    .field("load", &self.load())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashInitState {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashInitState {{ load: {=bool:?} }}", self.load())
            }
        }
        #[doc = "Enable the hardware padding feature of the HASH engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashPad(pub u32);
        impl HashPad {
            #[doc = "Configure hardware padding feature."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure hardware padding feature."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashPad {
            #[inline(always)]
            fn default() -> HashPad {
                HashPad(0)
            }
        }
        impl core::fmt::Debug for HashPad {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashPad")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashPad {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashPad {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Configure the HASH engine to automatically pad data at the end of the DMA transfer to complete the digest operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashPadAuto(pub u32);
        impl HashPadAuto {
            #[doc = "Enable automatic padding in hardware."]
            #[must_use]
            #[inline(always)]
            pub const fn hwpad(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable automatic padding in hardware."]
            #[inline(always)]
            pub const fn set_hwpad(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashPadAuto {
            #[inline(always)]
            fn default() -> HashPadAuto {
                HashPadAuto(0)
            }
        }
        impl core::fmt::Debug for HashPadAuto {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashPadAuto")
                    .field("hwpad", &self.hwpad())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashPadAuto {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashPadAuto {{ hwpad: {=bool:?} }}", self.hwpad())
            }
        }
        #[doc = "Force the hardware padding operation to trigger if the input data length is zero bytes."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashPadForce(pub u32);
        impl HashPadForce {
            #[doc = "Trigger hardware padding operation."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Trigger hardware padding operation."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for HashPadForce {
            #[inline(always)]
            fn default() -> HashPadForce {
                HashPadForce(0)
            }
        }
        impl core::fmt::Debug for HashPadForce {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashPadForce")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashPadForce {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashPadForce {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Reset the HASH engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashSwReset(pub u32);
        impl HashSwReset {
            #[doc = "Writing any value to this address resets the HASH engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the HASH engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashSwReset {
            #[inline(always)]
            fn default() -> HashSwReset {
                HashSwReset(0)
            }
        }
        impl core::fmt::Debug for HashSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "HASH engine HW version"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashVersion(pub u32);
        impl HashVersion {
            #[must_use]
            #[inline(always)]
            pub const fn patch(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[inline(always)]
            pub const fn set_patch(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Minor version number"]
            #[must_use]
            #[inline(always)]
            pub const fn minor_version_number(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Minor version number"]
            #[inline(always)]
            pub const fn set_minor_version_number(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Major version number"]
            #[must_use]
            #[inline(always)]
            pub const fn major_version_number(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Major version number"]
            #[inline(always)]
            pub const fn set_major_version_number(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for HashVersion {
            #[inline(always)]
            fn default() -> HashVersion {
                HashVersion(0)
            }
        }
        impl core::fmt::Debug for HashVersion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashVersion")
                    .field("patch", &self.patch())
                    .field("minor_version_number", &self.minor_version_number())
                    .field("major_version_number", &self.major_version_number())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashVersion {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HashVersion {{ patch: {=u8:?}, minor_version_number: {=u8:?}, major_version_number: {=u8:?} }}" , self . patch () , self . minor_version_number () , self . major_version_number ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ch {
            #[doc = "One Hi value is updated at a time."]
            ONE = 0x0,
            #[doc = "All Hi values are updated at the same time."]
            ALL = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ch {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ch {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ch {
            #[inline(always)]
            fn from(val: u8) -> Ch {
                Ch::from_bits(val)
            }
        }
        impl From<Ch> for u8 {
            #[inline(always)]
            fn from(val: Ch) -> u8 {
                Ch::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cw {
            _RESERVED_0 = 0x0,
            #[doc = "One concurrent word used by hash during signature generation"]
            ONE = 0x01,
            #[doc = "Two concurrent words used by hash during signature generation"]
            TWO = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Cw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cw {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cw {
            #[inline(always)]
            fn from(val: u8) -> Cw {
                Cw::from_bits(val)
            }
        }
        impl From<Cw> for u8 {
            #[inline(always)]
            fn from(val: Cw) -> u8 {
                Cw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dw {
            #[doc = "32 bits word data."]
            _32BITS = 0x0,
            #[doc = "64 bits word data."]
            _64BITS = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Dw {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dw {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dw {
            #[inline(always)]
            fn from(val: u8) -> Dw {
                Dw::from_bits(val)
            }
        }
        impl From<Dw> for u8 {
            #[inline(always)]
            fn from(val: Dw) -> u8 {
                Dw::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Use little-endian format for data and padding"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Use big-endian format for data and padding"]
            BIG_ENDIAN = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            _RESERVED_0 = 0x0,
            #[doc = "Select SHA1 mode"]
            SHA1 = 0x01,
            #[doc = "Select SHA256 mode"]
            SHA256 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            #[doc = "Select SHA224 mode"]
            SHA224 = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod cc_host_rgf {
    #[doc = "CRYPTOCELL HOST register interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcHostRgf {
        ptr: *mut u8,
    }
    unsafe impl Send for CcHostRgf {}
    unsafe impl Sync for CcHostRgf {}
    impl CcHostRgf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Interrupt request register. Each bit of this register holds the interrupt status of a single interrupt source. If corresponding IMR bit is unmasked, an interrupt is generated."]
        #[inline(always)]
        pub const fn irr(self) -> crate::common::Reg<regs::Irr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a00usize) as _) }
        }
        #[doc = "Interrupt mask register. Each bit of this register holds the mask of a single interrupt source."]
        #[inline(always)]
        pub const fn imr(self) -> crate::common::Reg<regs::Imr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a04usize) as _) }
        }
        #[doc = "Interrupt clear register. Writing a 1 bit into a field in this register will clear the corresponding bit in IRR."]
        #[inline(always)]
        pub const fn icr(self) -> crate::common::Reg<regs::Icr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a08usize) as _) }
        }
        #[doc = "This register defines the endianness of the Host-accessible registers, and can only be written once."]
        #[inline(always)]
        pub const fn endianness(self) -> crate::common::Reg<regs::Endianness, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a0cusize) as _) }
        }
        #[doc = "This register holds the CRYPTOCELL subsystem signature. See reset value."]
        #[inline(always)]
        pub const fn host_signature(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a24usize) as _) }
        }
        #[doc = "Hardware configuration of the CRYPTOCELL subsystem. Reset value holds the supported features."]
        #[inline(always)]
        pub const fn host_boot(self) -> crate::common::Reg<regs::HostBoot, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a28usize) as _) }
        }
        #[doc = "AES hardware key select."]
        #[inline(always)]
        pub const fn host_cryptokey_sel(
            self,
        ) -> crate::common::Reg<regs::HostCryptokeySel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a38usize) as _) }
        }
        #[doc = "This write-once register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain."]
        #[inline(always)]
        pub const fn host_iot_kprtl_lock(
            self,
        ) -> crate::common::Reg<regs::HostIotKprtlLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a4cusize) as _) }
        }
        #[doc = "This register holds bits 31:0 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. Reading from this address returns the K_DR valid status indicating if K_DR is successfully retained."]
        #[inline(always)]
        pub const fn host_iot_kdr0(
            self,
        ) -> crate::common::Reg<regs::HostIotKdr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a50usize) as _) }
        }
        #[doc = "This register holds bits 63:32 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain."]
        #[inline(always)]
        pub const fn host_iot_kdr1(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a54usize) as _) }
        }
        #[doc = "This register holds bits 95:64 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain."]
        #[inline(always)]
        pub const fn host_iot_kdr2(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a58usize) as _) }
        }
        #[doc = "This register holds bits 127:96 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain."]
        #[inline(always)]
        pub const fn host_iot_kdr3(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a5cusize) as _) }
        }
        #[doc = "Controls life-cycle state (LCS) for CRYPTOCELL subsystem"]
        #[inline(always)]
        pub const fn host_iot_lcs(self) -> crate::common::Reg<regs::HostIotLcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0a60usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register defines the endianness of the Host-accessible registers, and can only be written once."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Endianness(pub u32);
        impl Endianness {
            #[doc = "DOUT write endianness."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_wr_bg(&self) -> super::vals::DoutWrBg {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::DoutWrBg::from_bits(val as u8)
            }
            #[doc = "DOUT write endianness."]
            #[inline(always)]
            pub const fn set_dout_wr_bg(&mut self, val: super::vals::DoutWrBg) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "DIN read endianness."]
            #[must_use]
            #[inline(always)]
            pub const fn din_rd_bg(&self) -> super::vals::DinRdBg {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::DinRdBg::from_bits(val as u8)
            }
            #[doc = "DIN read endianness."]
            #[inline(always)]
            pub const fn set_din_rd_bg(&mut self, val: super::vals::DinRdBg) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "DOUT write word endianness."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_wr_wbg(&self) -> super::vals::DoutWrWbg {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::DoutWrWbg::from_bits(val as u8)
            }
            #[doc = "DOUT write word endianness."]
            #[inline(always)]
            pub const fn set_dout_wr_wbg(&mut self, val: super::vals::DoutWrWbg) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "DIN read word endianness."]
            #[must_use]
            #[inline(always)]
            pub const fn din_rd_wbg(&self) -> super::vals::DinRdWbg {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::DinRdWbg::from_bits(val as u8)
            }
            #[doc = "DIN read word endianness."]
            #[inline(always)]
            pub const fn set_din_rd_wbg(&mut self, val: super::vals::DinRdWbg) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Endianness {
            #[inline(always)]
            fn default() -> Endianness {
                Endianness(0)
            }
        }
        impl core::fmt::Debug for Endianness {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Endianness")
                    .field("dout_wr_bg", &self.dout_wr_bg())
                    .field("din_rd_bg", &self.din_rd_bg())
                    .field("dout_wr_wbg", &self.dout_wr_wbg())
                    .field("din_rd_wbg", &self.din_rd_wbg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Endianness {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Endianness {{ dout_wr_bg: {:?}, din_rd_bg: {:?}, dout_wr_wbg: {:?}, din_rd_wbg: {:?} }}" , self . dout_wr_bg () , self . din_rd_bg () , self . dout_wr_wbg () , self . din_rd_wbg ())
            }
        }
        #[doc = "Hardware configuration of the CRYPTOCELL subsystem. Reset value holds the supported features."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostBoot(pub u32);
        impl HostBoot {
            #[doc = "If this flag is set, full power gating is implemented"]
            #[must_use]
            #[inline(always)]
            pub const fn power_gating_exists_local(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, full power gating is implemented"]
            #[inline(always)]
            pub const fn set_power_gating_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "If this flag is set, large RKEK is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn large_rkek_local(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, large RKEK is supported"]
            #[inline(always)]
            pub const fn set_large_rkek_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this flag is set, HASH in fuses is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn hash_in_fuses_local(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, HASH in fuses is supported"]
            #[inline(always)]
            pub const fn set_hash_in_fuses_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "If this flag is set, external secure memory is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn ext_mem_secured_local(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, external secure memory is supported"]
            #[inline(always)]
            pub const fn set_ext_mem_secured_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "If this flag is set, RKEK ECC is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn rkek_ecc_exists_local_n(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, RKEK ECC is supported"]
            #[inline(always)]
            pub const fn set_rkek_ecc_exists_local_n(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "SRAM size"]
            #[must_use]
            #[inline(always)]
            pub const fn sram_size_local(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x07;
                val as u8
            }
            #[doc = "SRAM size"]
            #[inline(always)]
            pub const fn set_sram_size_local(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val as u32) & 0x07) << 6usize);
            }
            #[doc = "If this flag is set, Descriptors are supported"]
            #[must_use]
            #[inline(always)]
            pub const fn dscrptr_exists_local(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, Descriptors are supported"]
            #[inline(always)]
            pub const fn set_dscrptr_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "If this flag is set, PAU is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn pau_exists_local(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, PAU is supported"]
            #[inline(always)]
            pub const fn set_pau_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "If this flag is set, the RNG engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn rng_exists_local(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the RNG engine is present"]
            #[inline(always)]
            pub const fn set_rng_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "If this flag is set, the PKA engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn pka_exists_local(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the PKA engine is present"]
            #[inline(always)]
            pub const fn set_pka_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "If this flag is set, the RC4 engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn rc4_exists_local(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the RC4 engine is present"]
            #[inline(always)]
            pub const fn set_rc4_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "If this flag is set, the HASH engine supports SHA512"]
            #[must_use]
            #[inline(always)]
            pub const fn sha_512_prsnt_local(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the HASH engine supports SHA512"]
            #[inline(always)]
            pub const fn set_sha_512_prsnt_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "If this flag is set, the HASH engine supports SHA256"]
            #[must_use]
            #[inline(always)]
            pub const fn sha_256_prsnt_local(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the HASH engine supports SHA256"]
            #[inline(always)]
            pub const fn set_sha_256_prsnt_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "If this flag is set, the HASH engine supports MD5"]
            #[must_use]
            #[inline(always)]
            pub const fn md5_prsnt_local(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the HASH engine supports MD5"]
            #[inline(always)]
            pub const fn set_md5_prsnt_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "If this flag is set, the HASH engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn hash_exists_local(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the HASH engine is present"]
            #[inline(always)]
            pub const fn set_hash_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "If this flag is set, the C2 engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn c2_exists_local(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the C2 engine is present"]
            #[inline(always)]
            pub const fn set_c2_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "If this flag is set, the DES engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn des_exists_local(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the DES engine is present"]
            #[inline(always)]
            pub const fn set_des_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "If this flag is set, AES XCBC-MAC mode is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_xcbc_mac_exists_local(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES XCBC-MAC mode is supported"]
            #[inline(always)]
            pub const fn set_aes_xcbc_mac_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "If this flag is set, AES CMAC mode is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_cmac_exists_local(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES CMAC mode is supported"]
            #[inline(always)]
            pub const fn set_aes_cmac_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "If this flag is set, AES CCM mode is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_ccm_exists_local(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES CCM mode is supported"]
            #[inline(always)]
            pub const fn set_aes_ccm_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "If this flag is set, AES XEX mode T-value calculation in HW is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_xex_hw_t_calc_local(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES XEX mode T-value calculation in HW is supported"]
            #[inline(always)]
            pub const fn set_aes_xex_hw_t_calc_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "If this flag is set, AES XEX mode is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_xex_exists_local(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES XEX mode is supported"]
            #[inline(always)]
            pub const fn set_aes_xex_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "If this flag is set, AES CTR mode is supported"]
            #[must_use]
            #[inline(always)]
            pub const fn ctr_exists_local(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, AES CTR mode is supported"]
            #[inline(always)]
            pub const fn set_ctr_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If this flag is set, the AES engine data input support byte size resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_din_byte_resolution_local(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the AES engine data input support byte size resolution"]
            #[inline(always)]
            pub const fn set_aes_din_byte_resolution_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "If this flag is set, the AES engine supports tunneling operations"]
            #[must_use]
            #[inline(always)]
            pub const fn tunneling_enb_local(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the AES engine supports tunneling operations"]
            #[inline(always)]
            pub const fn set_tunneling_enb_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "If this flag is set, the AES engine supports 192/256 bits key sizes"]
            #[must_use]
            #[inline(always)]
            pub const fn support_256_192_key_local(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the AES engine supports 192/256 bits key sizes"]
            #[inline(always)]
            pub const fn set_support_256_192_key_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "If this flag is set, the AES engine only support encryption"]
            #[must_use]
            #[inline(always)]
            pub const fn only_encrypt_local(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the AES engine only support encryption"]
            #[inline(always)]
            pub const fn set_only_encrypt_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "If this flag is set, the AES engine is present"]
            #[must_use]
            #[inline(always)]
            pub const fn aes_exists_local(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the AES engine is present"]
            #[inline(always)]
            pub const fn set_aes_exists_local(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for HostBoot {
            #[inline(always)]
            fn default() -> HostBoot {
                HostBoot(0)
            }
        }
        impl core::fmt::Debug for HostBoot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostBoot")
                    .field(
                        "power_gating_exists_local",
                        &self.power_gating_exists_local(),
                    )
                    .field("large_rkek_local", &self.large_rkek_local())
                    .field("hash_in_fuses_local", &self.hash_in_fuses_local())
                    .field("ext_mem_secured_local", &self.ext_mem_secured_local())
                    .field("rkek_ecc_exists_local_n", &self.rkek_ecc_exists_local_n())
                    .field("sram_size_local", &self.sram_size_local())
                    .field("dscrptr_exists_local", &self.dscrptr_exists_local())
                    .field("pau_exists_local", &self.pau_exists_local())
                    .field("rng_exists_local", &self.rng_exists_local())
                    .field("pka_exists_local", &self.pka_exists_local())
                    .field("rc4_exists_local", &self.rc4_exists_local())
                    .field("sha_512_prsnt_local", &self.sha_512_prsnt_local())
                    .field("sha_256_prsnt_local", &self.sha_256_prsnt_local())
                    .field("md5_prsnt_local", &self.md5_prsnt_local())
                    .field("hash_exists_local", &self.hash_exists_local())
                    .field("c2_exists_local", &self.c2_exists_local())
                    .field("des_exists_local", &self.des_exists_local())
                    .field(
                        "aes_xcbc_mac_exists_local",
                        &self.aes_xcbc_mac_exists_local(),
                    )
                    .field("aes_cmac_exists_local", &self.aes_cmac_exists_local())
                    .field("aes_ccm_exists_local", &self.aes_ccm_exists_local())
                    .field("aes_xex_hw_t_calc_local", &self.aes_xex_hw_t_calc_local())
                    .field("aes_xex_exists_local", &self.aes_xex_exists_local())
                    .field("ctr_exists_local", &self.ctr_exists_local())
                    .field(
                        "aes_din_byte_resolution_local",
                        &self.aes_din_byte_resolution_local(),
                    )
                    .field("tunneling_enb_local", &self.tunneling_enb_local())
                    .field(
                        "support_256_192_key_local",
                        &self.support_256_192_key_local(),
                    )
                    .field("only_encrypt_local", &self.only_encrypt_local())
                    .field("aes_exists_local", &self.aes_exists_local())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostBoot {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "HostBoot {{ power_gating_exists_local: {=bool:?}, large_rkek_local: {=bool:?}, hash_in_fuses_local: {=bool:?}, ext_mem_secured_local: {=bool:?}, rkek_ecc_exists_local_n: {=bool:?}, sram_size_local: {=u8:?}, dscrptr_exists_local: {=bool:?}, pau_exists_local: {=bool:?}, rng_exists_local: {=bool:?}, pka_exists_local: {=bool:?}, rc4_exists_local: {=bool:?}, sha_512_prsnt_local: {=bool:?}, sha_256_prsnt_local: {=bool:?}, md5_prsnt_local: {=bool:?}, hash_exists_local: {=bool:?}, c2_exists_local: {=bool:?}, des_exists_local: {=bool:?}, aes_xcbc_mac_exists_local: {=bool:?}, aes_cmac_exists_local: {=bool:?}, aes_ccm_exists_local: {=bool:?}, aes_xex_hw_t_calc_local: {=bool:?}, aes_xex_exists_local: {=bool:?}, ctr_exists_local: {=bool:?}, aes_din_byte_resolution_local: {=bool:?}, tunneling_enb_local: {=bool:?}, support_256_192_key_local: {=bool:?}, only_encrypt_local: {=bool:?}, aes_exists_local: {=bool:?} }}" , self . power_gating_exists_local () , self . large_rkek_local () , self . hash_in_fuses_local () , self . ext_mem_secured_local () , self . rkek_ecc_exists_local_n () , self . sram_size_local () , self . dscrptr_exists_local () , self . pau_exists_local () , self . rng_exists_local () , self . pka_exists_local () , self . rc4_exists_local () , self . sha_512_prsnt_local () , self . sha_256_prsnt_local () , self . md5_prsnt_local () , self . hash_exists_local () , self . c2_exists_local () , self . des_exists_local () , self . aes_xcbc_mac_exists_local () , self . aes_cmac_exists_local () , self . aes_ccm_exists_local () , self . aes_xex_hw_t_calc_local () , self . aes_xex_exists_local () , self . ctr_exists_local () , self . aes_din_byte_resolution_local () , self . tunneling_enb_local () , self . support_256_192_key_local () , self . only_encrypt_local () , self . aes_exists_local ())
            }
        }
        #[doc = "AES hardware key select."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostCryptokeySel(pub u32);
        impl HostCryptokeySel {
            #[doc = "Select the source of the HW key that is used by the AES engine"]
            #[must_use]
            #[inline(always)]
            pub const fn host_cryptokey_sel(&self) -> super::vals::HostCryptokeySel {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::HostCryptokeySel::from_bits(val as u8)
            }
            #[doc = "Select the source of the HW key that is used by the AES engine"]
            #[inline(always)]
            pub const fn set_host_cryptokey_sel(&mut self, val: super::vals::HostCryptokeySel) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for HostCryptokeySel {
            #[inline(always)]
            fn default() -> HostCryptokeySel {
                HostCryptokeySel(0)
            }
        }
        impl core::fmt::Debug for HostCryptokeySel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostCryptokeySel")
                    .field("host_cryptokey_sel", &self.host_cryptokey_sel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostCryptokeySel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "HostCryptokeySel {{ host_cryptokey_sel: {:?} }}",
                    self.host_cryptokey_sel()
                )
            }
        }
        #[doc = "This register holds bits 31:0 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. Reading from this address returns the K_DR valid status indicating if K_DR is successfully retained."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostIotKdr0(pub u32);
        impl HostIotKdr0 {
            #[doc = "This register holds bits 31:0 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. Reading from this address returns the K_DR valid status indicating if K_DR is successfully retained. Write: K_DR bits 31:0."]
            #[must_use]
            #[inline(always)]
            pub const fn host_iot_kdr0(&self) -> super::vals::HostIotKdr0 {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::HostIotKdr0::from_bits(val as u32)
            }
            #[doc = "This register holds bits 31:0 of K_DR. The value of this register is saved in the CRYPTOCELL AO power domain. Reading from this address returns the K_DR valid status indicating if K_DR is successfully retained. Write: K_DR bits 31:0."]
            #[inline(always)]
            pub const fn set_host_iot_kdr0(&mut self, val: super::vals::HostIotKdr0) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for HostIotKdr0 {
            #[inline(always)]
            fn default() -> HostIotKdr0 {
                HostIotKdr0(0)
            }
        }
        impl core::fmt::Debug for HostIotKdr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostIotKdr0")
                    .field("host_iot_kdr0", &self.host_iot_kdr0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostIotKdr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "HostIotKdr0 {{ host_iot_kdr0: {:?} }}",
                    self.host_iot_kdr0()
                )
            }
        }
        #[doc = "This write-once register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostIotKprtlLock(pub u32);
        impl HostIotKprtlLock {
            #[doc = "This register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain."]
            #[must_use]
            #[inline(always)]
            pub const fn host_iot_kprtl_lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This register is the K_PRTL lock register. When this register is set, K_PRTL cannot be used and a zeroed key will be used instead. The value of this register is saved in the CRYPTOCELL AO power domain."]
            #[inline(always)]
            pub const fn set_host_iot_kprtl_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HostIotKprtlLock {
            #[inline(always)]
            fn default() -> HostIotKprtlLock {
                HostIotKprtlLock(0)
            }
        }
        impl core::fmt::Debug for HostIotKprtlLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostIotKprtlLock")
                    .field("host_iot_kprtl_lock", &self.host_iot_kprtl_lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostIotKprtlLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "HostIotKprtlLock {{ host_iot_kprtl_lock: {=bool:?} }}",
                    self.host_iot_kprtl_lock()
                )
            }
        }
        #[doc = "Controls life-cycle state (LCS) for CRYPTOCELL subsystem"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HostIotLcs(pub u32);
        impl HostIotLcs {
            #[doc = "Life-cycle state value. This field is write-once per reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lcs(&self) -> super::vals::Lcs {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Lcs::from_bits(val as u8)
            }
            #[doc = "Life-cycle state value. This field is write-once per reset."]
            #[inline(always)]
            pub const fn set_lcs(&mut self, val: super::vals::Lcs) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Read-only field. Indicates if CRYPTOCELL LCS has been successfully configured since last reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lcs_is_valid(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Read-only field. Indicates if CRYPTOCELL LCS has been successfully configured since last reset."]
            #[inline(always)]
            pub const fn set_lcs_is_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for HostIotLcs {
            #[inline(always)]
            fn default() -> HostIotLcs {
                HostIotLcs(0)
            }
        }
        impl core::fmt::Debug for HostIotLcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HostIotLcs")
                    .field("lcs", &self.lcs())
                    .field("lcs_is_valid", &self.lcs_is_valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostIotLcs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "HostIotLcs {{ lcs: {:?}, lcs_is_valid: {=bool:?} }}",
                    self.lcs(),
                    self.lcs_is_valid()
                )
            }
        }
        #[doc = "Interrupt clear register. Writing a 1 bit into a field in this register will clear the corresponding bit in IRR."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icr(pub u32);
        impl Icr {
            #[doc = "The RNG SRAM to DIN DMA done interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn sram_to_din_clear(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The RNG SRAM to DIN DMA done interrupt clear."]
            #[inline(always)]
            pub const fn set_sram_to_din_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_sram_clear(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt clear."]
            #[inline(always)]
            pub const fn set_dout_to_sram_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The memory to DIN DMA done interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn mem_to_din_clear(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The memory to DIN DMA done interrupt clear."]
            #[inline(always)]
            pub const fn set_mem_to_din_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The DOUT to memory DMA done interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_mem_clear(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The DOUT to memory DMA done interrupt clear."]
            #[inline(always)]
            pub const fn set_dout_to_mem_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "The AHB error interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_err_clear(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "The AHB error interrupt clear."]
            #[inline(always)]
            pub const fn set_ahb_err_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The PKA end of operation interrupt clear."]
            #[must_use]
            #[inline(always)]
            pub const fn pka_clear(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The PKA end of operation interrupt clear."]
            #[inline(always)]
            pub const fn set_pka_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "The RNG interrupt clear. Register RNG_ISR in the RNG engine must be cleared before this interrupt can be cleared."]
            #[must_use]
            #[inline(always)]
            pub const fn rng_clear(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "The RNG interrupt clear. Register RNG_ISR in the RNG engine must be cleared before this interrupt can be cleared."]
            #[inline(always)]
            pub const fn set_rng_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Icr {
            #[inline(always)]
            fn default() -> Icr {
                Icr(0)
            }
        }
        impl core::fmt::Debug for Icr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icr")
                    .field("sram_to_din_clear", &self.sram_to_din_clear())
                    .field("dout_to_sram_clear", &self.dout_to_sram_clear())
                    .field("mem_to_din_clear", &self.mem_to_din_clear())
                    .field("dout_to_mem_clear", &self.dout_to_mem_clear())
                    .field("ahb_err_clear", &self.ahb_err_clear())
                    .field("pka_clear", &self.pka_clear())
                    .field("rng_clear", &self.rng_clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Icr {{ sram_to_din_clear: {=bool:?}, dout_to_sram_clear: {=bool:?}, mem_to_din_clear: {=bool:?}, dout_to_mem_clear: {=bool:?}, ahb_err_clear: {=bool:?}, pka_clear: {=bool:?}, rng_clear: {=bool:?} }}" , self . sram_to_din_clear () , self . dout_to_sram_clear () , self . mem_to_din_clear () , self . dout_to_mem_clear () , self . ahb_err_clear () , self . pka_clear () , self . rng_clear ())
            }
        }
        #[doc = "Interrupt mask register. Each bit of this register holds the mask of a single interrupt source."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Imr(pub u32);
        impl Imr {
            #[doc = "The RNG SRAM to DIN DMA done interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn sram_to_din_mask(&self) -> super::vals::SramToDinMask {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::SramToDinMask::from_bits(val as u8)
            }
            #[doc = "The RNG SRAM to DIN DMA done interrupt mask."]
            #[inline(always)]
            pub const fn set_sram_to_din_mask(&mut self, val: super::vals::SramToDinMask) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_sram_mask(&self) -> super::vals::DoutToSramMask {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::DoutToSramMask::from_bits(val as u8)
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt mask."]
            #[inline(always)]
            pub const fn set_dout_to_sram_mask(&mut self, val: super::vals::DoutToSramMask) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "The memory to DIN DMA done interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn mem_to_din_mask(&self) -> super::vals::MemToDinMask {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::MemToDinMask::from_bits(val as u8)
            }
            #[doc = "The memory to DIN DMA done interrupt mask."]
            #[inline(always)]
            pub const fn set_mem_to_din_mask(&mut self, val: super::vals::MemToDinMask) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "The DOUT to memory DMA done interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_mem_mask(&self) -> super::vals::DoutToMemMask {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::DoutToMemMask::from_bits(val as u8)
            }
            #[doc = "The DOUT to memory DMA done interrupt mask."]
            #[inline(always)]
            pub const fn set_dout_to_mem_mask(&mut self, val: super::vals::DoutToMemMask) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "The AHB error interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_err_mask(&self) -> super::vals::AhbErrMask {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::AhbErrMask::from_bits(val as u8)
            }
            #[doc = "The AHB error interrupt mask."]
            #[inline(always)]
            pub const fn set_ahb_err_mask(&mut self, val: super::vals::AhbErrMask) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "The PKA end of operation interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn pka_mask(&self) -> super::vals::PkaMask {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::PkaMask::from_bits(val as u8)
            }
            #[doc = "The PKA end of operation interrupt mask."]
            #[inline(always)]
            pub const fn set_pka_mask(&mut self, val: super::vals::PkaMask) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "The RNG interrupt mask."]
            #[must_use]
            #[inline(always)]
            pub const fn rng_mask(&self) -> super::vals::RngMask {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::RngMask::from_bits(val as u8)
            }
            #[doc = "The RNG interrupt mask."]
            #[inline(always)]
            pub const fn set_rng_mask(&mut self, val: super::vals::RngMask) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Imr {
            #[inline(always)]
            fn default() -> Imr {
                Imr(0)
            }
        }
        impl core::fmt::Debug for Imr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Imr")
                    .field("sram_to_din_mask", &self.sram_to_din_mask())
                    .field("dout_to_sram_mask", &self.dout_to_sram_mask())
                    .field("mem_to_din_mask", &self.mem_to_din_mask())
                    .field("dout_to_mem_mask", &self.dout_to_mem_mask())
                    .field("ahb_err_mask", &self.ahb_err_mask())
                    .field("pka_mask", &self.pka_mask())
                    .field("rng_mask", &self.rng_mask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Imr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Imr {{ sram_to_din_mask: {:?}, dout_to_sram_mask: {:?}, mem_to_din_mask: {:?}, dout_to_mem_mask: {:?}, ahb_err_mask: {:?}, pka_mask: {:?}, rng_mask: {:?} }}" , self . sram_to_din_mask () , self . dout_to_sram_mask () , self . mem_to_din_mask () , self . dout_to_mem_mask () , self . ahb_err_mask () , self . pka_mask () , self . rng_mask ())
            }
        }
        #[doc = "Interrupt request register. Each bit of this register holds the interrupt status of a single interrupt source. If corresponding IMR bit is unmasked, an interrupt is generated."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Irr(pub u32);
        impl Irr {
            #[doc = "The RNG SRAM to DIN DMA done interrupt status. This interrupt is asserted when all data was delivered from RNG SRAM to DIN buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn sram_to_din_int(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The RNG SRAM to DIN DMA done interrupt status. This interrupt is asserted when all data was delivered from RNG SRAM to DIN buffer."]
            #[inline(always)]
            pub const fn set_sram_to_din_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt status. This interrupt is asserted when all data was delivered from DOUT buffer to RNG SRAM."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_sram_int(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The DOUT to RNG SRAM DMA done interrupt status. This interrupt is asserted when all data was delivered from DOUT buffer to RNG SRAM."]
            #[inline(always)]
            pub const fn set_dout_to_sram_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The memory to DIN DMA done interrupt status. This interrupt is asserted when all data was delivered from memory to DIN buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn mem_to_din_int(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The memory to DIN DMA done interrupt status. This interrupt is asserted when all data was delivered from memory to DIN buffer."]
            #[inline(always)]
            pub const fn set_mem_to_din_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The DOUT to memory DMA done interrupt status. This interrupt is asserted when all data was delivered from DOUT buffer to memory."]
            #[must_use]
            #[inline(always)]
            pub const fn dout_to_mem_int(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The DOUT to memory DMA done interrupt status. This interrupt is asserted when all data was delivered from DOUT buffer to memory."]
            #[inline(always)]
            pub const fn set_dout_to_mem_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "The AHB error interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn ahb_err_int(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "The AHB error interrupt status."]
            #[inline(always)]
            pub const fn set_ahb_err_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The PKA end of operation interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn pka_int(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The PKA end of operation interrupt status."]
            #[inline(always)]
            pub const fn set_pka_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "The RNG interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn rng_int(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "The RNG interrupt status."]
            #[inline(always)]
            pub const fn set_rng_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Irr {
            #[inline(always)]
            fn default() -> Irr {
                Irr(0)
            }
        }
        impl core::fmt::Debug for Irr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Irr")
                    .field("sram_to_din_int", &self.sram_to_din_int())
                    .field("dout_to_sram_int", &self.dout_to_sram_int())
                    .field("mem_to_din_int", &self.mem_to_din_int())
                    .field("dout_to_mem_int", &self.dout_to_mem_int())
                    .field("ahb_err_int", &self.ahb_err_int())
                    .field("pka_int", &self.pka_int())
                    .field("rng_int", &self.rng_int())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Irr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Irr {{ sram_to_din_int: {=bool:?}, dout_to_sram_int: {=bool:?}, mem_to_din_int: {=bool:?}, dout_to_mem_int: {=bool:?}, ahb_err_int: {=bool:?}, pka_int: {=bool:?}, rng_int: {=bool:?} }}" , self . sram_to_din_int () , self . dout_to_sram_int () , self . mem_to_din_int () , self . dout_to_mem_int () , self . ahb_err_int () , self . pka_int () , self . rng_int ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum AhbErrMask {
            #[doc = "Do not mask AHB error interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask AHB error interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl AhbErrMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> AhbErrMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for AhbErrMask {
            #[inline(always)]
            fn from(val: u8) -> AhbErrMask {
                AhbErrMask::from_bits(val)
            }
        }
        impl From<AhbErrMask> for u8 {
            #[inline(always)]
            fn from(val: AhbErrMask) -> u8 {
                AhbErrMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DinRdBg {
            #[doc = "Configure DIN read as little-endian"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Configure DIN read as big-endian"]
            BIG_ENDIAN = 0x01,
        }
        impl DinRdBg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DinRdBg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DinRdBg {
            #[inline(always)]
            fn from(val: u8) -> DinRdBg {
                DinRdBg::from_bits(val)
            }
        }
        impl From<DinRdBg> for u8 {
            #[inline(always)]
            fn from(val: DinRdBg) -> u8 {
                DinRdBg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DinRdWbg {
            #[doc = "Configure DIN read word as little-endian"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Configure DIN read word as big-endian"]
            BIG_ENDIAN = 0x01,
        }
        impl DinRdWbg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DinRdWbg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DinRdWbg {
            #[inline(always)]
            fn from(val: u8) -> DinRdWbg {
                DinRdWbg::from_bits(val)
            }
        }
        impl From<DinRdWbg> for u8 {
            #[inline(always)]
            fn from(val: DinRdWbg) -> u8 {
                DinRdWbg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutToMemMask {
            #[doc = "Do not mask DOUT to memory DMA done interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask DOUT to memory DMA done interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl DoutToMemMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutToMemMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutToMemMask {
            #[inline(always)]
            fn from(val: u8) -> DoutToMemMask {
                DoutToMemMask::from_bits(val)
            }
        }
        impl From<DoutToMemMask> for u8 {
            #[inline(always)]
            fn from(val: DoutToMemMask) -> u8 {
                DoutToMemMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutToSramMask {
            #[doc = "Do not mask DOUT to RNG SRAM DMA done interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask DOUT to RNG SRAM DMA done interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl DoutToSramMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutToSramMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutToSramMask {
            #[inline(always)]
            fn from(val: u8) -> DoutToSramMask {
                DoutToSramMask::from_bits(val)
            }
        }
        impl From<DoutToSramMask> for u8 {
            #[inline(always)]
            fn from(val: DoutToSramMask) -> u8 {
                DoutToSramMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutWrBg {
            #[doc = "Configure DOUT write as little-endian"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Configure DOUT write as big-endian"]
            BIG_ENDIAN = 0x01,
        }
        impl DoutWrBg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutWrBg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutWrBg {
            #[inline(always)]
            fn from(val: u8) -> DoutWrBg {
                DoutWrBg::from_bits(val)
            }
        }
        impl From<DoutWrBg> for u8 {
            #[inline(always)]
            fn from(val: DoutWrBg) -> u8 {
                DoutWrBg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DoutWrWbg {
            #[doc = "Configure DOUT write word as little-endian"]
            LITTLE_ENDIAN = 0x0,
            #[doc = "Configure DOUT write word as big-endian"]
            BIG_ENDIAN = 0x01,
        }
        impl DoutWrWbg {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DoutWrWbg {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DoutWrWbg {
            #[inline(always)]
            fn from(val: u8) -> DoutWrWbg {
                DoutWrWbg::from_bits(val)
            }
        }
        impl From<DoutWrWbg> for u8 {
            #[inline(always)]
            fn from(val: DoutWrWbg) -> u8 {
                DoutWrWbg::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HostCryptokeySel {
            #[doc = "Use device root key K_DR from CRYPTOCELL AO power domain"]
            K_DR = 0x0,
            #[doc = "Use hard-coded RTL key K_PRTL"]
            K_PRTL = 0x01,
            #[doc = "Use provided session key"]
            SESSION = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl HostCryptokeySel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> HostCryptokeySel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for HostCryptokeySel {
            #[inline(always)]
            fn from(val: u8) -> HostCryptokeySel {
                HostCryptokeySel::from_bits(val)
            }
        }
        impl From<HostCryptokeySel> for u8 {
            #[inline(always)]
            fn from(val: HostCryptokeySel) -> u8 {
                HostCryptokeySel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct HostIotKdr0(u32);
        impl HostIotKdr0 {
            #[doc = "Read: 128 bits K_DR key value is not yet retained in the CRYPTOCELL AO power domain."]
            pub const NOT_RETAINED: Self = Self(0x0);
            #[doc = "Read: 128 bits K_DR key value is successfully retained in the CRYPTOCELL AO power domain."]
            pub const RETAINED: Self = Self(0x01);
        }
        impl HostIotKdr0 {
            pub const fn from_bits(val: u32) -> HostIotKdr0 {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for HostIotKdr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("NOT_RETAINED"),
                    0x01 => f.write_str("RETAINED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HostIotKdr0 {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "NOT_RETAINED"),
                    0x01 => defmt::write!(f, "RETAINED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for HostIotKdr0 {
            #[inline(always)]
            fn from(val: u32) -> HostIotKdr0 {
                HostIotKdr0::from_bits(val)
            }
        }
        impl From<HostIotKdr0> for u32 {
            #[inline(always)]
            fn from(val: HostIotKdr0) -> u32 {
                HostIotKdr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lcs {
            #[doc = "CC310 operates in debug mode"]
            DEBUG_ENABLE = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "CC310 operates in secure mode"]
            SECURE = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Lcs {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lcs {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lcs {
            #[inline(always)]
            fn from(val: u8) -> Lcs {
                Lcs::from_bits(val)
            }
        }
        impl From<Lcs> for u8 {
            #[inline(always)]
            fn from(val: Lcs) -> u8 {
                Lcs::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum MemToDinMask {
            #[doc = "Do not mask memory to DIN DMA done interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask memory to DIN DMA done interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl MemToDinMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> MemToDinMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for MemToDinMask {
            #[inline(always)]
            fn from(val: u8) -> MemToDinMask {
                MemToDinMask::from_bits(val)
            }
        }
        impl From<MemToDinMask> for u8 {
            #[inline(always)]
            fn from(val: MemToDinMask) -> u8 {
                MemToDinMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PkaMask {
            #[doc = "Do not mask PKA end of operation interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask PKA end of operation interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl PkaMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PkaMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PkaMask {
            #[inline(always)]
            fn from(val: u8) -> PkaMask {
                PkaMask::from_bits(val)
            }
        }
        impl From<PkaMask> for u8 {
            #[inline(always)]
            fn from(val: PkaMask) -> u8 {
                PkaMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RngMask {
            #[doc = "Do not mask RNG interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask RNG interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl RngMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RngMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RngMask {
            #[inline(always)]
            fn from(val: u8) -> RngMask {
                RngMask::from_bits(val)
            }
        }
        impl From<RngMask> for u8 {
            #[inline(always)]
            fn from(val: RngMask) -> u8 {
                RngMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SramToDinMask {
            #[doc = "Do not mask RNG SRAM to DIN DMA done interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask RNG SRAM to DIN DMA done interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl SramToDinMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SramToDinMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SramToDinMask {
            #[inline(always)]
            fn from(val: u8) -> SramToDinMask {
                SramToDinMask::from_bits(val)
            }
        }
        impl From<SramToDinMask> for u8 {
            #[inline(always)]
            fn from(val: SramToDinMask) -> u8 {
                SramToDinMask::to_bits(val)
            }
        }
    }
}
pub mod cc_misc {
    #[doc = "CRYPTOCELL MISC interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcMisc {
        ptr: *mut u8,
    }
    unsafe impl Send for CcMisc {}
    unsafe impl Sync for CcMisc {}
    impl CcMisc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock control for the AES engine."]
        #[inline(always)]
        pub const fn aes_clk(self) -> crate::common::Reg<regs::AesClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0810usize) as _) }
        }
        #[doc = "Clock control for the HASH engine."]
        #[inline(always)]
        pub const fn hash_clk(self) -> crate::common::Reg<regs::HashClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0818usize) as _) }
        }
        #[doc = "Clock control for the PKA engine."]
        #[inline(always)]
        pub const fn pka_clk(self) -> crate::common::Reg<regs::PkaClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x081cusize) as _) }
        }
        #[doc = "Clock control for the DMA engines."]
        #[inline(always)]
        pub const fn dma_clk(self) -> crate::common::Reg<regs::DmaClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0820usize) as _) }
        }
        #[doc = "CRYPTOCELL clocks status register."]
        #[inline(always)]
        pub const fn clk_status(self) -> crate::common::Reg<regs::ClkStatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0824usize) as _) }
        }
        #[doc = "Clock control for the CHACHA engine."]
        #[inline(always)]
        pub const fn chacha_clk(self) -> crate::common::Reg<regs::ChachaClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0858usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Clock control for the AES engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AesClk(pub u32);
        impl AesClk {
            #[doc = "Enables clock for the AES engine."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the AES engine."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for AesClk {
            #[inline(always)]
            fn default() -> AesClk {
                AesClk(0)
            }
        }
        impl core::fmt::Debug for AesClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AesClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AesClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AesClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Clock control for the CHACHA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ChachaClk(pub u32);
        impl ChachaClk {
            #[doc = "Enables clock for the CHACHA engine."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the CHACHA engine."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ChachaClk {
            #[inline(always)]
            fn default() -> ChachaClk {
                ChachaClk(0)
            }
        }
        impl core::fmt::Debug for ChachaClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ChachaClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ChachaClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ChachaClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "CRYPTOCELL clocks status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ClkStatus(pub u32);
        impl ClkStatus {
            #[doc = "Status of AES engine clock."]
            #[must_use]
            #[inline(always)]
            pub const fn aes_clk(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of AES engine clock."]
            #[inline(always)]
            pub const fn set_aes_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Status of HASH engine clock."]
            #[must_use]
            #[inline(always)]
            pub const fn hash_clk(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Status of HASH engine clock."]
            #[inline(always)]
            pub const fn set_hash_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Status of PKA engine clock."]
            #[must_use]
            #[inline(always)]
            pub const fn pka_clk(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Status of PKA engine clock."]
            #[inline(always)]
            pub const fn set_pka_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Status of CHACHA engine clock."]
            #[must_use]
            #[inline(always)]
            pub const fn chacha_clk(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Status of CHACHA engine clock."]
            #[inline(always)]
            pub const fn set_chacha_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Status of DMA engines clock."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_clk(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Status of DMA engines clock."]
            #[inline(always)]
            pub const fn set_dma_clk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for ClkStatus {
            #[inline(always)]
            fn default() -> ClkStatus {
                ClkStatus(0)
            }
        }
        impl core::fmt::Debug for ClkStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ClkStatus")
                    .field("aes_clk", &self.aes_clk())
                    .field("hash_clk", &self.hash_clk())
                    .field("pka_clk", &self.pka_clk())
                    .field("chacha_clk", &self.chacha_clk())
                    .field("dma_clk", &self.dma_clk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ClkStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ClkStatus {{ aes_clk: {=bool:?}, hash_clk: {=bool:?}, pka_clk: {=bool:?}, chacha_clk: {=bool:?}, dma_clk: {=bool:?} }}" , self . aes_clk () , self . hash_clk () , self . pka_clk () , self . chacha_clk () , self . dma_clk ())
            }
        }
        #[doc = "Clock control for the DMA engines."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DmaClk(pub u32);
        impl DmaClk {
            #[doc = "Enables clock for the DMA engines."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the DMA engines."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DmaClk {
            #[inline(always)]
            fn default() -> DmaClk {
                DmaClk(0)
            }
        }
        impl core::fmt::Debug for DmaClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DmaClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DmaClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DmaClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Clock control for the HASH engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct HashClk(pub u32);
        impl HashClk {
            #[doc = "Enables clock for the HASH engine."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the HASH engine."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for HashClk {
            #[inline(always)]
            fn default() -> HashClk {
                HashClk(0)
            }
        }
        impl core::fmt::Debug for HashClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("HashClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for HashClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "HashClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Clock control for the PKA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaClk(pub u32);
        impl PkaClk {
            #[doc = "Enables clock for the PKA engine."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the PKA engine."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PkaClk {
            #[inline(always)]
            fn default() -> PkaClk {
                PkaClk(0)
            }
        }
        impl core::fmt::Debug for PkaClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PkaClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
    }
}
pub mod cc_pka {
    #[doc = "CRYPTOCELL PKA engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcPka {
        ptr: *mut u8,
    }
    unsafe impl Send for CcPka {}
    unsafe impl Sync for CcPka {}
    impl CcPka {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Register for mapping the virtual register R\\[n\\] to a physical address in the PKA SRAM."]
        #[inline(always)]
        pub const fn memory_map(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::MemoryMap, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Operation code to be executed by the PKA engine. Writing to this register triggers the PKA operation."]
        #[inline(always)]
        pub const fn opcode(self) -> crate::common::Reg<regs::Opcode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "This register defines the N, Np, T0, and T1 virtual register index."]
        #[inline(always)]
        pub const fn n_np_t0_t1_addr(
            self,
        ) -> crate::common::Reg<regs::NNpT0T1Addr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "This register holds the status for the PKA pipeline."]
        #[inline(always)]
        pub const fn pka_status(self) -> crate::common::Reg<regs::PkaStatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Reset the PKA engine."]
        #[inline(always)]
        pub const fn pka_sw_reset(self) -> crate::common::Reg<regs::PkaSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Description collection: This register holds the operands bit size."]
        #[inline(always)]
        pub const fn pka_l(self, n: usize) -> crate::common::Reg<regs::PkaL, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize + n * 4usize) as _)
            }
        }
        #[doc = "Status register indicating if the PKA pipeline is ready to receive a new OPCODE."]
        #[inline(always)]
        pub const fn pka_pipe(self) -> crate::common::Reg<regs::PkaPipe, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb0usize) as _) }
        }
        #[doc = "Status register indicating if the PKA operation has been completed."]
        #[inline(always)]
        pub const fn pka_done(self) -> crate::common::Reg<regs::PkaDone, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb4usize) as _) }
        }
        #[doc = "PKA engine HW version. Reset value holds the version."]
        #[inline(always)]
        pub const fn pka_version(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xc4usize) as _) }
        }
        #[doc = "Start address in PKA SRAM for subsequent write transactions."]
        #[inline(always)]
        pub const fn pka_sram_waddr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xd4usize) as _) }
        }
        #[doc = "Write data to PKA SRAM. Writing to this register triggers a DMA transaction writing data into PKA SRAM. The DMA address offset is automatically incremented during write."]
        #[inline(always)]
        pub const fn pka_sram_wdata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xd8usize) as _) }
        }
        #[doc = "Read data from PKA SRAM. Reading from this register triggers a DMA transaction read data from PKA SRAM. The DMA address offset is automatically incremented during read."]
        #[inline(always)]
        pub const fn pka_sram_rdata(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xdcusize) as _) }
        }
        #[doc = "Register for clearing PKA SRAM write buffer."]
        #[inline(always)]
        pub const fn pka_sram_wclear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe0usize) as _) }
        }
        #[doc = "Start address in PKA SRAM for subsequent read transactions."]
        #[inline(always)]
        pub const fn pka_sram_raddr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Register for mapping the virtual register R\\[n\\] to a physical address in the PKA SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MemoryMap(pub u32);
        impl MemoryMap {
            #[doc = "The physical word address used for the virtual register."]
            #[must_use]
            #[inline(always)]
            pub const fn addr(&self) -> u16 {
                let val = (self.0 >> 1usize) & 0x01ff;
                val as u16
            }
            #[doc = "The physical word address used for the virtual register."]
            #[inline(always)]
            pub const fn set_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 1usize)) | (((val as u32) & 0x01ff) << 1usize);
            }
        }
        impl Default for MemoryMap {
            #[inline(always)]
            fn default() -> MemoryMap {
                MemoryMap(0)
            }
        }
        impl core::fmt::Debug for MemoryMap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MemoryMap")
                    .field("addr", &self.addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MemoryMap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "MemoryMap {{ addr: {=u16:?} }}", self.addr())
            }
        }
        #[doc = "This register defines the N, Np, T0, and T1 virtual register index."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NNpT0T1Addr(pub u32);
        impl NNpT0T1Addr {
            #[doc = "Register N virtual register index. Default is R0."]
            #[must_use]
            #[inline(always)]
            pub const fn n_virtual_addr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Register N virtual register index. Default is R0."]
            #[inline(always)]
            pub const fn set_n_virtual_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Register Np virtual register index. Default is R1."]
            #[must_use]
            #[inline(always)]
            pub const fn np_virtual_addr(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x1f;
                val as u8
            }
            #[doc = "Register Np virtual register index. Default is R1."]
            #[inline(always)]
            pub const fn set_np_virtual_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 5usize)) | (((val as u32) & 0x1f) << 5usize);
            }
            #[doc = "Temporary register 0 virtual register index. Default is R30."]
            #[must_use]
            #[inline(always)]
            pub const fn t0_virtual_addr(&self) -> u8 {
                let val = (self.0 >> 10usize) & 0x1f;
                val as u8
            }
            #[doc = "Temporary register 0 virtual register index. Default is R30."]
            #[inline(always)]
            pub const fn set_t0_virtual_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 10usize)) | (((val as u32) & 0x1f) << 10usize);
            }
            #[doc = "Temporary register 1 virtual register index. Default is R31."]
            #[must_use]
            #[inline(always)]
            pub const fn t1_virtual_addr(&self) -> u8 {
                let val = (self.0 >> 15usize) & 0x1f;
                val as u8
            }
            #[doc = "Temporary register 1 virtual register index. Default is R31."]
            #[inline(always)]
            pub const fn set_t1_virtual_addr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 15usize)) | (((val as u32) & 0x1f) << 15usize);
            }
        }
        impl Default for NNpT0T1Addr {
            #[inline(always)]
            fn default() -> NNpT0T1Addr {
                NNpT0T1Addr(0)
            }
        }
        impl core::fmt::Debug for NNpT0T1Addr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NNpT0T1Addr")
                    .field("n_virtual_addr", &self.n_virtual_addr())
                    .field("np_virtual_addr", &self.np_virtual_addr())
                    .field("t0_virtual_addr", &self.t0_virtual_addr())
                    .field("t1_virtual_addr", &self.t1_virtual_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NNpT0T1Addr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "NNpT0T1Addr {{ n_virtual_addr: {=u8:?}, np_virtual_addr: {=u8:?}, t0_virtual_addr: {=u8:?}, t1_virtual_addr: {=u8:?} }}" , self . n_virtual_addr () , self . np_virtual_addr () , self . t0_virtual_addr () , self . t1_virtual_addr ())
            }
        }
        #[doc = "Operation code to be executed by the PKA engine. Writing to this register triggers the PKA operation."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opcode(pub u32);
        impl Opcode {
            #[doc = "Holds the operation tag or the operand C virtual register index."]
            #[must_use]
            #[inline(always)]
            pub const fn tag(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Holds the operation tag or the operand C virtual register index."]
            #[inline(always)]
            pub const fn set_tag(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "Result register virtual register index."]
            #[must_use]
            #[inline(always)]
            pub const fn reg_r(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x1f;
                val as u8
            }
            #[doc = "Result register virtual register index."]
            #[inline(always)]
            pub const fn set_reg_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 6usize)) | (((val as u32) & 0x1f) << 6usize);
            }
            #[doc = "This field controls the interpretation of REG_R."]
            #[must_use]
            #[inline(always)]
            pub const fn discard_r(&self) -> super::vals::DiscardR {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::DiscardR::from_bits(val as u8)
            }
            #[doc = "This field controls the interpretation of REG_R."]
            #[inline(always)]
            pub const fn set_discard_r(&mut self, val: super::vals::DiscardR) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Operand B virtual register index."]
            #[must_use]
            #[inline(always)]
            pub const fn reg_b(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x1f;
                val as u8
            }
            #[doc = "Operand B virtual register index."]
            #[inline(always)]
            pub const fn set_reg_b(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 12usize)) | (((val as u32) & 0x1f) << 12usize);
            }
            #[doc = "This field controls the interpretation of REG_B."]
            #[must_use]
            #[inline(always)]
            pub const fn const_b(&self) -> super::vals::ConstB {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::ConstB::from_bits(val as u8)
            }
            #[doc = "This field controls the interpretation of REG_B."]
            #[inline(always)]
            pub const fn set_const_b(&mut self, val: super::vals::ConstB) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Operand A virtual register index."]
            #[must_use]
            #[inline(always)]
            pub const fn reg_a(&self) -> u8 {
                let val = (self.0 >> 18usize) & 0x1f;
                val as u8
            }
            #[doc = "Operand A virtual register index."]
            #[inline(always)]
            pub const fn set_reg_a(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 18usize)) | (((val as u32) & 0x1f) << 18usize);
            }
            #[doc = "This field controls the interpretation of REG_A."]
            #[must_use]
            #[inline(always)]
            pub const fn const_a(&self) -> super::vals::ConstA {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::ConstA::from_bits(val as u8)
            }
            #[doc = "This field controls the interpretation of REG_A."]
            #[inline(always)]
            pub const fn set_const_a(&mut self, val: super::vals::ConstA) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
            #[doc = "The length of the operands. This value serves as an PKA length register index. E.g.: if LEN field value is set to 0, PKA_L\\[0\\] holds the size of the operands."]
            #[must_use]
            #[inline(always)]
            pub const fn len(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "The length of the operands. This value serves as an PKA length register index. E.g.: if LEN field value is set to 0, PKA_L\\[0\\] holds the size of the operands."]
            #[inline(always)]
            pub const fn set_len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
            #[doc = "Operation code to be executed by the PKA engine"]
            #[must_use]
            #[inline(always)]
            pub const fn opcode(&self) -> super::vals::Opcode {
                let val = (self.0 >> 27usize) & 0x1f;
                super::vals::Opcode::from_bits(val as u8)
            }
            #[doc = "Operation code to be executed by the PKA engine"]
            #[inline(always)]
            pub const fn set_opcode(&mut self, val: super::vals::Opcode) {
                self.0 =
                    (self.0 & !(0x1f << 27usize)) | (((val.to_bits() as u32) & 0x1f) << 27usize);
            }
        }
        impl Default for Opcode {
            #[inline(always)]
            fn default() -> Opcode {
                Opcode(0)
            }
        }
        impl core::fmt::Debug for Opcode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opcode")
                    .field("tag", &self.tag())
                    .field("reg_r", &self.reg_r())
                    .field("discard_r", &self.discard_r())
                    .field("reg_b", &self.reg_b())
                    .field("const_b", &self.const_b())
                    .field("reg_a", &self.reg_a())
                    .field("const_a", &self.const_a())
                    .field("len", &self.len())
                    .field("opcode", &self.opcode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opcode {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Opcode {{ tag: {=u8:?}, reg_r: {=u8:?}, discard_r: {:?}, reg_b: {=u8:?}, const_b: {:?}, reg_a: {=u8:?}, const_a: {:?}, len: {=u8:?}, opcode: {:?} }}" , self . tag () , self . reg_r () , self . discard_r () , self . reg_b () , self . const_b () , self . reg_a () , self . const_a () , self . len () , self . opcode ())
            }
        }
        #[doc = "Status register indicating if the PKA operation has been completed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaDone(pub u32);
        impl PkaDone {
            #[doc = "PKA operation status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::PkaDoneStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PkaDoneStatus::from_bits(val as u8)
            }
            #[doc = "PKA operation status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::PkaDoneStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PkaDone {
            #[inline(always)]
            fn default() -> PkaDone {
                PkaDone(0)
            }
        }
        impl core::fmt::Debug for PkaDone {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaDone")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaDone {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PkaDone {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Description collection: This register holds the operands bit size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaL(pub u32);
        impl PkaL {
            #[doc = "Operand bit size."]
            #[must_use]
            #[inline(always)]
            pub const fn op_size(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Operand bit size."]
            #[inline(always)]
            pub const fn set_op_size(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for PkaL {
            #[inline(always)]
            fn default() -> PkaL {
                PkaL(0)
            }
        }
        impl core::fmt::Debug for PkaL {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaL")
                    .field("op_size", &self.op_size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaL {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PkaL {{ op_size: {=u16:?} }}", self.op_size())
            }
        }
        #[doc = "Status register indicating if the PKA pipeline is ready to receive a new OPCODE."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaPipe(pub u32);
        impl PkaPipe {
            #[doc = "PKA pipeline status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PKA pipeline status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PkaPipe {
            #[inline(always)]
            fn default() -> PkaPipe {
                PkaPipe(0)
            }
        }
        impl core::fmt::Debug for PkaPipe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaPipe")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaPipe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PkaPipe {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "This register holds the status for the PKA pipeline."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaStatus(pub u32);
        impl PkaStatus {
            #[doc = "The most significant 4-bits of the operand updated in shift operation."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_msb_4bits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The most significant 4-bits of the operand updated in shift operation."]
            #[inline(always)]
            pub const fn set_alu_msb_4bits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "The least significant 4-bits of the operand updated in shift operation."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_lsb_4bits(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The least significant 4-bits of the operand updated in shift operation."]
            #[inline(always)]
            pub const fn set_alu_lsb_4bits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Indicates the MSB sign of the last operation."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_sign_out(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the MSB sign of the last operation."]
            #[inline(always)]
            pub const fn set_alu_sign_out(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Holds the carry of the last ALU operation."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_carry(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Holds the carry of the last ALU operation."]
            #[inline(always)]
            pub const fn set_alu_carry(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Holds the carry of the last modular operation."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_carry_mod(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Holds the carry of the last modular operation."]
            #[inline(always)]
            pub const fn set_alu_carry_mod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates the last subtraction operation sign."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_sub_is_zero(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the last subtraction operation sign."]
            #[inline(always)]
            pub const fn set_alu_sub_is_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates if the result of ALU OUT is zero."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_out_zero(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if the result of ALU OUT is zero."]
            #[inline(always)]
            pub const fn set_alu_out_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Modular overflow flag."]
            #[must_use]
            #[inline(always)]
            pub const fn alu_modovrflw(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Modular overflow flag."]
            #[inline(always)]
            pub const fn set_alu_modovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indication if the division is done by zero."]
            #[must_use]
            #[inline(always)]
            pub const fn div_by_zero(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indication if the division is done by zero."]
            #[inline(always)]
            pub const fn set_div_by_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates the modular inverse of zero."]
            #[must_use]
            #[inline(always)]
            pub const fn modinv_of_zero(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates the modular inverse of zero."]
            #[inline(always)]
            pub const fn set_modinv_of_zero(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Opcode of the last operation"]
            #[must_use]
            #[inline(always)]
            pub const fn opcode(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Opcode of the last operation"]
            #[inline(always)]
            pub const fn set_opcode(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
        }
        impl Default for PkaStatus {
            #[inline(always)]
            fn default() -> PkaStatus {
                PkaStatus(0)
            }
        }
        impl core::fmt::Debug for PkaStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaStatus")
                    .field("alu_msb_4bits", &self.alu_msb_4bits())
                    .field("alu_lsb_4bits", &self.alu_lsb_4bits())
                    .field("alu_sign_out", &self.alu_sign_out())
                    .field("alu_carry", &self.alu_carry())
                    .field("alu_carry_mod", &self.alu_carry_mod())
                    .field("alu_sub_is_zero", &self.alu_sub_is_zero())
                    .field("alu_out_zero", &self.alu_out_zero())
                    .field("alu_modovrflw", &self.alu_modovrflw())
                    .field("div_by_zero", &self.div_by_zero())
                    .field("modinv_of_zero", &self.modinv_of_zero())
                    .field("opcode", &self.opcode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PkaStatus {{ alu_msb_4bits: {=u8:?}, alu_lsb_4bits: {=u8:?}, alu_sign_out: {=bool:?}, alu_carry: {=bool:?}, alu_carry_mod: {=bool:?}, alu_sub_is_zero: {=bool:?}, alu_out_zero: {=bool:?}, alu_modovrflw: {=bool:?}, div_by_zero: {=bool:?}, modinv_of_zero: {=bool:?}, opcode: {=u8:?} }}" , self . alu_msb_4bits () , self . alu_lsb_4bits () , self . alu_sign_out () , self . alu_carry () , self . alu_carry_mod () , self . alu_sub_is_zero () , self . alu_out_zero () , self . alu_modovrflw () , self . div_by_zero () , self . modinv_of_zero () , self . opcode ())
            }
        }
        #[doc = "Reset the PKA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkaSwReset(pub u32);
        impl PkaSwReset {
            #[doc = "Writing any value to this address resets the PKA engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the PKA engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PkaSwReset {
            #[inline(always)]
            fn default() -> PkaSwReset {
                PkaSwReset(0)
            }
        }
        impl core::fmt::Debug for PkaSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkaSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkaSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PkaSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConstA {
            #[doc = "REG_A is intepreted as a register index."]
            REGISTER = 0x0,
            #[doc = "REG_A is intepreted as a constant."]
            CONSTANT = 0x01,
        }
        impl ConstA {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConstA {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConstA {
            #[inline(always)]
            fn from(val: u8) -> ConstA {
                ConstA::from_bits(val)
            }
        }
        impl From<ConstA> for u8 {
            #[inline(always)]
            fn from(val: ConstA) -> u8 {
                ConstA::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConstB {
            #[doc = "REG_B is intepreted as a register index."]
            REGISTER = 0x0,
            #[doc = "REG_B is intepreted as a constant."]
            CONSTANT = 0x01,
        }
        impl ConstB {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConstB {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConstB {
            #[inline(always)]
            fn from(val: u8) -> ConstB {
                ConstB::from_bits(val)
            }
        }
        impl From<ConstB> for u8 {
            #[inline(always)]
            fn from(val: ConstB) -> u8 {
                ConstB::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DiscardR {
            #[doc = "REG_R is intepreted as a register index."]
            REGISTER = 0x0,
            #[doc = "Result is discarded."]
            DISCARD = 0x01,
        }
        impl DiscardR {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DiscardR {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DiscardR {
            #[inline(always)]
            fn from(val: u8) -> DiscardR {
                DiscardR::from_bits(val)
            }
        }
        impl From<DiscardR> for u8 {
            #[inline(always)]
            fn from(val: DiscardR) -> u8 {
                DiscardR::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opcode {
            #[doc = "Terminate operation"]
            TERMINATE = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Add or Increment"]
            ADD_INC = 0x04,
            #[doc = "Subtract, Decrement, or Negate"]
            SUB_DEC_NEG = 0x05,
            #[doc = "Modular Add or Modular Increment"]
            MOD_ADD_INC = 0x06,
            #[doc = "Modular Subtract, Modular Decrement, or Modular Negate"]
            MOD_SUB_DEC_NEG = 0x07,
            #[doc = "Perform AND, test, or clear"]
            ANDTST0CLR0 = 0x08,
            #[doc = "Perform OR, copy, or set bits"]
            ORCOPYSET0 = 0x09,
            #[doc = "Perform XOR, flip bits, invert, or compare"]
            XORFLP0INVCMP = 0x0a,
            _RESERVED_b = 0x0b,
            #[doc = "Shift right 0 operation"]
            SHR0 = 0x0c,
            #[doc = "Shift right 1 operation"]
            SHR1 = 0x0d,
            #[doc = "Shift left 0 operation"]
            SHL0 = 0x0e,
            #[doc = "Shift left 1 operation"]
            SHL1 = 0x0f,
            #[doc = "Multiply low operation"]
            MUL_LOW = 0x10,
            #[doc = "Modular multiply operation"]
            MOD_MUL = 0x11,
            #[doc = "Modular multiply N operation"]
            MOD_MUL_N = 0x12,
            #[doc = "Modular exponentiation operation"]
            MOD_EXP = 0x13,
            #[doc = "Division operation"]
            DIVISION = 0x14,
            #[doc = "Modular inversion operation"]
            MOD_INV = 0x15,
            #[doc = "Modular division operation"]
            MOD_DIV = 0x16,
            #[doc = "Multiply high operation"]
            MUL_HIGH = 0x17,
            #[doc = "Modular multiplication acceleration"]
            MOD_MLAC = 0x18,
            #[doc = "Modular multiplication acceleration where final reduction is omitted"]
            MOD_MLACNR = 0x19,
            _RESERVED_1a = 0x1a,
            #[doc = "Reduction operation"]
            REDUCTION = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Opcode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opcode {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opcode {
            #[inline(always)]
            fn from(val: u8) -> Opcode {
                Opcode::from_bits(val)
            }
        }
        impl From<Opcode> for u8 {
            #[inline(always)]
            fn from(val: Opcode) -> u8 {
                Opcode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PkaDoneStatus {
            #[doc = "PKA operation is processing"]
            PROCESSING = 0x0,
            #[doc = "PKA operation is completed and pipeline is empty"]
            COMPLETED = 0x01,
        }
        impl PkaDoneStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PkaDoneStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PkaDoneStatus {
            #[inline(always)]
            fn from(val: u8) -> PkaDoneStatus {
                PkaDoneStatus::from_bits(val)
            }
        }
        impl From<PkaDoneStatus> for u8 {
            #[inline(always)]
            fn from(val: PkaDoneStatus) -> u8 {
                PkaDoneStatus::to_bits(val)
            }
        }
    }
}
pub mod cc_rng {
    #[doc = "CRYPTOCELL RNG engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcRng {
        ptr: *mut u8,
    }
    unsafe impl Send for CcRng {}
    unsafe impl Sync for CcRng {}
    impl CcRng {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Interrupt mask register. Each bit of this register holds the mask of a single interrupt source."]
        #[inline(always)]
        pub const fn rng_imr(self) -> crate::common::Reg<regs::RngImr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Interrupt status register. Each bit of this register holds the interrupt status of a single interrupt source. If corresponding RNG_IMR bit is unmasked, an interrupt is generated."]
        #[inline(always)]
        pub const fn rng_isr(self) -> crate::common::Reg<regs::RngIsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Interrupt clear register. Writing a 1 bit into a field in this register will clear the corresponding bit in RNG_ISR."]
        #[inline(always)]
        pub const fn rng_icr(self) -> crate::common::Reg<regs::RngIcr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "TRNG ring oscillator length configuration"]
        #[inline(always)]
        pub const fn trng_config(self) -> crate::common::Reg<regs::TrngConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "This register indicates if TRNG entropy collection is valid."]
        #[inline(always)]
        pub const fn trng_valid(self) -> crate::common::Reg<regs::TrngValid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Description collection: The entropy holding registers (EHR) hold 192-bits random data collected by the TRNG. The initial EHR_DATA\\[0\\] register holds the least significant bits \\[31:0\\] of the random data value."]
        #[inline(always)]
        pub const fn ehr_data(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize + n * 4usize) as _)
            }
        }
        #[doc = "This register controls the ring oscillator circuit used as a noise source."]
        #[inline(always)]
        pub const fn noise_source(
            self,
        ) -> crate::common::Reg<regs::NoiseSource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x012cusize) as _) }
        }
        #[doc = "Sample count defining the number of CPU clock cycles between two consecutive noise source samples."]
        #[inline(always)]
        pub const fn sample_cnt(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0130usize) as _) }
        }
        #[doc = "Statistics counter for autocorrelation test activations. Statistics collection is stopped if one of the counters reach its limit of all ones."]
        #[inline(always)]
        pub const fn autocorr_statistic(
            self,
        ) -> crate::common::Reg<regs::AutocorrStatistic, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0134usize) as _) }
        }
        #[doc = "Debug register for the TRNG. This register is used to bypass TRNG tests in hardware."]
        #[inline(always)]
        pub const fn trng_debug(self) -> crate::common::Reg<regs::TrngDebug, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0138usize) as _) }
        }
        #[doc = "Reset the RNG engine."]
        #[inline(always)]
        pub const fn rng_sw_reset(self) -> crate::common::Reg<regs::RngSwReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize) as _) }
        }
        #[doc = "Status register for RNG engine activity."]
        #[inline(always)]
        pub const fn rng_busy(self) -> crate::common::Reg<regs::RngBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01b8usize) as _) }
        }
        #[doc = "Reset the TRNG, including internal counter of collected bits and registers EHR_DATA and TRNG_VALID."]
        #[inline(always)]
        pub const fn trng_reset(self) -> crate::common::Reg<regs::TrngReset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01bcusize) as _) }
        }
        #[doc = "Hardware configuration of RNG engine. Reset value holds the supported features."]
        #[inline(always)]
        pub const fn rng_hw_flags(self) -> crate::common::Reg<regs::RngHwFlags, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c0usize) as _) }
        }
        #[doc = "Control clock for the RNG engine."]
        #[inline(always)]
        pub const fn rng_clk(self) -> crate::common::Reg<regs::RngClk, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c4usize) as _) }
        }
        #[doc = "Writing to this register enables the RNG DMA engine."]
        #[inline(always)]
        pub const fn rng_dma(self) -> crate::common::Reg<regs::RngDma, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c8usize) as _) }
        }
        #[doc = "This register defines which ring oscillator length configuration should be used when using the RNG DMA engine."]
        #[inline(always)]
        pub const fn rng_dma_rosc_len(
            self,
        ) -> crate::common::Reg<regs::RngDmaRoscLen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "This register defines the start address in TRNG SRAM for the TRNG data to be collected by the RNG DMA engine."]
        #[inline(always)]
        pub const fn rng_dma_sram_addr(
            self,
        ) -> crate::common::Reg<regs::RngDmaSramAddr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d0usize) as _) }
        }
        #[doc = "This register defines the number of 192-bits samples that the RNG DMA engine collects per run."]
        #[inline(always)]
        pub const fn rng_dma_samples_num(
            self,
        ) -> crate::common::Reg<regs::RngDmaSamplesNum, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d4usize) as _) }
        }
        #[doc = "This register defines the maximum number of CPU clock cycles per TRNG collection of 192-bits samples. If the number of cycles for a collection exceeds this threshold the WATCHDOG interrupt is triggered."]
        #[inline(always)]
        pub const fn rng_watchdog_val(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d8usize) as _) }
        }
        #[doc = "Status register for RNG DMA engine activity."]
        #[inline(always)]
        pub const fn rng_dma_busy(self) -> crate::common::Reg<regs::RngDmaBusy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01dcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Statistics counter for autocorrelation test activations. Statistics collection is stopped if one of the counters reach its limit of all ones."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AutocorrStatistic(pub u32);
        impl AutocorrStatistic {
            #[doc = "Count each time an autocorrelation test starts. Any write to the field resets the counter."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_trys(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Count each time an autocorrelation test starts. Any write to the field resets the counter."]
            #[inline(always)]
            pub const fn set_autocorr_trys(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
            #[doc = "Count each time an autocorrelation test fails. Any write to the field resets the counter."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_fails(&self) -> u8 {
                let val = (self.0 >> 14usize) & 0xff;
                val as u8
            }
            #[doc = "Count each time an autocorrelation test fails. Any write to the field resets the counter."]
            #[inline(always)]
            pub const fn set_autocorr_fails(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 14usize)) | (((val as u32) & 0xff) << 14usize);
            }
        }
        impl Default for AutocorrStatistic {
            #[inline(always)]
            fn default() -> AutocorrStatistic {
                AutocorrStatistic(0)
            }
        }
        impl core::fmt::Debug for AutocorrStatistic {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AutocorrStatistic")
                    .field("autocorr_trys", &self.autocorr_trys())
                    .field("autocorr_fails", &self.autocorr_fails())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AutocorrStatistic {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "AutocorrStatistic {{ autocorr_trys: {=u16:?}, autocorr_fails: {=u8:?} }}",
                    self.autocorr_trys(),
                    self.autocorr_fails()
                )
            }
        }
        #[doc = "This register controls the ring oscillator circuit used as a noise source."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NoiseSource(pub u32);
        impl NoiseSource {
            #[doc = "Enable or disable the noise source."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable the noise source."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for NoiseSource {
            #[inline(always)]
            fn default() -> NoiseSource {
                NoiseSource(0)
            }
        }
        impl core::fmt::Debug for NoiseSource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NoiseSource")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NoiseSource {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "NoiseSource {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Status register for RNG engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngBusy(pub u32);
        impl RngBusy {
            #[doc = "RNG engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::RngBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::RngBusyStatus::from_bits(val as u8)
            }
            #[doc = "RNG engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::RngBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "TRNG status."]
            #[must_use]
            #[inline(always)]
            pub const fn trng_status(&self) -> super::vals::TrngStatus {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::TrngStatus::from_bits(val as u8)
            }
            #[doc = "TRNG status."]
            #[inline(always)]
            pub const fn set_trng_status(&mut self, val: super::vals::TrngStatus) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for RngBusy {
            #[inline(always)]
            fn default() -> RngBusy {
                RngBusy(0)
            }
        }
        impl core::fmt::Debug for RngBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngBusy")
                    .field("status", &self.status())
                    .field("trng_status", &self.trng_status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RngBusy {{ status: {:?}, trng_status: {:?} }}",
                    self.status(),
                    self.trng_status()
                )
            }
        }
        #[doc = "Control clock for the RNG engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngClk(pub u32);
        impl RngClk {
            #[doc = "Enables clock for the RNG engine."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables clock for the RNG engine."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RngClk {
            #[inline(always)]
            fn default() -> RngClk {
                RngClk(0)
            }
        }
        impl core::fmt::Debug for RngClk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngClk")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngClk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RngClk {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Writing to this register enables the RNG DMA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngDma(pub u32);
        impl RngDma {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RngDma {
            #[inline(always)]
            fn default() -> RngDma {
                RngDma(0)
            }
        }
        impl core::fmt::Debug for RngDma {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngDma")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngDma {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RngDma {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Status register for RNG DMA engine activity."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngDmaBusy(pub u32);
        impl RngDmaBusy {
            #[doc = "RNG DMA engine status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::RngDmaBusyStatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::RngDmaBusyStatus::from_bits(val as u8)
            }
            #[doc = "RNG DMA engine status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::RngDmaBusyStatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "The active ring oscillator length configuration used by the RNG DMA engine."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc_len(&self) -> super::vals::RngDmaBusyRoscLen {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::RngDmaBusyRoscLen::from_bits(val as u8)
            }
            #[doc = "The active ring oscillator length configuration used by the RNG DMA engine."]
            #[inline(always)]
            pub const fn set_rosc_len(&mut self, val: super::vals::RngDmaBusyRoscLen) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
            #[doc = "Number of samples already collected using the current ring oscillator configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn num_of_samples(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0xff;
                val as u8
            }
            #[doc = "Number of samples already collected using the current ring oscillator configuration."]
            #[inline(always)]
            pub const fn set_num_of_samples(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 3usize)) | (((val as u32) & 0xff) << 3usize);
            }
        }
        impl Default for RngDmaBusy {
            #[inline(always)]
            fn default() -> RngDmaBusy {
                RngDmaBusy(0)
            }
        }
        impl core::fmt::Debug for RngDmaBusy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngDmaBusy")
                    .field("status", &self.status())
                    .field("rosc_len", &self.rosc_len())
                    .field("num_of_samples", &self.num_of_samples())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngDmaBusy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RngDmaBusy {{ status: {:?}, rosc_len: {:?}, num_of_samples: {=u8:?} }}",
                    self.status(),
                    self.rosc_len(),
                    self.num_of_samples()
                )
            }
        }
        #[doc = "This register defines which ring oscillator length configuration should be used when using the RNG DMA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngDmaRoscLen(pub u32);
        impl RngDmaRoscLen {
            #[doc = "Use shortest ROSC1 ring oscillator configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Use shortest ROSC1 ring oscillator configuration."]
            #[inline(always)]
            pub const fn set_rosc1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Use ROSC2 ring oscillator configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Use ROSC2 ring oscillator configuration."]
            #[inline(always)]
            pub const fn set_rosc2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Use ROSC3 ring oscillator configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Use ROSC3 ring oscillator configuration."]
            #[inline(always)]
            pub const fn set_rosc3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Use longest ROSC4 ring oscillator configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Use longest ROSC4 ring oscillator configuration."]
            #[inline(always)]
            pub const fn set_rosc4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for RngDmaRoscLen {
            #[inline(always)]
            fn default() -> RngDmaRoscLen {
                RngDmaRoscLen(0)
            }
        }
        impl core::fmt::Debug for RngDmaRoscLen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngDmaRoscLen")
                    .field("rosc1", &self.rosc1())
                    .field("rosc2", &self.rosc2())
                    .field("rosc3", &self.rosc3())
                    .field("rosc4", &self.rosc4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngDmaRoscLen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngDmaRoscLen {{ rosc1: {=bool:?}, rosc2: {=bool:?}, rosc3: {=bool:?}, rosc4: {=bool:?} }}" , self . rosc1 () , self . rosc2 () , self . rosc3 () , self . rosc4 ())
            }
        }
        #[doc = "This register defines the number of 192-bits samples that the RNG DMA engine collects per run."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngDmaSamplesNum(pub u32);
        impl RngDmaSamplesNum {
            #[doc = "Defines the number of 192-bits samples that the DMA engine collects per run."]
            #[must_use]
            #[inline(always)]
            pub const fn rng_samples_num(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Defines the number of 192-bits samples that the DMA engine collects per run."]
            #[inline(always)]
            pub const fn set_rng_samples_num(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for RngDmaSamplesNum {
            #[inline(always)]
            fn default() -> RngDmaSamplesNum {
                RngDmaSamplesNum(0)
            }
        }
        impl core::fmt::Debug for RngDmaSamplesNum {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngDmaSamplesNum")
                    .field("rng_samples_num", &self.rng_samples_num())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngDmaSamplesNum {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RngDmaSamplesNum {{ rng_samples_num: {=u8:?} }}",
                    self.rng_samples_num()
                )
            }
        }
        #[doc = "This register defines the start address in TRNG SRAM for the TRNG data to be collected by the RNG DMA engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngDmaSramAddr(pub u32);
        impl RngDmaSramAddr {
            #[doc = "Start address of the TRNG data in TRNG SRAM."]
            #[must_use]
            #[inline(always)]
            pub const fn rng_sram_dma_addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Start address of the TRNG data in TRNG SRAM."]
            #[inline(always)]
            pub const fn set_rng_sram_dma_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
        }
        impl Default for RngDmaSramAddr {
            #[inline(always)]
            fn default() -> RngDmaSramAddr {
                RngDmaSramAddr(0)
            }
        }
        impl core::fmt::Debug for RngDmaSramAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngDmaSramAddr")
                    .field("rng_sram_dma_addr", &self.rng_sram_dma_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngDmaSramAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RngDmaSramAddr {{ rng_sram_dma_addr: {=u16:?} }}",
                    self.rng_sram_dma_addr()
                )
            }
        }
        #[doc = "Hardware configuration of RNG engine. Reset value holds the supported features."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngHwFlags(pub u32);
        impl RngHwFlags {
            #[doc = "Data width supported by the entropy collector"]
            #[must_use]
            #[inline(always)]
            pub const fn ehr_width(&self) -> super::vals::EhrWidth {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EhrWidth::from_bits(val as u8)
            }
            #[doc = "Data width supported by the entropy collector"]
            #[inline(always)]
            pub const fn set_ehr_width(&mut self, val: super::vals::EhrWidth) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "If this flag is set, the engine include support for continuous random number generator test."]
            #[must_use]
            #[inline(always)]
            pub const fn crngt_exists(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include support for continuous random number generator test."]
            #[inline(always)]
            pub const fn set_crngt_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "If this flag is set, the engine include support for autocorrelation test."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_exists(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include support for autocorrelation test."]
            #[inline(always)]
            pub const fn set_autocorr_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "If this flag is set, the engine include support for bypassing TRNG tests."]
            #[must_use]
            #[inline(always)]
            pub const fn bypass_exists(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include support for bypassing TRNG tests."]
            #[inline(always)]
            pub const fn set_bypass_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "If this flag is set, the engine include a pseudo-random number generator."]
            #[must_use]
            #[inline(always)]
            pub const fn prng_exists(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include a pseudo-random number generator."]
            #[inline(always)]
            pub const fn set_prng_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "If this flag is set, the engine include support for known answer tests."]
            #[must_use]
            #[inline(always)]
            pub const fn kat_exists(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include support for known answer tests."]
            #[inline(always)]
            pub const fn set_kat_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "If this flag is set, the engine include support for automatic reseeding."]
            #[must_use]
            #[inline(always)]
            pub const fn reseeding_exists(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "If this flag is set, the engine include support for automatic reseeding."]
            #[inline(always)]
            pub const fn set_reseeding_exists(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn rng_use_5_sboxes(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_rng_use_5_sboxes(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for RngHwFlags {
            #[inline(always)]
            fn default() -> RngHwFlags {
                RngHwFlags(0)
            }
        }
        impl core::fmt::Debug for RngHwFlags {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngHwFlags")
                    .field("ehr_width", &self.ehr_width())
                    .field("crngt_exists", &self.crngt_exists())
                    .field("autocorr_exists", &self.autocorr_exists())
                    .field("bypass_exists", &self.bypass_exists())
                    .field("prng_exists", &self.prng_exists())
                    .field("kat_exists", &self.kat_exists())
                    .field("reseeding_exists", &self.reseeding_exists())
                    .field("rng_use_5_sboxes", &self.rng_use_5_sboxes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngHwFlags {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngHwFlags {{ ehr_width: {:?}, crngt_exists: {=bool:?}, autocorr_exists: {=bool:?}, bypass_exists: {=bool:?}, prng_exists: {=bool:?}, kat_exists: {=bool:?}, reseeding_exists: {=bool:?}, rng_use_5_sboxes: {=bool:?} }}" , self . ehr_width () , self . crngt_exists () , self . autocorr_exists () , self . bypass_exists () , self . prng_exists () , self . kat_exists () , self . reseeding_exists () , self . rng_use_5_sboxes ())
            }
        }
        #[doc = "Interrupt clear register. Writing a 1 bit into a field in this register will clear the corresponding bit in RNG_ISR."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngIcr(pub u32);
        impl RngIcr {
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[must_use]
            #[inline(always)]
            pub const fn ehr_valid_clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[inline(always)]
            pub const fn set_ehr_valid_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Cannot be cleared by software! Only RNG reset clears this bit."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_err_clear(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Cannot be cleared by software! Only RNG reset clears this bit."]
            #[inline(always)]
            pub const fn set_autocorr_err_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[must_use]
            #[inline(always)]
            pub const fn crngt_err_clear(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[inline(always)]
            pub const fn set_crngt_err_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[must_use]
            #[inline(always)]
            pub const fn vnc_err_clear(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[inline(always)]
            pub const fn set_vnc_err_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[must_use]
            #[inline(always)]
            pub const fn watchdog_clear(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[inline(always)]
            pub const fn set_watchdog_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_done_clear(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Writing value '1' clears corresponding bit in RNG_ISR"]
            #[inline(always)]
            pub const fn set_dma_done_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for RngIcr {
            #[inline(always)]
            fn default() -> RngIcr {
                RngIcr(0)
            }
        }
        impl core::fmt::Debug for RngIcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngIcr")
                    .field("ehr_valid_clear", &self.ehr_valid_clear())
                    .field("autocorr_err_clear", &self.autocorr_err_clear())
                    .field("crngt_err_clear", &self.crngt_err_clear())
                    .field("vnc_err_clear", &self.vnc_err_clear())
                    .field("watchdog_clear", &self.watchdog_clear())
                    .field("dma_done_clear", &self.dma_done_clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngIcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngIcr {{ ehr_valid_clear: {=bool:?}, autocorr_err_clear: {=bool:?}, crngt_err_clear: {=bool:?}, vnc_err_clear: {=bool:?}, watchdog_clear: {=bool:?}, dma_done_clear: {=bool:?} }}" , self . ehr_valid_clear () , self . autocorr_err_clear () , self . crngt_err_clear () , self . vnc_err_clear () , self . watchdog_clear () , self . dma_done_clear ())
            }
        }
        #[doc = "Interrupt mask register. Each bit of this register holds the mask of a single interrupt source."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngImr(pub u32);
        impl RngImr {
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn ehr_valid_mask(&self) -> super::vals::EhrValidMask {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EhrValidMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_ehr_valid_mask(&mut self, val: super::vals::EhrValidMask) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_err_mask(&self) -> super::vals::AutocorrErrMask {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::AutocorrErrMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_autocorr_err_mask(&mut self, val: super::vals::AutocorrErrMask) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn crngt_err_mask(&self) -> super::vals::CrngtErrMask {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::CrngtErrMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_crngt_err_mask(&mut self, val: super::vals::CrngtErrMask) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn vnc_err_mask(&self) -> super::vals::VncErrMask {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::VncErrMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_vnc_err_mask(&mut self, val: super::vals::VncErrMask) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn watchdog_mask(&self) -> super::vals::WatchdogMask {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::WatchdogMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_watchdog_mask(&mut self, val: super::vals::WatchdogMask) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_done_mask(&self) -> super::vals::DmaDoneMask {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::DmaDoneMask::from_bits(val as u8)
            }
            #[doc = "See RNG_ISR for explanation on this interrupt."]
            #[inline(always)]
            pub const fn set_dma_done_mask(&mut self, val: super::vals::DmaDoneMask) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
        }
        impl Default for RngImr {
            #[inline(always)]
            fn default() -> RngImr {
                RngImr(0)
            }
        }
        impl core::fmt::Debug for RngImr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngImr")
                    .field("ehr_valid_mask", &self.ehr_valid_mask())
                    .field("autocorr_err_mask", &self.autocorr_err_mask())
                    .field("crngt_err_mask", &self.crngt_err_mask())
                    .field("vnc_err_mask", &self.vnc_err_mask())
                    .field("watchdog_mask", &self.watchdog_mask())
                    .field("dma_done_mask", &self.dma_done_mask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngImr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngImr {{ ehr_valid_mask: {:?}, autocorr_err_mask: {:?}, crngt_err_mask: {:?}, vnc_err_mask: {:?}, watchdog_mask: {:?}, dma_done_mask: {:?} }}" , self . ehr_valid_mask () , self . autocorr_err_mask () , self . crngt_err_mask () , self . vnc_err_mask () , self . watchdog_mask () , self . dma_done_mask ())
            }
        }
        #[doc = "Interrupt status register. Each bit of this register holds the interrupt status of a single interrupt source. If corresponding RNG_IMR bit is unmasked, an interrupt is generated."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngIsr(pub u32);
        impl RngIsr {
            #[doc = "192-bits have been collected and are ready to be read."]
            #[must_use]
            #[inline(always)]
            pub const fn ehr_valid_int(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "192-bits have been collected and are ready to be read."]
            #[inline(always)]
            pub const fn set_ehr_valid_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Autocorrelation error. Failure occurs when autocorrelation test has failed four times in a row. Once set, the TRNG ceases to function until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_err_int(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Autocorrelation error. Failure occurs when autocorrelation test has failed four times in a row. Once set, the TRNG ceases to function until next reset."]
            #[inline(always)]
            pub const fn set_autocorr_err_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Continuous random number generator test error. Failure occurs when two consecutive blocks of 16 collected bits are equal."]
            #[must_use]
            #[inline(always)]
            pub const fn crngt_err_int(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Continuous random number generator test error. Failure occurs when two consecutive blocks of 16 collected bits are equal."]
            #[inline(always)]
            pub const fn set_crngt_err_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "von Neumann corrector error. Failure occurs if 32 consecutive collected bits are identical, ZERO, or ONE."]
            #[must_use]
            #[inline(always)]
            pub const fn vnc_err_int(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "von Neumann corrector error. Failure occurs if 32 consecutive collected bits are identical, ZERO, or ONE."]
            #[inline(always)]
            pub const fn set_vnc_err_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Maximum number of CPU clock cycles per sample have been exceeded. See RNG_WATCHDOG_VAL for more information."]
            #[must_use]
            #[inline(always)]
            pub const fn watchdog_int(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Maximum number of CPU clock cycles per sample have been exceeded. See RNG_WATCHDOG_VAL for more information."]
            #[inline(always)]
            pub const fn set_watchdog_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "RNG DMA to SRAM is completed."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_done_int(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "RNG DMA to SRAM is completed."]
            #[inline(always)]
            pub const fn set_dma_done_int(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for RngIsr {
            #[inline(always)]
            fn default() -> RngIsr {
                RngIsr(0)
            }
        }
        impl core::fmt::Debug for RngIsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngIsr")
                    .field("ehr_valid_int", &self.ehr_valid_int())
                    .field("autocorr_err_int", &self.autocorr_err_int())
                    .field("crngt_err_int", &self.crngt_err_int())
                    .field("vnc_err_int", &self.vnc_err_int())
                    .field("watchdog_int", &self.watchdog_int())
                    .field("dma_done_int", &self.dma_done_int())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngIsr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngIsr {{ ehr_valid_int: {=bool:?}, autocorr_err_int: {=bool:?}, crngt_err_int: {=bool:?}, vnc_err_int: {=bool:?}, watchdog_int: {=bool:?}, dma_done_int: {=bool:?} }}" , self . ehr_valid_int () , self . autocorr_err_int () , self . crngt_err_int () , self . vnc_err_int () , self . watchdog_int () , self . dma_done_int ())
            }
        }
        #[doc = "Reset the RNG engine."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngSwReset(pub u32);
        impl RngSwReset {
            #[doc = "Writing any value to this address resets the RNG engine. The reset takes 4 CPU clock cycles to complete."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the RNG engine. The reset takes 4 CPU clock cycles to complete."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RngSwReset {
            #[inline(always)]
            fn default() -> RngSwReset {
                RngSwReset(0)
            }
        }
        impl core::fmt::Debug for RngSwReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngSwReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngSwReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RngSwReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "TRNG ring oscillator length configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TrngConfig(pub u32);
        impl TrngConfig {
            #[doc = "Set the length of the oscillator ring (= the number of inverters) out of four possible configurations."]
            #[must_use]
            #[inline(always)]
            pub const fn rosc_len(&self) -> super::vals::TrngConfigRoscLen {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TrngConfigRoscLen::from_bits(val as u8)
            }
            #[doc = "Set the length of the oscillator ring (= the number of inverters) out of four possible configurations."]
            #[inline(always)]
            pub const fn set_rosc_len(&mut self, val: super::vals::TrngConfigRoscLen) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TrngConfig {
            #[inline(always)]
            fn default() -> TrngConfig {
                TrngConfig(0)
            }
        }
        impl core::fmt::Debug for TrngConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TrngConfig")
                    .field("rosc_len", &self.rosc_len())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TrngConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TrngConfig {{ rosc_len: {:?} }}", self.rosc_len())
            }
        }
        #[doc = "Debug register for the TRNG. This register is used to bypass TRNG tests in hardware."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TrngDebug(pub u32);
        impl TrngDebug {
            #[doc = "Bypass the von Neumann corrector post-processing test, including the 32 consecutive bits test."]
            #[must_use]
            #[inline(always)]
            pub const fn vnc_bypass(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass the von Neumann corrector post-processing test, including the 32 consecutive bits test."]
            #[inline(always)]
            pub const fn set_vnc_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Bypass the Continuous Random Number Generator Test (CRNGT)."]
            #[must_use]
            #[inline(always)]
            pub const fn crngt_bypass(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass the Continuous Random Number Generator Test (CRNGT)."]
            #[inline(always)]
            pub const fn set_crngt_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Bypass the autocorrelation test."]
            #[must_use]
            #[inline(always)]
            pub const fn autocorr_bypass(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass the autocorrelation test."]
            #[inline(always)]
            pub const fn set_autocorr_bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for TrngDebug {
            #[inline(always)]
            fn default() -> TrngDebug {
                TrngDebug(0)
            }
        }
        impl core::fmt::Debug for TrngDebug {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TrngDebug")
                    .field("vnc_bypass", &self.vnc_bypass())
                    .field("crngt_bypass", &self.crngt_bypass())
                    .field("autocorr_bypass", &self.autocorr_bypass())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TrngDebug {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TrngDebug {{ vnc_bypass: {=bool:?}, crngt_bypass: {=bool:?}, autocorr_bypass: {=bool:?} }}" , self . vnc_bypass () , self . crngt_bypass () , self . autocorr_bypass ())
            }
        }
        #[doc = "Reset the TRNG, including internal counter of collected bits and registers EHR_DATA and TRNG_VALID."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TrngReset(pub u32);
        impl TrngReset {
            #[doc = "Writing any value to this address resets the internal bits counter and registers EHR_DATA and TRNG_VALID. Register NOISE_SOURCE must be disabled in order for the reset to take place."]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing any value to this address resets the internal bits counter and registers EHR_DATA and TRNG_VALID. Register NOISE_SOURCE must be disabled in order for the reset to take place."]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TrngReset {
            #[inline(always)]
            fn default() -> TrngReset {
                TrngReset(0)
            }
        }
        impl core::fmt::Debug for TrngReset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TrngReset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TrngReset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TrngReset {{ reset: {=bool:?} }}", self.reset())
            }
        }
        #[doc = "This register indicates if TRNG entropy collection is valid."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TrngValid(pub u32);
        impl TrngValid {
            #[doc = "A value of 1 indicates that collection of bits in the TRNG is completed, and data can be read from EHR_DATA registers."]
            #[must_use]
            #[inline(always)]
            pub const fn ehr_data(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "A value of 1 indicates that collection of bits in the TRNG is completed, and data can be read from EHR_DATA registers."]
            #[inline(always)]
            pub const fn set_ehr_data(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TrngValid {
            #[inline(always)]
            fn default() -> TrngValid {
                TrngValid(0)
            }
        }
        impl core::fmt::Debug for TrngValid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TrngValid")
                    .field("ehr_data", &self.ehr_data())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TrngValid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TrngValid {{ ehr_data: {=bool:?} }}", self.ehr_data())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum AutocorrErrMask {
            #[doc = "Do not mask autocorrelation interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask autocorrelation interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl AutocorrErrMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> AutocorrErrMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for AutocorrErrMask {
            #[inline(always)]
            fn from(val: u8) -> AutocorrErrMask {
                AutocorrErrMask::from_bits(val)
            }
        }
        impl From<AutocorrErrMask> for u8 {
            #[inline(always)]
            fn from(val: AutocorrErrMask) -> u8 {
                AutocorrErrMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CrngtErrMask {
            #[doc = "Do not mask the CRNGT error interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask the CRNGT error interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl CrngtErrMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CrngtErrMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CrngtErrMask {
            #[inline(always)]
            fn from(val: u8) -> CrngtErrMask {
                CrngtErrMask::from_bits(val)
            }
        }
        impl From<CrngtErrMask> for u8 {
            #[inline(always)]
            fn from(val: CrngtErrMask) -> u8 {
                CrngtErrMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DmaDoneMask {
            #[doc = "Do not mask the RNG DMA completion interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask the RNG DMA completion interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl DmaDoneMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DmaDoneMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DmaDoneMask {
            #[inline(always)]
            fn from(val: u8) -> DmaDoneMask {
                DmaDoneMask::from_bits(val)
            }
        }
        impl From<DmaDoneMask> for u8 {
            #[inline(always)]
            fn from(val: DmaDoneMask) -> u8 {
                DmaDoneMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EhrValidMask {
            #[doc = "Do not mask EHR interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask EHR interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl EhrValidMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EhrValidMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EhrValidMask {
            #[inline(always)]
            fn from(val: u8) -> EhrValidMask {
                EhrValidMask::from_bits(val)
            }
        }
        impl From<EhrValidMask> for u8 {
            #[inline(always)]
            fn from(val: EhrValidMask) -> u8 {
                EhrValidMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EhrWidth {
            #[doc = "128 bits EHR width"]
            _128BITS = 0x0,
            #[doc = "192 bits EHR width"]
            _192BITS = 0x01,
        }
        impl EhrWidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EhrWidth {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EhrWidth {
            #[inline(always)]
            fn from(val: u8) -> EhrWidth {
                EhrWidth::from_bits(val)
            }
        }
        impl From<EhrWidth> for u8 {
            #[inline(always)]
            fn from(val: EhrWidth) -> u8 {
                EhrWidth::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RngBusyStatus {
            #[doc = "RNG engine is idle"]
            IDLE = 0x0,
            #[doc = "RNG engine is busy"]
            BUSY = 0x01,
        }
        impl RngBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RngBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RngBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> RngBusyStatus {
                RngBusyStatus::from_bits(val)
            }
        }
        impl From<RngBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: RngBusyStatus) -> u8 {
                RngBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RngDmaBusyRoscLen {
            #[doc = "Shortest ROSC1 ring oscillator configuration used."]
            ROSC1 = 0x0,
            #[doc = "ROSC2 ring oscillator configuration used."]
            ROSC2 = 0x01,
            #[doc = "ROSC3 ring oscillator configuration used."]
            ROSC3 = 0x02,
            #[doc = "Longest ROSC4 ring oscillator configuration used."]
            ROSC4 = 0x03,
        }
        impl RngDmaBusyRoscLen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RngDmaBusyRoscLen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RngDmaBusyRoscLen {
            #[inline(always)]
            fn from(val: u8) -> RngDmaBusyRoscLen {
                RngDmaBusyRoscLen::from_bits(val)
            }
        }
        impl From<RngDmaBusyRoscLen> for u8 {
            #[inline(always)]
            fn from(val: RngDmaBusyRoscLen) -> u8 {
                RngDmaBusyRoscLen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RngDmaBusyStatus {
            #[doc = "RNG DMA engine is idle"]
            IDLE = 0x0,
            #[doc = "RNG DMA engine is busy"]
            BUSY = 0x01,
        }
        impl RngDmaBusyStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RngDmaBusyStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RngDmaBusyStatus {
            #[inline(always)]
            fn from(val: u8) -> RngDmaBusyStatus {
                RngDmaBusyStatus::from_bits(val)
            }
        }
        impl From<RngDmaBusyStatus> for u8 {
            #[inline(always)]
            fn from(val: RngDmaBusyStatus) -> u8 {
                RngDmaBusyStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TrngConfigRoscLen {
            #[doc = "Use shortest ROSC1 ring oscillator configuration."]
            ROSC1 = 0x0,
            #[doc = "Use ROSC2 ring oscillator configuration."]
            ROSC2 = 0x01,
            #[doc = "Use ROSC3 ring oscillator configuration."]
            ROSC3 = 0x02,
            #[doc = "Use longest ROSC4 ring oscillator configuration."]
            ROSC4 = 0x03,
        }
        impl TrngConfigRoscLen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TrngConfigRoscLen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TrngConfigRoscLen {
            #[inline(always)]
            fn from(val: u8) -> TrngConfigRoscLen {
                TrngConfigRoscLen::from_bits(val)
            }
        }
        impl From<TrngConfigRoscLen> for u8 {
            #[inline(always)]
            fn from(val: TrngConfigRoscLen) -> u8 {
                TrngConfigRoscLen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TrngStatus {
            #[doc = "TRNG is idle"]
            IDLE = 0x0,
            #[doc = "TRNG is busy"]
            BUSY = 0x01,
        }
        impl TrngStatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TrngStatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TrngStatus {
            #[inline(always)]
            fn from(val: u8) -> TrngStatus {
                TrngStatus::from_bits(val)
            }
        }
        impl From<TrngStatus> for u8 {
            #[inline(always)]
            fn from(val: TrngStatus) -> u8 {
                TrngStatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum VncErrMask {
            #[doc = "Do not mask the von Neumann corrector error interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask the von Neumann corrector error interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl VncErrMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> VncErrMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for VncErrMask {
            #[inline(always)]
            fn from(val: u8) -> VncErrMask {
                VncErrMask::from_bits(val)
            }
        }
        impl From<VncErrMask> for u8 {
            #[inline(always)]
            fn from(val: VncErrMask) -> u8 {
                VncErrMask::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum WatchdogMask {
            #[doc = "Do not mask the watchdog interrupt i.e. interrupt is generated"]
            IRQENABLE = 0x0,
            #[doc = "Mask the watchdog interrupt i.e. no interrupt is generated"]
            IRQDISABLE = 0x01,
        }
        impl WatchdogMask {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> WatchdogMask {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for WatchdogMask {
            #[inline(always)]
            fn from(val: u8) -> WatchdogMask {
                WatchdogMask::from_bits(val)
            }
        }
        impl From<WatchdogMask> for u8 {
            #[inline(always)]
            fn from(val: WatchdogMask) -> u8 {
                WatchdogMask::to_bits(val)
            }
        }
    }
}
pub mod cc_rng_sram {
    #[doc = "CRYPTOCELL RNG SRAM interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CcRngSram {
        ptr: *mut u8,
    }
    unsafe impl Send for CcRngSram {}
    unsafe impl Sync for CcRngSram {}
    impl CcRngSram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Read/Write data from RNG SRAM"]
        #[inline(always)]
        pub const fn sram_data(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "First address given to RNG SRAM DMA for read/write transactions from/to RNG SRAM."]
        #[inline(always)]
        pub const fn sram_addr(self) -> crate::common::Reg<regs::SramAddr, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f04usize) as _) }
        }
        #[doc = "RNG SRAM DMA engine is ready to read/write from/to RNG SRAM."]
        #[inline(always)]
        pub const fn sram_data_ready(
            self,
        ) -> crate::common::Reg<regs::SramDataReady, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "First address given to RNG SRAM DMA for read/write transactions from/to RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SramAddr(pub u32);
        impl SramAddr {
            #[doc = "RNG SRAM starting address"]
            #[must_use]
            #[inline(always)]
            pub const fn sram_addr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "RNG SRAM starting address"]
            #[inline(always)]
            pub const fn set_sram_addr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for SramAddr {
            #[inline(always)]
            fn default() -> SramAddr {
                SramAddr(0)
            }
        }
        impl core::fmt::Debug for SramAddr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SramAddr")
                    .field("sram_addr", &self.sram_addr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramAddr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SramAddr {{ sram_addr: {=u16:?} }}", self.sram_addr())
            }
        }
        #[doc = "RNG SRAM DMA engine is ready to read/write from/to RNG SRAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SramDataReady(pub u32);
        impl SramDataReady {
            #[doc = "RNG SRAM DMA status."]
            #[must_use]
            #[inline(always)]
            pub const fn sram_ready(&self) -> super::vals::SramReady {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SramReady::from_bits(val as u8)
            }
            #[doc = "RNG SRAM DMA status."]
            #[inline(always)]
            pub const fn set_sram_ready(&mut self, val: super::vals::SramReady) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SramDataReady {
            #[inline(always)]
            fn default() -> SramDataReady {
                SramDataReady(0)
            }
        }
        impl core::fmt::Debug for SramDataReady {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SramDataReady")
                    .field("sram_ready", &self.sram_ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SramDataReady {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SramDataReady {{ sram_ready: {:?} }}", self.sram_ready())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SramReady {
            #[doc = "DMA is busy"]
            BUSY = 0x0,
            #[doc = "DMA is idle"]
            IDLE = 0x01,
        }
        impl SramReady {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SramReady {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SramReady {
            #[inline(always)]
            fn from(val: u8) -> SramReady {
                SramReady::from_bits(val)
            }
        }
        impl From<SramReady> for u8 {
            #[inline(always)]
            fn from(val: SramReady) -> u8 {
                SramReady::to_bits(val)
            }
        }
    }
}
pub mod clock {
    #[doc = "Clock management 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clock {
        ptr: *mut u8,
    }
    unsafe impl Send for Clock {}
    unsafe impl Sync for Clock {}
    impl Clock {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start HFCLK source"]
        #[inline(always)]
        pub const fn tasks_hfclkstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop HFCLK source"]
        #[inline(always)]
        pub const fn tasks_hfclkstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Start LFCLK source"]
        #[inline(always)]
        pub const fn tasks_lfclkstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Stop LFCLK source"]
        #[inline(always)]
        pub const fn tasks_lfclkstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task HFCLKSTART"]
        #[inline(always)]
        pub const fn subscribe_hfclkstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task HFCLKSTOP"]
        #[inline(always)]
        pub const fn subscribe_hfclkstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTART"]
        #[inline(always)]
        pub const fn subscribe_lfclkstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTOP"]
        #[inline(always)]
        pub const fn subscribe_lfclkstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "HFCLK oscillator started"]
        #[inline(always)]
        pub const fn events_hfclkstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "LFCLK started"]
        #[inline(always)]
        pub const fn events_lfclkstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event HFCLKSTARTED"]
        #[inline(always)]
        pub const fn publish_hfclkstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event LFCLKSTARTED"]
        #[inline(always)]
        pub const fn publish_lfclkstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Status indicating that HFCLKSTART task has been triggered"]
        #[inline(always)]
        pub const fn hfclkrun(self) -> crate::common::Reg<regs::Hfclkrun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0408usize) as _) }
        }
        #[doc = "The register shows if HFXO has been requested by triggering HFCLKSTART task and if it has been started (STATE)."]
        #[inline(always)]
        pub const fn hfclkstat(self) -> crate::common::Reg<regs::Hfclkstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x040cusize) as _) }
        }
        #[doc = "Status indicating that LFCLKSTART task has been triggered"]
        #[inline(always)]
        pub const fn lfclkrun(self) -> crate::common::Reg<regs::Lfclkrun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0414usize) as _) }
        }
        #[doc = "The register shows which LFCLK source has been requested (SRC) when triggering LFCLKSTART task and if the source has been started (STATE)."]
        #[inline(always)]
        pub const fn lfclkstat(self) -> crate::common::Reg<regs::Lfclkstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0418usize) as _) }
        }
        #[doc = "Copy of LFCLKSRC register, set after LFCLKSTART task has been triggered"]
        #[inline(always)]
        pub const fn lfclksrccopy(
            self,
        ) -> crate::common::Reg<regs::Lfclksrccopy, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x041cusize) as _) }
        }
        #[doc = "Clock source for the LFCLK. LFCLKSTART task starts a clock source selected with this register."]
        #[inline(always)]
        pub const fn lfclksrc(self) -> crate::common::Reg<regs::Lfclksrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status indicating that HFCLKSTART task has been triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfclkrun(pub u32);
        impl Hfclkrun {
            #[doc = "HFCLKSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "HFCLKSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hfclkrun {
            #[inline(always)]
            fn default() -> Hfclkrun {
                Hfclkrun(0)
            }
        }
        impl core::fmt::Debug for Hfclkrun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfclkrun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfclkrun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hfclkrun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "The register shows if HFXO has been requested by triggering HFCLKSTART task and if it has been started (STATE)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfclkstat(pub u32);
        impl Hfclkstat {
            #[doc = "Active clock source"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::HfclkstatSrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::HfclkstatSrc::from_bits(val as u8)
            }
            #[doc = "Active clock source"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::HfclkstatSrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "HFCLK state"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "HFCLK state"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Hfclkstat {
            #[inline(always)]
            fn default() -> Hfclkstat {
                Hfclkstat(0)
            }
        }
        impl core::fmt::Debug for Hfclkstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfclkstat")
                    .field("src", &self.src())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfclkstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hfclkstat {{ src: {:?}, state: {=bool:?} }}",
                    self.src(),
                    self.state()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event HFCLKSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn hfclkstarted(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event HFCLKSTARTED"]
            #[inline(always)]
            pub const fn set_hfclkstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn lfclkstarted(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[inline(always)]
            pub const fn set_lfclkstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("hfclkstarted", &self.hfclkstarted())
                    .field("lfclkstarted", &self.lfclkstarted())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ hfclkstarted: {=bool:?}, lfclkstarted: {=bool:?} }}",
                    self.hfclkstarted(),
                    self.lfclkstarted()
                )
            }
        }
        #[doc = "Status indicating that LFCLKSTART task has been triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfclkrun(pub u32);
        impl Lfclkrun {
            #[doc = "LFCLKSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLKSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lfclkrun {
            #[inline(always)]
            fn default() -> Lfclkrun {
                Lfclkrun(0)
            }
        }
        impl core::fmt::Debug for Lfclkrun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfclkrun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfclkrun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lfclkrun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Clock source for the LFCLK. LFCLKSTART task starts a clock source selected with this register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfclksrc(pub u32);
        impl Lfclksrc {
            #[doc = "Clock source"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Clock source"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Lfclksrc {
            #[inline(always)]
            fn default() -> Lfclksrc {
                Lfclksrc(0)
            }
        }
        impl core::fmt::Debug for Lfclksrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfclksrc")
                    .field("src", &self.src())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfclksrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lfclksrc {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Copy of LFCLKSRC register, set after LFCLKSTART task has been triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfclksrccopy(pub u32);
        impl Lfclksrccopy {
            #[doc = "Clock source"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Clock source"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Lfclksrccopy {
            #[inline(always)]
            fn default() -> Lfclksrccopy {
                Lfclksrccopy(0)
            }
        }
        impl core::fmt::Debug for Lfclksrccopy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfclksrccopy")
                    .field("src", &self.src())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfclksrccopy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lfclksrccopy {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "The register shows which LFCLK source has been requested (SRC) when triggering LFCLKSTART task and if the source has been started (STATE)."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfclkstat(pub u32);
        impl Lfclkstat {
            #[doc = "Active clock source"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Active clock source"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "LFCLK state"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLK state"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Lfclkstat {
            #[inline(always)]
            fn default() -> Lfclkstat {
                Lfclkstat(0)
            }
        }
        impl core::fmt::Debug for Lfclkstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfclkstat")
                    .field("src", &self.src())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfclkstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lfclkstat {{ src: {:?}, state: {=bool:?} }}",
                    self.src(),
                    self.state()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum HfclkstatSrc {
            #[doc = "HFINT - 64 MHz on-chip oscillator"]
            HFINT = 0x0,
            #[doc = "HFXO - 64 MHz clock derived from external 32 MHz crystal oscillator"]
            HFXO = 0x01,
        }
        impl HfclkstatSrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> HfclkstatSrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for HfclkstatSrc {
            #[inline(always)]
            fn from(val: u8) -> HfclkstatSrc {
                HfclkstatSrc::from_bits(val)
            }
        }
        impl From<HfclkstatSrc> for u8 {
            #[inline(always)]
            fn from(val: HfclkstatSrc) -> u8 {
                HfclkstatSrc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lfclksrc {
            #[doc = "Reserved for future use (equals selecting LFRC)"]
            RFU = 0x0,
            #[doc = "32.768 kHz RC oscillator"]
            LFRC = 0x01,
            #[doc = "32.768 kHz crystal oscillator"]
            LFXO = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lfclksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lfclksrc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lfclksrc {
            #[inline(always)]
            fn from(val: u8) -> Lfclksrc {
                Lfclksrc::from_bits(val)
            }
        }
        impl From<Lfclksrc> for u8 {
            #[inline(always)]
            fn from(val: Lfclksrc) -> u8 {
                Lfclksrc::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write(&self, f: impl FnOnce(&mut T)) {
            let mut val = Default::default();
            f(&mut val);
            self.write_value(val);
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify(&self, f: impl FnOnce(&mut T)) {
            let mut val = self.read();
            f(&mut val);
            self.write_value(val);
        }
    }
}
pub mod cryptocell {
    #[doc = "CRYPTOCELL register interface"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptocell {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptocell {}
    unsafe impl Sync for Cryptocell {}
    impl Cryptocell {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable CRYPTOCELL subsystem."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable CRYPTOCELL subsystem."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable the CRYPTOCELL subsystem."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable the CRYPTOCELL subsystem."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
    }
}
pub mod ctrlapperi {
    #[doc = "Control access port"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctrlapperi {
        ptr: *mut u8,
    }
    unsafe impl Send for Ctrlapperi {}
    unsafe impl Sync for Ctrlapperi {}
    impl Ctrlapperi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn mailbox(self) -> Mailbox {
            unsafe { Mailbox::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "This register disables the ERASEPROTECT register and performs an ERASEALL operation."]
        #[inline(always)]
        pub const fn disable(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mailbox {
        ptr: *mut u8,
    }
    unsafe impl Send for Mailbox {}
    unsafe impl Sync for Mailbox {}
    impl Mailbox {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data sent from the debugger to the CPU."]
        #[inline(always)]
        pub const fn rxdata(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "This register shows a status that indicates if data sent from the debugger to the CPU has been read."]
        #[inline(always)]
        pub const fn rxstatus(self) -> crate::common::Reg<regs::Rxstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Data sent from the CPU to the debugger."]
        #[inline(always)]
        pub const fn txdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "This register shows a status that indicates if the data sent from the CPU to the debugger has been read."]
        #[inline(always)]
        pub const fn txstatus(self) -> crate::common::Reg<regs::Txstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "This register shows a status that indicates if data sent from the debugger to the CPU has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxstatus(pub u32);
        impl Rxstatus {
            #[doc = "Status of data in register RXDATA"]
            #[must_use]
            #[inline(always)]
            pub const fn rxstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register RXDATA"]
            #[inline(always)]
            pub const fn set_rxstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxstatus {
            #[inline(always)]
            fn default() -> Rxstatus {
                Rxstatus(0)
            }
        }
        impl core::fmt::Debug for Rxstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxstatus")
                    .field("rxstatus", &self.rxstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxstatus {{ rxstatus: {=bool:?} }}", self.rxstatus())
            }
        }
        #[doc = "This register shows a status that indicates if the data sent from the CPU to the debugger has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txstatus(pub u32);
        impl Txstatus {
            #[doc = "Status of data in register TXDATA"]
            #[must_use]
            #[inline(always)]
            pub const fn txstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register TXDATA"]
            #[inline(always)]
            pub const fn set_txstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txstatus {
            #[inline(always)]
            fn default() -> Txstatus {
                Txstatus(0)
            }
        }
        impl core::fmt::Debug for Txstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txstatus")
                    .field("txstatus", &self.txstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txstatus {{ txstatus: {=bool:?} }}", self.txstatus())
            }
        }
    }
}
pub mod dppic {
    #[doc = "Distributed programmable peripheral interconnect controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Channel group tasks"]
        #[inline(always)]
        pub const fn tasks_chg(self, n: usize) -> TasksChg {
            assert!(n < 6usize);
            unsafe { TasksChg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_chg(self, n: usize) -> SubscribeChg {
            assert!(n < 6usize);
            unsafe { SubscribeChg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 8usize) as _) }
        }
        #[doc = "Channel enable register"]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Channel enable set register"]
        #[inline(always)]
        pub const fn chenset(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Channel enable clear register"]
        #[inline(always)]
        pub const fn chenclr(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0800usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeChg {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeChg {}
    unsafe impl Sync for SubscribeChg {}
    impl SubscribeChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].EN"]
        #[inline(always)]
        pub const fn en(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].DIS"]
        #[inline(always)]
        pub const fn dis(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Channel group tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksChg {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksChg {}
    unsafe impl Sync for TasksChg {}
    impl TasksChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Enable channel group n"]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Disable channel group n"]
        #[inline(always)]
        pub const fn dis(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Channel enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chen {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize))
            }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "Include or exclude channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Include or exclude channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chg {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize))
            }
        }
    }
}
pub mod egu {
    #[doc = "Event generator unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Egu {
        ptr: *mut u8,
    }
    unsafe impl Send for Egu {}
    unsafe impl Sync for Egu {}
    impl Egu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Trigger n for triggering the corresponding TRIGGERED\\[n\\] event"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Event number n generated by triggering the corresponding TRIGGER\\[n\\] task"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 16usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[inline(always)]
            pub const fn set_triggered(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered[0]", &self.triggered(0usize))
                    .field("triggered[1]", &self.triggered(1usize))
                    .field("triggered[2]", &self.triggered(2usize))
                    .field("triggered[3]", &self.triggered(3usize))
                    .field("triggered[4]", &self.triggered(4usize))
                    .field("triggered[5]", &self.triggered(5usize))
                    .field("triggered[6]", &self.triggered(6usize))
                    .field("triggered[7]", &self.triggered(7usize))
                    .field("triggered[8]", &self.triggered(8usize))
                    .field("triggered[9]", &self.triggered(9usize))
                    .field("triggered[10]", &self.triggered(10usize))
                    .field("triggered[11]", &self.triggered(11usize))
                    .field("triggered[12]", &self.triggered(12usize))
                    .field("triggered[13]", &self.triggered(13usize))
                    .field("triggered[14]", &self.triggered(14usize))
                    .field("triggered[15]", &self.triggered(15usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ triggered[0]: {=bool:?}, triggered[1]: {=bool:?}, triggered[2]: {=bool:?}, triggered[3]: {=bool:?}, triggered[4]: {=bool:?}, triggered[5]: {=bool:?}, triggered[6]: {=bool:?}, triggered[7]: {=bool:?}, triggered[8]: {=bool:?}, triggered[9]: {=bool:?}, triggered[10]: {=bool:?}, triggered[11]: {=bool:?}, triggered[12]: {=bool:?}, triggered[13]: {=bool:?}, triggered[14]: {=bool:?}, triggered[15]: {=bool:?} }}" , self . triggered (0usize) , self . triggered (1usize) , self . triggered (2usize) , self . triggered (3usize) , self . triggered (4usize) , self . triggered (5usize) , self . triggered (6usize) , self . triggered (7usize) , self . triggered (8usize) , self . triggered (9usize) , self . triggered (10usize) , self . triggered (11usize) , self . triggered (12usize) , self . triggered (13usize) , self . triggered (14usize) , self . triggered (15usize))
            }
        }
    }
}
pub mod etb {
    #[doc = "Embedded Trace Buffer"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Etb {
        ptr: *mut u8,
    }
    unsafe impl Send for Etb {}
    unsafe impl Sync for Etb {}
    impl Etb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "ETB RAM Depth Register"]
        #[inline(always)]
        pub const fn rdp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "ETB Status Register"]
        #[inline(always)]
        pub const fn sts(self) -> crate::common::Reg<regs::Sts, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "ETB RAM Read Data Register"]
        #[inline(always)]
        pub const fn rrd(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "ETB RAM Read Pointer Register"]
        #[inline(always)]
        pub const fn rrp(self) -> crate::common::Reg<regs::Rrp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "ETB RAM Write Pointer Register"]
        #[inline(always)]
        pub const fn rwp(self) -> crate::common::Reg<regs::Rwp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "ETB Trigger Counter Register"]
        #[inline(always)]
        pub const fn trg(self) -> crate::common::Reg<regs::Trg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "ETB Control Register"]
        #[inline(always)]
        pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "ETB RAM Write Data Register"]
        #[inline(always)]
        pub const fn rwd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "ETB Formatter and Flush Status Register"]
        #[inline(always)]
        pub const fn ffsr(self) -> crate::common::Reg<regs::Ffsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "ETB Formatter and Flush Control Register"]
        #[inline(always)]
        pub const fn ffcr(self) -> crate::common::Reg<regs::Ffcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Integration Test Miscellaneous Output Register 0"]
        #[inline(always)]
        pub const fn itmiscop0(self) -> crate::common::Reg<regs::Itmiscop0, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee0usize) as _) }
        }
        #[doc = "Integration Test Trigger In and Flush In Acknowledge Register"]
        #[inline(always)]
        pub const fn ittrflinack(self) -> crate::common::Reg<regs::Ittrflinack, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee4usize) as _) }
        }
        #[doc = "Integration Test Trigger In and Flush In Register"]
        #[inline(always)]
        pub const fn ittrflin(self) -> crate::common::Reg<regs::Ittrflin, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee8usize) as _) }
        }
        #[doc = "Integration Test ATB Data Register 0"]
        #[inline(always)]
        pub const fn itatbdata0(self) -> crate::common::Reg<regs::Itatbdata0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0eecusize) as _) }
        }
        #[doc = "Integration Test ATB Control Register 2"]
        #[inline(always)]
        pub const fn itatbctr2(self) -> crate::common::Reg<regs::Itatbctr2, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef0usize) as _) }
        }
        #[doc = "Integration Test ATB Control Register 1"]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef4usize) as _) }
        }
        #[doc = "Integration Test ATB Control Register 0"]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef8usize) as _) }
        }
        #[doc = "Integration Mode Control Register"]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Claim Tag Set Register"]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa0usize) as _) }
        }
        #[doc = "Claim Tag Clear Register"]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa4usize) as _) }
        }
        #[doc = "Lock Access Register"]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb0usize) as _) }
        }
        #[doc = "Lock Status Register"]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb4usize) as _) }
        }
        #[doc = "Authentication Status Register"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb8usize) as _) }
        }
        #[doc = "Device Configuration Register"]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fc8usize) as _) }
        }
        #[doc = "Device Type Identifier Register"]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fccusize) as _) }
        }
        #[doc = "Peripheral ID4 Register"]
        #[inline(always)]
        pub const fn periphid4(self) -> crate::common::Reg<regs::Periphid4, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fd0usize) as _) }
        }
        #[doc = "Peripheral ID0 Register"]
        #[inline(always)]
        pub const fn periphid0(self) -> crate::common::Reg<regs::Periphid0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe0usize) as _) }
        }
        #[doc = "Peripheral ID1 Register"]
        #[inline(always)]
        pub const fn periphid1(self) -> crate::common::Reg<regs::Periphid1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe4usize) as _) }
        }
        #[doc = "Peripheral ID2 Register"]
        #[inline(always)]
        pub const fn periphid2(self) -> crate::common::Reg<regs::Periphid2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe8usize) as _) }
        }
        #[doc = "Peripheral ID3 Register"]
        #[inline(always)]
        pub const fn periphid3(self) -> crate::common::Reg<regs::Periphid3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fecusize) as _) }
        }
        #[doc = "Component ID0 Register"]
        #[inline(always)]
        pub const fn compid0(self) -> crate::common::Reg<regs::Compid0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff0usize) as _) }
        }
        #[doc = "Component ID1 Register"]
        #[inline(always)]
        pub const fn compid1(self) -> crate::common::Reg<regs::Compid1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff4usize) as _) }
        }
        #[doc = "Component ID2 Register"]
        #[inline(always)]
        pub const fn compid2(self) -> crate::common::Reg<regs::Compid2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff8usize) as _) }
        }
        #[doc = "Component ID3 Register"]
        #[inline(always)]
        pub const fn compid3(self) -> crate::common::Reg<regs::Compid3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Authentication Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Indicates the security level for non-secure invasive debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Indicates the security level for non-secure invasive debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Indicates the security level for non-secure non-invasive debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> u8 {
                let val = (self.0 >> 2usize) & 0x03;
                val as u8
            }
            #[doc = "Indicates the security level for non-secure non-invasive debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
            }
            #[doc = "Indicates the security level for secure invasive debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x03;
                val as u8
            }
            #[doc = "Indicates the security level for secure invasive debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize);
            }
            #[doc = "Indicates the security level for secure non-invasive debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "Indicates the security level for secure non-invasive debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Authstatus {{ nsid: {=u8:?}, nsnid: {=u8:?}, sid: {=u8:?}, snid: {=u8:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Claim Tag Clear Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "The value present reflects the current setting of the Claim Tag."]
            #[must_use]
            #[inline(always)]
            pub const fn claimclr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "The value present reflects the current setting of the Claim Tag."]
            #[inline(always)]
            pub const fn set_claimclr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("claimclr", &self.claimclr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Claimclr {{ claimclr: {=u8:?} }}", self.claimclr())
            }
        }
        #[doc = "Claim Tag Set Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "This claim tag bit is implemented"]
            #[must_use]
            #[inline(always)]
            pub const fn claimset(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This claim tag bit is implemented"]
            #[inline(always)]
            pub const fn set_claimset(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("claimset", &self.claimset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Claimset {{ claimset: {=u8:?} }}", self.claimset())
            }
        }
        #[doc = "Component ID0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compid0(pub u32);
        impl Compid0 {
            #[doc = "Contains bits \\[7:0\\] of the component identification"]
            #[must_use]
            #[inline(always)]
            pub const fn prmbl_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contains bits \\[7:0\\] of the component identification"]
            #[inline(always)]
            pub const fn set_prmbl_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Compid0 {
            #[inline(always)]
            fn default() -> Compid0 {
                Compid0(0)
            }
        }
        impl core::fmt::Debug for Compid0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compid0")
                    .field("prmbl_0", &self.prmbl_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compid0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Compid0 {{ prmbl_0: {=u8:?} }}", self.prmbl_0())
            }
        }
        #[doc = "Component ID1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compid1(pub u32);
        impl Compid1 {
            #[doc = "Contains bits \\[11:8\\] of the component identification"]
            #[must_use]
            #[inline(always)]
            pub const fn prmbl_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Contains bits \\[11:8\\] of the component identification"]
            #[inline(always)]
            pub const fn set_prmbl_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Class of the component. E. g. ROM table, CoreSight component etc. Constitutes bits \\[15:12\\] of the component identification."]
            #[must_use]
            #[inline(always)]
            pub const fn class(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Class of the component. E. g. ROM table, CoreSight component etc. Constitutes bits \\[15:12\\] of the component identification."]
            #[inline(always)]
            pub const fn set_class(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Compid1 {
            #[inline(always)]
            fn default() -> Compid1 {
                Compid1(0)
            }
        }
        impl core::fmt::Debug for Compid1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compid1")
                    .field("prmbl_1", &self.prmbl_1())
                    .field("class", &self.class())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compid1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Compid1 {{ prmbl_1: {=u8:?}, class: {=u8:?} }}",
                    self.prmbl_1(),
                    self.class()
                )
            }
        }
        #[doc = "Component ID2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compid2(pub u32);
        impl Compid2 {
            #[doc = "Contains bits \\[23:16\\] of the component identification"]
            #[must_use]
            #[inline(always)]
            pub const fn prmbl_2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contains bits \\[23:16\\] of the component identification"]
            #[inline(always)]
            pub const fn set_prmbl_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Compid2 {
            #[inline(always)]
            fn default() -> Compid2 {
                Compid2(0)
            }
        }
        impl core::fmt::Debug for Compid2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compid2")
                    .field("prmbl_2", &self.prmbl_2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compid2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Compid2 {{ prmbl_2: {=u8:?} }}", self.prmbl_2())
            }
        }
        #[doc = "Component ID3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Compid3(pub u32);
        impl Compid3 {
            #[doc = "Contains bits \\[31:24\\] of the component identification"]
            #[must_use]
            #[inline(always)]
            pub const fn prmbl_3(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Contains bits \\[31:24\\] of the component identification"]
            #[inline(always)]
            pub const fn set_prmbl_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Compid3 {
            #[inline(always)]
            fn default() -> Compid3 {
                Compid3(0)
            }
        }
        impl core::fmt::Debug for Compid3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Compid3")
                    .field("prmbl_3", &self.prmbl_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Compid3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Compid3 {{ prmbl_3: {=u8:?} }}", self.prmbl_3())
            }
        }
        #[doc = "ETB Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctl(pub u32);
        impl Ctl {
            #[doc = "ETB Trace Capture Enable. This is the master enable bit forcing FtStopped HIGH when TraceCaptEn is LOW. When capture is disabled, any remaining data in the ATB formatter is stored to RAM. When all data is stored the formatter outputs FtStopped. Capture is fully disabled, or complete, when FtStopped goes HIGH. See ETB Formatter and Flush Status Register, FFSR, 0x300."]
            #[must_use]
            #[inline(always)]
            pub const fn tracecapten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "ETB Trace Capture Enable. This is the master enable bit forcing FtStopped HIGH when TraceCaptEn is LOW. When capture is disabled, any remaining data in the ATB formatter is stored to RAM. When all data is stored the formatter outputs FtStopped. Capture is fully disabled, or complete, when FtStopped goes HIGH. See ETB Formatter and Flush Status Register, FFSR, 0x300."]
            #[inline(always)]
            pub const fn set_tracecapten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ctl {
            #[inline(always)]
            fn default() -> Ctl {
                Ctl(0)
            }
        }
        impl core::fmt::Debug for Ctl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctl")
                    .field("tracecapten", &self.tracecapten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ctl {{ tracecapten: {=bool:?} }}", self.tracecapten())
            }
        }
        #[doc = "Device Configuration Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "When non-zero this value indicates the type/number of ATB multiplexing present on the input to the ATB."]
            #[must_use]
            #[inline(always)]
            pub const fn extmuxnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "When non-zero this value indicates the type/number of ATB multiplexing present on the input to the ATB."]
            #[inline(always)]
            pub const fn set_extmuxnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "This bit returns 0 on reads indicating that the ETB RAM operates synchronously to atclk."]
            #[must_use]
            #[inline(always)]
            pub const fn ramclk(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "This bit returns 0 on reads indicating that the ETB RAM operates synchronously to atclk."]
            #[inline(always)]
            pub const fn set_ramclk(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("extmuxnum", &self.extmuxnum())
                    .field("ramclk", &self.ramclk())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devid {{ extmuxnum: {=u8:?}, ramclk: {=bool:?} }}",
                    self.extmuxnum(),
                    self.ramclk()
                )
            }
        }
        #[doc = "Device Type Identifier Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "Major classification grouping for this debug/trace component"]
            #[must_use]
            #[inline(always)]
            pub const fn major_type(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Major classification grouping for this debug/trace component"]
            #[inline(always)]
            pub const fn set_major_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Sub-classification within the major category"]
            #[must_use]
            #[inline(always)]
            pub const fn sub_type(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Sub-classification within the major category"]
            #[inline(always)]
            pub const fn set_sub_type(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major_type", &self.major_type())
                    .field("sub_type", &self.sub_type())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devtype {{ major_type: {=u8:?}, sub_type: {=u8:?} }}",
                    self.major_type(),
                    self.sub_type()
                )
            }
        }
        #[doc = "ETB Formatter and Flush Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffcr(pub u32);
        impl Ffcr {
            #[doc = "Do not embed Triggers into the formatted stream. Trace disable cycles and triggers are indicated by TRACECTL, where fitted. Can only be changed when FtStopped is HIGH. This bit is clear on reset."]
            #[must_use]
            #[inline(always)]
            pub const fn enftc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Do not embed Triggers into the formatted stream. Trace disable cycles and triggers are indicated by TRACECTL, where fitted. Can only be changed when FtStopped is HIGH. This bit is clear on reset."]
            #[inline(always)]
            pub const fn set_enftc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Continuous mode in the ETB corresponds to normal mode with the embedding of triggers. Can only be changed when FtStopped is HIGH. This bit is clear on reset."]
            #[must_use]
            #[inline(always)]
            pub const fn enfcont(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Continuous mode in the ETB corresponds to normal mode with the embedding of triggers. Can only be changed when FtStopped is HIGH. This bit is clear on reset."]
            #[inline(always)]
            pub const fn set_enfcont(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Set this bit to enable use of the flushin connection. This is clear on reset."]
            #[must_use]
            #[inline(always)]
            pub const fn fonflin(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Set this bit to enable use of the flushin connection. This is clear on reset."]
            #[inline(always)]
            pub const fn set_fonflin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Generate flush using Trigger event. Set this bit to cause a flush of data in the system when a Trigger Event occurs. This bit is clear on reset. A Trigger Event is defined as when the Trigger counter reaches zero (where fitted) or, in the case of the trigger counter being zero (or not fitted), when trigin is HIGH."]
            #[must_use]
            #[inline(always)]
            pub const fn fontrig(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Generate flush using Trigger event. Set this bit to cause a flush of data in the system when a Trigger Event occurs. This bit is clear on reset. A Trigger Event is defined as when the Trigger counter reaches zero (where fitted) or, in the case of the trigger counter being zero (or not fitted), when trigin is HIGH."]
            #[inline(always)]
            pub const fn set_fontrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Setting this bit causes a flush to be generated. This is cleared when this flush has been serviced. This bit is clear on reset."]
            #[must_use]
            #[inline(always)]
            pub const fn fonman(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Setting this bit causes a flush to be generated. This is cleared when this flush has been serviced. This bit is clear on reset."]
            #[inline(always)]
            pub const fn set_fonman(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicate a trigger on trigin being asserted."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicate a trigger on trigin being asserted."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicate a trigger on a Trigger Event."]
            #[must_use]
            #[inline(always)]
            pub const fn trigevt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicate a trigger on a Trigger Event."]
            #[inline(always)]
            pub const fn set_trigevt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates a trigger on Flush completion (afreadys being returned)."]
            #[must_use]
            #[inline(always)]
            pub const fn trigfl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger on Flush completion (afreadys being returned)."]
            #[inline(always)]
            pub const fn set_trigfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "This forces the FIFO to drain off any part-completed packets. Setting this bit enables this function but this is clear on reset (disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn stopfl(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "This forces the FIFO to drain off any part-completed packets. Setting this bit enables this function but this is clear on reset (disabled)."]
            #[inline(always)]
            pub const fn set_stopfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Stop the formatter after a Trigger Event is observed. Reset to disabled (zero)."]
            #[must_use]
            #[inline(always)]
            pub const fn stoptrig(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Stop the formatter after a Trigger Event is observed. Reset to disabled (zero)."]
            #[inline(always)]
            pub const fn set_stoptrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Ffcr {
            #[inline(always)]
            fn default() -> Ffcr {
                Ffcr(0)
            }
        }
        impl core::fmt::Debug for Ffcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffcr")
                    .field("enftc", &self.enftc())
                    .field("enfcont", &self.enfcont())
                    .field("fonflin", &self.fonflin())
                    .field("fontrig", &self.fontrig())
                    .field("fonman", &self.fonman())
                    .field("trigin", &self.trigin())
                    .field("trigevt", &self.trigevt())
                    .field("trigfl", &self.trigfl())
                    .field("stopfl", &self.stopfl())
                    .field("stoptrig", &self.stoptrig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ffcr {{ enftc: {=bool:?}, enfcont: {=bool:?}, fonflin: {=bool:?}, fontrig: {=bool:?}, fonman: {=bool:?}, trigin: {=bool:?}, trigevt: {=bool:?}, trigfl: {=bool:?}, stopfl: {=bool:?}, stoptrig: {=bool:?} }}" , self . enftc () , self . enfcont () , self . fonflin () , self . fontrig () , self . fonman () , self . trigin () , self . trigevt () , self . trigfl () , self . stopfl () , self . stoptrig ())
            }
        }
        #[doc = "ETB Formatter and Flush Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffsr(pub u32);
        impl Ffsr {
            #[doc = "Flush In Progress. This is an indication of the current state of afvalids."]
            #[must_use]
            #[inline(always)]
            pub const fn flinprog(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flush In Progress. This is an indication of the current state of afvalids."]
            #[inline(always)]
            pub const fn set_flinprog(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Formatter stopped. The formatter has received a stop request signal and all trace data and post-amble has been output. Any more trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[must_use]
            #[inline(always)]
            pub const fn ftstopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Formatter stopped. The formatter has received a stop request signal and all trace data and post-amble has been output. Any more trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[inline(always)]
            pub const fn set_ftstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ffsr {
            #[inline(always)]
            fn default() -> Ffsr {
                Ffsr(0)
            }
        }
        impl core::fmt::Debug for Ffsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffsr")
                    .field("flinprog", &self.flinprog())
                    .field("ftstopped", &self.ftstopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ffsr {{ flinprog: {=bool:?}, ftstopped: {=bool:?} }}",
                    self.flinprog(),
                    self.ftstopped()
                )
            }
        }
        #[doc = "Integration Test ATB Control Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "Read the value of atvalids."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atvalids."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Read the value of afreadys."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of afreadys."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Read the value of atbytess."]
            #[must_use]
            #[inline(always)]
            pub const fn atbytes(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x03;
                val as u8
            }
            #[doc = "Read the value of atbytess."]
            #[inline(always)]
            pub const fn set_atbytes(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .field("atbytes", &self.atbytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr0 {{ atvalid: {=bool:?}, afready: {=bool:?}, atbytes: {=u8:?} }}",
                    self.atvalid(),
                    self.afready(),
                    self.atbytes()
                )
            }
        }
        #[doc = "Integration Test ATB Control Register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "Read the value of atids."]
            #[must_use]
            #[inline(always)]
            pub const fn atid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Read the value of atids."]
            #[inline(always)]
            pub const fn set_atid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atid", &self.atid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itatbctr1 {{ atid: {=u8:?} }}", self.atid())
            }
        }
        #[doc = "Integration Test ATB Control Register 2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr2(pub u32);
        impl Itatbctr2 {
            #[doc = "Set the value of atreadys."]
            #[must_use]
            #[inline(always)]
            pub const fn atreadys(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of atreadys."]
            #[inline(always)]
            pub const fn set_atreadys(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Set the value of afvalids."]
            #[must_use]
            #[inline(always)]
            pub const fn afvalids(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of afvalids."]
            #[inline(always)]
            pub const fn set_afvalids(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itatbctr2 {
            #[inline(always)]
            fn default() -> Itatbctr2 {
                Itatbctr2(0)
            }
        }
        impl core::fmt::Debug for Itatbctr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr2")
                    .field("atreadys", &self.atreadys())
                    .field("afvalids", &self.afvalids())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr2 {{ atreadys: {=bool:?}, afvalids: {=bool:?} }}",
                    self.atreadys(),
                    self.afvalids()
                )
            }
        }
        #[doc = "Integration Test ATB Data Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbdata0(pub u32);
        impl Itatbdata0 {
            #[doc = "Read the value of atdatas\\[0\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atdatas\\[0\\]."]
            #[inline(always)]
            pub const fn set_atdata_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Read the value of atdatas\\[7\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_7(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atdatas\\[7\\]."]
            #[inline(always)]
            pub const fn set_atdata_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Read the value of atdatas\\[15\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_15(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atdatas\\[15\\]."]
            #[inline(always)]
            pub const fn set_atdata_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Read the value of atdatas\\[23\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_23(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atdatas\\[23\\]."]
            #[inline(always)]
            pub const fn set_atdata_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Read the value of atdatas\\[31\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_31(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of atdatas\\[31\\]."]
            #[inline(always)]
            pub const fn set_atdata_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Itatbdata0 {
            #[inline(always)]
            fn default() -> Itatbdata0 {
                Itatbdata0(0)
            }
        }
        impl core::fmt::Debug for Itatbdata0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbdata0")
                    .field("atdata_0", &self.atdata_0())
                    .field("atdata_7", &self.atdata_7())
                    .field("atdata_15", &self.atdata_15())
                    .field("atdata_23", &self.atdata_23())
                    .field("atdata_31", &self.atdata_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbdata0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Itatbdata0 {{ atdata_0: {=bool:?}, atdata_7: {=bool:?}, atdata_15: {=bool:?}, atdata_23: {=bool:?}, atdata_31: {=bool:?} }}" , self . atdata_0 () , self . atdata_7 () , self . atdata_15 () , self . atdata_23 () , self . atdata_31 ())
            }
        }
        #[doc = "Integration Mode Control Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Allows the component to switch from functional mode to integration mode or back."]
            #[must_use]
            #[inline(always)]
            pub const fn integration_mode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Allows the component to switch from functional mode to integration mode or back."]
            #[inline(always)]
            pub const fn set_integration_mode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl")
                    .field("integration_mode", &self.integration_mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itctrl {{ integration_mode: {=bool:?} }}",
                    self.integration_mode()
                )
            }
        }
        #[doc = "Integration Test Miscellaneous Output Register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itmiscop0(pub u32);
        impl Itmiscop0 {
            #[doc = "Set the value of acqcomp."]
            #[must_use]
            #[inline(always)]
            pub const fn acqcomp(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of acqcomp."]
            #[inline(always)]
            pub const fn set_acqcomp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Set the value of full output port."]
            #[must_use]
            #[inline(always)]
            pub const fn full(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of full output port."]
            #[inline(always)]
            pub const fn set_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itmiscop0 {
            #[inline(always)]
            fn default() -> Itmiscop0 {
                Itmiscop0(0)
            }
        }
        impl core::fmt::Debug for Itmiscop0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itmiscop0")
                    .field("acqcomp", &self.acqcomp())
                    .field("full", &self.full())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itmiscop0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itmiscop0 {{ acqcomp: {=bool:?}, full: {=bool:?} }}",
                    self.acqcomp(),
                    self.full()
                )
            }
        }
        #[doc = "Integration Test Trigger In and Flush In Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflin(pub u32);
        impl Ittrflin {
            #[doc = "Read the value of trigin."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of trigin."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Read the value of flushin."]
            #[must_use]
            #[inline(always)]
            pub const fn flushin(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Read the value of flushin."]
            #[inline(always)]
            pub const fn set_flushin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflin {
            #[inline(always)]
            fn default() -> Ittrflin {
                Ittrflin(0)
            }
        }
        impl core::fmt::Debug for Ittrflin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflin")
                    .field("trigin", &self.trigin())
                    .field("flushin", &self.flushin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflin {{ trigin: {=bool:?}, flushin: {=bool:?} }}",
                    self.trigin(),
                    self.flushin()
                )
            }
        }
        #[doc = "Integration Test Trigger In and Flush In Acknowledge Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflinack(pub u32);
        impl Ittrflinack {
            #[doc = "Set the value of triginack."]
            #[must_use]
            #[inline(always)]
            pub const fn triginack(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of triginack."]
            #[inline(always)]
            pub const fn set_triginack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Set the value of flushinack."]
            #[must_use]
            #[inline(always)]
            pub const fn flushinack(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Set the value of flushinack."]
            #[inline(always)]
            pub const fn set_flushinack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflinack {
            #[inline(always)]
            fn default() -> Ittrflinack {
                Ittrflinack(0)
            }
        }
        impl core::fmt::Debug for Ittrflinack {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflinack")
                    .field("triginack", &self.triginack())
                    .field("flushinack", &self.flushinack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflinack {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflinack {{ triginack: {=bool:?}, flushinack: {=bool:?} }}",
                    self.triginack(),
                    self.flushinack()
                )
            }
        }
        #[doc = "Lock Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device. This bit reads as 0 when read from an external debugger (paddrdbg31 = 1) since external debugger accesses are not subject to Lock Registers."]
            #[must_use]
            #[inline(always)]
            pub const fn lockexist(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device. This bit reads as 0 when read from an external debugger (paddrdbg31 = 1) since external debugger accesses are not subject to Lock Registers."]
            #[inline(always)]
            pub const fn set_lockexist(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock. This bit reads as 0 when read from an external debugger (paddrdbg31 = 1) since external debugger accesses are not subject to Lock Registers."]
            #[must_use]
            #[inline(always)]
            pub const fn lockgrant(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock. This bit reads as 0 when read from an external debugger (paddrdbg31 = 1) since external debugger accesses are not subject to Lock Registers."]
            #[inline(always)]
            pub const fn set_lockgrant(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register (0xFB0) is implemented as 8-bit or 32-bit"]
            #[must_use]
            #[inline(always)]
            pub const fn locktype(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if the Lock Access Register (0xFB0) is implemented as 8-bit or 32-bit"]
            #[inline(always)]
            pub const fn set_locktype(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("lockexist", &self.lockexist())
                    .field("lockgrant", &self.lockgrant())
                    .field("locktype", &self.locktype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ lockexist: {=bool:?}, lockgrant: {=bool:?}, locktype: {=bool:?} }}",
                    self.lockexist(),
                    self.lockgrant(),
                    self.locktype()
                )
            }
        }
        #[doc = "Peripheral ID0 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Periphid0(pub u32);
        impl Periphid0 {
            #[doc = "Bits \\[7:0\\] of the component's part number. This is selected by the designer of the component."]
            #[must_use]
            #[inline(always)]
            pub const fn part_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Bits \\[7:0\\] of the component's part number. This is selected by the designer of the component."]
            #[inline(always)]
            pub const fn set_part_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Periphid0 {
            #[inline(always)]
            fn default() -> Periphid0 {
                Periphid0(0)
            }
        }
        impl core::fmt::Debug for Periphid0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Periphid0")
                    .field("part_0", &self.part_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Periphid0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Periphid0 {{ part_0: {=u8:?} }}", self.part_0())
            }
        }
        #[doc = "Peripheral ID1 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Periphid1(pub u32);
        impl Periphid1 {
            #[doc = "Bits \\[11:8\\] of the component's part number. This is selected by the designer of the component."]
            #[must_use]
            #[inline(always)]
            pub const fn part_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Bits \\[11:8\\] of the component's part number. This is selected by the designer of the component."]
            #[inline(always)]
            pub const fn set_part_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Bits 3:0 of the JEDEC identity code indicating the designer of the component (along with the continuation code)"]
            #[must_use]
            #[inline(always)]
            pub const fn des_0(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Bits 3:0 of the JEDEC identity code indicating the designer of the component (along with the continuation code)"]
            #[inline(always)]
            pub const fn set_des_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Periphid1 {
            #[inline(always)]
            fn default() -> Periphid1 {
                Periphid1(0)
            }
        }
        impl core::fmt::Debug for Periphid1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Periphid1")
                    .field("part_1", &self.part_1())
                    .field("des_0", &self.des_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Periphid1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Periphid1 {{ part_1: {=u8:?}, des_0: {=u8:?} }}",
                    self.part_1(),
                    self.des_0()
                )
            }
        }
        #[doc = "Peripheral ID2 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Periphid2(pub u32);
        impl Periphid2 {
            #[doc = "Bits 6:4 of the JEDEC identity code indicating the designer of the component (along with the continuation code)"]
            #[must_use]
            #[inline(always)]
            pub const fn des_1(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Bits 6:4 of the JEDEC identity code indicating the designer of the component (along with the continuation code)"]
            #[inline(always)]
            pub const fn set_des_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Always set. Indicates that a JEDEC assigned value is used"]
            #[must_use]
            #[inline(always)]
            pub const fn jedec(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Always set. Indicates that a JEDEC assigned value is used"]
            #[inline(always)]
            pub const fn set_jedec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The Revision field is an incremental value starting at 0x0 for the first design of this component. This only increases by 1 for both major and minor revisions and is simply used as a look-up to establish the exact major/minor revision."]
            #[must_use]
            #[inline(always)]
            pub const fn revision(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "The Revision field is an incremental value starting at 0x0 for the first design of this component. This only increases by 1 for both major and minor revisions and is simply used as a look-up to establish the exact major/minor revision."]
            #[inline(always)]
            pub const fn set_revision(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Periphid2 {
            #[inline(always)]
            fn default() -> Periphid2 {
                Periphid2(0)
            }
        }
        impl core::fmt::Debug for Periphid2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Periphid2")
                    .field("des_1", &self.des_1())
                    .field("jedec", &self.jedec())
                    .field("revision", &self.revision())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Periphid2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Periphid2 {{ des_1: {=u8:?}, jedec: {=bool:?}, revision: {=u8:?} }}",
                    self.des_1(),
                    self.jedec(),
                    self.revision()
                )
            }
        }
        #[doc = "Peripheral ID3 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Periphid3(pub u32);
        impl Periphid3 {
            #[doc = "Where the component is reusable IP, this value indicates if the customer has modified the behavior of the component. In most cases this field is zero."]
            #[must_use]
            #[inline(always)]
            pub const fn cmod(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Where the component is reusable IP, this value indicates if the customer has modified the behavior of the component. In most cases this field is zero."]
            #[inline(always)]
            pub const fn set_cmod(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This field indicates minor errata fixes specific to this design, for example metal fixes after implementation. In most cases this field is zero. It is recommended that component designers ensure this field can be changed by a metal fix if required, for example by driving it from registers that reset to zero."]
            #[must_use]
            #[inline(always)]
            pub const fn revand(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "This field indicates minor errata fixes specific to this design, for example metal fixes after implementation. In most cases this field is zero. It is recommended that component designers ensure this field can be changed by a metal fix if required, for example by driving it from registers that reset to zero."]
            #[inline(always)]
            pub const fn set_revand(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Periphid3 {
            #[inline(always)]
            fn default() -> Periphid3 {
                Periphid3(0)
            }
        }
        impl core::fmt::Debug for Periphid3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Periphid3")
                    .field("cmod", &self.cmod())
                    .field("revand", &self.revand())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Periphid3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Periphid3 {{ cmod: {=u8:?}, revand: {=u8:?} }}",
                    self.cmod(),
                    self.revand()
                )
            }
        }
        #[doc = "Peripheral ID4 Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Periphid4(pub u32);
        impl Periphid4 {
            #[doc = "JEDEC continuation code indicating the designer of the component (along with the identity code)"]
            #[must_use]
            #[inline(always)]
            pub const fn des_2(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "JEDEC continuation code indicating the designer of the component (along with the identity code)"]
            #[inline(always)]
            pub const fn set_des_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "This is a 4-bit value that indicates the total contiguous size of the memory window used by this component in powers of 2 from the standard 4KB. If a component only requires the standard 4KB then this should read as 0x0, 4KB only, for 8KB set to 0x1, 16KB == 0x2, 32KB == 0x3, and so on."]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "This is a 4-bit value that indicates the total contiguous size of the memory window used by this component in powers of 2 from the standard 4KB. If a component only requires the standard 4KB then this should read as 0x0, 4KB only, for 8KB set to 0x1, 16KB == 0x2, 32KB == 0x3, and so on."]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Periphid4 {
            #[inline(always)]
            fn default() -> Periphid4 {
                Periphid4(0)
            }
        }
        impl core::fmt::Debug for Periphid4 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Periphid4")
                    .field("des_2", &self.des_2())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Periphid4 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Periphid4 {{ des_2: {=u8:?}, size: {=u8:?} }}",
                    self.des_2(),
                    self.size()
                )
            }
        }
        #[doc = "ETB RAM Read Pointer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rrp(pub u32);
        impl Rrp {
            #[doc = "Sets the read pointer used to read entries from the Trace RAM over the APB interface."]
            #[must_use]
            #[inline(always)]
            pub const fn ram_read_pointer(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Sets the read pointer used to read entries from the Trace RAM over the APB interface."]
            #[inline(always)]
            pub const fn set_ram_read_pointer(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Rrp {
            #[inline(always)]
            fn default() -> Rrp {
                Rrp(0)
            }
        }
        impl core::fmt::Debug for Rrp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rrp")
                    .field("ram_read_pointer", &self.ram_read_pointer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rrp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rrp {{ ram_read_pointer: {=u16:?} }}",
                    self.ram_read_pointer()
                )
            }
        }
        #[doc = "ETB RAM Write Pointer Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rwp(pub u32);
        impl Rwp {
            #[doc = "Sets the write pointer used to write entries from the CoreSight bus into the Trace RAM."]
            #[must_use]
            #[inline(always)]
            pub const fn ram_write_pointer(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Sets the write pointer used to write entries from the CoreSight bus into the Trace RAM."]
            #[inline(always)]
            pub const fn set_ram_write_pointer(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Rwp {
            #[inline(always)]
            fn default() -> Rwp {
                Rwp(0)
            }
        }
        impl core::fmt::Debug for Rwp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rwp")
                    .field("ram_write_pointer", &self.ram_write_pointer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rwp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rwp {{ ram_write_pointer: {=u16:?} }}",
                    self.ram_write_pointer()
                )
            }
        }
        #[doc = "ETB Status Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sts(pub u32);
        impl Sts {
            #[doc = "RAM Full. The flag indicates when the RAM write pointer has wrapped around."]
            #[must_use]
            #[inline(always)]
            pub const fn full(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RAM Full. The flag indicates when the RAM write pointer has wrapped around."]
            #[inline(always)]
            pub const fn set_full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The Triggered bit is set when a trigger has been observed. This does not indicate that a trigger has been embedded in the trace data by the formatter, but is determined by the programming of the Formatter and Flush Control Register."]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The Triggered bit is set when a trigger has been observed. This does not indicate that a trigger has been embedded in the trace data by the formatter, but is determined by the programming of the Formatter and Flush Control Register."]
            #[inline(always)]
            pub const fn set_triggered(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The acquisition complete flag indicates that capture has been completed when the formatter stops because of any of the methods defined in the Formatter and Flush Control Register, or TraceCaptEn = 0. This also results in FtStopped in the Formatter and Flush Status Register going HIGH."]
            #[must_use]
            #[inline(always)]
            pub const fn acqcomp(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The acquisition complete flag indicates that capture has been completed when the formatter stops because of any of the methods defined in the Formatter and Flush Control Register, or TraceCaptEn = 0. This also results in FtStopped in the Formatter and Flush Status Register going HIGH."]
            #[inline(always)]
            pub const fn set_acqcomp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Formatter pipeline empty. All data stored to RAM."]
            #[must_use]
            #[inline(always)]
            pub const fn ftempty(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Formatter pipeline empty. All data stored to RAM."]
            #[inline(always)]
            pub const fn set_ftempty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Sts {
            #[inline(always)]
            fn default() -> Sts {
                Sts(0)
            }
        }
        impl core::fmt::Debug for Sts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sts")
                    .field("full", &self.full())
                    .field("triggered", &self.triggered())
                    .field("acqcomp", &self.acqcomp())
                    .field("ftempty", &self.ftempty())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sts {{ full: {=bool:?}, triggered: {=bool:?}, acqcomp: {=bool:?}, ftempty: {=bool:?} }}" , self . full () , self . triggered () , self . acqcomp () , self . ftempty ())
            }
        }
        #[doc = "ETB Trigger Counter Register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trg(pub u32);
        impl Trg {
            #[doc = "The counter is used as follows:Trace after - The counter is set to a large value, slightly less than the number of entries in the RAM. Trace before - The counter is set to a small value. Trace about - The counter is set to half the depth of the Trace RAM. This register must not be written to when trace capture is enabled (FtStopped=0, TraceCaptEn=1). If a write is attempted, the register is not updated. A read access is permitted with trace capture enabled."]
            #[must_use]
            #[inline(always)]
            pub const fn trigger_counter(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "The counter is used as follows:Trace after - The counter is set to a large value, slightly less than the number of entries in the RAM. Trace before - The counter is set to a small value. Trace about - The counter is set to half the depth of the Trace RAM. This register must not be written to when trace capture is enabled (FtStopped=0, TraceCaptEn=1). If a write is attempted, the register is not updated. A read access is permitted with trace capture enabled."]
            #[inline(always)]
            pub const fn set_trigger_counter(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Trg {
            #[inline(always)]
            fn default() -> Trg {
                Trg(0)
            }
        }
        impl core::fmt::Debug for Trg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trg")
                    .field("trigger_counter", &self.trigger_counter())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trg {{ trigger_counter: {=u16:?} }}",
                    self.trigger_counter()
                )
            }
        }
    }
}
pub mod etm {
    #[doc = "Embedded Trace Macrocell"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Etm {
        ptr: *mut u8,
    }
    unsafe impl Send for Etm {}
    unsafe impl Sync for Etm {}
    impl Etm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enables the trace unit."]
        #[inline(always)]
        pub const fn trcprgctlr(self) -> crate::common::Reg<regs::Trcprgctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[inline(always)]
        pub const fn trcprocselr(self) -> crate::common::Reg<regs::Trcprocselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Idle status bit"]
        #[inline(always)]
        pub const fn trcstatr(self) -> crate::common::Reg<regs::Trcstatr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trcconfigr(self) -> crate::common::Reg<regs::Trcconfigr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[inline(always)]
        pub const fn trceventctl0r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl0r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trceventctl1r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl1r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[inline(always)]
        pub const fn trcstallctlr(
            self,
        ) -> crate::common::Reg<regs::Trcstallctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[inline(always)]
        pub const fn trctsctlr(self) -> crate::common::Reg<regs::Trctsctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[inline(always)]
        pub const fn trcsyncpr(self) -> crate::common::Reg<regs::Trcsyncpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[inline(always)]
        pub const fn trcccctlr(self) -> crate::common::Reg<regs::Trcccctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x38usize) as _) }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[inline(always)]
        pub const fn trcbbctlr(self) -> crate::common::Reg<regs::Trcbbctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trctraceidr(self) -> crate::common::Reg<regs::Trctraceidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize) as _) }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[inline(always)]
        pub const fn trcqctlr(self) -> crate::common::Reg<regs::Trcqctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x44usize) as _) }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[inline(always)]
        pub const fn trcvictlr(self) -> crate::common::Reg<regs::Trcvictlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcviiectlr(self) -> crate::common::Reg<regs::Trcviiectlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvissctlr(self) -> crate::common::Reg<regs::Trcvissctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvipcssctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvipcssctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[inline(always)]
        pub const fn trcvdctlr(self) -> crate::common::Reg<regs::Trcvdctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdsacctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdsacctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdarcctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdarcctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqevr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcseqevr, crate::common::RW> {
            assert!(n < 3usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqrstevr(
            self,
        ) -> crate::common::Reg<regs::Trcseqrstevr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqstr(self) -> crate::common::Reg<regs::Trcseqstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcextinselr(
            self,
        ) -> crate::common::Reg<regs::Trcextinselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0120usize) as _) }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntrldvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntrldvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntctlr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0150usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0160usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[inline(always)]
        pub const fn trcrsctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcrsctlr, crate::common::RW> {
            assert!(n < 30usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize + n * 4usize) as _)
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcssccr0(self) -> crate::common::Reg<regs::Trcssccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0280usize) as _) }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[inline(always)]
        pub const fn trcsscsr0(self) -> crate::common::Reg<regs::Trcsscsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02a0usize) as _) }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[inline(always)]
        pub const fn trcsspcicr0(self) -> crate::common::Reg<regs::Trcsspcicr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x02c0usize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcpdcr(self) -> crate::common::Reg<regs::Trcpdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0310usize) as _) }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[inline(always)]
        pub const fn trcpdsr(self) -> crate::common::Reg<regs::Trcpdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0314usize) as _) }
        }
        #[doc = "Sets the state of output pins."]
        #[inline(always)]
        pub const fn trcitatbidr(self) -> crate::common::Reg<regs::Trcitatbidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee4usize) as _) }
        }
        #[doc = "Reads the state of the input pins."]
        #[inline(always)]
        pub const fn trcitiatbinr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatbinr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef4usize) as _) }
        }
        #[doc = "Sets the state of the output pins."]
        #[inline(always)]
        pub const fn trcitiatboutr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatboutr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0efcusize) as _) }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[inline(always)]
        pub const fn trcitctrl(self) -> crate::common::Reg<regs::Trcitctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[inline(always)]
        pub const fn trcclaimset(self) -> crate::common::Reg<regs::Trcclaimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa0usize) as _) }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn trcclaimclr(self) -> crate::common::Reg<regs::Trcclaimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn trcauthstatus(
            self,
        ) -> crate::common::Reg<regs::Trcauthstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb8usize) as _) }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[inline(always)]
        pub const fn trcdevarch(self) -> crate::common::Reg<regs::Trcdevarch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fbcusize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcdevtype(self) -> crate::common::Reg<regs::Trcdevtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fccusize) as _) }
        }
        #[doc = "Description collection: Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn trcpidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fd0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Coresight component identification registers."]
        #[inline(always)]
        pub const fn trccidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff0usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcauthstatus(pub u32);
        impl Trcauthstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Trcauthstatus {
            #[inline(always)]
            fn default() -> Trcauthstatus {
                Trcauthstatus(0)
            }
        }
        impl core::fmt::Debug for Trcauthstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcauthstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcauthstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcauthstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcbbctlr(pub u32);
        impl Trcbbctlr {
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[must_use]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[inline(always)]
            pub const fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[must_use]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[inline(always)]
            pub const fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[must_use]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[inline(always)]
            pub const fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[must_use]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[inline(always)]
            pub const fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[must_use]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[inline(always)]
            pub const fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[must_use]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[inline(always)]
            pub const fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[must_use]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[inline(always)]
            pub const fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[must_use]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[inline(always)]
            pub const fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Trcbbctlr {
            #[inline(always)]
            fn default() -> Trcbbctlr {
                Trcbbctlr(0)
            }
        }
        impl core::fmt::Debug for Trcbbctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcbbctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcbbctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcbbctlr {{ range_0: {=bool:?}, range_1: {=bool:?}, range_2: {=bool:?}, range_3: {=bool:?}, range_4: {=bool:?}, range_5: {=bool:?}, range_6: {=bool:?}, range_7: {=bool:?} }}" , self . range_0 () , self . range_1 () , self . range_2 () , self . range_3 () , self . range_4 () , self . range_5 () , self . range_6 () , self . range_7 ())
            }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcccctlr(pub u32);
        impl Trcccctlr {
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[must_use]
            #[inline(always)]
            pub const fn threshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[inline(always)]
            pub const fn set_threshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Trcccctlr {
            #[inline(always)]
            fn default() -> Trcccctlr {
                Trcccctlr(0)
            }
        }
        impl core::fmt::Debug for Trcccctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcccctlr")
                    .field("threshold", &self.threshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcccctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcccctlr {{ threshold: {=u16:?} }}", self.threshold())
            }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimclr(pub u32);
        impl Trcclaimclr {
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_0(&self) -> super::vals::Clr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clr0::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_0(&mut self, val: super::vals::Clr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_1(&self) -> super::vals::Clr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Clr1::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_1(&mut self, val: super::vals::Clr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_2(&self) -> super::vals::Clr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clr2::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_2(&mut self, val: super::vals::Clr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_3(&self) -> super::vals::Clr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Clr3::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_3(&mut self, val: super::vals::Clr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimclr {
            #[inline(always)]
            fn default() -> Trcclaimclr {
                Trcclaimclr(0)
            }
        }
        impl core::fmt::Debug for Trcclaimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimclr")
                    .field("clr_0", &self.clr_0())
                    .field("clr_1", &self.clr_1())
                    .field("clr_2", &self.clr_2())
                    .field("clr_3", &self.clr_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcclaimclr {{ clr_0: {:?}, clr_1: {:?}, clr_2: {:?}, clr_3: {:?} }}",
                    self.clr_0(),
                    self.clr_1(),
                    self.clr_2(),
                    self.clr_3()
                )
            }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimset(pub u32);
        impl Trcclaimset {
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_0(&self) -> super::vals::Set0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Set0::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_0(&mut self, val: super::vals::Set0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_1(&self) -> super::vals::Set1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Set1::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_1(&mut self, val: super::vals::Set1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_2(&self) -> super::vals::Set2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Set2::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_2(&mut self, val: super::vals::Set2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_3(&self) -> super::vals::Set3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Set3::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_3(&mut self, val: super::vals::Set3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimset {
            #[inline(always)]
            fn default() -> Trcclaimset {
                Trcclaimset(0)
            }
        }
        impl core::fmt::Debug for Trcclaimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimset")
                    .field("set_0", &self.set_0())
                    .field("set_1", &self.set_1())
                    .field("set_2", &self.set_2())
                    .field("set_3", &self.set_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcclaimset {{ set_0: {:?}, set_1: {:?}, set_2: {:?}, set_3: {:?} }}",
                    self.set_0(),
                    self.set_1(),
                    self.set_2(),
                    self.set_3()
                )
            }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntctlr(pub u32);
        impl Trccntctlr {
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[must_use]
            #[inline(always)]
            pub const fn cntevent(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[inline(always)]
            pub const fn set_cntevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn rldevent(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[inline(always)]
            pub const fn set_rldevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[must_use]
            #[inline(always)]
            pub const fn rldself(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[inline(always)]
            pub const fn set_rldself(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[must_use]
            #[inline(always)]
            pub const fn cntchain(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[inline(always)]
            pub const fn set_cntchain(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trccntctlr {
            #[inline(always)]
            fn default() -> Trccntctlr {
                Trccntctlr(0)
            }
        }
        impl core::fmt::Debug for Trccntctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntctlr")
                    .field("cntevent", &self.cntevent())
                    .field("rldevent", &self.rldevent())
                    .field("rldself", &self.rldself())
                    .field("cntchain", &self.cntchain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trccntctlr {{ cntevent: {=u8:?}, rldevent: {=u8:?}, rldself: {=bool:?}, cntchain: {=bool:?} }}" , self . cntevent () , self . rldevent () , self . rldself () , self . cntchain ())
            }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntrldvr(pub u32);
        impl Trccntrldvr {
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntrldvr {
            #[inline(always)]
            fn default() -> Trccntrldvr {
                Trccntrldvr(0)
            }
        }
        impl core::fmt::Debug for Trccntrldvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntrldvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntrldvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trccntrldvr {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntvr(pub u32);
        impl Trccntvr {
            #[doc = "Contains the count value of counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the count value of counter n."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntvr {
            #[inline(always)]
            fn default() -> Trccntvr {
                Trccntvr(0)
            }
        }
        impl core::fmt::Debug for Trccntvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trccntvr {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcconfigr(pub u32);
        impl Trcconfigr {
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[must_use]
            #[inline(always)]
            pub const fn loadasp0inst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn set_loadasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[must_use]
            #[inline(always)]
            pub const fn storeasp0inst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn set_storeasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Branch broadcast mode bit."]
            #[must_use]
            #[inline(always)]
            pub const fn bb(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Branch broadcast mode bit."]
            #[inline(always)]
            pub const fn set_bb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cci(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[inline(always)]
            pub const fn set_cci(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Context ID tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cid(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Context ID tracing bit."]
            #[inline(always)]
            pub const fn set_cid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn vmid(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[inline(always)]
            pub const fn set_vmid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Conditional instruction tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cond(&self) -> super::vals::Cond {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cond::from_bits(val as u8)
            }
            #[doc = "Conditional instruction tracing bit."]
            #[inline(always)]
            pub const fn set_cond(&mut self, val: super::vals::Cond) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Global timestamp tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn ts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Global timestamp tracing bit."]
            #[inline(always)]
            pub const fn set_ts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Return stack enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn rs(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Return stack enable bit."]
            #[inline(always)]
            pub const fn set_rs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Q element enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn qe(&self) -> super::vals::Qe {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Qe::from_bits(val as u8)
            }
            #[doc = "Q element enable field."]
            #[inline(always)]
            pub const fn set_qe(&mut self, val: super::vals::Qe) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u32) & 0x03) << 13usize);
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[must_use]
            #[inline(always)]
            pub const fn vmidopt(&self) -> super::vals::Vmidopt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vmidopt::from_bits(val as u8)
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[inline(always)]
            pub const fn set_vmidopt(&mut self, val: super::vals::Vmidopt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Data address tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data address tracing bit."]
            #[inline(always)]
            pub const fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Data value tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Data value tracing bit."]
            #[inline(always)]
            pub const fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trcconfigr {
            #[inline(always)]
            fn default() -> Trcconfigr {
                Trcconfigr(0)
            }
        }
        impl core::fmt::Debug for Trcconfigr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcconfigr")
                    .field("loadasp0inst", &self.loadasp0inst())
                    .field("storeasp0inst", &self.storeasp0inst())
                    .field("bb", &self.bb())
                    .field("cci", &self.cci())
                    .field("cid", &self.cid())
                    .field("vmid", &self.vmid())
                    .field("cond", &self.cond())
                    .field("ts", &self.ts())
                    .field("rs", &self.rs())
                    .field("qe", &self.qe())
                    .field("vmidopt", &self.vmidopt())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcconfigr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcconfigr {{ loadasp0inst: {=bool:?}, storeasp0inst: {=bool:?}, bb: {=bool:?}, cci: {=bool:?}, cid: {=bool:?}, vmid: {=bool:?}, cond: {:?}, ts: {=bool:?}, rs: {=bool:?}, qe: {:?}, vmidopt: {:?}, da: {=bool:?}, dv: {=bool:?} }}" , self . loadasp0inst () , self . storeasp0inst () , self . bb () , self . cci () , self . cid () , self . vmid () , self . cond () , self . ts () , self . rs () , self . qe () , self . vmidopt () , self . da () , self . dv ())
            }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevarch(pub u32);
        impl Trcdevarch {
            #[doc = "Architecture ID"]
            #[must_use]
            #[inline(always)]
            pub const fn archid(&self) -> super::vals::Archid {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Archid::from_bits(val as u16)
            }
            #[doc = "Architecture ID"]
            #[inline(always)]
            pub const fn set_archid(&mut self, val: super::vals::Archid) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
            #[doc = "Architecture revision"]
            #[must_use]
            #[inline(always)]
            pub const fn revision(&self) -> super::vals::Revision {
                let val = (self.0 >> 16usize) & 0x0f;
                super::vals::Revision::from_bits(val as u8)
            }
            #[doc = "Architecture revision"]
            #[inline(always)]
            pub const fn set_revision(&mut self, val: super::vals::Revision) {
                self.0 =
                    (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
            }
            #[doc = "This register is implemented"]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "This register is implemented"]
            #[inline(always)]
            pub const fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Defines the architect of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn architect(&self) -> super::vals::Architect {
                let val = (self.0 >> 21usize) & 0x07ff;
                super::vals::Architect::from_bits(val as u16)
            }
            #[doc = "Defines the architect of the component"]
            #[inline(always)]
            pub const fn set_architect(&mut self, val: super::vals::Architect) {
                self.0 = (self.0 & !(0x07ff << 21usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 21usize);
            }
        }
        impl Default for Trcdevarch {
            #[inline(always)]
            fn default() -> Trcdevarch {
                Trcdevarch(0)
            }
        }
        impl core::fmt::Debug for Trcdevarch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevarch")
                    .field("archid", &self.archid())
                    .field("revision", &self.revision())
                    .field("present", &self.present())
                    .field("architect", &self.architect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevarch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcdevarch {{ archid: {:?}, revision: {:?}, present: {:?}, architect: {:?} }}",
                    self.archid(),
                    self.revision(),
                    self.present(),
                    self.architect()
                )
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevtype(pub u32);
        impl Trcdevtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Trcdevtype {
            #[inline(always)]
            fn default() -> Trcdevtype {
                Trcdevtype(0)
            }
        }
        impl core::fmt::Debug for Trcdevtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcdevtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl0r(pub u32);
        impl Trceventctl0r {
            #[doc = "Select which event should generate trace elements."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate trace elements."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trceventctl0r {
            #[inline(always)]
            fn default() -> Trceventctl0r {
                Trceventctl0r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl0r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl0r")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl0r {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trceventctl0r {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl1r(pub u32);
        impl Trceventctl1r {
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Data event enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn dataen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Data event enable bit."]
            #[inline(always)]
            pub const fn set_dataen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn atb(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[inline(always)]
            pub const fn set_atb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[must_use]
            #[inline(always)]
            pub const fn lpoverride(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[inline(always)]
            pub const fn set_lpoverride(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trceventctl1r {
            #[inline(always)]
            fn default() -> Trceventctl1r {
                Trceventctl1r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl1r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl1r")
                    .field("insten_0", &self.insten_0())
                    .field("insten_1", &self.insten_1())
                    .field("insten_2", &self.insten_2())
                    .field("insten_3", &self.insten_3())
                    .field("dataen", &self.dataen())
                    .field("atb", &self.atb())
                    .field("lpoverride", &self.lpoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl1r {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trceventctl1r {{ insten_0: {=bool:?}, insten_1: {=bool:?}, insten_2: {=bool:?}, insten_3: {=bool:?}, dataen: {=bool:?}, atb: {=bool:?}, lpoverride: {=bool:?} }}" , self . insten_0 () , self . insten_1 () , self . insten_2 () , self . insten_3 () , self . dataen () , self . atb () , self . lpoverride ())
            }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcextinselr(pub u32);
        impl Trcextinselr {
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Trcextinselr {
            #[inline(always)]
            fn default() -> Trcextinselr {
                Trcextinselr(0)
            }
        }
        impl core::fmt::Debug for Trcextinselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcextinselr")
                    .field("sel_0", &self.sel_0())
                    .field("sel_1", &self.sel_1())
                    .field("sel_2", &self.sel_2())
                    .field("sel_3", &self.sel_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcextinselr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcextinselr {{ sel_0: {=u8:?}, sel_1: {=u8:?}, sel_2: {=u8:?}, sel_3: {=u8:?} }}" , self . sel_0 () , self . sel_1 () , self . sel_2 () , self . sel_3 ())
            }
        }
        #[doc = "Sets the state of output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitatbidr(pub u32);
        impl Trcitatbidr {
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[inline(always)]
            pub const fn set_id_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[inline(always)]
            pub const fn set_id_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[inline(always)]
            pub const fn set_id_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[inline(always)]
            pub const fn set_id_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[inline(always)]
            pub const fn set_id_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[inline(always)]
            pub const fn set_id_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[inline(always)]
            pub const fn set_id_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Trcitatbidr {
            #[inline(always)]
            fn default() -> Trcitatbidr {
                Trcitatbidr(0)
            }
        }
        impl core::fmt::Debug for Trcitatbidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitatbidr")
                    .field("id_0", &self.id_0())
                    .field("id_1", &self.id_1())
                    .field("id_2", &self.id_2())
                    .field("id_3", &self.id_3())
                    .field("id_4", &self.id_4())
                    .field("id_5", &self.id_5())
                    .field("id_6", &self.id_6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitatbidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcitatbidr {{ id_0: {=bool:?}, id_1: {=bool:?}, id_2: {=bool:?}, id_3: {=bool:?}, id_4: {=bool:?}, id_5: {=bool:?}, id_6: {=bool:?} }}" , self . id_0 () , self . id_1 () , self . id_2 () , self . id_3 () , self . id_4 () , self . id_5 () , self . id_6 ())
            }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitctrl(pub u32);
        impl Trcitctrl {
            #[doc = "Integration mode enable"]
            #[must_use]
            #[inline(always)]
            pub const fn ime(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Integration mode enable"]
            #[inline(always)]
            pub const fn set_ime(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcitctrl {
            #[inline(always)]
            fn default() -> Trcitctrl {
                Trcitctrl(0)
            }
        }
        impl core::fmt::Debug for Trcitctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitctrl")
                    .field("ime", &self.ime())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcitctrl {{ ime: {=bool:?} }}", self.ime())
            }
        }
        #[doc = "Reads the state of the input pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatbinr(pub u32);
        impl Trcitiatbinr {
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatbinr {
            #[inline(always)]
            fn default() -> Trcitiatbinr {
                Trcitiatbinr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatbinr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatbinr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatbinr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcitiatbinr {{ atvalid: {=bool:?}, afready: {=bool:?} }}",
                    self.atvalid(),
                    self.afready()
                )
            }
        }
        #[doc = "Sets the state of the output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatboutr(pub u32);
        impl Trcitiatboutr {
            #[doc = "Drives the ATVALIDMI output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATVALIDMI output pin."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatboutr {
            #[inline(always)]
            fn default() -> Trcitiatboutr {
                Trcitiatboutr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatboutr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatboutr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatboutr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcitiatboutr {{ atvalid: {=bool:?}, afready: {=bool:?} }}",
                    self.atvalid(),
                    self.afready()
                )
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdcr(pub u32);
        impl Trcpdcr {
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[must_use]
            #[inline(always)]
            pub const fn pu(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[inline(always)]
            pub const fn set_pu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcpdcr {
            #[inline(always)]
            fn default() -> Trcpdcr {
                Trcpdcr(0)
            }
        }
        impl core::fmt::Debug for Trcpdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdcr").field("pu", &self.pu()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcpdcr {{ pu: {=bool:?} }}", self.pu())
            }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdsr(pub u32);
        impl Trcpdsr {
            #[doc = "Indicates ETM is powered up"]
            #[must_use]
            #[inline(always)]
            pub const fn power(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates ETM is powered up"]
            #[inline(always)]
            pub const fn set_power(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[must_use]
            #[inline(always)]
            pub const fn stickypd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[inline(always)]
            pub const fn set_stickypd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcpdsr {
            #[inline(always)]
            fn default() -> Trcpdsr {
                Trcpdsr(0)
            }
        }
        impl core::fmt::Debug for Trcpdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdsr")
                    .field("power", &self.power())
                    .field("stickypd", &self.stickypd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcpdsr {{ power: {=bool:?}, stickypd: {=bool:?} }}",
                    self.power(),
                    self.stickypd()
                )
            }
        }
        #[doc = "Enables the trace unit."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprgctlr(pub u32);
        impl Trcprgctlr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcprgctlr {
            #[inline(always)]
            fn default() -> Trcprgctlr {
                Trcprgctlr(0)
            }
        }
        impl core::fmt::Debug for Trcprgctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprgctlr")
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprgctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcprgctlr {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprocselr(pub u32);
        impl Trcprocselr {
            #[doc = "PE select bits that select the PE to trace."]
            #[must_use]
            #[inline(always)]
            pub const fn procsel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "PE select bits that select the PE to trace."]
            #[inline(always)]
            pub const fn set_procsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcprocselr {
            #[inline(always)]
            fn default() -> Trcprocselr {
                Trcprocselr(0)
            }
        }
        impl core::fmt::Debug for Trcprocselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprocselr")
                    .field("procsel", &self.procsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprocselr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcprocselr {{ procsel: {=u8:?} }}", self.procsel())
            }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcqctlr(pub u32);
        impl Trcqctlr {
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Trcqctlr {
            #[inline(always)]
            fn default() -> Trcqctlr {
                Trcqctlr(0)
            }
        }
        impl core::fmt::Debug for Trcqctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcqctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcqctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcqctlr {{ range_0: {=bool:?}, range_1: {=bool:?}, range_2: {=bool:?}, range_3: {=bool:?}, range_4: {=bool:?}, range_5: {=bool:?}, range_6: {=bool:?}, range_7: {=bool:?}, mode: {:?} }}" , self . range_0 () , self . range_1 () , self . range_2 () , self . range_3 () , self . range_4 () , self . range_5 () , self . range_6 () , self . range_7 () , self . mode ())
            }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcrsctlr(pub u32);
        impl Trcrsctlr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcrsctlr {
            #[inline(always)]
            fn default() -> Trcrsctlr {
                Trcrsctlr(0)
            }
        }
        impl core::fmt::Debug for Trcrsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcrsctlr").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcrsctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcrsctlr {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqevr(pub u32);
        impl Trcseqevr {
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Trcseqevr {
            #[inline(always)]
            fn default() -> Trcseqevr {
                Trcseqevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqevr")
                    .field("f_0", &self.f_0())
                    .field("f_1", &self.f_1())
                    .field("f_2", &self.f_2())
                    .field("f_3", &self.f_3())
                    .field("f_4", &self.f_4())
                    .field("f_5", &self.f_5())
                    .field("f_6", &self.f_6())
                    .field("f_7", &self.f_7())
                    .field("b_0", &self.b_0())
                    .field("b_1", &self.b_1())
                    .field("b_2", &self.b_2())
                    .field("b_3", &self.b_3())
                    .field("b_4", &self.b_4())
                    .field("b_5", &self.b_5())
                    .field("b_6", &self.b_6())
                    .field("b_7", &self.b_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqevr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcseqevr {{ f_0: {=bool:?}, f_1: {=bool:?}, f_2: {=bool:?}, f_3: {=bool:?}, f_4: {=bool:?}, f_5: {=bool:?}, f_6: {=bool:?}, f_7: {=bool:?}, b_0: {=bool:?}, b_1: {=bool:?}, b_2: {=bool:?}, b_3: {=bool:?}, b_4: {=bool:?}, b_5: {=bool:?}, b_6: {=bool:?}, b_7: {=bool:?} }}" , self . f_0 () , self . f_1 () , self . f_2 () , self . f_3 () , self . f_4 () , self . f_5 () , self . f_6 () , self . f_7 () , self . b_0 () , self . b_1 () , self . b_2 () , self . b_3 () , self . b_4 () , self . b_5 () , self . b_6 () , self . b_7 ())
            }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqrstevr(pub u32);
        impl Trcseqrstevr {
            #[doc = "Select which event should reset the sequencer."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should reset the sequencer."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trcseqrstevr {
            #[inline(always)]
            fn default() -> Trcseqrstevr {
                Trcseqrstevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqrstevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqrstevr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqrstevr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcseqrstevr {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqstr(pub u32);
        impl Trcseqstr {
            #[doc = "Sets or returns the state of the sequencer."]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Sets or returns the state of the sequencer."]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Trcseqstr {
            #[inline(always)]
            fn default() -> Trcseqstr {
                Trcseqstr(0)
            }
        }
        impl core::fmt::Debug for Trcseqstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqstr")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcseqstr {{ state: {:?} }}", self.state())
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcssccr0(pub u32);
        impl Trcssccr0 {
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[must_use]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[inline(always)]
            pub const fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcssccr0 {
            #[inline(always)]
            fn default() -> Trcssccr0 {
                Trcssccr0(0)
            }
        }
        impl core::fmt::Debug for Trcssccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcssccr0")
                    .field("rst", &self.rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcssccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcssccr0 {{ rst: {=bool:?} }}", self.rst())
            }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsscsr0(pub u32);
        impl Trcsscsr0 {
            #[doc = "Instruction address comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn inst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction address comparator support"]
            #[inline(always)]
            pub const fn set_inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Data address comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Data address comparator support"]
            #[inline(always)]
            pub const fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Data value comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Data value comparator support"]
            #[inline(always)]
            pub const fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Process counter value comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn pc(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Process counter value comparator support"]
            #[inline(always)]
            pub const fn set_pc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Trcsscsr0 {
            #[inline(always)]
            fn default() -> Trcsscsr0 {
                Trcsscsr0(0)
            }
        }
        impl core::fmt::Debug for Trcsscsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsscsr0")
                    .field("inst", &self.inst())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .field("pc", &self.pc())
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsscsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcsscsr0 {{ inst: {=bool:?}, da: {=bool:?}, dv: {=bool:?}, pc: {=bool:?}, status: {=bool:?} }}" , self . inst () , self . da () , self . dv () , self . pc () , self . status ())
            }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsspcicr0(pub u32);
        impl Trcsspcicr0 {
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcsspcicr0 {
            #[inline(always)]
            fn default() -> Trcsspcicr0 {
                Trcsspcicr0(0)
            }
        }
        impl core::fmt::Debug for Trcsspcicr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsspcicr0")
                    .field("pc_0", &self.pc_0())
                    .field("pc_1", &self.pc_1())
                    .field("pc_2", &self.pc_2())
                    .field("pc_3", &self.pc_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsspcicr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcsspcicr0 {{ pc_0: {=bool:?}, pc_1: {=bool:?}, pc_2: {=bool:?}, pc_3: {=bool:?} }}" , self . pc_0 () , self . pc_1 () , self . pc_2 () , self . pc_3 ())
            }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstallctlr(pub u32);
        impl Trcstallctlr {
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[must_use]
            #[inline(always)]
            pub const fn level(&self) -> super::vals::Level {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Level::from_bits(val as u8)
            }
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[inline(always)]
            pub const fn set_level(&mut self, val: super::vals::Level) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn istall(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_istall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn dstall(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_dstall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn instpriority(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_instpriority(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn datadiscardload(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_datadiscardload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn datadiscardstore(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_datadiscardstore(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Trace overflow prevention bit."]
            #[must_use]
            #[inline(always)]
            pub const fn nooverflow(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Trace overflow prevention bit."]
            #[inline(always)]
            pub const fn set_nooverflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Trcstallctlr {
            #[inline(always)]
            fn default() -> Trcstallctlr {
                Trcstallctlr(0)
            }
        }
        impl core::fmt::Debug for Trcstallctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstallctlr")
                    .field("level", &self.level())
                    .field("istall", &self.istall())
                    .field("dstall", &self.dstall())
                    .field("instpriority", &self.instpriority())
                    .field("datadiscardload", &self.datadiscardload())
                    .field("datadiscardstore", &self.datadiscardstore())
                    .field("nooverflow", &self.nooverflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstallctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcstallctlr {{ level: {:?}, istall: {=bool:?}, dstall: {=bool:?}, instpriority: {=bool:?}, datadiscardload: {=bool:?}, datadiscardstore: {=bool:?}, nooverflow: {=bool:?} }}" , self . level () , self . istall () , self . dstall () , self . instpriority () , self . datadiscardload () , self . datadiscardstore () , self . nooverflow ())
            }
        }
        #[doc = "Idle status bit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstatr(pub u32);
        impl Trcstatr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Programmers' model stable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn pmstable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Programmers' model stable bit"]
            #[inline(always)]
            pub const fn set_pmstable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcstatr {
            #[inline(always)]
            fn default() -> Trcstatr {
                Trcstatr(0)
            }
        }
        impl core::fmt::Debug for Trcstatr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstatr")
                    .field("idle", &self.idle())
                    .field("pmstable", &self.pmstable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstatr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcstatr {{ idle: {=bool:?}, pmstable: {=bool:?} }}",
                    self.idle(),
                    self.pmstable()
                )
            }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsyncpr(pub u32);
        impl Trcsyncpr {
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[must_use]
            #[inline(always)]
            pub const fn period(&self) -> super::vals::Period {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Period::from_bits(val as u8)
            }
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[inline(always)]
            pub const fn set_period(&mut self, val: super::vals::Period) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcsyncpr {
            #[inline(always)]
            fn default() -> Trcsyncpr {
                Trcsyncpr(0)
            }
        }
        impl core::fmt::Debug for Trcsyncpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsyncpr")
                    .field("period", &self.period())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsyncpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcsyncpr {{ period: {:?} }}", self.period())
            }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctraceidr(pub u32);
        impl Trctraceidr {
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[must_use]
            #[inline(always)]
            pub const fn traceid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[inline(always)]
            pub const fn set_traceid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Trctraceidr {
            #[inline(always)]
            fn default() -> Trctraceidr {
                Trctraceidr(0)
            }
        }
        impl core::fmt::Debug for Trctraceidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctraceidr")
                    .field("traceid", &self.traceid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctraceidr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trctraceidr {{ traceid: {=u8:?} }}", self.traceid())
            }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctsctlr(pub u32);
        impl Trctsctlr {
            #[doc = "Select which event should generate time stamps."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate time stamps."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trctsctlr {
            #[inline(always)]
            fn default() -> Trctsctlr {
                Trctsctlr(0)
            }
        }
        impl core::fmt::Debug for Trctsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctsctlr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctsctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trctsctlr {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdarcctlr(pub u32);
        impl Trcvdarcctlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdarcctlr {
            #[inline(always)]
            fn default() -> Trcvdarcctlr {
                Trcvdarcctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdarcctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdarcctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdarcctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdarcctlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdctlr(pub u32);
        impl Trcvdctlr {
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[must_use]
            #[inline(always)]
            pub const fn sprel(&self) -> super::vals::Sprel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Sprel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[inline(always)]
            pub const fn set_sprel(&mut self, val: super::vals::Sprel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[must_use]
            #[inline(always)]
            pub const fn pcrel(&self) -> super::vals::Pcrel {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcrel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[inline(always)]
            pub const fn set_pcrel(&mut self, val: super::vals::Pcrel) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[must_use]
            #[inline(always)]
            pub const fn tbi(&self) -> super::vals::Tbi {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tbi::from_bits(val as u8)
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[inline(always)]
            pub const fn set_tbi(&mut self, val: super::vals::Tbi) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[must_use]
            #[inline(always)]
            pub const fn trcexdata(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[inline(always)]
            pub const fn set_trcexdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trcvdctlr {
            #[inline(always)]
            fn default() -> Trcvdctlr {
                Trcvdctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdctlr")
                    .field("event_0", &self.event_0())
                    .field("event_1", &self.event_1())
                    .field("event_2", &self.event_2())
                    .field("event_3", &self.event_3())
                    .field("event_4", &self.event_4())
                    .field("event_5", &self.event_5())
                    .field("event_6", &self.event_6())
                    .field("event_7", &self.event_7())
                    .field("sprel", &self.sprel())
                    .field("pcrel", &self.pcrel())
                    .field("tbi", &self.tbi())
                    .field("trcexdata", &self.trcexdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdctlr {{ event_0: {=bool:?}, event_1: {=bool:?}, event_2: {=bool:?}, event_3: {=bool:?}, event_4: {=bool:?}, event_5: {=bool:?}, event_6: {=bool:?}, event_7: {=bool:?}, sprel: {:?}, pcrel: {:?}, tbi: {:?}, trcexdata: {=bool:?} }}" , self . event_0 () , self . event_1 () , self . event_2 () , self . event_3 () , self . event_4 () , self . event_5 () , self . event_6 () , self . event_7 () , self . sprel () , self . pcrel () , self . tbi () , self . trcexdata ())
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdsacctlr(pub u32);
        impl Trcvdsacctlr {
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdsacctlr {
            #[inline(always)]
            fn default() -> Trcvdsacctlr {
                Trcvdsacctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdsacctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdsacctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdsacctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdsacctlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvictlr(pub u32);
        impl Trcvictlr {
            #[doc = "Select which resource number should be filtered."]
            #[must_use]
            #[inline(always)]
            pub const fn event_sel(&self) -> super::vals::EventSel {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::EventSel::from_bits(val as u8)
            }
            #[doc = "Select which resource number should be filtered."]
            #[inline(always)]
            pub const fn set_event_sel(&mut self, val: super::vals::EventSel) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[must_use]
            #[inline(always)]
            pub const fn ssstatus(&self) -> super::vals::Ssstatus {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ssstatus::from_bits(val as u8)
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[inline(always)]
            pub const fn set_ssstatus(&mut self, val: super::vals::Ssstatus) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[must_use]
            #[inline(always)]
            pub const fn trcreset(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[inline(always)]
            pub const fn set_trcreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[must_use]
            #[inline(always)]
            pub const fn trcerr(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[inline(always)]
            pub const fn set_trcerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel0_s(&self) -> super::vals::Exlevel0S {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Exlevel0S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn set_exlevel0_s(&mut self, val: super::vals::Exlevel0S) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel1_s(&self) -> super::vals::Exlevel1S {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Exlevel1S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn set_exlevel1_s(&mut self, val: super::vals::Exlevel1S) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel2_s(&self) -> super::vals::Exlevel2S {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Exlevel2S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn set_exlevel2_s(&mut self, val: super::vals::Exlevel2S) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel3_s(&self) -> super::vals::Exlevel3S {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Exlevel3S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn set_exlevel3_s(&mut self, val: super::vals::Exlevel3S) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel0_ns(&self) -> super::vals::Exlevel0Ns {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Exlevel0Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn set_exlevel0_ns(&mut self, val: super::vals::Exlevel0Ns) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel1_ns(&self) -> super::vals::Exlevel1Ns {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Exlevel1Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn set_exlevel1_ns(&mut self, val: super::vals::Exlevel1Ns) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel2_ns(&self) -> super::vals::Exlevel2Ns {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Exlevel2Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn set_exlevel2_ns(&mut self, val: super::vals::Exlevel2Ns) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel3_ns(&self) -> super::vals::Exlevel3Ns {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Exlevel3Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn set_exlevel3_ns(&mut self, val: super::vals::Exlevel3Ns) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvictlr {
            #[inline(always)]
            fn default() -> Trcvictlr {
                Trcvictlr(0)
            }
        }
        impl core::fmt::Debug for Trcvictlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvictlr")
                    .field("event_sel", &self.event_sel())
                    .field("ssstatus", &self.ssstatus())
                    .field("trcreset", &self.trcreset())
                    .field("trcerr", &self.trcerr())
                    .field("exlevel0_s", &self.exlevel0_s())
                    .field("exlevel1_s", &self.exlevel1_s())
                    .field("exlevel2_s", &self.exlevel2_s())
                    .field("exlevel3_s", &self.exlevel3_s())
                    .field("exlevel0_ns", &self.exlevel0_ns())
                    .field("exlevel1_ns", &self.exlevel1_ns())
                    .field("exlevel2_ns", &self.exlevel2_ns())
                    .field("exlevel3_ns", &self.exlevel3_ns())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvictlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvictlr {{ event_sel: {:?}, ssstatus: {:?}, trcreset: {=bool:?}, trcerr: {=bool:?}, exlevel0_s: {:?}, exlevel1_s: {:?}, exlevel2_s: {:?}, exlevel3_s: {:?}, exlevel0_ns: {:?}, exlevel1_ns: {:?}, exlevel2_ns: {:?}, exlevel3_ns: {:?} }}" , self . event_sel () , self . ssstatus () , self . trcreset () , self . trcerr () , self . exlevel0_s () , self . exlevel1_s () , self . exlevel2_s () , self . exlevel3_s () , self . exlevel0_ns () , self . exlevel1_ns () , self . exlevel2_ns () , self . exlevel3_ns ())
            }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcviiectlr(pub u32);
        impl Trcviiectlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcviiectlr {
            #[inline(always)]
            fn default() -> Trcviiectlr {
                Trcviiectlr(0)
            }
        }
        impl core::fmt::Debug for Trcviiectlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcviiectlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcviiectlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcviiectlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvipcssctlr(pub u32);
        impl Trcvipcssctlr {
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvipcssctlr {
            #[inline(always)]
            fn default() -> Trcvipcssctlr {
                Trcvipcssctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvipcssctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvipcssctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvipcssctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvipcssctlr {{ start_0: {=bool:?}, start_1: {=bool:?}, start_2: {=bool:?}, start_3: {=bool:?}, start_4: {=bool:?}, start_5: {=bool:?}, start_6: {=bool:?}, start_7: {=bool:?}, stop_0: {=bool:?}, stop_1: {=bool:?}, stop_2: {=bool:?}, stop_3: {=bool:?}, stop_4: {=bool:?}, stop_5: {=bool:?}, stop_6: {=bool:?}, stop_7: {=bool:?} }}" , self . start_0 () , self . start_1 () , self . start_2 () , self . start_3 () , self . start_4 () , self . start_5 () , self . start_6 () , self . start_7 () , self . stop_0 () , self . stop_1 () , self . stop_2 () , self . stop_3 () , self . stop_4 () , self . stop_5 () , self . stop_6 () , self . stop_7 ())
            }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvissctlr(pub u32);
        impl Trcvissctlr {
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvissctlr {
            #[inline(always)]
            fn default() -> Trcvissctlr {
                Trcvissctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvissctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvissctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvissctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvissctlr {{ start_0: {=bool:?}, start_1: {=bool:?}, start_2: {=bool:?}, start_3: {=bool:?}, start_4: {=bool:?}, start_5: {=bool:?}, start_6: {=bool:?}, start_7: {=bool:?}, stop_0: {=bool:?}, stop_1: {=bool:?}, stop_2: {=bool:?}, stop_3: {=bool:?}, stop_4: {=bool:?}, stop_5: {=bool:?}, stop_6: {=bool:?}, stop_7: {=bool:?} }}" , self . start_0 () , self . start_1 () , self . start_2 () , self . start_3 () , self . start_4 () , self . start_5 () , self . start_6 () , self . start_7 () , self . stop_0 () , self . stop_1 () , self . stop_2 () , self . stop_3 () , self . stop_4 () , self . stop_5 () , self . stop_6 () , self . stop_7 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Archid(u16);
        impl Archid {
            #[doc = "Component is an ETMv4 component"]
            pub const ETMV42: Self = Self(0x4a13);
        }
        impl Archid {
            pub const fn from_bits(val: u16) -> Archid {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Archid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x4a13 => f.write_str("ETMV42"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Archid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x4a13 => defmt::write!(f, "ETMV42"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Archid {
            #[inline(always)]
            fn from(val: u16) -> Archid {
                Archid::from_bits(val)
            }
        }
        impl From<Archid> for u16 {
            #[inline(always)]
            fn from(val: Archid) -> u16 {
                Archid::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Architect(u16);
        impl Architect {
            #[doc = "This peripheral was architected by Arm."]
            pub const ARM: Self = Self(0x023b);
        }
        impl Architect {
            pub const fn from_bits(val: u16) -> Architect {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Architect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x023b => f.write_str("ARM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Architect {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x023b => defmt::write!(f, "ARM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Architect {
            #[inline(always)]
            fn from(val: u16) -> Architect {
                Architect::from_bits(val)
            }
        }
        impl From<Architect> for u16 {
            #[inline(always)]
            fn from(val: Architect) -> u16 {
                Architect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr0 {
            #[inline(always)]
            fn from(val: u8) -> Clr0 {
                Clr0::from_bits(val)
            }
        }
        impl From<Clr0> for u8 {
            #[inline(always)]
            fn from(val: Clr0) -> u8 {
                Clr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr1 {
            #[inline(always)]
            fn from(val: u8) -> Clr1 {
                Clr1::from_bits(val)
            }
        }
        impl From<Clr1> for u8 {
            #[inline(always)]
            fn from(val: Clr1) -> u8 {
                Clr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr2 {
            #[inline(always)]
            fn from(val: u8) -> Clr2 {
                Clr2::from_bits(val)
            }
        }
        impl From<Clr2> for u8 {
            #[inline(always)]
            fn from(val: Clr2) -> u8 {
                Clr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr3 {
            #[inline(always)]
            fn from(val: u8) -> Clr3 {
                Clr3::from_bits(val)
            }
        }
        impl From<Clr3> for u8 {
            #[inline(always)]
            fn from(val: Clr3) -> u8 {
                Clr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cond {
            #[doc = "Conditional instruction tracing is disabled."]
            DISABLED = 0x0,
            #[doc = "Conditional load instructions are traced."]
            LOAD_ONLY = 0x01,
            #[doc = "Conditional store instructions are traced."]
            STORE_ONLY = 0x02,
            #[doc = "Conditional load and store instructions are traced."]
            LOAD_AND_STORE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "All conditional instructions are traced."]
            ALL = 0x07,
        }
        impl Cond {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cond {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cond {
            #[inline(always)]
            fn from(val: u8) -> Cond {
                Cond::from_bits(val)
            }
        }
        impl From<Cond> for u8 {
            #[inline(always)]
            fn from(val: Cond) -> u8 {
                Cond::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EventSel {
            #[doc = "This event is not filtered."]
            DISABLED = 0x0,
            #[doc = "This event is filtered."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl EventSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EventSel {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EventSel {
            #[inline(always)]
            fn from(val: u8) -> EventSel {
                EventSel::from_bits(val)
            }
        }
        impl From<EventSel> for u8 {
            #[inline(always)]
            fn from(val: EventSel) -> u8 {
                EventSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0Ns {
                Exlevel0Ns::from_bits(val)
            }
        }
        impl From<Exlevel0Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0Ns) -> u8 {
                Exlevel0Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0S {
                Exlevel0S::from_bits(val)
            }
        }
        impl From<Exlevel0S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0S) -> u8 {
                Exlevel0S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1Ns {
                Exlevel1Ns::from_bits(val)
            }
        }
        impl From<Exlevel1Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1Ns) -> u8 {
                Exlevel1Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1S {
                Exlevel1S::from_bits(val)
            }
        }
        impl From<Exlevel1S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1S) -> u8 {
                Exlevel1S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2Ns {
                Exlevel2Ns::from_bits(val)
            }
        }
        impl From<Exlevel2Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2Ns) -> u8 {
                Exlevel2Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2S {
                Exlevel2S::from_bits(val)
            }
        }
        impl From<Exlevel2S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2S) -> u8 {
                Exlevel2S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3Ns {
                Exlevel3Ns::from_bits(val)
            }
        }
        impl From<Exlevel3Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3Ns) -> u8 {
                Exlevel3Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3S {
                Exlevel3S::from_bits(val)
            }
        }
        impl From<Exlevel3S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3S) -> u8 {
                Exlevel3S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Level {
            #[doc = "Zero invasion. This setting has a greater risk of a FIFO overflow"]
            MIN = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Maximum invasion occurs but there is less risk of a FIFO overflow."]
            MAX = 0x0f,
        }
        impl Level {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Level {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Level {
            #[inline(always)]
            fn from(val: u8) -> Level {
                Level::from_bits(val)
            }
        }
        impl From<Level> for u8 {
            #[inline(always)]
            fn from(val: Level) -> u8 {
                Level::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Peripheral is a trace source."]
            TRACE_SOURCE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Exclude mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit cannot generate Q elements. If no ranges are selected, Q elements are permitted across the entire memory map."]
            EXCLUDE = 0x0,
            #[doc = "Include mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit can generate Q elements. If all the implemented bits in RANGE are set to 0 then Q elements are disabled."]
            INCLUDE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcrel {
            #[doc = "The trace unit does not affect the tracing of PC-relative transfers."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not trace the address or value portions of PC-relative transfers."]
            DISABLED = 0x01,
        }
        impl Pcrel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcrel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcrel {
            #[inline(always)]
            fn from(val: u8) -> Pcrel {
                Pcrel::from_bits(val)
            }
        }
        impl From<Pcrel> for u8 {
            #[inline(always)]
            fn from(val: Pcrel) -> u8 {
                Pcrel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Period {
            #[doc = "Trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request."]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Period {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Period {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Period {
            #[inline(always)]
            fn from(val: u8) -> Period {
                Period::from_bits(val)
            }
        }
        impl From<Period> for u8 {
            #[inline(always)]
            fn from(val: Period) -> u8 {
                Period::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "The register is not implemented."]
            ABSENT = 0x0,
            #[doc = "The register is implemented."]
            PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Qe {
            #[doc = "Q elements are disabled."]
            DISABLED = 0x0,
            #[doc = "Q elements with instruction counts are enabled. Q elements without instruction counts are disabled."]
            ONLY_WITHOUT_INST_COUNTS = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Q elements with and without instruction counts are enabled."]
            ENABLED = 0x03,
        }
        impl Qe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Qe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Qe {
            #[inline(always)]
            fn from(val: u8) -> Qe {
                Qe::from_bits(val)
            }
        }
        impl From<Qe> for u8 {
            #[inline(always)]
            fn from(val: Qe) -> u8 {
                Qe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Revision {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Component is part of architecture 4.2"]
            V2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Revision {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Revision {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Revision {
            #[inline(always)]
            fn from(val: u8) -> Revision {
                Revision::from_bits(val)
            }
        }
        impl From<Revision> for u8 {
            #[inline(always)]
            fn from(val: Revision) -> u8 {
                Revision::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set0 {
            #[inline(always)]
            fn from(val: u8) -> Set0 {
                Set0::from_bits(val)
            }
        }
        impl From<Set0> for u8 {
            #[inline(always)]
            fn from(val: Set0) -> u8 {
                Set0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set1 {
            #[inline(always)]
            fn from(val: u8) -> Set1 {
                Set1::from_bits(val)
            }
        }
        impl From<Set1> for u8 {
            #[inline(always)]
            fn from(val: Set1) -> u8 {
                Set1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set2 {
            #[inline(always)]
            fn from(val: u8) -> Set2 {
                Set2::from_bits(val)
            }
        }
        impl From<Set2> for u8 {
            #[inline(always)]
            fn from(val: Set2) -> u8 {
                Set2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set3 {
            #[inline(always)]
            fn from(val: u8) -> Set3 {
                Set3::from_bits(val)
            }
        }
        impl From<Set3> for u8 {
            #[inline(always)]
            fn from(val: Set3) -> u8 {
                Set3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprel {
            #[doc = "The trace unit does not affect the tracing of SP-relative transfers."]
            ENABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "The trace unit does not trace the address portion of SP-relative transfers. If data value tracing is enabled then the trace unit generates a P1 data address element."]
            DATA_ONLY = 0x02,
            #[doc = "The trace unit does not trace the address or value portions of SP-relative transfers."]
            DISABLED = 0x03,
        }
        impl Sprel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprel {
            #[inline(always)]
            fn from(val: u8) -> Sprel {
                Sprel::from_bits(val)
            }
        }
        impl From<Sprel> for u8 {
            #[inline(always)]
            fn from(val: Sprel) -> u8 {
                Sprel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssstatus {
            #[doc = "The start/stop logic is in the stopped state."]
            STOPPED = 0x0,
            #[doc = "The start/stop logic is in the started state."]
            STARTED = 0x01,
        }
        impl Ssstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssstatus {
            #[inline(always)]
            fn from(val: u8) -> Ssstatus {
                Ssstatus::from_bits(val)
            }
        }
        impl From<Ssstatus> for u8 {
            #[inline(always)]
            fn from(val: Ssstatus) -> u8 {
                Ssstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "The sequencer is in state 0."]
            STATE0 = 0x0,
            #[doc = "The sequencer is in state 1."]
            STATE1 = 0x01,
            #[doc = "The sequencer is in state 2."]
            STATE2 = 0x02,
            #[doc = "The sequencer is in state 3."]
            STATE3 = 0x03,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a processor trace source."]
            PROCESSOR_TRACE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbi {
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bit\\[55\\] of the data address, that is, it sign-extends the value."]
            SIGN_EXTEND = 0x0,
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bits\\[63:56\\] of the data address."]
            COPY = 0x01,
        }
        impl Tbi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbi {
            #[inline(always)]
            fn from(val: u8) -> Tbi {
                Tbi::from_bits(val)
            }
        }
        impl From<Tbi> for u8 {
            #[inline(always)]
            fn from(val: Tbi) -> u8 {
                Tbi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vmidopt {
            #[doc = "VTTBR_EL2.VMID is used. If the trace unit supports a Virtual context identifier larger than the VTTBR_EL2.VMID, the upper unused bits are always zero. If the trace unit supports a Virtual context identifier larger than 8 bits and if the VTCR_EL2.VS bit forces use of an 8-bit Virtual context identifier, bits \\[15:8\\] of the trace unit Virtual context identifier are always zero."]
            VTTBR_EL2 = 0x0,
            #[doc = "CONTEXTIDR_EL2 is used."]
            CONTEXTIDR_EL2 = 0x01,
        }
        impl Vmidopt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vmidopt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vmidopt {
            #[inline(always)]
            fn from(val: u8) -> Vmidopt {
                Vmidopt::from_bits(val)
            }
        }
        impl From<Vmidopt> for u8 {
            #[inline(always)]
            fn from(val: Vmidopt) -> u8 {
                Vmidopt::to_bits(val)
            }
        }
    }
}
pub mod ficr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ficr {
        ptr: *mut u8,
    }
    unsafe impl Send for Ficr {}
    unsafe impl Sync for Ficr {}
    impl Ficr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SIP-specific device information is provided in the following chapters."]
        #[inline(always)]
        pub const fn sipinfo(self) -> Sipinfo {
            unsafe { Sipinfo::from_ptr(self.ptr.wrapping_add(0x0140usize) as _) }
        }
        #[doc = "Device info"]
        #[inline(always)]
        pub const fn info(self) -> Info {
            unsafe { Info::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trimcnf(self, n: usize) -> Trimcnf {
            assert!(n < 256usize);
            unsafe { Trimcnf::from_ptr(self.ptr.wrapping_add(0x0300usize + n * 8usize) as _) }
        }
        #[doc = "NIST800-90B RNG calibration data"]
        #[inline(always)]
        pub const fn trng90b(self) -> Trng90b {
            unsafe { Trng90b::from_ptr(self.ptr.wrapping_add(0x0c00usize) as _) }
        }
    }
    #[doc = "Device info"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Info {
        ptr: *mut u8,
    }
    unsafe impl Send for Info {}
    unsafe impl Sync for Info {}
    impl Info {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Device identifier"]
        #[inline(always)]
        pub const fn deviceid(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 4usize) as _)
            }
        }
        #[doc = "RAM variant"]
        #[inline(always)]
        pub const fn ram(self) -> crate::common::Reg<regs::Ram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Flash variant"]
        #[inline(always)]
        pub const fn flash(self) -> crate::common::Reg<regs::Flash, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Code memory page size"]
        #[inline(always)]
        pub const fn codepagesize(
            self,
        ) -> crate::common::Reg<regs::Codepagesize, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Code memory size"]
        #[inline(always)]
        pub const fn codesize(self) -> crate::common::Reg<regs::Codesize, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Device type"]
        #[inline(always)]
        pub const fn devicetype(self) -> crate::common::Reg<regs::Devicetype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
    }
    #[doc = "SIP-specific device information is provided in the following chapters."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sipinfo {
        ptr: *mut u8,
    }
    unsafe impl Send for Sipinfo {}
    unsafe impl Sync for Sipinfo {}
    impl Sipinfo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "SIP part number"]
        #[inline(always)]
        pub const fn partno(self) -> crate::common::Reg<regs::Partno, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description collection: SIP hardware revision, encoded in ASCII, for example B0A or B1A"]
        #[inline(always)]
        pub const fn hwrevision(self, n: usize) -> crate::common::Reg<u8, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize + n * 1usize) as _)
            }
        }
        #[doc = "Description collection: SIP VARIANT, encoded in ASCII, for example SIAA, SIBA or SICA. See Ordering information for details."]
        #[inline(always)]
        pub const fn variant(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Variant, crate::common::R> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize + n * 1usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trimcnf {
        ptr: *mut u8,
    }
    unsafe impl Send for Trimcnf {}
    unsafe impl Sync for Trimcnf {}
    impl Trimcnf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Address"]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Data"]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "NIST800-90B RNG calibration data"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trng90b {
        ptr: *mut u8,
    }
    unsafe impl Send for Trng90b {}
    unsafe impl Sync for Trng90b {}
    impl Trng90b {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Amount of bytes for the required entropy bits"]
        #[inline(always)]
        pub const fn bytes(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Repetition counter cutoff"]
        #[inline(always)]
        pub const fn rccutoff(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Adaptive proportion cutoff"]
        #[inline(always)]
        pub const fn apcutoff(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Amount of bytes for the startup tests"]
        #[inline(always)]
        pub const fn startup(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Sample count for ring oscillator configuration 1"]
        #[inline(always)]
        pub const fn rosc1(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Sample count for ring oscillator configuration 2"]
        #[inline(always)]
        pub const fn rosc2(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Sample count for ring oscillator configuration 3"]
        #[inline(always)]
        pub const fn rosc3(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Sample count for ring oscillator configuration 4"]
        #[inline(always)]
        pub const fn rosc4(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Code memory page size"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Codepagesize(pub u32);
        impl Codepagesize {
            #[doc = "Code memory page size"]
            #[must_use]
            #[inline(always)]
            pub const fn codepagesize(&self) -> super::vals::Codepagesize {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Codepagesize::from_bits(val as u32)
            }
            #[doc = "Code memory page size"]
            #[inline(always)]
            pub const fn set_codepagesize(&mut self, val: super::vals::Codepagesize) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Codepagesize {
            #[inline(always)]
            fn default() -> Codepagesize {
                Codepagesize(0)
            }
        }
        impl core::fmt::Debug for Codepagesize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Codepagesize")
                    .field("codepagesize", &self.codepagesize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Codepagesize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Codepagesize {{ codepagesize: {:?} }}",
                    self.codepagesize()
                )
            }
        }
        #[doc = "Code memory size"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Codesize(pub u32);
        impl Codesize {
            #[doc = "Code memory size in number of pages Total code space is: CODEPAGESIZE * CODESIZE"]
            #[must_use]
            #[inline(always)]
            pub const fn codesize(&self) -> super::vals::Codesize {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Codesize::from_bits(val as u32)
            }
            #[doc = "Code memory size in number of pages Total code space is: CODEPAGESIZE * CODESIZE"]
            #[inline(always)]
            pub const fn set_codesize(&mut self, val: super::vals::Codesize) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Codesize {
            #[inline(always)]
            fn default() -> Codesize {
                Codesize(0)
            }
        }
        impl core::fmt::Debug for Codesize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Codesize")
                    .field("codesize", &self.codesize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Codesize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Codesize {{ codesize: {:?} }}", self.codesize())
            }
        }
        #[doc = "Device type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devicetype(pub u32);
        impl Devicetype {
            #[doc = "Device type"]
            #[must_use]
            #[inline(always)]
            pub const fn devicetype(&self) -> super::vals::Devicetype {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Devicetype::from_bits(val as u32)
            }
            #[doc = "Device type"]
            #[inline(always)]
            pub const fn set_devicetype(&mut self, val: super::vals::Devicetype) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Devicetype {
            #[inline(always)]
            fn default() -> Devicetype {
                Devicetype(0)
            }
        }
        impl core::fmt::Debug for Devicetype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devicetype")
                    .field("devicetype", &self.devicetype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devicetype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Devicetype {{ devicetype: {:?} }}", self.devicetype())
            }
        }
        #[doc = "Flash variant"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Flash(pub u32);
        impl Flash {
            #[doc = "Flash variant"]
            #[must_use]
            #[inline(always)]
            pub const fn flash(&self) -> super::vals::Flash {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Flash::from_bits(val as u32)
            }
            #[doc = "Flash variant"]
            #[inline(always)]
            pub const fn set_flash(&mut self, val: super::vals::Flash) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Flash {
            #[inline(always)]
            fn default() -> Flash {
                Flash(0)
            }
        }
        impl core::fmt::Debug for Flash {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Flash")
                    .field("flash", &self.flash())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Flash {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Flash {{ flash: {:?} }}", self.flash())
            }
        }
        #[doc = "SIP part number"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Partno(pub u32);
        impl Partno {
            #[must_use]
            #[inline(always)]
            pub const fn partno(&self) -> super::vals::Partno {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Partno::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_partno(&mut self, val: super::vals::Partno) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Partno {
            #[inline(always)]
            fn default() -> Partno {
                Partno(0)
            }
        }
        impl core::fmt::Debug for Partno {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Partno")
                    .field("partno", &self.partno())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Partno {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Partno {{ partno: {:?} }}", self.partno())
            }
        }
        #[doc = "RAM variant"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ram(pub u32);
        impl Ram {
            #[doc = "RAM variant"]
            #[must_use]
            #[inline(always)]
            pub const fn ram(&self) -> super::vals::Ram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Ram::from_bits(val as u32)
            }
            #[doc = "RAM variant"]
            #[inline(always)]
            pub const fn set_ram(&mut self, val: super::vals::Ram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ram {
            #[inline(always)]
            fn default() -> Ram {
                Ram(0)
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ram").field("ram", &self.ram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ram {{ ram: {:?} }}", self.ram())
            }
        }
        #[doc = "Description collection: SIP VARIANT, encoded in ASCII, for example SIAA, SIBA or SICA. See Ordering information for details."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Variant(pub u8);
        impl Variant {
            #[must_use]
            #[inline(always)]
            pub const fn variant(&self) -> super::vals::Variant {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Variant::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_variant(&mut self, val: super::vals::Variant) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u8) & 0xff) << 0usize);
            }
        }
        impl Default for Variant {
            #[inline(always)]
            fn default() -> Variant {
                Variant(0)
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Variant")
                    .field("variant", &self.variant())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Variant {{ variant: {:?} }}", self.variant())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Codepagesize(u32);
        impl Codepagesize {
            #[doc = "4 kByte"]
            pub const K4096: Self = Self(0x1000);
        }
        impl Codepagesize {
            pub const fn from_bits(val: u32) -> Codepagesize {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Codepagesize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x1000 => f.write_str("K4096"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Codepagesize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x1000 => defmt::write!(f, "K4096"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Codepagesize {
            #[inline(always)]
            fn from(val: u32) -> Codepagesize {
                Codepagesize::from_bits(val)
            }
        }
        impl From<Codepagesize> for u32 {
            #[inline(always)]
            fn from(val: Codepagesize) -> u32 {
                Codepagesize::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Codesize(u32);
        impl Codesize {
            #[doc = "256 pages"]
            pub const P256: Self = Self(0x0100);
        }
        impl Codesize {
            pub const fn from_bits(val: u32) -> Codesize {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Codesize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("P256"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Codesize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "P256"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Codesize {
            #[inline(always)]
            fn from(val: u32) -> Codesize {
                Codesize::from_bits(val)
            }
        }
        impl From<Codesize> for u32 {
            #[inline(always)]
            fn from(val: Codesize) -> u32 {
                Codesize::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Devicetype(u32);
        impl Devicetype {
            #[doc = "Device is an physical DIE"]
            pub const DIE: Self = Self(0x0);
            #[doc = "Device is an FPGA"]
            pub const FPGA: Self = Self(0xffff_ffff);
        }
        impl Devicetype {
            pub const fn from_bits(val: u32) -> Devicetype {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Devicetype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DIE"),
                    0xffff_ffff => f.write_str("FPGA"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devicetype {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DIE"),
                    0xffff_ffff => defmt::write!(f, "FPGA"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Devicetype {
            #[inline(always)]
            fn from(val: u32) -> Devicetype {
                Devicetype::from_bits(val)
            }
        }
        impl From<Devicetype> for u32 {
            #[inline(always)]
            fn from(val: Devicetype) -> u32 {
                Devicetype::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Flash(u32);
        impl Flash {
            #[doc = "1 MByte FLASH"]
            pub const K1024: Self = Self(0x0400);
        }
        impl Flash {
            pub const fn from_bits(val: u32) -> Flash {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Flash {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0400 => f.write_str("K1024"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Flash {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0400 => defmt::write!(f, "K1024"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Flash {
            #[inline(always)]
            fn from(val: u32) -> Flash {
                Flash::from_bits(val)
            }
        }
        impl From<Flash> for u32 {
            #[inline(always)]
            fn from(val: Flash) -> u32 {
                Flash::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Partno(u32);
        impl Partno {
            #[doc = "Device is an nRF9131 sip"]
            pub const _9131: Self = Self(0x9131);
            #[doc = "Device is an nRF9151 sip"]
            pub const _9151: Self = Self(0x9151);
            #[doc = "Device is an nRF9160 sip"]
            pub const _9160: Self = Self(0x9160);
            #[doc = "Device is an nRF9161 sip"]
            pub const _9161: Self = Self(0x9161);
        }
        impl Partno {
            pub const fn from_bits(val: u32) -> Partno {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Partno {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x9131 => f.write_str("_9131"),
                    0x9151 => f.write_str("_9151"),
                    0x9160 => f.write_str("_9160"),
                    0x9161 => f.write_str("_9161"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Partno {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x9131 => defmt::write!(f, "_9131"),
                    0x9151 => defmt::write!(f, "_9151"),
                    0x9160 => defmt::write!(f, "_9160"),
                    0x9161 => defmt::write!(f, "_9161"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Partno {
            #[inline(always)]
            fn from(val: u32) -> Partno {
                Partno::from_bits(val)
            }
        }
        impl From<Partno> for u32 {
            #[inline(always)]
            fn from(val: Partno) -> u32 {
                Partno::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ram(u32);
        impl Ram {
            #[doc = "256 kByte RAM"]
            pub const K256: Self = Self(0x0100);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Ram {
            pub const fn from_bits(val: u32) -> Ram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("K256"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "K256"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Ram {
            #[inline(always)]
            fn from(val: u32) -> Ram {
                Ram::from_bits(val)
            }
        }
        impl From<Ram> for u32 {
            #[inline(always)]
            fn from(val: Ram) -> u32 {
                Ram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Variant(u8);
        impl Variant {
            #[doc = "Unspecified"]
            pub const A: Self = Self(0x41);
            #[doc = "Unspecified"]
            pub const B: Self = Self(0x42);
            #[doc = "Unspecified"]
            pub const C: Self = Self(0x43);
            #[doc = "Unspecified"]
            pub const I: Self = Self(0x49);
            #[doc = "Unspecified"]
            pub const L: Self = Self(0x4c);
            #[doc = "Unspecified"]
            pub const S: Self = Self(0x53);
        }
        impl Variant {
            pub const fn from_bits(val: u8) -> Variant {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x41 => f.write_str("A"),
                    0x42 => f.write_str("B"),
                    0x43 => f.write_str("C"),
                    0x49 => f.write_str("I"),
                    0x4c => f.write_str("L"),
                    0x53 => f.write_str("S"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x41 => defmt::write!(f, "A"),
                    0x42 => defmt::write!(f, "B"),
                    0x43 => defmt::write!(f, "C"),
                    0x49 => defmt::write!(f, "I"),
                    0x4c => defmt::write!(f, "L"),
                    0x53 => defmt::write!(f, "S"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Variant {
            #[inline(always)]
            fn from(val: u8) -> Variant {
                Variant::from_bits(val)
            }
        }
        impl From<Variant> for u8 {
            #[inline(always)]
            fn from(val: Variant) -> u8 {
                Variant::to_bits(val)
            }
        }
    }
}
pub mod fpu {
    #[doc = "FPU"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fpu {
        ptr: *mut u8,
    }
    unsafe impl Send for Fpu {}
    unsafe impl Sync for Fpu {}
    impl Fpu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Write GPIO port"]
        #[inline(always)]
        pub const fn out(self) -> crate::common::Reg<regs::Out, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outset(self) -> crate::common::Reg<regs::Outset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outclr(self) -> crate::common::Reg<regs::Outclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Read GPIO port"]
        #[inline(always)]
        pub const fn in_(self) -> crate::common::Reg<regs::In, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Direction of GPIO pins"]
        #[inline(always)]
        pub const fn dir(self) -> crate::common::Reg<regs::Dir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "DIR set register"]
        #[inline(always)]
        pub const fn dirset(self) -> crate::common::Reg<regs::Dirset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "DIR clear register"]
        #[inline(always)]
        pub const fn dirclr(self) -> crate::common::Reg<regs::Dirclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[inline(always)]
        pub const fn latch(self) -> crate::common::Reg<regs::Latch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode (For non-secure pin only)"]
        #[inline(always)]
        pub const fn detectmode(self) -> crate::common::Reg<regs::Detectmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode (For secure pin only)"]
        #[inline(always)]
        pub const fn detectmode_sec(
            self,
        ) -> crate::common::Reg<regs::DetectmodeSec, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Description collection: Configuration of GPIO pins"]
        #[inline(always)]
        pub const fn pin_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PinCnf, crate::common::RW> {
            assert!(n < 32usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Select between default DETECT signal behavior and LDETECT mode (For non-secure pin only)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Detectmode(pub u32);
        impl Detectmode {
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[must_use]
            #[inline(always)]
            pub const fn detectmode(&self) -> super::vals::Detectmode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detectmode::from_bits(val as u8)
            }
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub const fn set_detectmode(&mut self, val: super::vals::Detectmode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Detectmode {
            #[inline(always)]
            fn default() -> Detectmode {
                Detectmode(0)
            }
        }
        impl core::fmt::Debug for Detectmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Detectmode")
                    .field("detectmode", &self.detectmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Detectmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Detectmode {{ detectmode: {:?} }}", self.detectmode())
            }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode (For secure pin only)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DetectmodeSec(pub u32);
        impl DetectmodeSec {
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[must_use]
            #[inline(always)]
            pub const fn detectmode(&self) -> super::vals::Detectmode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detectmode::from_bits(val as u8)
            }
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub const fn set_detectmode(&mut self, val: super::vals::Detectmode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DetectmodeSec {
            #[inline(always)]
            fn default() -> DetectmodeSec {
                DetectmodeSec(0)
            }
        }
        impl core::fmt::Debug for DetectmodeSec {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DetectmodeSec")
                    .field("detectmode", &self.detectmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DetectmodeSec {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DetectmodeSec {{ detectmode: {:?} }}", self.detectmode())
            }
        }
        #[doc = "Direction of GPIO pins"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dir(pub u32);
        impl Dir {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> super::vals::Dir {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: super::vals::Dir) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
            }
        }
        impl Default for Dir {
            #[inline(always)]
            fn default() -> Dir {
                Dir(0)
            }
        }
        impl core::fmt::Debug for Dir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dir")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dir {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dir {{ pin[0]: {:?}, pin[1]: {:?}, pin[2]: {:?}, pin[3]: {:?}, pin[4]: {:?}, pin[5]: {:?}, pin[6]: {:?}, pin[7]: {:?}, pin[8]: {:?}, pin[9]: {:?}, pin[10]: {:?}, pin[11]: {:?}, pin[12]: {:?}, pin[13]: {:?}, pin[14]: {:?}, pin[15]: {:?}, pin[16]: {:?}, pin[17]: {:?}, pin[18]: {:?}, pin[19]: {:?}, pin[20]: {:?}, pin[21]: {:?}, pin[22]: {:?}, pin[23]: {:?}, pin[24]: {:?}, pin[25]: {:?}, pin[26]: {:?}, pin[27]: {:?}, pin[28]: {:?}, pin[29]: {:?}, pin[30]: {:?}, pin[31]: {:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR clear register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirclr(pub u32);
        impl Dirclr {
            #[doc = "Set as input pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as input pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirclr {
            #[inline(always)]
            fn default() -> Dirclr {
                Dirclr(0)
            }
        }
        impl core::fmt::Debug for Dirclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR set register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirset(pub u32);
        impl Dirset {
            #[doc = "Set as output pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as output pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirset {
            #[inline(always)]
            fn default() -> Dirset {
                Dirset(0)
            }
        }
        impl core::fmt::Debug for Dirset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Read GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct In(pub u32);
        impl In {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for In {
            #[inline(always)]
            fn default() -> In {
                In(0)
            }
        }
        impl core::fmt::Debug for In {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("In")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for In {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "In {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Latch(pub u32);
        impl Latch {
            #[doc = "Status on whether PIN\\[0\\] has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Status on whether PIN\\[0\\] has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Latch {
            #[inline(always)]
            fn default() -> Latch {
                Latch(0)
            }
        }
        impl core::fmt::Debug for Latch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Latch")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Latch {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Latch {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Write GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Out(pub u32);
        impl Out {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Out {
            #[inline(always)]
            fn default() -> Out {
                Out(0)
            }
        }
        impl core::fmt::Debug for Out {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Out")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Out {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Out {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outclr(pub u32);
        impl Outclr {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outclr {
            #[inline(always)]
            fn default() -> Outclr {
                Outclr(0)
            }
        }
        impl core::fmt::Debug for Outclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outset(pub u32);
        impl Outset {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outset {
            #[inline(always)]
            fn default() -> Outset {
                Outset(0)
            }
        }
        impl core::fmt::Debug for Outset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Description collection: Configuration of GPIO pins"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PinCnf(pub u32);
        impl PinCnf {
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[must_use]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[inline(always)]
            pub const fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Connect or disconnect input buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn input(&self) -> super::vals::Input {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Input::from_bits(val as u8)
            }
            #[doc = "Connect or disconnect input buffer"]
            #[inline(always)]
            pub const fn set_input(&mut self, val: super::vals::Input) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pull configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn pull(&self) -> super::vals::Pull {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Pull::from_bits(val as u8)
            }
            #[doc = "Pull configuration"]
            #[inline(always)]
            pub const fn set_pull(&mut self, val: super::vals::Pull) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Drive configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn drive(&self) -> super::vals::Drive {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration"]
            #[inline(always)]
            pub const fn set_drive(&mut self, val: super::vals::Drive) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Pin sensing mechanism"]
            #[must_use]
            #[inline(always)]
            pub const fn sense(&self) -> super::vals::Sense {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Sense::from_bits(val as u8)
            }
            #[doc = "Pin sensing mechanism"]
            #[inline(always)]
            pub const fn set_sense(&mut self, val: super::vals::Sense) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
        }
        impl Default for PinCnf {
            #[inline(always)]
            fn default() -> PinCnf {
                PinCnf(0)
            }
        }
        impl core::fmt::Debug for PinCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PinCnf")
                    .field("dir", &self.dir())
                    .field("input", &self.input())
                    .field("pull", &self.pull())
                    .field("drive", &self.drive())
                    .field("sense", &self.sense())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PinCnf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PinCnf {{ dir: {:?}, input: {:?}, pull: {:?}, drive: {:?}, sense: {:?} }}",
                    self.dir(),
                    self.input(),
                    self.pull(),
                    self.drive(),
                    self.sense()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detectmode {
            #[doc = "DETECT directly connected to PIN DETECT signals"]
            DEFAULT = 0x0,
            #[doc = "Use the latched LDETECT behavior"]
            LDETECT = 0x01,
        }
        impl Detectmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detectmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detectmode {
            #[inline(always)]
            fn from(val: u8) -> Detectmode {
                Detectmode::from_bits(val)
            }
        }
        impl From<Detectmode> for u8 {
            #[inline(always)]
            fn from(val: Detectmode) -> u8 {
                Detectmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            #[doc = "Configure pin as an input pin"]
            INPUT = 0x0,
            #[doc = "Configure pin as an output pin"]
            OUTPUT = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drive {
            #[doc = "Standard '0', standard '1'"]
            S0S1 = 0x0,
            #[doc = "High drive '0', standard '1'"]
            H0S1 = 0x01,
            #[doc = "Standard '0', high drive '1'"]
            S0H1 = 0x02,
            #[doc = "High drive '0', high 'drive '1''"]
            H0H1 = 0x03,
            #[doc = "Disconnect '0', standard '1' (normally used for wired-or connections)"]
            D0S1 = 0x04,
            #[doc = "Disconnect '0', high drive '1' (normally used for wired-or connections)"]
            D0H1 = 0x05,
            #[doc = "Standard '0', disconnect '1' (normally used for wired-and connections)"]
            S0D1 = 0x06,
            #[doc = "High drive '0', disconnect '1' (normally used for wired-and connections)"]
            H0D1 = 0x07,
        }
        impl Drive {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drive {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drive {
            #[inline(always)]
            fn from(val: u8) -> Drive {
                Drive::from_bits(val)
            }
        }
        impl From<Drive> for u8 {
            #[inline(always)]
            fn from(val: Drive) -> u8 {
                Drive::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Input {
            #[doc = "Connect input buffer"]
            CONNECT = 0x0,
            #[doc = "Disconnect input buffer"]
            DISCONNECT = 0x01,
        }
        impl Input {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Input {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Input {
            #[inline(always)]
            fn from(val: u8) -> Input {
                Input::from_bits(val)
            }
        }
        impl From<Input> for u8 {
            #[inline(always)]
            fn from(val: Input) -> u8 {
                Input::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pull {
            #[doc = "No pull"]
            DISABLED = 0x0,
            #[doc = "Pull down on pin"]
            PULLDOWN = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Pull up on pin"]
            PULLUP = 0x03,
        }
        impl Pull {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pull {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pull {
            #[inline(always)]
            fn from(val: u8) -> Pull {
                Pull::from_bits(val)
            }
        }
        impl From<Pull> for u8 {
            #[inline(always)]
            fn from(val: Pull) -> u8 {
                Pull::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sense {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Sense for high level"]
            HIGH = 0x02,
            #[doc = "Sense for low level"]
            LOW = 0x03,
        }
        impl Sense {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sense {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sense {
            #[inline(always)]
            fn from(val: u8) -> Sense {
                Sense::from_bits(val)
            }
        }
        impl From<Sense> for u8 {
            #[inline(always)]
            fn from(val: Sense) -> u8 {
                Sense::to_bits(val)
            }
        }
    }
}
pub mod gpiote {
    #[doc = "GPIO Tasks and Events 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is configured in CONFIG\\[n\\].POLARITY."]
        #[inline(always)]
        pub const fn tasks_out(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it high."]
        #[inline(always)]
        pub const fn tasks_set(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it low."]
        #[inline(always)]
        pub const fn tasks_clr(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x60usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task OUT\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task SET\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_set(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task CLR\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_clr(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xe0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Event generated from pin specified in CONFIG\\[n\\].PSEL"]
        #[inline(always)]
        pub const fn events_in(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Event generated from multiple input GPIO pins with SENSE mechanism enabled"]
        #[inline(always)]
        pub const fn events_port(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 1usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x017cusize + n * 0usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event IN\\[n\\]"]
        #[inline(always)]
        pub const fn publish_in(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event PORT"]
        #[inline(always)]
        pub const fn publish_port(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01fcusize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 1usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize + n * 0usize) as _)
            }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 1usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize + n * 0usize) as _)
            }
        }
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[inline(always)]
        pub const fn config(self, n: usize) -> crate::common::Reg<regs::Config, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[must_use]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[inline(always)]
            pub const fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize);
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[must_use]
            #[inline(always)]
            pub const fn polarity(&self) -> super::vals::Polarity {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Polarity::from_bits(val as u8)
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[inline(always)]
            pub const fn set_polarity(&mut self, val: super::vals::Polarity) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[must_use]
            #[inline(always)]
            pub const fn outinit(&self) -> super::vals::Outinit {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Outinit::from_bits(val as u8)
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[inline(always)]
            pub const fn set_outinit(&mut self, val: super::vals::Outinit) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("mode", &self.mode())
                    .field("psel", &self.psel())
                    .field("polarity", &self.polarity())
                    .field("outinit", &self.outinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ mode: {:?}, psel: {=u8:?}, polarity: {:?}, outinit: {:?} }}",
                    self.mode(),
                    self.psel(),
                    self.polarity(),
                    self.outinit()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn in_(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[inline(always)]
            pub const fn set_in_(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event PORT"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("in_[0]", &self.in_(0usize))
                    .field("in_[1]", &self.in_(1usize))
                    .field("in_[2]", &self.in_(2usize))
                    .field("in_[3]", &self.in_(3usize))
                    .field("in_[4]", &self.in_(4usize))
                    .field("in_[5]", &self.in_(5usize))
                    .field("in_[6]", &self.in_(6usize))
                    .field("in_[7]", &self.in_(7usize))
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ in_[0]: {=bool:?}, in_[1]: {=bool:?}, in_[2]: {=bool:?}, in_[3]: {=bool:?}, in_[4]: {=bool:?}, in_[5]: {=bool:?}, in_[6]: {=bool:?}, in_[7]: {=bool:?}, port: {=bool:?} }}" , self . in_ (0usize) , self . in_ (1usize) , self . in_ (2usize) , self . in_ (3usize) , self . in_ (4usize) , self . in_ (5usize) , self . in_ (6usize) , self . in_ (7usize) , self . port ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module."]
            DISABLED = 0x0,
            #[doc = "Event mode"]
            EVENT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Task mode"]
            TASK = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outinit {
            #[doc = "Task mode: Initial value of pin before task triggering is low"]
            LOW = 0x0,
            #[doc = "Task mode: Initial value of pin before task triggering is high"]
            HIGH = 0x01,
        }
        impl Outinit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outinit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outinit {
            #[inline(always)]
            fn from(val: u8) -> Outinit {
                Outinit::from_bits(val)
            }
        }
        impl From<Outinit> for u8 {
            #[inline(always)]
            fn from(val: Outinit) -> u8 {
                Outinit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Polarity {
            #[doc = "Task mode: No effect on pin from OUT\\[n\\] task. Event mode: no IN\\[n\\] event generated on pin activity."]
            NONE = 0x0,
            #[doc = "Task mode: Set pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when rising edge on pin."]
            LO_TO_HI = 0x01,
            #[doc = "Task mode: Clear pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when falling edge on pin."]
            HI_TO_LO = 0x02,
            #[doc = "Task mode: Toggle pin from OUT\\[n\\]. Event mode: Generate IN\\[n\\] when any change on pin."]
            TOGGLE = 0x03,
        }
        impl Polarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Polarity {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Polarity {
            #[inline(always)]
            fn from(val: u8) -> Polarity {
                Polarity::from_bits(val)
            }
        }
        impl From<Polarity> for u8 {
            #[inline(always)]
            fn from(val: Polarity) -> u8 {
                Polarity::to_bits(val)
            }
        }
    }
}
pub mod i2s {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2S mode."]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Reception (RX) enable."]
        #[inline(always)]
        pub const fn rxen(self) -> crate::common::Reg<regs::Rxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Transmission (TX) enable."]
        #[inline(always)]
        pub const fn txen(self) -> crate::common::Reg<regs::Txen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Master clock generator enable."]
        #[inline(always)]
        pub const fn mcken(self) -> crate::common::Reg<regs::Mcken, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Master clock generator frequency."]
        #[inline(always)]
        pub const fn mckfreq(self) -> crate::common::Reg<regs::Mckfreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "MCK / LRCK ratio."]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Sample width."]
        #[inline(always)]
        pub const fn swidth(self) -> crate::common::Reg<regs::Swidth, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x18usize) as _) }
        }
        #[doc = "Alignment of sample within a frame."]
        #[inline(always)]
        pub const fn align(self) -> crate::common::Reg<regs::Align, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Frame format."]
        #[inline(always)]
        pub const fn format(self) -> crate::common::Reg<regs::Format, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Enable channels."]
        #[inline(always)]
        pub const fn channels(self) -> crate::common::Reg<regs::Channels, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
    }
    #[doc = "Inter-IC Sound 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct I2s {
        ptr: *mut u8,
    }
    unsafe impl Send for I2s {}
    unsafe impl Sync for I2s {}
    impl I2s {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous I2S transfer. Also starts MCK generator when this is enabled."]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops I2S transfer. Also stops MCK generator. Triggering this task will cause the STOPPED event to be generated."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words that are received on the SDIN pin."]
        #[inline(always)]
        pub const fn events_rxptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "I2S transfer stopped."]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin."]
        #[inline(always)]
        pub const fn events_txptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Publish configuration for event RXPTRUPD"]
        #[inline(always)]
        pub const fn publish_rxptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXPTRUPD"]
        #[inline(always)]
        pub const fn publish_txptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable I2S module."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.wrapping_add(0x0538usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxtxd(self) -> Rxtxd {
            unsafe { Rxtxd::from_ptr(self.ptr.wrapping_add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0560usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for MCK signal."]
        #[inline(always)]
        pub const fn mck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SCK signal."]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for LRCK signal."]
        #[inline(always)]
        pub const fn lrck(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for SDIN signal."]
        #[inline(always)]
        pub const fn sdin(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Pin select for SDOUT signal."]
        #[inline(always)]
        pub const fn sdout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Receive buffer RAM start address."]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxtxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxtxd {}
    unsafe impl Sync for Rxtxd {}
    impl Rxtxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Size of RXD and TXD buffers."]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Transmit buffer RAM start address."]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Alignment of sample within a frame."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Align(pub u32);
        impl Align {
            #[doc = "Alignment of sample within a frame."]
            #[must_use]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Alignment of sample within a frame."]
            #[inline(always)]
            pub const fn set_align(&mut self, val: super::vals::Align) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Align {
            #[inline(always)]
            fn default() -> Align {
                Align(0)
            }
        }
        impl core::fmt::Debug for Align {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Align")
                    .field("align", &self.align())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Align {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Align {{ align: {:?} }}", self.align())
            }
        }
        #[doc = "Enable channels."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Channels(pub u32);
        impl Channels {
            #[doc = "Enable channels."]
            #[must_use]
            #[inline(always)]
            pub const fn channels(&self) -> super::vals::Channels {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Channels::from_bits(val as u8)
            }
            #[doc = "Enable channels."]
            #[inline(always)]
            pub const fn set_channels(&mut self, val: super::vals::Channels) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Channels {
            #[inline(always)]
            fn default() -> Channels {
                Channels(0)
            }
        }
        impl core::fmt::Debug for Channels {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Channels")
                    .field("channels", &self.channels())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Channels {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Channels {{ channels: {:?} }}", self.channels())
            }
        }
        #[doc = "Enable I2S module."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable I2S module."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable I2S module."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Frame format."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Format(pub u32);
        impl Format {
            #[doc = "Frame format."]
            #[must_use]
            #[inline(always)]
            pub const fn format(&self) -> super::vals::Format {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Format::from_bits(val as u8)
            }
            #[doc = "Frame format."]
            #[inline(always)]
            pub const fn set_format(&mut self, val: super::vals::Format) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Format {
            #[inline(always)]
            fn default() -> Format {
                Format(0)
            }
        }
        impl core::fmt::Debug for Format {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Format")
                    .field("format", &self.format())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Format {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Format {{ format: {:?} }}", self.format())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn rxptrupd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[inline(always)]
            pub const fn set_rxptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn txptrupd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[inline(always)]
            pub const fn set_txptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxptrupd", &self.rxptrupd())
                    .field("stopped", &self.stopped())
                    .field("txptrupd", &self.txptrupd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ rxptrupd: {=bool:?}, stopped: {=bool:?}, txptrupd: {=bool:?} }}",
                    self.rxptrupd(),
                    self.stopped(),
                    self.txptrupd()
                )
            }
        }
        #[doc = "Size of RXD and TXD buffers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words."]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words."]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Master clock generator enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mcken(pub u32);
        impl Mcken {
            #[doc = "Master clock generator enable."]
            #[must_use]
            #[inline(always)]
            pub const fn mcken(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master clock generator enable."]
            #[inline(always)]
            pub const fn set_mcken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mcken {
            #[inline(always)]
            fn default() -> Mcken {
                Mcken(0)
            }
        }
        impl core::fmt::Debug for Mcken {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mcken")
                    .field("mcken", &self.mcken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mcken {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mcken {{ mcken: {=bool:?} }}", self.mcken())
            }
        }
        #[doc = "Master clock generator frequency."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mckfreq(pub u32);
        impl Mckfreq {
            #[doc = "Master clock generator frequency."]
            #[must_use]
            #[inline(always)]
            pub const fn mckfreq(&self) -> super::vals::Mckfreq {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Mckfreq::from_bits(val as u32)
            }
            #[doc = "Master clock generator frequency."]
            #[inline(always)]
            pub const fn set_mckfreq(&mut self, val: super::vals::Mckfreq) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mckfreq {
            #[inline(always)]
            fn default() -> Mckfreq {
                Mckfreq(0)
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mckfreq")
                    .field("mckfreq", &self.mckfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mckfreq {{ mckfreq: {:?} }}", self.mckfreq())
            }
        }
        #[doc = "I2S mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "I2S mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "I2S mode."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "MCK / LRCK ratio."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "MCK / LRCK ratio."]
            #[must_use]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "MCK / LRCK ratio."]
            #[inline(always)]
            pub const fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ratio {{ ratio: {:?} }}", self.ratio())
            }
        }
        #[doc = "Reception (RX) enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxen(pub u32);
        impl Rxen {
            #[doc = "Reception (RX) enable."]
            #[must_use]
            #[inline(always)]
            pub const fn rxen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reception (RX) enable."]
            #[inline(always)]
            pub const fn set_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxen {
            #[inline(always)]
            fn default() -> Rxen {
                Rxen(0)
            }
        }
        impl core::fmt::Debug for Rxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxen").field("rxen", &self.rxen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxen {{ rxen: {=bool:?} }}", self.rxen())
            }
        }
        #[doc = "Sample width."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swidth(pub u32);
        impl Swidth {
            #[doc = "Sample width."]
            #[must_use]
            #[inline(always)]
            pub const fn swidth(&self) -> super::vals::Swidth {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Swidth::from_bits(val as u8)
            }
            #[doc = "Sample width."]
            #[inline(always)]
            pub const fn set_swidth(&mut self, val: super::vals::Swidth) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Swidth {
            #[inline(always)]
            fn default() -> Swidth {
                Swidth(0)
            }
        }
        impl core::fmt::Debug for Swidth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swidth")
                    .field("swidth", &self.swidth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swidth {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Swidth {{ swidth: {:?} }}", self.swidth())
            }
        }
        #[doc = "Transmission (TX) enable."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txen(pub u32);
        impl Txen {
            #[doc = "Transmission (TX) enable."]
            #[must_use]
            #[inline(always)]
            pub const fn txen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transmission (TX) enable."]
            #[inline(always)]
            pub const fn set_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txen {
            #[inline(always)]
            fn default() -> Txen {
                Txen(0)
            }
        }
        impl core::fmt::Debug for Txen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txen").field("txen", &self.txen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txen {{ txen: {=bool:?} }}", self.txen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            #[doc = "Left-aligned."]
            LEFT = 0x0,
            #[doc = "Right-aligned."]
            RIGHT = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Channels {
            #[doc = "Stereo."]
            STEREO = 0x0,
            #[doc = "Left only."]
            LEFT = 0x01,
            #[doc = "Right only."]
            RIGHT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Channels {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Channels {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Channels {
            #[inline(always)]
            fn from(val: u8) -> Channels {
                Channels::from_bits(val)
            }
        }
        impl From<Channels> for u8 {
            #[inline(always)]
            fn from(val: Channels) -> u8 {
                Channels::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Format {
            #[doc = "Original I2S format."]
            I2S = 0x0,
            #[doc = "Alternate (left- or right-aligned) format."]
            ALIGNED = 0x01,
        }
        impl Format {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Format {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Format {
            #[inline(always)]
            fn from(val: u8) -> Format {
                Format::from_bits(val)
            }
        }
        impl From<Format> for u8 {
            #[inline(always)]
            fn from(val: Format) -> u8 {
                Format::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Mckfreq(u32);
        impl Mckfreq {
            #[doc = "32 MHz / 125 = 0.256 MHz"]
            pub const _32MDIV125: Self = Self(0x020c_0000);
            #[doc = "32 MHz / 63 = 0.5079365 MHz"]
            pub const _32MDIV63: Self = Self(0x0410_0000);
            #[doc = "32 MHz / 42 = 0.7619048 MHz"]
            pub const _32MDIV42: Self = Self(0x0600_0000);
            #[doc = "32 MHz / 32 = 1.0 MHz"]
            pub const _32MDIV32: Self = Self(0x0800_0000);
            #[doc = "32 MHz / 31 = 1.0322581 MHz"]
            pub const _32MDIV31: Self = Self(0x0840_0000);
            #[doc = "32 MHz / 30 = 1.0666667 MHz"]
            pub const _32MDIV30: Self = Self(0x0880_0000);
            #[doc = "32 MHz / 23 = 1.3913043 MHz"]
            pub const _32MDIV23: Self = Self(0x0b00_0000);
            #[doc = "32 MHz / 21 = 1.5238095"]
            pub const _32MDIV21: Self = Self(0x0c00_0000);
            #[doc = "32 MHz / 16 = 2.0 MHz"]
            pub const _32MDIV16: Self = Self(0x1000_0000);
            #[doc = "32 MHz / 15 = 2.1333333 MHz"]
            pub const _32MDIV15: Self = Self(0x1100_0000);
            #[doc = "32 MHz / 11 = 2.9090909 MHz"]
            pub const _32MDIV11: Self = Self(0x1600_0000);
            #[doc = "32 MHz / 10 = 3.2 MHz"]
            pub const _32MDIV10: Self = Self(0x1800_0000);
            #[doc = "32 MHz / 8 = 4.0 MHz"]
            pub const _32MDIV8: Self = Self(0x2000_0000);
        }
        impl Mckfreq {
            pub const fn from_bits(val: u32) -> Mckfreq {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x020c_0000 => f.write_str("_32MDIV125"),
                    0x0410_0000 => f.write_str("_32MDIV63"),
                    0x0600_0000 => f.write_str("_32MDIV42"),
                    0x0800_0000 => f.write_str("_32MDIV32"),
                    0x0840_0000 => f.write_str("_32MDIV31"),
                    0x0880_0000 => f.write_str("_32MDIV30"),
                    0x0b00_0000 => f.write_str("_32MDIV23"),
                    0x0c00_0000 => f.write_str("_32MDIV21"),
                    0x1000_0000 => f.write_str("_32MDIV16"),
                    0x1100_0000 => f.write_str("_32MDIV15"),
                    0x1600_0000 => f.write_str("_32MDIV11"),
                    0x1800_0000 => f.write_str("_32MDIV10"),
                    0x2000_0000 => f.write_str("_32MDIV8"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x020c_0000 => defmt::write!(f, "_32MDIV125"),
                    0x0410_0000 => defmt::write!(f, "_32MDIV63"),
                    0x0600_0000 => defmt::write!(f, "_32MDIV42"),
                    0x0800_0000 => defmt::write!(f, "_32MDIV32"),
                    0x0840_0000 => defmt::write!(f, "_32MDIV31"),
                    0x0880_0000 => defmt::write!(f, "_32MDIV30"),
                    0x0b00_0000 => defmt::write!(f, "_32MDIV23"),
                    0x0c00_0000 => defmt::write!(f, "_32MDIV21"),
                    0x1000_0000 => defmt::write!(f, "_32MDIV16"),
                    0x1100_0000 => defmt::write!(f, "_32MDIV15"),
                    0x1600_0000 => defmt::write!(f, "_32MDIV11"),
                    0x1800_0000 => defmt::write!(f, "_32MDIV10"),
                    0x2000_0000 => defmt::write!(f, "_32MDIV8"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Mckfreq {
            #[inline(always)]
            fn from(val: u32) -> Mckfreq {
                Mckfreq::from_bits(val)
            }
        }
        impl From<Mckfreq> for u32 {
            #[inline(always)]
            fn from(val: Mckfreq) -> u32 {
                Mckfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx."]
            MASTER = 0x0,
            #[doc = "Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx"]
            SLAVE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "LRCK = MCK / 32"]
            _32X = 0x0,
            #[doc = "LRCK = MCK / 48"]
            _48X = 0x01,
            #[doc = "LRCK = MCK / 64"]
            _64X = 0x02,
            #[doc = "LRCK = MCK / 96"]
            _96X = 0x03,
            #[doc = "LRCK = MCK / 128"]
            _128X = 0x04,
            #[doc = "LRCK = MCK / 192"]
            _192X = 0x05,
            #[doc = "LRCK = MCK / 256"]
            _256X = 0x06,
            #[doc = "LRCK = MCK / 384"]
            _384X = 0x07,
            #[doc = "LRCK = MCK / 512"]
            _512X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swidth {
            #[doc = "8 bit."]
            _8BIT = 0x0,
            #[doc = "16 bit."]
            _16BIT = 0x01,
            #[doc = "24 bit."]
            _24BIT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Swidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swidth {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swidth {
            #[inline(always)]
            fn from(val: u8) -> Swidth {
                Swidth::from_bits(val)
            }
        }
        impl From<Swidth> for u8 {
            #[inline(always)]
            fn from(val: Swidth) -> u8 {
                Swidth::to_bits(val)
            }
        }
    }
}
pub mod ipc {
    #[doc = "Interprocessor communication 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ipc {
        ptr: *mut u8,
    }
    unsafe impl Send for Ipc {}
    unsafe impl Sync for Ipc {}
    impl Ipc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Trigger events on IPC channel enabled in SEND_CNF\\[n\\]"]
        #[inline(always)]
        pub const fn tasks_send(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Subscribe configuration for task SEND\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_send(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Event received on one or more of the enabled IPC channels in RECEIVE_CNF\\[n\\]"]
        #[inline(always)]
        pub const fn events_receive(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event RECEIVE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_receive(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize + n * 4usize) as _)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Description collection: Send event configuration for TASKS_SEND\\[n\\]"]
        #[inline(always)]
        pub const fn send_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::SendCnf, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Receive event configuration for EVENTS_RECEIVE\\[n\\]"]
        #[inline(always)]
        pub const fn receive_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::ReceiveCnf, crate::common::RW> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0590usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: General purpose memory"]
        #[inline(always)]
        pub const fn gpmem(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0610usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RECEIVE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[0\\]"]
            #[inline(always)]
            pub const fn set_receive0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[1\\]"]
            #[inline(always)]
            pub const fn set_receive1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[2\\]"]
            #[inline(always)]
            pub const fn set_receive2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[3\\]"]
            #[inline(always)]
            pub const fn set_receive3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[4\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[4\\]"]
            #[inline(always)]
            pub const fn set_receive4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[5\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[5\\]"]
            #[inline(always)]
            pub const fn set_receive5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[6\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[6\\]"]
            #[inline(always)]
            pub const fn set_receive6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[7\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn receive7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RECEIVE\\[7\\]"]
            #[inline(always)]
            pub const fn set_receive7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("receive0", &self.receive0())
                    .field("receive1", &self.receive1())
                    .field("receive2", &self.receive2())
                    .field("receive3", &self.receive3())
                    .field("receive4", &self.receive4())
                    .field("receive5", &self.receive5())
                    .field("receive6", &self.receive6())
                    .field("receive7", &self.receive7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ receive0: {=bool:?}, receive1: {=bool:?}, receive2: {=bool:?}, receive3: {=bool:?}, receive4: {=bool:?}, receive5: {=bool:?}, receive6: {=bool:?}, receive7: {=bool:?} }}" , self . receive0 () , self . receive1 () , self . receive2 () , self . receive3 () , self . receive4 () , self . receive5 () , self . receive6 () , self . receive7 ())
            }
        }
        #[doc = "Description collection: Receive event configuration for EVENTS_RECEIVE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ReceiveCnf(pub u32);
        impl ReceiveCnf {
            #[doc = "Enable subscription to IPC channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn chen0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 0"]
            #[inline(always)]
            pub const fn set_chen0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable subscription to IPC channel 1"]
            #[must_use]
            #[inline(always)]
            pub const fn chen1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 1"]
            #[inline(always)]
            pub const fn set_chen1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable subscription to IPC channel 2"]
            #[must_use]
            #[inline(always)]
            pub const fn chen2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 2"]
            #[inline(always)]
            pub const fn set_chen2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable subscription to IPC channel 3"]
            #[must_use]
            #[inline(always)]
            pub const fn chen3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 3"]
            #[inline(always)]
            pub const fn set_chen3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable subscription to IPC channel 4"]
            #[must_use]
            #[inline(always)]
            pub const fn chen4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 4"]
            #[inline(always)]
            pub const fn set_chen4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable subscription to IPC channel 5"]
            #[must_use]
            #[inline(always)]
            pub const fn chen5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 5"]
            #[inline(always)]
            pub const fn set_chen5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable subscription to IPC channel 6"]
            #[must_use]
            #[inline(always)]
            pub const fn chen6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 6"]
            #[inline(always)]
            pub const fn set_chen6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable subscription to IPC channel 7"]
            #[must_use]
            #[inline(always)]
            pub const fn chen7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable subscription to IPC channel 7"]
            #[inline(always)]
            pub const fn set_chen7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for ReceiveCnf {
            #[inline(always)]
            fn default() -> ReceiveCnf {
                ReceiveCnf(0)
            }
        }
        impl core::fmt::Debug for ReceiveCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ReceiveCnf")
                    .field("chen0", &self.chen0())
                    .field("chen1", &self.chen1())
                    .field("chen2", &self.chen2())
                    .field("chen3", &self.chen3())
                    .field("chen4", &self.chen4())
                    .field("chen5", &self.chen5())
                    .field("chen6", &self.chen6())
                    .field("chen7", &self.chen7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ReceiveCnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ReceiveCnf {{ chen0: {=bool:?}, chen1: {=bool:?}, chen2: {=bool:?}, chen3: {=bool:?}, chen4: {=bool:?}, chen5: {=bool:?}, chen6: {=bool:?}, chen7: {=bool:?} }}" , self . chen0 () , self . chen1 () , self . chen2 () , self . chen3 () , self . chen4 () , self . chen5 () , self . chen6 () , self . chen7 ())
            }
        }
        #[doc = "Description collection: Send event configuration for TASKS_SEND\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SendCnf(pub u32);
        impl SendCnf {
            #[doc = "Enable broadcasting on IPC channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn chen0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 0"]
            #[inline(always)]
            pub const fn set_chen0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable broadcasting on IPC channel 1"]
            #[must_use]
            #[inline(always)]
            pub const fn chen1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 1"]
            #[inline(always)]
            pub const fn set_chen1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable broadcasting on IPC channel 2"]
            #[must_use]
            #[inline(always)]
            pub const fn chen2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 2"]
            #[inline(always)]
            pub const fn set_chen2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable broadcasting on IPC channel 3"]
            #[must_use]
            #[inline(always)]
            pub const fn chen3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 3"]
            #[inline(always)]
            pub const fn set_chen3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable broadcasting on IPC channel 4"]
            #[must_use]
            #[inline(always)]
            pub const fn chen4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 4"]
            #[inline(always)]
            pub const fn set_chen4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable broadcasting on IPC channel 5"]
            #[must_use]
            #[inline(always)]
            pub const fn chen5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 5"]
            #[inline(always)]
            pub const fn set_chen5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable broadcasting on IPC channel 6"]
            #[must_use]
            #[inline(always)]
            pub const fn chen6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 6"]
            #[inline(always)]
            pub const fn set_chen6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable broadcasting on IPC channel 7"]
            #[must_use]
            #[inline(always)]
            pub const fn chen7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable broadcasting on IPC channel 7"]
            #[inline(always)]
            pub const fn set_chen7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for SendCnf {
            #[inline(always)]
            fn default() -> SendCnf {
                SendCnf(0)
            }
        }
        impl core::fmt::Debug for SendCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SendCnf")
                    .field("chen0", &self.chen0())
                    .field("chen1", &self.chen1())
                    .field("chen2", &self.chen2())
                    .field("chen3", &self.chen3())
                    .field("chen4", &self.chen4())
                    .field("chen5", &self.chen5())
                    .field("chen6", &self.chen6())
                    .field("chen7", &self.chen7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SendCnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SendCnf {{ chen0: {=bool:?}, chen1: {=bool:?}, chen2: {=bool:?}, chen3: {=bool:?}, chen4: {=bool:?}, chen5: {=bool:?}, chen6: {=bool:?}, chen7: {=bool:?} }}" , self . chen0 () , self . chen1 () , self . chen2 () , self . chen3 () , self . chen4 () , self . chen5 () , self . chen6 () , self . chen7 ())
            }
        }
    }
}
pub mod kmu {
    #[doc = "Key management unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kmu {
        ptr: *mut u8,
    }
    unsafe impl Send for Kmu {}
    unsafe impl Sync for Kmu {}
    impl Kmu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Push a key slot over secure APB"]
        #[inline(always)]
        pub const fn tasks_push_keyslot(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Key slot successfully pushed over secure APB"]
        #[inline(always)]
        pub const fn events_keyslot_pushed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Key slot has been revoked and cannot be tasked for selection"]
        #[inline(always)]
        pub const fn events_keyslot_revoked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "No key slot selected, no destination address defined, or error during push operation"]
        #[inline(always)]
        pub const fn events_keyslot_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x030cusize) as _) }
        }
        #[doc = "Status bits for KMU operation"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x040cusize) as _) }
        }
        #[doc = "Select key slot to be read over AHB or pushed over secure APB when TASKS_PUSH_KEYSLOT is started"]
        #[inline(always)]
        pub const fn selectkeyslot(
            self,
        ) -> crate::common::Reg<regs::Selectkeyslot, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event KEYSLOT_PUSHED"]
            #[must_use]
            #[inline(always)]
            pub const fn keyslot_pushed(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event KEYSLOT_PUSHED"]
            #[inline(always)]
            pub const fn set_keyslot_pushed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event KEYSLOT_REVOKED"]
            #[must_use]
            #[inline(always)]
            pub const fn keyslot_revoked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event KEYSLOT_REVOKED"]
            #[inline(always)]
            pub const fn set_keyslot_revoked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event KEYSLOT_ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn keyslot_error(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event KEYSLOT_ERROR"]
            #[inline(always)]
            pub const fn set_keyslot_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("keyslot_pushed", &self.keyslot_pushed())
                    .field("keyslot_revoked", &self.keyslot_revoked())
                    .field("keyslot_error", &self.keyslot_error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ keyslot_pushed: {=bool:?}, keyslot_revoked: {=bool:?}, keyslot_error: {=bool:?} }}" , self . keyslot_pushed () , self . keyslot_revoked () , self . keyslot_error ())
            }
        }
        #[doc = "Select key slot to be read over AHB or pushed over secure APB when TASKS_PUSH_KEYSLOT is started"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Selectkeyslot(pub u32);
        impl Selectkeyslot {
            #[doc = "Select key slot ID to be read over AHB, or pushed over secure APB, when TASKS_PUSH_KEYSLOT is started. NOTE: ID=0 is not a valid key slot ID. The 0 ID should be used when the KMU is idle or not in use. NOTE: Index N in UICR-&gt;KEYSLOT.KEY\\[N\\] and UICR-&gt;KEYSLOT.CONFIG\\[N\\] corresponds to KMU key slot ID=N+1."]
            #[must_use]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select key slot ID to be read over AHB, or pushed over secure APB, when TASKS_PUSH_KEYSLOT is started. NOTE: ID=0 is not a valid key slot ID. The 0 ID should be used when the KMU is idle or not in use. NOTE: Index N in UICR-&gt;KEYSLOT.KEY\\[N\\] and UICR-&gt;KEYSLOT.CONFIG\\[N\\] corresponds to KMU key slot ID=N+1."]
            #[inline(always)]
            pub const fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Selectkeyslot {
            #[inline(always)]
            fn default() -> Selectkeyslot {
                Selectkeyslot(0)
            }
        }
        impl core::fmt::Debug for Selectkeyslot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Selectkeyslot")
                    .field("id", &self.id())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Selectkeyslot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Selectkeyslot {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "Status bits for KMU operation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Key slot ID successfully selected by the KMU"]
            #[must_use]
            #[inline(always)]
            pub const fn selected(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Key slot ID successfully selected by the KMU"]
            #[inline(always)]
            pub const fn set_selected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Violation status"]
            #[must_use]
            #[inline(always)]
            pub const fn blocked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Violation status"]
            #[inline(always)]
            pub const fn set_blocked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("selected", &self.selected())
                    .field("blocked", &self.blocked())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ selected: {=bool:?}, blocked: {=bool:?} }}",
                    self.selected(),
                    self.blocked()
                )
            }
        }
    }
}
pub mod nvmc {
    #[doc = "Non-volatile memory controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nvmc {
        ptr: *mut u8,
    }
    unsafe impl Send for Nvmc {}
    unsafe impl Sync for Nvmc {}
    impl Nvmc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Ready flag"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<regs::Ready, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Ready flag"]
        #[inline(always)]
        pub const fn readynext(self) -> crate::common::Reg<regs::Readynext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0408usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Register for erasing all non-volatile user memory"]
        #[inline(always)]
        pub const fn eraseall(self) -> crate::common::Reg<regs::Eraseall, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Register for partial erase configuration"]
        #[inline(always)]
        pub const fn erasepagepartialcfg(
            self,
        ) -> crate::common::Reg<regs::Erasepagepartialcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x051cusize) as _) }
        }
        #[doc = "I-code cache configuration register"]
        #[inline(always)]
        pub const fn icachecnf(self) -> crate::common::Reg<regs::Icachecnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "I-code cache hit counter"]
        #[inline(always)]
        pub const fn ihit(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0548usize) as _) }
        }
        #[doc = "I-code cache miss counter"]
        #[inline(always)]
        pub const fn imiss(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x054cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn configns(self) -> crate::common::Reg<regs::Configns, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0584usize) as _) }
        }
        #[doc = "Non-secure APPROTECT enable register"]
        #[inline(always)]
        pub const fn writeuicrns(self) -> crate::common::Reg<regs::Writeuicrns, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0588usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."]
            #[must_use]
            #[inline(always)]
            pub const fn wen(&self) -> super::vals::Wen {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Wen::from_bits(val as u8)
            }
            #[doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."]
            #[inline(always)]
            pub const fn set_wen(&mut self, val: super::vals::Wen) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config").field("wen", &self.wen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Config {{ wen: {:?} }}", self.wen())
            }
        }
        #[doc = "Unspecified"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Configns(pub u32);
        impl Configns {
            #[doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."]
            #[must_use]
            #[inline(always)]
            pub const fn wen(&self) -> super::vals::ConfignsWen {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ConfignsWen::from_bits(val as u8)
            }
            #[doc = "Program memory access mode. It is strongly recommended to only activate erase and write modes when they are actively used. Enabling write or erase will invalidate the cache and keep it invalidated."]
            #[inline(always)]
            pub const fn set_wen(&mut self, val: super::vals::ConfignsWen) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Configns {
            #[inline(always)]
            fn default() -> Configns {
                Configns(0)
            }
        }
        impl core::fmt::Debug for Configns {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Configns")
                    .field("wen", &self.wen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Configns {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Configns {{ wen: {:?} }}", self.wen())
            }
        }
        #[doc = "Register for erasing all non-volatile user memory"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eraseall(pub u32);
        impl Eraseall {
            #[doc = "Erase all non-volatile memory including UICR registers. Note that erasing must be enabled by setting CONFIG.WEN = Een before the non-volatile memory can be erased."]
            #[must_use]
            #[inline(always)]
            pub const fn eraseall(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Erase all non-volatile memory including UICR registers. Note that erasing must be enabled by setting CONFIG.WEN = Een before the non-volatile memory can be erased."]
            #[inline(always)]
            pub const fn set_eraseall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Eraseall {
            #[inline(always)]
            fn default() -> Eraseall {
                Eraseall(0)
            }
        }
        impl core::fmt::Debug for Eraseall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eraseall")
                    .field("eraseall", &self.eraseall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eraseall {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eraseall {{ eraseall: {=bool:?} }}", self.eraseall())
            }
        }
        #[doc = "Register for partial erase configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Erasepagepartialcfg(pub u32);
        impl Erasepagepartialcfg {
            #[doc = "Duration of the partial erase in milliseconds"]
            #[must_use]
            #[inline(always)]
            pub const fn duration(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Duration of the partial erase in milliseconds"]
            #[inline(always)]
            pub const fn set_duration(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Erasepagepartialcfg {
            #[inline(always)]
            fn default() -> Erasepagepartialcfg {
                Erasepagepartialcfg(0)
            }
        }
        impl core::fmt::Debug for Erasepagepartialcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Erasepagepartialcfg")
                    .field("duration", &self.duration())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Erasepagepartialcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Erasepagepartialcfg {{ duration: {=u8:?} }}",
                    self.duration()
                )
            }
        }
        #[doc = "I-code cache configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Icachecnf(pub u32);
        impl Icachecnf {
            #[doc = "Cache enable"]
            #[must_use]
            #[inline(always)]
            pub const fn cacheen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Cache enable"]
            #[inline(always)]
            pub const fn set_cacheen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Cache profiling enable"]
            #[must_use]
            #[inline(always)]
            pub const fn cacheprofen(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Cache profiling enable"]
            #[inline(always)]
            pub const fn set_cacheprofen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Icachecnf {
            #[inline(always)]
            fn default() -> Icachecnf {
                Icachecnf(0)
            }
        }
        impl core::fmt::Debug for Icachecnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Icachecnf")
                    .field("cacheen", &self.cacheen())
                    .field("cacheprofen", &self.cacheprofen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Icachecnf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Icachecnf {{ cacheen: {=bool:?}, cacheprofen: {=bool:?} }}",
                    self.cacheen(),
                    self.cacheprofen()
                )
            }
        }
        #[doc = "Ready flag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ready(pub u32);
        impl Ready {
            #[doc = "NVMC is ready or busy"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "NVMC is ready or busy"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ready {
            #[inline(always)]
            fn default() -> Ready {
                Ready(0)
            }
        }
        impl core::fmt::Debug for Ready {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ready")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ready {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ready {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Ready flag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynext(pub u32);
        impl Readynext {
            #[doc = "NVMC can accept a new write operation"]
            #[must_use]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "NVMC can accept a new write operation"]
            #[inline(always)]
            pub const fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Readynext {
            #[inline(always)]
            fn default() -> Readynext {
                Readynext(0)
            }
        }
        impl core::fmt::Debug for Readynext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynext")
                    .field("readynext", &self.readynext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynext {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Readynext {{ readynext: {=bool:?} }}", self.readynext())
            }
        }
        #[doc = "Non-secure APPROTECT enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writeuicrns(pub u32);
        impl Writeuicrns {
            #[doc = "Allow non-secure code to set APPROTECT"]
            #[must_use]
            #[inline(always)]
            pub const fn set(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Allow non-secure code to set APPROTECT"]
            #[inline(always)]
            pub const fn set_set(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Key to write in order to validate the write operation"]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::Key {
                let val = (self.0 >> 4usize) & 0x0fff_ffff;
                super::vals::Key::from_bits(val as u32)
            }
            #[doc = "Key to write in order to validate the write operation"]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::Key) {
                self.0 = (self.0 & !(0x0fff_ffff << 4usize))
                    | (((val.to_bits() as u32) & 0x0fff_ffff) << 4usize);
            }
        }
        impl Default for Writeuicrns {
            #[inline(always)]
            fn default() -> Writeuicrns {
                Writeuicrns(0)
            }
        }
        impl core::fmt::Debug for Writeuicrns {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writeuicrns")
                    .field("set", &self.set())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writeuicrns {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Writeuicrns {{ set: {=bool:?}, key: {:?} }}",
                    self.set(),
                    self.key()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfignsWen {
            #[doc = "Read only access"]
            REN = 0x0,
            #[doc = "Write enabled"]
            WEN = 0x01,
            #[doc = "Erase enabled"]
            EEN = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ConfignsWen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfignsWen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfignsWen {
            #[inline(always)]
            fn from(val: u8) -> ConfignsWen {
                ConfignsWen::from_bits(val)
            }
        }
        impl From<ConfignsWen> for u8 {
            #[inline(always)]
            fn from(val: ConfignsWen) -> u8 {
                ConfignsWen::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Key(u32);
        impl Key {
            #[doc = "Key value"]
            pub const KEYVALID: Self = Self(0x0afb_e5a7);
        }
        impl Key {
            pub const fn from_bits(val: u32) -> Key {
                Self(val & 0x0fff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Key {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0afb_e5a7 => f.write_str("KEYVALID"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Key {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0afb_e5a7 => defmt::write!(f, "KEYVALID"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Key {
            #[inline(always)]
            fn from(val: u32) -> Key {
                Key::from_bits(val)
            }
        }
        impl From<Key> for u32 {
            #[inline(always)]
            fn from(val: Key) -> u32 {
                Key::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Wen {
            #[doc = "Read only access"]
            REN = 0x0,
            #[doc = "Write enabled"]
            WEN = 0x01,
            #[doc = "Erase enabled"]
            EEN = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Partial erase enabled"]
            PEEN = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Wen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Wen {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Wen {
            #[inline(always)]
            fn from(val: u8) -> Wen {
                Wen::from_bits(val)
            }
        }
        impl From<Wen> for u8 {
            #[inline(always)]
            fn from(val: Wen) -> u8 {
                Wen::to_bits(val)
            }
        }
    }
}
pub mod pdm {
    #[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pdm {}
    unsafe impl Sync for Pdm {}
    impl Pdm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous PDM transfer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stops PDM transfer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "PDM transfer has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "PDM transfer has finished"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "PDM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "PDM clock generator control"]
        #[inline(always)]
        pub const fn pdmclkctrl(self) -> crate::common::Reg<regs::Pdmclkctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Defines the routing of the connected PDM microphones' signals"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Left output gain adjustment"]
        #[inline(always)]
        pub const fn gainl(self) -> crate::common::Reg<regs::Gainl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
        #[doc = "Right output gain adjustment"]
        #[inline(always)]
        pub const fn gainr(self) -> crate::common::Reg<regs::Gainr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x051cusize) as _) }
        }
        #[doc = "Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly."]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn sample(self) -> Sample {
            unsafe { Sample::from_ptr(self.ptr.wrapping_add(0x0560usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin number configuration for PDM CLK signal"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin number configuration for PDM DIN signal"]
        #[inline(always)]
        pub const fn din(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sample {
        ptr: *mut u8,
    }
    unsafe impl Send for Sample {}
    unsafe impl Sync for Sample {}
    impl Sample {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM address pointer to write samples to with EasyDMA"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PDM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PDM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PDM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Left output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainl(pub u32);
        impl Gainl {
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[must_use]
            #[inline(always)]
            pub const fn gainl(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[inline(always)]
            pub const fn set_gainl(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainl {
            #[inline(always)]
            fn default() -> Gainl {
                Gainl(0)
            }
        }
        impl core::fmt::Debug for Gainl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainl")
                    .field("gainl", &self.gainl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainl {{ gainl: {:?} }}", self.gainl())
            }
        }
        #[doc = "Right output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainr(pub u32);
        impl Gainr {
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[must_use]
            #[inline(always)]
            pub const fn gainr(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[inline(always)]
            pub const fn set_gainr(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainr {
            #[inline(always)]
            fn default() -> Gainr {
                Gainr(0)
            }
        }
        impl core::fmt::Debug for Gainr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainr")
                    .field("gainr", &self.gainr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainr {{ gainr: {:?} }}", self.gainr())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ started: {=bool:?}, stopped: {=bool:?}, end: {=bool:?} }}",
                    self.started(),
                    self.stopped(),
                    self.end()
                )
            }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[must_use]
            #[inline(always)]
            pub const fn buffsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[inline(always)]
            pub const fn set_buffsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("buffsize", &self.buffsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ buffsize: {=u16:?} }}", self.buffsize())
            }
        }
        #[doc = "Defines the routing of the connected PDM microphones' signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Mono or stereo operation"]
            #[must_use]
            #[inline(always)]
            pub const fn operation(&self) -> super::vals::Operation {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Operation::from_bits(val as u8)
            }
            #[doc = "Mono or stereo operation"]
            #[inline(always)]
            pub const fn set_operation(&mut self, val: super::vals::Operation) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled"]
            #[must_use]
            #[inline(always)]
            pub const fn edge(&self) -> super::vals::Edge {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Edge::from_bits(val as u8)
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled"]
            #[inline(always)]
            pub const fn set_edge(&mut self, val: super::vals::Edge) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("operation", &self.operation())
                    .field("edge", &self.edge())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ operation: {:?}, edge: {:?} }}",
                    self.operation(),
                    self.edge()
                )
            }
        }
        #[doc = "PDM clock generator control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdmclkctrl(pub u32);
        impl Pdmclkctrl {
            #[doc = "PDM_CLK frequency configuration."]
            #[must_use]
            #[inline(always)]
            pub const fn freq(&self) -> super::vals::Freq {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Freq::from_bits(val as u32)
            }
            #[doc = "PDM_CLK frequency configuration."]
            #[inline(always)]
            pub const fn set_freq(&mut self, val: super::vals::Freq) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Pdmclkctrl {
            #[inline(always)]
            fn default() -> Pdmclkctrl {
                Pdmclkctrl(0)
            }
        }
        impl core::fmt::Debug for Pdmclkctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdmclkctrl")
                    .field("freq", &self.freq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdmclkctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pdmclkctrl {{ freq: {:?} }}", self.freq())
            }
        }
        #[doc = "Selects the ratio between PDM_CLK and output sample rate. Change PDMCLKCTRL accordingly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "Selects the ratio between PDM_CLK and output sample rate"]
            #[must_use]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "Selects the ratio between PDM_CLK and output sample rate"]
            #[inline(always)]
            pub const fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ratio {{ ratio: {:?} }}", self.ratio())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edge {
            #[doc = "Left (or mono) is sampled on falling edge of PDM_CLK"]
            LEFT_FALLING = 0x0,
            #[doc = "Left (or mono) is sampled on rising edge of PDM_CLK"]
            LEFT_RISING = 0x01,
        }
        impl Edge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edge {
            #[inline(always)]
            fn from(val: u8) -> Edge {
                Edge::from_bits(val)
            }
        }
        impl From<Edge> for u8 {
            #[inline(always)]
            fn from(val: Edge) -> u8 {
                Edge::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Freq(u32);
        impl Freq {
            #[doc = "PDM_CLK = 32 MHz / 32 = 1.000 MHz"]
            pub const _1000K: Self = Self(0x0800_0000);
            #[doc = "PDM_CLK = 32 MHz / 31 = 1.032 MHz. Nominal clock for RATIO=Ratio64."]
            pub const DEFAULT: Self = Self(0x0840_0000);
            #[doc = "PDM_CLK = 32 MHz / 30 = 1.067 MHz"]
            pub const _1067K: Self = Self(0x0880_0000);
            #[doc = "PDM_CLK = 32 MHz / 26 = 1.231 MHz"]
            pub const _1231K: Self = Self(0x0980_0000);
            #[doc = "PDM_CLK = 32 MHz / 25 = 1.280 MHz. Nominal clock for RATIO=Ratio80."]
            pub const _1280K: Self = Self(0x0a00_0000);
            #[doc = "PDM_CLK = 32 MHz / 24 = 1.333 MHz"]
            pub const _1333K: Self = Self(0x0a80_0000);
        }
        impl Freq {
            pub const fn from_bits(val: u32) -> Freq {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Freq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0800_0000 => f.write_str("_1000K"),
                    0x0840_0000 => f.write_str("DEFAULT"),
                    0x0880_0000 => f.write_str("_1067K"),
                    0x0980_0000 => f.write_str("_1231K"),
                    0x0a00_0000 => f.write_str("_1280K"),
                    0x0a80_0000 => f.write_str("_1333K"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freq {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0800_0000 => defmt::write!(f, "_1000K"),
                    0x0840_0000 => defmt::write!(f, "DEFAULT"),
                    0x0880_0000 => defmt::write!(f, "_1067K"),
                    0x0980_0000 => defmt::write!(f, "_1231K"),
                    0x0a00_0000 => defmt::write!(f, "_1280K"),
                    0x0a80_0000 => defmt::write!(f, "_1333K"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Freq {
            #[inline(always)]
            fn from(val: u32) -> Freq {
                Freq::from_bits(val)
            }
        }
        impl From<Freq> for u32 {
            #[inline(always)]
            fn from(val: Freq) -> u32 {
                Freq::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Gain(u8);
        impl Gain {
            #[doc = "-20 dB gain adjustment (minimum)"]
            pub const MIN_GAIN: Self = Self(0x0);
            #[doc = "0 dB gain adjustment"]
            pub const DEFAULT_GAIN: Self = Self(0x28);
            #[doc = "+20 dB gain adjustment (maximum)"]
            pub const MAX_GAIN: Self = Self(0x50);
        }
        impl Gain {
            pub const fn from_bits(val: u8) -> Gain {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_GAIN"),
                    0x28 => f.write_str("DEFAULT_GAIN"),
                    0x50 => f.write_str("MAX_GAIN"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_GAIN"),
                    0x28 => defmt::write!(f, "DEFAULT_GAIN"),
                    0x50 => defmt::write!(f, "MAX_GAIN"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Operation {
            #[doc = "Sample and store one pair (left + right) of 16-bit samples per RAM word R=\\[31:16\\]; L=\\[15:0\\]"]
            STEREO = 0x0,
            #[doc = "Sample and store two successive left samples (16 bits each) per RAM word L1=\\[31:16\\]; L0=\\[15:0\\]"]
            MONO = 0x01,
        }
        impl Operation {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Operation {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Operation {
            #[inline(always)]
            fn from(val: u8) -> Operation {
                Operation::from_bits(val)
            }
        }
        impl From<Operation> for u8 {
            #[inline(always)]
            fn from(val: Operation) -> u8 {
                Operation::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "Ratio of 64"]
            RATIO64 = 0x0,
            #[doc = "Ratio of 80"]
            RATIO80 = 0x01,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
    }
}
pub mod power {
    #[doc = "LTE Modem"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ltemodem {
        ptr: *mut u8,
    }
    unsafe impl Send for Ltemodem {}
    unsafe impl Sync for Ltemodem {}
    impl Ltemodem {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start LTE modem"]
        #[inline(always)]
        pub const fn startn(self) -> crate::common::Reg<regs::Startn, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Force off LTE modem"]
        #[inline(always)]
        pub const fn forceoff(self) -> crate::common::Reg<regs::Forceoff, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Power control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable constant latency mode."]
        #[inline(always)]
        pub const fn tasks_constlat(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x78usize) as _) }
        }
        #[doc = "Enable low power mode (variable latency)"]
        #[inline(always)]
        pub const fn tasks_lowpwr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x7cusize) as _) }
        }
        #[doc = "Subscribe configuration for task CONSTLAT"]
        #[inline(always)]
        pub const fn subscribe_constlat(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xf8usize) as _) }
        }
        #[doc = "Subscribe configuration for task LOWPWR"]
        #[inline(always)]
        pub const fn subscribe_lowpwr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xfcusize) as _) }
        }
        #[doc = "Power failure warning"]
        #[inline(always)]
        pub const fn events_pofwarn(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "CPU entered WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepenter(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "CPU exited WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepexit(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Publish configuration for event POFWARN"]
        #[inline(always)]
        pub const fn publish_pofwarn(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPENTER"]
        #[inline(always)]
        pub const fn publish_sleepenter(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPEXIT"]
        #[inline(always)]
        pub const fn publish_sleepexit(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Reset reason"]
        #[inline(always)]
        pub const fn resetreas(self) -> crate::common::Reg<regs::Resetreas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Modem domain power status"]
        #[inline(always)]
        pub const fn powerstatus(self) -> crate::common::Reg<regs::Power, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[inline(always)]
        pub const fn gpregret(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Gpregret, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x051cusize + n * 4usize) as _)
            }
        }
        #[doc = "LTE Modem"]
        #[inline(always)]
        pub const fn ltemodem(self) -> Ltemodem {
            unsafe { Ltemodem::from_ptr(self.ptr.wrapping_add(0x0610usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Force off LTE modem"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Forceoff(pub u32);
        impl Forceoff {
            #[doc = "Force off LTE modem"]
            #[must_use]
            #[inline(always)]
            pub const fn forceoff(&self) -> super::vals::Forceoff {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Forceoff::from_bits(val as u8)
            }
            #[doc = "Force off LTE modem"]
            #[inline(always)]
            pub const fn set_forceoff(&mut self, val: super::vals::Forceoff) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Forceoff {
            #[inline(always)]
            fn default() -> Forceoff {
                Forceoff(0)
            }
        }
        impl core::fmt::Debug for Forceoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Forceoff")
                    .field("forceoff", &self.forceoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Forceoff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Forceoff {{ forceoff: {:?} }}", self.forceoff())
            }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gpregret(pub u32);
        impl Gpregret {
            #[doc = "General purpose retention register"]
            #[must_use]
            #[inline(always)]
            pub const fn gpregret(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "General purpose retention register"]
            #[inline(always)]
            pub const fn set_gpregret(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Gpregret {
            #[inline(always)]
            fn default() -> Gpregret {
                Gpregret(0)
            }
        }
        impl core::fmt::Debug for Gpregret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gpregret")
                    .field("gpregret", &self.gpregret())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gpregret {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gpregret {{ gpregret: {=u8:?} }}", self.gpregret())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[must_use]
            #[inline(always)]
            pub const fn pofwarn(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[inline(always)]
            pub const fn set_pofwarn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepenter(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[inline(always)]
            pub const fn set_sleepenter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepexit(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[inline(always)]
            pub const fn set_sleepexit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("pofwarn", &self.pofwarn())
                    .field("sleepenter", &self.sleepenter())
                    .field("sleepexit", &self.sleepexit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ pofwarn: {=bool:?}, sleepenter: {=bool:?}, sleepexit: {=bool:?} }}",
                    self.pofwarn(),
                    self.sleepenter(),
                    self.sleepexit()
                )
            }
        }
        #[doc = "Modem domain power status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Power(pub u32);
        impl Power {
            #[doc = "LTE modem domain status"]
            #[must_use]
            #[inline(always)]
            pub const fn ltemodem(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LTE modem domain status"]
            #[inline(always)]
            pub const fn set_ltemodem(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Power {
            #[inline(always)]
            fn default() -> Power {
                Power(0)
            }
        }
        impl core::fmt::Debug for Power {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Power")
                    .field("ltemodem", &self.ltemodem())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Power {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Power {{ ltemodem: {=bool:?} }}", self.ltemodem())
            }
        }
        #[doc = "Reset reason"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resetreas(pub u32);
        impl Resetreas {
            #[doc = "Reset from pin reset detected"]
            #[must_use]
            #[inline(always)]
            pub const fn resetpin(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from pin reset detected"]
            #[inline(always)]
            pub const fn set_resetpin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset from global watchdog detected"]
            #[must_use]
            #[inline(always)]
            pub const fn dog(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from global watchdog detected"]
            #[inline(always)]
            pub const fn set_dog(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode, when wakeup is triggered by DETECT signal from GPIO"]
            #[must_use]
            #[inline(always)]
            pub const fn off(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode, when wakeup is triggered by DETECT signal from GPIO"]
            #[inline(always)]
            pub const fn set_off(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode, when wakeup is triggered by entering debug interface mode"]
            #[must_use]
            #[inline(always)]
            pub const fn dif(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode, when wakeup is triggered by entering debug interface mode"]
            #[inline(always)]
            pub const fn set_dif(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Reset from AIRCR.SYSRESETREQ detected"]
            #[must_use]
            #[inline(always)]
            pub const fn sreq(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from AIRCR.SYSRESETREQ detected"]
            #[inline(always)]
            pub const fn set_sreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Reset from CPU lock-up detected"]
            #[must_use]
            #[inline(always)]
            pub const fn lockup(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from CPU lock-up detected"]
            #[inline(always)]
            pub const fn set_lockup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Reset triggered through CTRL-AP"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlap(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Reset triggered through CTRL-AP"]
            #[inline(always)]
            pub const fn set_ctrlap(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Resetreas {
            #[inline(always)]
            fn default() -> Resetreas {
                Resetreas(0)
            }
        }
        impl core::fmt::Debug for Resetreas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resetreas")
                    .field("resetpin", &self.resetpin())
                    .field("dog", &self.dog())
                    .field("off", &self.off())
                    .field("dif", &self.dif())
                    .field("sreq", &self.sreq())
                    .field("lockup", &self.lockup())
                    .field("ctrlap", &self.ctrlap())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resetreas {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Resetreas {{ resetpin: {=bool:?}, dog: {=bool:?}, off: {=bool:?}, dif: {=bool:?}, sreq: {=bool:?}, lockup: {=bool:?}, ctrlap: {=bool:?} }}" , self . resetpin () , self . dog () , self . off () , self . dif () , self . sreq () , self . lockup () , self . ctrlap ())
            }
        }
        #[doc = "Start LTE modem"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Startn(pub u32);
        impl Startn {
            #[doc = "Start LTE modem"]
            #[must_use]
            #[inline(always)]
            pub const fn startn(&self) -> super::vals::Startn {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Startn::from_bits(val as u8)
            }
            #[doc = "Start LTE modem"]
            #[inline(always)]
            pub const fn set_startn(&mut self, val: super::vals::Startn) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Startn {
            #[inline(always)]
            fn default() -> Startn {
                Startn(0)
            }
        }
        impl core::fmt::Debug for Startn {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Startn")
                    .field("startn", &self.startn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Startn {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Startn {{ startn: {:?} }}", self.startn())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Forceoff {
            #[doc = "Release force off"]
            RELEASE = 0x0,
            #[doc = "Hold force off active"]
            HOLD = 0x01,
        }
        impl Forceoff {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Forceoff {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Forceoff {
            #[inline(always)]
            fn from(val: u8) -> Forceoff {
                Forceoff::from_bits(val)
            }
        }
        impl From<Forceoff> for u8 {
            #[inline(always)]
            fn from(val: Forceoff) -> u8 {
                Forceoff::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Startn {
            #[doc = "Start LTE modem"]
            START = 0x0,
            #[doc = "Hold LTE modem disabled"]
            HOLD = 0x01,
        }
        impl Startn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Startn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Startn {
            #[inline(always)]
            fn from(val: u8) -> Startn {
                Startn::from_bits(val)
            }
        }
        impl From<Startn> for u8 {
            #[inline(always)]
            fn from(val: Startn) -> u8 {
                Startn::to_bits(val)
            }
        }
    }
}
pub mod pwm {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> DmaSeq {
            assert!(n < 2usize);
            unsafe { DmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 32usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaSeq {}
    unsafe impl Sync for DmaSeq {}
    impl DmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Beginning address in RAM of this sequence"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Number of values (duty cycles) in this sequence"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Cnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[inline(always)]
        pub const fn refresh(self) -> crate::common::Reg<regs::Refresh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[inline(always)]
        pub const fn enddelay(self) -> crate::common::Reg<regs::Enddelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Output pin select for PWM channel n"]
        #[inline(always)]
        pub const fn out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Pulse width modulation unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm {}
    unsafe impl Sync for Pwm {}
    impl Pwm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running."]
        #[inline(always)]
        pub const fn tasks_nextstep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task SEQSTART\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_seqstart(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize + n * 4usize) as _)
            }
        }
        #[doc = "Subscribe configuration for task NEXTSTEP"]
        #[inline(always)]
        pub const fn subscribe_nextstep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Response to STOP task, emitted when PWM pulses are no longer generated"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Description collection: First PWM period started on sequence n"]
        #[inline(always)]
        pub const fn events_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter"]
        #[inline(always)]
        pub const fn events_seqend(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize + n * 4usize) as _)
            }
        }
        #[doc = "Emitted at the end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"]
        #[inline(always)]
        pub const fn events_loopsdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQSTARTED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event SEQEND\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqend(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event PWMPERIODEND"]
        #[inline(always)]
        pub const fn publish_pwmperiodend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event LOOPSDONE"]
        #[inline(always)]
        pub const fn publish_loopsdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x019cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "PWM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[inline(always)]
        pub const fn countertop(self) -> crate::common::Reg<regs::Countertop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Configuration of the decoder"]
        #[inline(always)]
        pub const fn decoder(self) -> crate::common::Reg<regs::Decoder, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Number of playbacks of a loop"]
        #[inline(always)]
        pub const fn loop_(self) -> crate::common::Reg<regs::Loop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0520usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0560usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn seq(self, n: usize) -> TasksDmaSeq {
            assert!(n < 2usize);
            unsafe { TasksDmaSeq::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaSeq {}
    unsafe impl Sync for TasksDmaSeq {}
    impl TasksDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Loads the first PWM value on all enabled channels from sequence n, and starts playing that sequence at the rate defined in SEQ\\[n\\]REFRESH and/or DECODER.MODE. Causes PWM generation to start if not running."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Number of values (duty cycles) in this sequence"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnt(pub u32);
        impl Cnt {
            #[doc = "Number of values (duty cycles) in this sequence"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::CntCnt {
                let val = (self.0 >> 0usize) & 0x7fff;
                super::vals::CntCnt::from_bits(val as u16)
            }
            #[doc = "Number of values (duty cycles) in this sequence"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::CntCnt) {
                self.0 =
                    (self.0 & !(0x7fff << 0usize)) | (((val.to_bits() as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Cnt {
            #[inline(always)]
            fn default() -> Cnt {
                Cnt(0)
            }
        }
        impl core::fmt::Debug for Cnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnt").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cnt {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Countertop(pub u32);
        impl Countertop {
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[must_use]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[inline(always)]
            pub const fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Countertop {
            #[inline(always)]
            fn default() -> Countertop {
                Countertop(0)
            }
        }
        impl core::fmt::Debug for Countertop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Countertop")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Countertop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Countertop {{ countertop: {=u16:?} }}",
                    self.countertop()
                )
            }
        }
        #[doc = "Configuration of the decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Decoder(pub u32);
        impl Decoder {
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn load(&self) -> super::vals::Load {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Load::from_bits(val as u8)
            }
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[inline(always)]
            pub const fn set_load(&mut self, val: super::vals::Load) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Decoder {
            #[inline(always)]
            fn default() -> Decoder {
                Decoder(0)
            }
        }
        impl core::fmt::Debug for Decoder {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Decoder")
                    .field("load", &self.load())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Decoder {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Decoder {{ load: {:?}, mode: {:?} }}",
                    self.load(),
                    self.mode()
                )
            }
        }
        #[doc = "PWM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PWM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PWM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enddelay(pub u32);
        impl Enddelay {
            #[doc = "Time added after the sequence in PWM periods"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Time added after the sequence in PWM periods"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Enddelay {
            #[inline(always)]
            fn default() -> Enddelay {
                Enddelay(0)
            }
        }
        impl core::fmt::Debug for Enddelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enddelay")
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enddelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enddelay {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqstarted0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqstarted1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqend0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqend1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[inline(always)]
            pub const fn set_loopsdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("seqstarted0", &self.seqstarted0())
                    .field("seqstarted1", &self.seqstarted1())
                    .field("seqend0", &self.seqend0())
                    .field("seqend1", &self.seqend1())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .field("loopsdone", &self.loopsdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, seqstarted0: {=bool:?}, seqstarted1: {=bool:?}, seqend0: {=bool:?}, seqend1: {=bool:?}, pwmperiodend: {=bool:?}, loopsdone: {=bool:?} }}" , self . stopped () , self . seqstarted0 () , self . seqstarted1 () , self . seqend0 () , self . seqend1 () , self . pwmperiodend () , self . loopsdone ())
            }
        }
        #[doc = "Number of playbacks of a loop"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Loop(pub u32);
        impl Loop {
            #[doc = "Number of playbacks of pattern cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::LoopCnt {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::LoopCnt::from_bits(val as u16)
            }
            #[doc = "Number of playbacks of pattern cycles"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::LoopCnt) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Loop {
            #[inline(always)]
            fn default() -> Loop {
                Loop(0)
            }
        }
        impl core::fmt::Debug for Loop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Loop").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Loop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Loop {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[must_use]
            #[inline(always)]
            pub const fn updown(&self) -> super::vals::Updown {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Updown::from_bits(val as u8)
            }
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[inline(always)]
            pub const fn set_updown(&mut self, val: super::vals::Updown) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("updown", &self.updown())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ updown: {:?} }}", self.updown())
            }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler of PWM_CLK"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> super::vals::Prescaler {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Prescaler::from_bits(val as u8)
            }
            #[doc = "Prescaler of PWM_CLK"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: super::vals::Prescaler) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {:?} }}", self.prescaler())
            }
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refresh(pub u32);
        impl Refresh {
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::RefreshCnt {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                super::vals::RefreshCnt::from_bits(val as u32)
            }
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::RefreshCnt) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Refresh {
            #[inline(always)]
            fn default() -> Refresh {
                Refresh(0)
            }
        }
        impl core::fmt::Debug for Refresh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refresh").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refresh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refresh {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event SEQEND\\[0\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0_stop(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[0\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend0_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SEQEND\\[1\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[1\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend1_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task SEQSTART\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_dma_seq0_start(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task SEQSTART\\[0\\]"]
            #[inline(always)]
            pub const fn set_loopsdone_dma_seq0_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task SEQSTART\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_seqstart1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task SEQSTART\\[1\\]"]
            #[inline(always)]
            pub const fn set_loopsdone_seqstart1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[inline(always)]
            pub const fn set_loopsdone_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("seqend0_stop", &self.seqend0_stop())
                    .field("seqend1_stop", &self.seqend1_stop())
                    .field("loopsdone_dma_seq0_start", &self.loopsdone_dma_seq0_start())
                    .field("loopsdone_seqstart1", &self.loopsdone_seqstart1())
                    .field("loopsdone_stop", &self.loopsdone_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ seqend0_stop: {=bool:?}, seqend1_stop: {=bool:?}, loopsdone_dma_seq0_start: {=bool:?}, loopsdone_seqstart1: {=bool:?}, loopsdone_stop: {=bool:?} }}" , self . seqend0_stop () , self . seqend1_stop () , self . loopsdone_dma_seq0_start () , self . loopsdone_seqstart1 () , self . loopsdone_stop ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct CntCnt(u16);
        impl CntCnt {
            #[doc = "Sequence is disabled, and shall not be started as it is empty"]
            pub const DISABLED: Self = Self(0x0);
        }
        impl CntCnt {
            pub const fn from_bits(val: u16) -> CntCnt {
                Self(val & 0x7fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for CntCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CntCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for CntCnt {
            #[inline(always)]
            fn from(val: u16) -> CntCnt {
                CntCnt::from_bits(val)
            }
        }
        impl From<CntCnt> for u16 {
            #[inline(always)]
            fn from(val: CntCnt) -> u16 {
                CntCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Load {
            #[doc = "1st half word (16-bit) used in all PWM channels 0..3"]
            COMMON = 0x0,
            #[doc = "1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3"]
            GROUPED = 0x01,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3"]
            INDIVIDUAL = 0x02,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP"]
            WAVE_FORM = 0x03,
        }
        impl Load {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Load {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Load {
            #[inline(always)]
            fn from(val: u8) -> Load {
                Load::from_bits(val)
            }
        }
        impl From<Load> for u8 {
            #[inline(always)]
            fn from(val: Load) -> u8 {
                Load::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct LoopCnt(u16);
        impl LoopCnt {
            #[doc = "Looping disabled (stop at the end of the sequence)"]
            pub const DISABLED: Self = Self(0x0);
        }
        impl LoopCnt {
            pub const fn from_bits(val: u16) -> LoopCnt {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for LoopCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LoopCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for LoopCnt {
            #[inline(always)]
            fn from(val: u16) -> LoopCnt {
                LoopCnt::from_bits(val)
            }
        }
        impl From<LoopCnt> for u16 {
            #[inline(always)]
            fn from(val: LoopCnt) -> u16 {
                LoopCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "SEQ\\[n\\].REFRESH is used to determine loading internal compare registers"]
            REFRESH_COUNT = 0x0,
            #[doc = "NEXTSTEP task causes a new value to be loaded to internal compare registers"]
            NEXT_STEP = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prescaler {
            #[doc = "Divide by 1 (16 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (8 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (4 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (2 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (1 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (500 kHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (250 kHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (125 kHz)"]
            DIV_128 = 0x07,
        }
        impl Prescaler {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prescaler {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prescaler {
            #[inline(always)]
            fn from(val: u8) -> Prescaler {
                Prescaler::from_bits(val)
            }
        }
        impl From<Prescaler> for u8 {
            #[inline(always)]
            fn from(val: Prescaler) -> u8 {
                Prescaler::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct RefreshCnt(u32);
        impl RefreshCnt {
            #[doc = "Update every PWM period"]
            pub const CONTINUOUS: Self = Self(0x0);
        }
        impl RefreshCnt {
            pub const fn from_bits(val: u32) -> RefreshCnt {
                Self(val & 0x00ff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for RefreshCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("CONTINUOUS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RefreshCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "CONTINUOUS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for RefreshCnt {
            #[inline(always)]
            fn from(val: u32) -> RefreshCnt {
                RefreshCnt::from_bits(val)
            }
        }
        impl From<RefreshCnt> for u32 {
            #[inline(always)]
            fn from(val: RefreshCnt) -> u32 {
                RefreshCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Updown {
            #[doc = "Up counter, edge-aligned PWM duty cycle"]
            UP = 0x0,
            #[doc = "Up and down counter, center-aligned PWM duty cycle"]
            UP_AND_DOWN = 0x01,
        }
        impl Updown {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Updown {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Updown {
            #[inline(always)]
            fn from(val: u8) -> Updown {
                Updown::from_bits(val)
            }
        }
        impl From<Updown> for u8 {
            #[inline(always)]
            fn from(val: Updown) -> u8 {
                Updown::to_bits(val)
            }
        }
    }
}
pub mod regulators {
    #[doc = "Voltage regulators control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Regulators {
        ptr: *mut u8,
    }
    unsafe impl Send for Regulators {}
    unsafe impl Sync for Regulators {}
    impl Regulators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System OFF register"]
        #[inline(always)]
        pub const fn systemoff(self) -> crate::common::Reg<regs::Systemoff, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "External power failure warning configuration"]
        #[inline(always)]
        pub const fn extpofcon(self) -> crate::common::Reg<regs::Extpofcon, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize) as _) }
        }
        #[doc = "Enable a step-down DC/DC voltage regulator."]
        #[inline(always)]
        pub const fn dcdcen(self) -> crate::common::Reg<regs::Dcdcen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0578usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable a step-down DC/DC voltage regulator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcdcen(pub u32);
        impl Dcdcen {
            #[doc = "Enable DC/DC buck regulator"]
            #[must_use]
            #[inline(always)]
            pub const fn dcdcen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable DC/DC buck regulator"]
            #[inline(always)]
            pub const fn set_dcdcen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dcdcen {
            #[inline(always)]
            fn default() -> Dcdcen {
                Dcdcen(0)
            }
        }
        impl core::fmt::Debug for Dcdcen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcdcen")
                    .field("dcdcen", &self.dcdcen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcdcen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dcdcen {{ dcdcen: {=bool:?} }}", self.dcdcen())
            }
        }
        #[doc = "External power failure warning configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extpofcon(pub u32);
        impl Extpofcon {
            #[doc = "Enable or disable external power failure warning"]
            #[must_use]
            #[inline(always)]
            pub const fn pof(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable external power failure warning"]
            #[inline(always)]
            pub const fn set_pof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Extpofcon {
            #[inline(always)]
            fn default() -> Extpofcon {
                Extpofcon(0)
            }
        }
        impl core::fmt::Debug for Extpofcon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extpofcon")
                    .field("pof", &self.pof())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extpofcon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Extpofcon {{ pof: {=bool:?} }}", self.pof())
            }
        }
        #[doc = "System OFF register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Systemoff(pub u32);
        impl Systemoff {
            #[doc = "Enable System OFF mode"]
            #[must_use]
            #[inline(always)]
            pub const fn systemoff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable System OFF mode"]
            #[inline(always)]
            pub const fn set_systemoff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Systemoff {
            #[inline(always)]
            fn default() -> Systemoff {
                Systemoff(0)
            }
        }
        impl core::fmt::Debug for Systemoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Systemoff")
                    .field("systemoff", &self.systemoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Systemoff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Systemoff {{ systemoff: {=bool:?} }}", self.systemoff())
            }
        }
    }
}
pub mod rtc {
    #[doc = "Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start RTC counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop RTC counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Clear RTC counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Set counter to 0xFFFFF0"]
        #[inline(always)]
        pub const fn tasks_trigovrflw(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task TRIGOVRFLW"]
        #[inline(always)]
        pub const fn subscribe_trigovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Event on counter increment"]
        #[inline(always)]
        pub const fn events_tick(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Event on counter overflow"]
        #[inline(always)]
        pub const fn events_ovrflw(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize + n * 4usize) as _)
            }
        }
        #[doc = "Publish configuration for event TICK"]
        #[inline(always)]
        pub const fn publish_tick(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event OVRFLW"]
        #[inline(always)]
        pub const fn publish_ovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c0usize + n * 4usize) as _)
            }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0340usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0344usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0348usize) as _) }
        }
        #[doc = "Current counter value"]
        #[inline(always)]
        pub const fn counter(self) -> crate::common::Reg<regs::Counter, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "12-bit prescaler for counter frequency (32768/(PRESCALER+1)). Must be written when RTC is stopped."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Compare register n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "Compare value"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Compare value"]
            #[inline(always)]
            pub const fn set_compare(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("compare", &self.compare())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cc {{ compare: {=u32:?} }}", self.compare())
            }
        }
        #[doc = "Current counter value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Counter(pub u32);
        impl Counter {
            #[doc = "Counter value"]
            #[must_use]
            #[inline(always)]
            pub const fn counter(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Counter value"]
            #[inline(always)]
            pub const fn set_counter(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Counter {
            #[inline(always)]
            fn default() -> Counter {
                Counter(0)
            }
        }
        impl core::fmt::Debug for Counter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Counter")
                    .field("counter", &self.counter())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Counter {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Counter {{ counter: {=u32:?} }}", self.counter())
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event TICK"]
            #[must_use]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event TICK"]
            #[inline(always)]
            pub const fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[must_use]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[inline(always)]
            pub const fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Evt {{ tick: {=bool:?}, ovrflw: {=bool:?}, compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?} }}" , self . tick () , self . ovrflw () , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize))
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[must_use]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[inline(always)]
            pub const fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[must_use]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[inline(always)]
            pub const fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ tick: {=bool:?}, ovrflw: {=bool:?}, compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?} }}" , self . tick () , self . ovrflw () , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize))
            }
        }
        #[doc = "12-bit prescaler for counter frequency (32768/(PRESCALER+1)). Must be written when RTC is stopped."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {=u16:?} }}", self.prescaler())
            }
        }
    }
}
pub mod saadc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ch {
        ptr: *mut u8,
    }
    unsafe impl Send for Ch {}
    unsafe impl Sync for Ch {}
    impl Ch {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pselp(self) -> crate::common::Reg<regs::Pselp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pseln(self) -> crate::common::Reg<regs::Pseln, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsCh {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsCh {}
    unsafe impl Sync for EventsCh {}
    impl EventsCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Last results is equal or above CH\\[n\\].LIMIT.HIGH"]
        #[inline(always)]
        pub const fn limith(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Last results is equal or below CH\\[n\\].LIMIT.LOW"]
        #[inline(always)]
        pub const fn limitl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishCh {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishCh {}
    unsafe impl Sync for PublishCh {}
    impl PublishCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITH"]
        #[inline(always)]
        pub const fn limith(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITL"]
        #[inline(always)]
        pub const fn limitl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "RESULT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Result {
        ptr: *mut u8,
    }
    unsafe impl Send for Result {}
    unsafe impl Sync for Result {}
    impl Result {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of buffer words to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of buffer words transferred since last START"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Analog to Digital Converter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Saadc {
        ptr: *mut u8,
    }
    unsafe impl Send for Saadc {}
    unsafe impl Sync for Saadc {}
    impl Saadc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the ADC and prepare the result buffer in RAM"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Take one ADC sample, if scan is enabled all channels are sampled"]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Stop the ADC and terminate any on-going conversion"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Starts offset auto-calibration"]
        #[inline(always)]
        pub const fn tasks_calibrateoffset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CALIBRATEOFFSET"]
        #[inline(always)]
        pub const fn subscribe_calibrateoffset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "The ADC has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "The ADC has filled up the Result buffer"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM."]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "A result is ready to get transferred to RAM."]
        #[inline(always)]
        pub const fn events_resultdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x010cusize) as _) }
        }
        #[doc = "Calibration is complete"]
        #[inline(always)]
        pub const fn events_calibratedone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "The ADC has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0114usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_ch(self, n: usize) -> EventsCh {
            assert!(n < 8usize);
            unsafe { EventsCh::from_ptr(self.ptr.wrapping_add(0x0118usize + n * 8usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event RESULTDONE"]
        #[inline(always)]
        pub const fn publish_resultdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event CALIBRATEDONE"]
        #[inline(always)]
        pub const fn publish_calibratedone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_ch(self, n: usize) -> PublishCh {
            assert!(n < 8usize);
            unsafe { PublishCh::from_ptr(self.ptr.wrapping_add(0x0198usize + n * 8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Enable or disable ADC"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> Ch {
            assert!(n < 8usize);
            unsafe { Ch::from_ptr(self.ptr.wrapping_add(0x0510usize + n * 16usize) as _) }
        }
        #[doc = "Resolution configuration"]
        #[inline(always)]
        pub const fn resolution(self) -> crate::common::Reg<regs::Resolution, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f0usize) as _) }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[inline(always)]
        pub const fn oversample(self) -> crate::common::Reg<regs::Oversample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f4usize) as _) }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[inline(always)]
        pub const fn samplerate(self) -> crate::common::Reg<regs::Samplerate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05f8usize) as _) }
        }
        #[doc = "RESULT EasyDMA channel"]
        #[inline(always)]
        pub const fn result(self) -> Result {
            unsafe { Result::from_ptr(self.ptr.wrapping_add(0x062cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of buffer words transferred since last START"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of buffer words transferred since last START. This register can be read after an END or STOPPED event."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer words transferred since last START. This register can be read after an END or STOPPED event."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Positive channel resistor control"]
            #[must_use]
            #[inline(always)]
            pub const fn resp(&self) -> super::vals::Resp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Resp::from_bits(val as u8)
            }
            #[doc = "Positive channel resistor control"]
            #[inline(always)]
            pub const fn set_resp(&mut self, val: super::vals::Resp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Negative channel resistor control"]
            #[must_use]
            #[inline(always)]
            pub const fn resn(&self) -> super::vals::Resn {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Resn::from_bits(val as u8)
            }
            #[doc = "Negative channel resistor control"]
            #[inline(always)]
            pub const fn set_resn(&mut self, val: super::vals::Resn) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Gain control"]
            #[must_use]
            #[inline(always)]
            pub const fn gain(&self) -> super::vals::Gain {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Gain control"]
            #[inline(always)]
            pub const fn set_gain(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Reference control"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference control"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage"]
            #[must_use]
            #[inline(always)]
            pub const fn tacq(&self) -> super::vals::Tacq {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Tacq::from_bits(val as u8)
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage"]
            #[inline(always)]
            pub const fn set_tacq(&mut self, val: super::vals::Tacq) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Enable differential mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::ConfigMode {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::ConfigMode::from_bits(val as u8)
            }
            #[doc = "Enable differential mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::ConfigMode) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable burst mode"]
            #[must_use]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable burst mode"]
            #[inline(always)]
            pub const fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("resp", &self.resp())
                    .field("resn", &self.resn())
                    .field("gain", &self.gain())
                    .field("refsel", &self.refsel())
                    .field("tacq", &self.tacq())
                    .field("mode", &self.mode())
                    .field("burst", &self.burst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ resp: {:?}, resn: {:?}, gain: {:?}, refsel: {:?}, tacq: {:?}, mode: {:?}, burst: {=bool:?} }}" , self . resp () , self . resn () , self . gain () , self . refsel () , self . tacq () , self . mode () , self . burst ())
            }
        }
        #[doc = "Enable or disable ADC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable ADC"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable ADC"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[must_use]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn resultdone(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[inline(always)]
            pub const fn set_resultdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn calibratedone(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[inline(always)]
            pub const fn set_calibratedone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimith(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[inline(always)]
            pub const fn set_chlimith(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimitl(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[inline(always)]
            pub const fn set_chlimitl(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("end", &self.end())
                    .field("done", &self.done())
                    .field("resultdone", &self.resultdone())
                    .field("calibratedone", &self.calibratedone())
                    .field("stopped", &self.stopped())
                    .field("chlimith[0]", &self.chlimith(0usize))
                    .field("chlimith[1]", &self.chlimith(1usize))
                    .field("chlimith[2]", &self.chlimith(2usize))
                    .field("chlimith[3]", &self.chlimith(3usize))
                    .field("chlimith[4]", &self.chlimith(4usize))
                    .field("chlimith[5]", &self.chlimith(5usize))
                    .field("chlimith[6]", &self.chlimith(6usize))
                    .field("chlimith[7]", &self.chlimith(7usize))
                    .field("chlimitl[0]", &self.chlimitl(0usize))
                    .field("chlimitl[1]", &self.chlimitl(1usize))
                    .field("chlimitl[2]", &self.chlimitl(2usize))
                    .field("chlimitl[3]", &self.chlimitl(3usize))
                    .field("chlimitl[4]", &self.chlimitl(4usize))
                    .field("chlimitl[5]", &self.chlimitl(5usize))
                    .field("chlimitl[6]", &self.chlimitl(6usize))
                    .field("chlimitl[7]", &self.chlimitl(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, end: {=bool:?}, done: {=bool:?}, resultdone: {=bool:?}, calibratedone: {=bool:?}, stopped: {=bool:?}, chlimith[0]: {=bool:?}, chlimith[1]: {=bool:?}, chlimith[2]: {=bool:?}, chlimith[3]: {=bool:?}, chlimith[4]: {=bool:?}, chlimith[5]: {=bool:?}, chlimith[6]: {=bool:?}, chlimith[7]: {=bool:?}, chlimitl[0]: {=bool:?}, chlimitl[1]: {=bool:?}, chlimitl[2]: {=bool:?}, chlimitl[3]: {=bool:?}, chlimitl[4]: {=bool:?}, chlimitl[5]: {=bool:?}, chlimitl[6]: {=bool:?}, chlimitl[7]: {=bool:?} }}" , self . started () , self . end () , self . done () , self . resultdone () , self . calibratedone () , self . stopped () , self . chlimith (0usize) , self . chlimith (1usize) , self . chlimith (2usize) , self . chlimith (3usize) , self . chlimith (4usize) , self . chlimith (5usize) , self . chlimith (6usize) , self . chlimith (7usize) , self . chlimitl (0usize) , self . chlimitl (1usize) , self . chlimitl (2usize) , self . chlimitl (3usize) , self . chlimitl (4usize) , self . chlimitl (5usize) , self . chlimitl (6usize) , self . chlimitl (7usize))
            }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "Low level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Low level limit"]
            #[inline(always)]
            pub const fn set_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "High level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn high(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "High level limit"]
            #[inline(always)]
            pub const fn set_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("low", &self.low())
                    .field("high", &self.high())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Limit {{ low: {=u16:?}, high: {=u16:?} }}",
                    self.low(),
                    self.high()
                )
            }
        }
        #[doc = "Maximum number of buffer words to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of buffer words to transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum number of buffer words to transfer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oversample(pub u32);
        impl Oversample {
            #[doc = "Oversample control"]
            #[must_use]
            #[inline(always)]
            pub const fn oversample(&self) -> super::vals::Oversample {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Oversample::from_bits(val as u8)
            }
            #[doc = "Oversample control"]
            #[inline(always)]
            pub const fn set_oversample(&mut self, val: super::vals::Oversample) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Oversample {
            #[inline(always)]
            fn default() -> Oversample {
                Oversample(0)
            }
        }
        impl core::fmt::Debug for Oversample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oversample")
                    .field("oversample", &self.oversample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oversample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oversample {{ oversample: {:?} }}", self.oversample())
            }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pseln(pub u32);
        impl Pseln {
            #[doc = "Analog negative input, enables differential channel"]
            #[must_use]
            #[inline(always)]
            pub const fn pseln(&self) -> super::vals::Psel {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Psel::from_bits(val as u8)
            }
            #[doc = "Analog negative input, enables differential channel"]
            #[inline(always)]
            pub const fn set_pseln(&mut self, val: super::vals::Psel) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Pseln {
            #[inline(always)]
            fn default() -> Pseln {
                Pseln(0)
            }
        }
        impl core::fmt::Debug for Pseln {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pseln")
                    .field("pseln", &self.pseln())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pseln {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pseln {{ pseln: {:?} }}", self.pseln())
            }
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pselp(pub u32);
        impl Pselp {
            #[doc = "Analog positive input channel"]
            #[must_use]
            #[inline(always)]
            pub const fn pselp(&self) -> super::vals::Psel {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Psel::from_bits(val as u8)
            }
            #[doc = "Analog positive input channel"]
            #[inline(always)]
            pub const fn set_pselp(&mut self, val: super::vals::Psel) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Pselp {
            #[inline(always)]
            fn default() -> Pselp {
                Pselp(0)
            }
        }
        impl core::fmt::Debug for Pselp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pselp")
                    .field("pselp", &self.pselp())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pselp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pselp {{ pselp: {:?} }}", self.pselp())
            }
        }
        #[doc = "Resolution configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resolution(pub u32);
        impl Resolution {
            #[doc = "Set the resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> super::vals::Val {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Val::from_bits(val as u8)
            }
            #[doc = "Set the resolution"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: super::vals::Val) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Resolution {
            #[inline(always)]
            fn default() -> Resolution {
                Resolution(0)
            }
        }
        impl core::fmt::Debug for Resolution {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resolution")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resolution {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Resolution {{ val: {:?} }}", self.val())
            }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Samplerate(pub u32);
        impl Samplerate {
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[must_use]
            #[inline(always)]
            pub const fn cc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[inline(always)]
            pub const fn set_cc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Select mode for sample rate control"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::SamplerateMode {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::SamplerateMode::from_bits(val as u8)
            }
            #[doc = "Select mode for sample rate control"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::SamplerateMode) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Samplerate {
            #[inline(always)]
            fn default() -> Samplerate {
                Samplerate(0)
            }
        }
        impl core::fmt::Debug for Samplerate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Samplerate")
                    .field("cc", &self.cc())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Samplerate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Samplerate {{ cc: {=u16:?}, mode: {:?} }}",
                    self.cc(),
                    self.mode()
                )
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "Status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigMode {
            #[doc = "Single ended, PSELN will be ignored, negative input to ADC shorted to GND"]
            SE = 0x0,
            #[doc = "Differential"]
            DIFF = 0x01,
        }
        impl ConfigMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigMode {
            #[inline(always)]
            fn from(val: u8) -> ConfigMode {
                ConfigMode::from_bits(val)
            }
        }
        impl From<ConfigMode> for u8 {
            #[inline(always)]
            fn from(val: ConfigMode) -> u8 {
                ConfigMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain {
            #[doc = "1/6"]
            GAIN1_6 = 0x0,
            #[doc = "1/5"]
            GAIN1_5 = 0x01,
            #[doc = "1/4"]
            GAIN1_4 = 0x02,
            #[doc = "1/3"]
            GAIN1_3 = 0x03,
            #[doc = "1/2"]
            GAIN1_2 = 0x04,
            #[doc = "1"]
            GAIN1 = 0x05,
            #[doc = "2"]
            GAIN2 = 0x06,
            #[doc = "4"]
            GAIN4 = 0x07,
        }
        impl Gain {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oversample {
            #[doc = "Bypass oversampling"]
            BYPASS = 0x0,
            #[doc = "Oversample 2x"]
            OVER2X = 0x01,
            #[doc = "Oversample 4x"]
            OVER4X = 0x02,
            #[doc = "Oversample 8x"]
            OVER8X = 0x03,
            #[doc = "Oversample 16x"]
            OVER16X = 0x04,
            #[doc = "Oversample 32x"]
            OVER32X = 0x05,
            #[doc = "Oversample 64x"]
            OVER64X = 0x06,
            #[doc = "Oversample 128x"]
            OVER128X = 0x07,
            #[doc = "Oversample 256x"]
            OVER256X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Oversample {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oversample {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oversample {
            #[inline(always)]
            fn from(val: u8) -> Oversample {
                Oversample::from_bits(val)
            }
        }
        impl From<Oversample> for u8 {
            #[inline(always)]
            fn from(val: Oversample) -> u8 {
                Oversample::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Psel {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "AIN0"]
            ANALOG_INPUT0 = 0x01,
            #[doc = "AIN1"]
            ANALOG_INPUT1 = 0x02,
            #[doc = "AIN2"]
            ANALOG_INPUT2 = 0x03,
            #[doc = "AIN3"]
            ANALOG_INPUT3 = 0x04,
            #[doc = "AIN4"]
            ANALOG_INPUT4 = 0x05,
            #[doc = "AIN5"]
            ANALOG_INPUT5 = 0x06,
            #[doc = "AIN6"]
            ANALOG_INPUT6 = 0x07,
            #[doc = "AIN7"]
            ANALOG_INPUT7 = 0x08,
            #[doc = "VDD_GPIO"]
            VDD_GPIO = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Psel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Psel {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Psel {
            #[inline(always)]
            fn from(val: u8) -> Psel {
                Psel::from_bits(val)
            }
        }
        impl From<Psel> for u8 {
            #[inline(always)]
            fn from(val: Psel) -> u8 {
                Psel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "Internal reference (0.6 V)"]
            INTERNAL = 0x0,
            #[doc = "VDD_GPIO/4 as reference"]
            VDD1_4 = 0x01,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resn {
            #[doc = "Bypass resistor ladder"]
            BYPASS = 0x0,
            #[doc = "Pull-down to GND"]
            PULLDOWN = 0x01,
            #[doc = "Pull-up to VDD_GPIO"]
            PULLUP = 0x02,
            #[doc = "Set input at VDD_GPIO/2"]
            VDD1_2 = 0x03,
        }
        impl Resn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resn {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resn {
            #[inline(always)]
            fn from(val: u8) -> Resn {
                Resn::from_bits(val)
            }
        }
        impl From<Resn> for u8 {
            #[inline(always)]
            fn from(val: Resn) -> u8 {
                Resn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resp {
            #[doc = "Bypass resistor ladder"]
            BYPASS = 0x0,
            #[doc = "Pull-down to GND"]
            PULLDOWN = 0x01,
            #[doc = "Pull-up to VDD_GPIO"]
            PULLUP = 0x02,
            #[doc = "Set input at VDD_GPIO/2"]
            VDD1_2 = 0x03,
        }
        impl Resp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resp {
            #[inline(always)]
            fn from(val: u8) -> Resp {
                Resp::from_bits(val)
            }
        }
        impl From<Resp> for u8 {
            #[inline(always)]
            fn from(val: Resp) -> u8 {
                Resp::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SamplerateMode {
            #[doc = "Rate is controlled from SAMPLE task"]
            TASK = 0x0,
            #[doc = "Rate is controlled from local timer (use CC to control the rate)"]
            TIMERS = 0x01,
        }
        impl SamplerateMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SamplerateMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SamplerateMode {
            #[inline(always)]
            fn from(val: u8) -> SamplerateMode {
                SamplerateMode::from_bits(val)
            }
        }
        impl From<SamplerateMode> for u8 {
            #[inline(always)]
            fn from(val: SamplerateMode) -> u8 {
                SamplerateMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "ADC is ready. No on-going conversion."]
            READY = 0x0,
            #[doc = "ADC is busy. Single conversion in progress."]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tacq {
            #[doc = "3 us"]
            _3US = 0x0,
            #[doc = "5 us"]
            _5US = 0x01,
            #[doc = "10 us"]
            _10US = 0x02,
            #[doc = "15 us"]
            _15US = 0x03,
            #[doc = "20 us"]
            _20US = 0x04,
            #[doc = "40 us"]
            _40US = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tacq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tacq {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tacq {
            #[inline(always)]
            fn from(val: u8) -> Tacq {
                Tacq::from_bits(val)
            }
        }
        impl From<Tacq> for u8 {
            #[inline(always)]
            fn from(val: Tacq) -> u8 {
                Tacq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Val {
            #[doc = "8 bit"]
            _8BIT = 0x0,
            #[doc = "10 bit"]
            _10BIT = 0x01,
            #[doc = "12 bit"]
            _12BIT = 0x02,
            #[doc = "14 bit"]
            _14BIT = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Val {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Val {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Val {
            #[inline(always)]
            fn from(val: u8) -> Val {
                Val::from_bits(val)
            }
        }
        impl From<Val> for u8 {
            #[inline(always)]
            fn from(val: Val) -> u8 {
                Val::to_bits(val)
            }
        }
    }
}
pub mod shared {
    pub mod regs {
        #[doc = "Pin select for LRCK signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Pin number"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.connect()
                )
            }
        }
        #[doc = "Publish configuration for event HFCLKSTARTED"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Publish(pub u32);
        impl Publish {
            #[doc = "DPPI channel that event HFCLKSTARTED will publish to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that event HFCLKSTARTED will publish to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Publish {
            #[inline(always)]
            fn default() -> Publish {
                Publish(0)
            }
        }
        impl core::fmt::Debug for Publish {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Publish")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Publish {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Publish {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
        #[doc = "Subscribe configuration for task HFCLKSTART"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Subscribe(pub u32);
        impl Subscribe {
            #[doc = "DPPI channel that task HFCLKSTART will subscribe to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that task HFCLKSTART will subscribe to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Subscribe {
            #[inline(always)]
            fn default() -> Subscribe {
                Subscribe(0)
            }
        }
        impl core::fmt::Debug for Subscribe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Subscribe")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Subscribe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Subscribe {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Connect {
            #[doc = "Connect"]
            CONNECTED = 0x0,
            #[doc = "Disconnect"]
            DISCONNECTED = 0x01,
        }
        impl Connect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Connect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Connect {
            #[inline(always)]
            fn from(val: u8) -> Connect {
                Connect::from_bits(val)
            }
        }
        impl From<Connect> for u8 {
            #[inline(always)]
            fn from(val: Connect) -> u8 {
                Connect::to_bits(val)
            }
        }
    }
}
pub mod spim {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD EasyDMA channel"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "TXD EasyDMA channel"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "RXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "TXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spim {
        ptr: *mut u8,
    }
    unsafe impl Send for Spim {}
    unsafe impl Sync for Spim {}
    impl Spim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start SPI transaction"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Stop SPI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Suspend SPI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Resume SPI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "SPI transaction has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "End of RXD buffer reached"]
        #[inline(always)]
        pub const fn events_endrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "End of RXD buffer and TXD buffer reached"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0118usize) as _) }
        }
        #[doc = "End of TXD buffer reached"]
        #[inline(always)]
        pub const fn events_endtx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0120usize) as _) }
        }
        #[doc = "Transaction started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event ENDTX"]
        #[inline(always)]
        pub const fn publish_endtx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a0usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Enable SPIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "SPI frequency. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0554usize) as _) }
        }
        #[doc = "Over-read character. Character clocked out in case an over-read of the TXD buffer."]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Enable SPIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "SPI frequency. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "SPI master data rate"]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> super::vals::Frequency {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Frequency::from_bits(val as u32)
            }
            #[doc = "SPI master data rate"]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: super::vals::Frequency) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frequency {{ frequency: {:?} }}", self.frequency())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ENDRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn set_endrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event ENDTX"]
            #[must_use]
            #[inline(always)]
            pub const fn endtx(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ENDTX"]
            #[inline(always)]
            pub const fn set_endtx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("endrx", &self.endrx())
                    .field("end", &self.end())
                    .field("endtx", &self.endtx())
                    .field("started", &self.started())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, endrx: {=bool:?}, end: {=bool:?}, endtx: {=bool:?}, started: {=bool:?} }}" , self . stopped () , self . endrx () , self . end () , self . endtx () , self . started ())
            }
        }
        #[doc = "Over-read character. Character clocked out in case an over-read of the TXD buffer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character clocked out in case an over-read of the TXD buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character clocked out in case an over-read of the TXD buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdList(pub u32);
        impl RxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::RxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::RxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::RxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for RxdList {
            #[inline(always)]
            fn default() -> RxdList {
                RxdList(0)
            }
        }
        impl core::fmt::Debug for RxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in receive buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in receive buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_start", &self.end_start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Shorts {{ end_start: {=bool:?} }}", self.end_start())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdList(pub u32);
        impl TxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::TxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::TxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TxdList {
            #[inline(always)]
            fn default() -> TxdList {
                TxdList(0)
            }
        }
        impl core::fmt::Debug for TxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Enable SPIM"]
            ENABLED = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frequency(u32);
        impl Frequency {
            #[doc = "125 kbps"]
            pub const K125: Self = Self(0x0200_0000);
            #[doc = "250 kbps"]
            pub const K250: Self = Self(0x0400_0000);
            #[doc = "500 kbps"]
            pub const K500: Self = Self(0x0800_0000);
            #[doc = "1 Mbps"]
            pub const M1: Self = Self(0x1000_0000);
            #[doc = "2 Mbps"]
            pub const M2: Self = Self(0x2000_0000);
            #[doc = "4 Mbps"]
            pub const M4: Self = Self(0x4000_0000);
            #[doc = "8 Mbps"]
            pub const M8: Self = Self(0x8000_0000);
        }
        impl Frequency {
            pub const fn from_bits(val: u32) -> Frequency {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0200_0000 => f.write_str("K125"),
                    0x0400_0000 => f.write_str("K250"),
                    0x0800_0000 => f.write_str("K500"),
                    0x1000_0000 => f.write_str("M1"),
                    0x2000_0000 => f.write_str("M2"),
                    0x4000_0000 => f.write_str("M4"),
                    0x8000_0000 => f.write_str("M8"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0200_0000 => defmt::write!(f, "K125"),
                    0x0400_0000 => defmt::write!(f, "K250"),
                    0x0800_0000 => defmt::write!(f, "K500"),
                    0x1000_0000 => defmt::write!(f, "M1"),
                    0x2000_0000 => defmt::write!(f, "M2"),
                    0x4000_0000 => defmt::write!(f, "M4"),
                    0x8000_0000 => defmt::write!(f, "M8"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Frequency {
            #[inline(always)]
            fn from(val: u32) -> Frequency {
                Frequency::from_bits(val)
            }
        }
        impl From<Frequency> for u32 {
            #[inline(always)]
            fn from(val: Frequency) -> u32 {
                Frequency::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl RxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxdListList {
            #[inline(always)]
            fn from(val: u8) -> RxdListList {
                RxdListList::from_bits(val)
            }
        }
        impl From<RxdListList> for u8 {
            #[inline(always)]
            fn from(val: RxdListList) -> u8 {
                RxdListList::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl TxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxdListList {
            #[inline(always)]
            fn from(val: u8) -> TxdListList {
                TxdListList::from_bits(val)
            }
        }
        impl From<TxdListList> for u8 {
            #[inline(always)]
            fn from(val: TxdListList) -> u8 {
                TxdListList::to_bits(val)
            }
        }
    }
}
pub mod spis {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes received in last granted transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "TXD data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transmitted in last granted transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "End of RXD buffer reached"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for CSN signal"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "SPI Slave 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spis {
        ptr: *mut u8,
    }
    unsafe impl Send for Spis {}
    unsafe impl Sync for Spis {}
    impl Spis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Acquire SPI semaphore"]
        #[inline(always)]
        pub const fn tasks_acquire(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Release SPI semaphore, enabling the SPI slave to acquire it"]
        #[inline(always)]
        pub const fn tasks_release(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACQUIRE"]
        #[inline(always)]
        pub const fn subscribe_acquire(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task RELEASE"]
        #[inline(always)]
        pub const fn subscribe_release(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa8usize) as _) }
        }
        #[doc = "Granted transaction completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Semaphore acquired"]
        #[inline(always)]
        pub const fn events_acquired(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0128usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event ACQUIRED"]
        #[inline(always)]
        pub const fn publish_acquired(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Semaphore status register"]
        #[inline(always)]
        pub const fn semstat(self) -> crate::common::Reg<regs::Semstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Status from last transaction"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0440usize) as _) }
        }
        #[doc = "Enable SPI slave"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0554usize) as _) }
        }
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[inline(always)]
        pub const fn def(self) -> crate::common::Reg<regs::Def, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x055cusize) as _) }
        }
        #[doc = "Over-read character"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Def(pub u32);
        impl Def {
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[must_use]
            #[inline(always)]
            pub const fn def(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[inline(always)]
            pub const fn set_def(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Def {
            #[inline(always)]
            fn default() -> Def {
                Def(0)
            }
        }
        impl core::fmt::Debug for Def {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Def").field("def", &self.def()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Def {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Def {{ def: {=u8:?} }}", self.def())
            }
        }
        #[doc = "Enable SPI slave"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPI slave"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPI slave"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ENDRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn set_endrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[must_use]
            #[inline(always)]
            pub const fn acquired(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[inline(always)]
            pub const fn set_acquired(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("endrx", &self.endrx())
                    .field("acquired", &self.acquired())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ end: {=bool:?}, endrx: {=bool:?}, acquired: {=bool:?} }}",
                    self.end(),
                    self.endrx(),
                    self.acquired()
                )
            }
        }
        #[doc = "Over-read character"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes received in last granted transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes received in the last granted transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes received in the last granted transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdList(pub u32);
        impl RxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::RxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::RxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::RxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for RxdList {
            #[inline(always)]
            fn default() -> RxdList {
                RxdList(0)
            }
        }
        impl core::fmt::Debug for RxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in receive buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in receive buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Semaphore status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semstat(pub u32);
        impl Semstat {
            #[doc = "Semaphore status"]
            #[must_use]
            #[inline(always)]
            pub const fn semstat(&self) -> super::vals::Semstat {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Semstat::from_bits(val as u8)
            }
            #[doc = "Semaphore status"]
            #[inline(always)]
            pub const fn set_semstat(&mut self, val: super::vals::Semstat) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Semstat {
            #[inline(always)]
            fn default() -> Semstat {
                Semstat(0)
            }
        }
        impl core::fmt::Debug for Semstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semstat")
                    .field("semstat", &self.semstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Semstat {{ semstat: {:?} }}", self.semstat())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[must_use]
            #[inline(always)]
            pub const fn end_acquire(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[inline(always)]
            pub const fn set_end_acquire(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_acquire", &self.end_acquire())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Shorts {{ end_acquire: {=bool:?} }}", self.end_acquire())
            }
        }
        #[doc = "Status from last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("overread", &self.overread())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ overread: {=bool:?}, overflow: {=bool:?} }}",
                    self.overread(),
                    self.overflow()
                )
            }
        }
        #[doc = "Number of bytes transmitted in last granted transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transmitted in last granted transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transmitted in last granted transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdList(pub u32);
        impl TxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::TxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::TxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TxdList {
            #[inline(always)]
            fn default() -> TxdList {
                TxdList(0)
            }
        }
        impl core::fmt::Debug for TxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPI slave"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable SPI slave"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl RxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxdListList {
            #[inline(always)]
            fn from(val: u8) -> RxdListList {
                RxdListList::from_bits(val)
            }
        }
        impl From<RxdListList> for u8 {
            #[inline(always)]
            fn from(val: RxdListList) -> u8 {
                RxdListList::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Semstat {
            #[doc = "Semaphore is free"]
            FREE = 0x0,
            #[doc = "Semaphore is assigned to CPU"]
            CPU = 0x01,
            #[doc = "Semaphore is assigned to SPI slave"]
            SPIS = 0x02,
            #[doc = "Semaphore is assigned to SPI but a handover to the CPU is pending"]
            CPUPENDING = 0x03,
        }
        impl Semstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Semstat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Semstat {
            #[inline(always)]
            fn from(val: u8) -> Semstat {
                Semstat::from_bits(val)
            }
        }
        impl From<Semstat> for u8 {
            #[inline(always)]
            fn from(val: Semstat) -> u8 {
                Semstat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl TxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxdListList {
            #[inline(always)]
            fn from(val: u8) -> TxdListList {
                TxdListList::from_bits(val)
            }
        }
        impl From<TxdListList> for u8 {
            #[inline(always)]
            fn from(val: TxdListList) -> u8 {
                TxdListList::to_bits(val)
            }
        }
    }
}
pub mod spu {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppi {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppi {}
    unsafe impl Sync for Dppi {}
    impl Dppi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Select between secure and non-secure attribute for the DPPI channels."]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::DppiPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Prevent further modification of the corresponding PERM register"]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::DppiLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Extdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Extdomain {}
    unsafe impl Sync for Extdomain {}
    impl Extdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access for bus access generated from the external domain n List capabilities of the external domain n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::ExtdomainPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flashnsc {
        ptr: *mut u8,
    }
    unsafe impl Send for Flashnsc {}
    unsafe impl Sync for Flashnsc {}
    impl Flashnsc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Define which flash region can contain the non-secure callable (NSC) region n"]
        #[inline(always)]
        pub const fn region(self) -> crate::common::Reg<regs::FlashnscRegion, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Define the size of the non-secure callable (NSC) region n"]
        #[inline(always)]
        pub const fn size(self) -> crate::common::Reg<regs::FlashnscSize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flashregion {
        ptr: *mut u8,
    }
    unsafe impl Send for Flashregion {}
    unsafe impl Sync for Flashregion {}
    impl Flashregion {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access permissions for flash region n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::FlashregionPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpioport {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpioport {}
    unsafe impl Sync for Gpioport {}
    impl Gpioport {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Select between secure and non-secure attribute for pins 0 to 31 of port n."]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::GpioportPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Prevent further modification of the corresponding PERM register"]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::GpioportLock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periphid {
        ptr: *mut u8,
    }
    unsafe impl Send for Periphid {}
    unsafe impl Sync for Periphid {}
    impl Periphid {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: List capabilities and access permissions for the peripheral with ID n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::PeriphidPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ramnsc {
        ptr: *mut u8,
    }
    unsafe impl Send for Ramnsc {}
    unsafe impl Sync for Ramnsc {}
    impl Ramnsc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Define which RAM region can contain the non-secure callable (NSC) region n"]
        #[inline(always)]
        pub const fn region(self) -> crate::common::Reg<regs::RamnscRegion, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Define the size of the non-secure callable (NSC) region n"]
        #[inline(always)]
        pub const fn size(self) -> crate::common::Reg<regs::RamnscSize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ramregion {
        ptr: *mut u8,
    }
    unsafe impl Send for Ramregion {}
    unsafe impl Sync for Ramregion {}
    impl Ramregion {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access permissions for RAM region n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::RamregionPerm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "System protection unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spu {
        ptr: *mut u8,
    }
    unsafe impl Send for Spu {}
    unsafe impl Sync for Spu {}
    impl Spu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A security violation has been detected for the RAM memory space"]
        #[inline(always)]
        pub const fn events_ramaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "A security violation has been detected for the flash memory space"]
        #[inline(always)]
        pub const fn events_flashaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "A security violation has been detected on one or several peripherals"]
        #[inline(always)]
        pub const fn events_periphaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "Publish configuration for event RAMACCERR"]
        #[inline(always)]
        pub const fn publish_ramaccerr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event FLASHACCERR"]
        #[inline(always)]
        pub const fn publish_flashaccerr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event PERIPHACCERR"]
        #[inline(always)]
        pub const fn publish_periphaccerr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Show implemented features for the current device"]
        #[inline(always)]
        pub const fn cap(self) -> crate::common::Reg<regs::Cap, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn extdomain(self, n: usize) -> Extdomain {
            assert!(n < 1usize);
            unsafe { Extdomain::from_ptr(self.ptr.wrapping_add(0x0440usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dppi(self, n: usize) -> Dppi {
            assert!(n < 1usize);
            unsafe { Dppi::from_ptr(self.ptr.wrapping_add(0x0480usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpioport(self, n: usize) -> Gpioport {
            assert!(n < 1usize);
            unsafe { Gpioport::from_ptr(self.ptr.wrapping_add(0x04c0usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn flashnsc(self, n: usize) -> Flashnsc {
            assert!(n < 2usize);
            unsafe { Flashnsc::from_ptr(self.ptr.wrapping_add(0x0500usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ramnsc(self, n: usize) -> Ramnsc {
            assert!(n < 2usize);
            unsafe { Ramnsc::from_ptr(self.ptr.wrapping_add(0x0540usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn flashregion(self, n: usize) -> Flashregion {
            assert!(n < 32usize);
            unsafe { Flashregion::from_ptr(self.ptr.wrapping_add(0x0600usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ramregion(self, n: usize) -> Ramregion {
            assert!(n < 32usize);
            unsafe { Ramregion::from_ptr(self.ptr.wrapping_add(0x0700usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periphid(self, n: usize) -> Periphid {
            assert!(n < 67usize);
            unsafe { Periphid::from_ptr(self.ptr.wrapping_add(0x0800usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Show implemented features for the current device"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cap(pub u32);
        impl Cap {
            #[doc = "Show ARM TrustZone status"]
            #[must_use]
            #[inline(always)]
            pub const fn tzm(&self) -> super::vals::Tzm {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Tzm::from_bits(val as u8)
            }
            #[doc = "Show ARM TrustZone status"]
            #[inline(always)]
            pub const fn set_tzm(&mut self, val: super::vals::Tzm) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Cap {
            #[inline(always)]
            fn default() -> Cap {
                Cap(0)
            }
        }
        impl core::fmt::Debug for Cap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cap").field("tzm", &self.tzm()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cap {{ tzm: {:?} }}", self.tzm())
            }
        }
        #[doc = "Description cluster: Prevent further modification of the corresponding PERM register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DppiLock(pub u32);
        impl DppiLock {
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DppiLock {
            #[inline(always)]
            fn default() -> DppiLock {
                DppiLock(0)
            }
        }
        impl core::fmt::Debug for DppiLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DppiLock")
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DppiLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DppiLock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "Description cluster: Select between secure and non-secure attribute for the DPPI channels."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DppiPerm(pub u32);
        impl DppiPerm {
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Select secure attribute."]
            #[must_use]
            #[inline(always)]
            pub const fn channel15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute."]
            #[inline(always)]
            pub const fn set_channel15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for DppiPerm {
            #[inline(always)]
            fn default() -> DppiPerm {
                DppiPerm(0)
            }
        }
        impl core::fmt::Debug for DppiPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DppiPerm")
                    .field("channel0", &self.channel0())
                    .field("channel1", &self.channel1())
                    .field("channel2", &self.channel2())
                    .field("channel3", &self.channel3())
                    .field("channel4", &self.channel4())
                    .field("channel5", &self.channel5())
                    .field("channel6", &self.channel6())
                    .field("channel7", &self.channel7())
                    .field("channel8", &self.channel8())
                    .field("channel9", &self.channel9())
                    .field("channel10", &self.channel10())
                    .field("channel11", &self.channel11())
                    .field("channel12", &self.channel12())
                    .field("channel13", &self.channel13())
                    .field("channel14", &self.channel14())
                    .field("channel15", &self.channel15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DppiPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DppiPerm {{ channel0: {=bool:?}, channel1: {=bool:?}, channel2: {=bool:?}, channel3: {=bool:?}, channel4: {=bool:?}, channel5: {=bool:?}, channel6: {=bool:?}, channel7: {=bool:?}, channel8: {=bool:?}, channel9: {=bool:?}, channel10: {=bool:?}, channel11: {=bool:?}, channel12: {=bool:?}, channel13: {=bool:?}, channel14: {=bool:?}, channel15: {=bool:?} }}" , self . channel0 () , self . channel1 () , self . channel2 () , self . channel3 () , self . channel4 () , self . channel5 () , self . channel6 () , self . channel7 () , self . channel8 () , self . channel9 () , self . channel10 () , self . channel11 () , self . channel12 () , self . channel13 () , self . channel14 () , self . channel15 ())
            }
        }
        #[doc = "Description cluster: Access for bus access generated from the external domain n List capabilities of the external domain n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtdomainPerm(pub u32);
        impl ExtdomainPerm {
            #[doc = "Define configuration capabilities for TrustZone Cortex-M secure attribute"]
            #[must_use]
            #[inline(always)]
            pub const fn securemapping(&self) -> super::vals::ExtdomainPermSecuremapping {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::ExtdomainPermSecuremapping::from_bits(val as u8)
            }
            #[doc = "Define configuration capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub const fn set_securemapping(
                &mut self,
                val: super::vals::ExtdomainPermSecuremapping,
            ) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Peripheral security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for ExtdomainPerm {
            #[inline(always)]
            fn default() -> ExtdomainPerm {
                ExtdomainPerm(0)
            }
        }
        impl core::fmt::Debug for ExtdomainPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtdomainPerm")
                    .field("securemapping", &self.securemapping())
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtdomainPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "ExtdomainPerm {{ securemapping: {:?}, secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.securemapping(),
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description cluster: Define which flash region can contain the non-secure callable (NSC) region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashnscRegion(pub u32);
        impl FlashnscRegion {
            #[doc = "Region number"]
            #[must_use]
            #[inline(always)]
            pub const fn region(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Region number"]
            #[inline(always)]
            pub const fn set_region(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for FlashnscRegion {
            #[inline(always)]
            fn default() -> FlashnscRegion {
                FlashnscRegion(0)
            }
        }
        impl core::fmt::Debug for FlashnscRegion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashnscRegion")
                    .field("region", &self.region())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashnscRegion {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FlashnscRegion {{ region: {=u8:?}, lock: {=bool:?} }}",
                    self.region(),
                    self.lock()
                )
            }
        }
        #[doc = "Description cluster: Define the size of the non-secure callable (NSC) region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashnscSize(pub u32);
        impl FlashnscSize {
            #[doc = "Size of the non-secure callable (NSC) region n"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> super::vals::FlashnscSizeSize {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::FlashnscSizeSize::from_bits(val as u8)
            }
            #[doc = "Size of the non-secure callable (NSC) region n"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: super::vals::FlashnscSizeSize) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for FlashnscSize {
            #[inline(always)]
            fn default() -> FlashnscSize {
                FlashnscSize(0)
            }
        }
        impl core::fmt::Debug for FlashnscSize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashnscSize")
                    .field("size", &self.size())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashnscSize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "FlashnscSize {{ size: {:?}, lock: {=bool:?} }}",
                    self.size(),
                    self.lock()
                )
            }
        }
        #[doc = "Description cluster: Access permissions for flash region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct FlashregionPerm(pub u32);
        impl FlashregionPerm {
            #[doc = "Configure instruction fetch permissions from flash region n"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure instruction fetch permissions from flash region n"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure write permission for flash region n"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Configure write permission for flash region n"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Configure read permissions for flash region n"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Configure read permissions for flash region n"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Security attribute for flash region n"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribute for flash region n"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for FlashregionPerm {
            #[inline(always)]
            fn default() -> FlashregionPerm {
                FlashregionPerm(0)
            }
        }
        impl core::fmt::Debug for FlashregionPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("FlashregionPerm")
                    .field("execute", &self.execute())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for FlashregionPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "FlashregionPerm {{ execute: {=bool:?}, write: {=bool:?}, read: {=bool:?}, secattr: {=bool:?}, lock: {=bool:?} }}" , self . execute () , self . write () , self . read () , self . secattr () , self . lock ())
            }
        }
        #[doc = "Description cluster: Prevent further modification of the corresponding PERM register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioportLock(pub u32);
        impl GpioportLock {
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GpioportLock {
            #[inline(always)]
            fn default() -> GpioportLock {
                GpioportLock(0)
            }
        }
        impl core::fmt::Debug for GpioportLock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioportLock")
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioportLock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "GpioportLock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "Description cluster: Select between secure and non-secure attribute for pins 0 to 31 of port n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioportPerm(pub u32);
        impl GpioportPerm {
            #[doc = "Select secure attribute attribute for PIN 0."]
            #[must_use]
            #[inline(always)]
            pub const fn pin0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 0."]
            #[inline(always)]
            pub const fn set_pin0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select secure attribute attribute for PIN 1."]
            #[must_use]
            #[inline(always)]
            pub const fn pin1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 1."]
            #[inline(always)]
            pub const fn set_pin1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Select secure attribute attribute for PIN 2."]
            #[must_use]
            #[inline(always)]
            pub const fn pin2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 2."]
            #[inline(always)]
            pub const fn set_pin2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Select secure attribute attribute for PIN 3."]
            #[must_use]
            #[inline(always)]
            pub const fn pin3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 3."]
            #[inline(always)]
            pub const fn set_pin3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Select secure attribute attribute for PIN 4."]
            #[must_use]
            #[inline(always)]
            pub const fn pin4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 4."]
            #[inline(always)]
            pub const fn set_pin4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Select secure attribute attribute for PIN 5."]
            #[must_use]
            #[inline(always)]
            pub const fn pin5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 5."]
            #[inline(always)]
            pub const fn set_pin5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Select secure attribute attribute for PIN 6."]
            #[must_use]
            #[inline(always)]
            pub const fn pin6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 6."]
            #[inline(always)]
            pub const fn set_pin6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Select secure attribute attribute for PIN 7."]
            #[must_use]
            #[inline(always)]
            pub const fn pin7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 7."]
            #[inline(always)]
            pub const fn set_pin7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Select secure attribute attribute for PIN 8."]
            #[must_use]
            #[inline(always)]
            pub const fn pin8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 8."]
            #[inline(always)]
            pub const fn set_pin8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Select secure attribute attribute for PIN 9."]
            #[must_use]
            #[inline(always)]
            pub const fn pin9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 9."]
            #[inline(always)]
            pub const fn set_pin9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Select secure attribute attribute for PIN 10."]
            #[must_use]
            #[inline(always)]
            pub const fn pin10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 10."]
            #[inline(always)]
            pub const fn set_pin10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Select secure attribute attribute for PIN 11."]
            #[must_use]
            #[inline(always)]
            pub const fn pin11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 11."]
            #[inline(always)]
            pub const fn set_pin11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Select secure attribute attribute for PIN 12."]
            #[must_use]
            #[inline(always)]
            pub const fn pin12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 12."]
            #[inline(always)]
            pub const fn set_pin12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Select secure attribute attribute for PIN 13."]
            #[must_use]
            #[inline(always)]
            pub const fn pin13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 13."]
            #[inline(always)]
            pub const fn set_pin13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Select secure attribute attribute for PIN 14."]
            #[must_use]
            #[inline(always)]
            pub const fn pin14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 14."]
            #[inline(always)]
            pub const fn set_pin14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Select secure attribute attribute for PIN 15."]
            #[must_use]
            #[inline(always)]
            pub const fn pin15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 15."]
            #[inline(always)]
            pub const fn set_pin15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Select secure attribute attribute for PIN 16."]
            #[must_use]
            #[inline(always)]
            pub const fn pin16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 16."]
            #[inline(always)]
            pub const fn set_pin16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Select secure attribute attribute for PIN 17."]
            #[must_use]
            #[inline(always)]
            pub const fn pin17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 17."]
            #[inline(always)]
            pub const fn set_pin17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Select secure attribute attribute for PIN 18."]
            #[must_use]
            #[inline(always)]
            pub const fn pin18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 18."]
            #[inline(always)]
            pub const fn set_pin18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Select secure attribute attribute for PIN 19."]
            #[must_use]
            #[inline(always)]
            pub const fn pin19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 19."]
            #[inline(always)]
            pub const fn set_pin19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Select secure attribute attribute for PIN 20."]
            #[must_use]
            #[inline(always)]
            pub const fn pin20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 20."]
            #[inline(always)]
            pub const fn set_pin20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Select secure attribute attribute for PIN 21."]
            #[must_use]
            #[inline(always)]
            pub const fn pin21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 21."]
            #[inline(always)]
            pub const fn set_pin21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Select secure attribute attribute for PIN 22."]
            #[must_use]
            #[inline(always)]
            pub const fn pin22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 22."]
            #[inline(always)]
            pub const fn set_pin22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Select secure attribute attribute for PIN 23."]
            #[must_use]
            #[inline(always)]
            pub const fn pin23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 23."]
            #[inline(always)]
            pub const fn set_pin23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Select secure attribute attribute for PIN 24."]
            #[must_use]
            #[inline(always)]
            pub const fn pin24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 24."]
            #[inline(always)]
            pub const fn set_pin24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Select secure attribute attribute for PIN 25."]
            #[must_use]
            #[inline(always)]
            pub const fn pin25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 25."]
            #[inline(always)]
            pub const fn set_pin25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Select secure attribute attribute for PIN 26."]
            #[must_use]
            #[inline(always)]
            pub const fn pin26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 26."]
            #[inline(always)]
            pub const fn set_pin26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Select secure attribute attribute for PIN 27."]
            #[must_use]
            #[inline(always)]
            pub const fn pin27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 27."]
            #[inline(always)]
            pub const fn set_pin27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Select secure attribute attribute for PIN 28."]
            #[must_use]
            #[inline(always)]
            pub const fn pin28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 28."]
            #[inline(always)]
            pub const fn set_pin28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Select secure attribute attribute for PIN 29."]
            #[must_use]
            #[inline(always)]
            pub const fn pin29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 29."]
            #[inline(always)]
            pub const fn set_pin29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Select secure attribute attribute for PIN 30."]
            #[must_use]
            #[inline(always)]
            pub const fn pin30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 30."]
            #[inline(always)]
            pub const fn set_pin30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Select secure attribute attribute for PIN 31."]
            #[must_use]
            #[inline(always)]
            pub const fn pin31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Select secure attribute attribute for PIN 31."]
            #[inline(always)]
            pub const fn set_pin31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for GpioportPerm {
            #[inline(always)]
            fn default() -> GpioportPerm {
                GpioportPerm(0)
            }
        }
        impl core::fmt::Debug for GpioportPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioportPerm")
                    .field("pin0", &self.pin0())
                    .field("pin1", &self.pin1())
                    .field("pin2", &self.pin2())
                    .field("pin3", &self.pin3())
                    .field("pin4", &self.pin4())
                    .field("pin5", &self.pin5())
                    .field("pin6", &self.pin6())
                    .field("pin7", &self.pin7())
                    .field("pin8", &self.pin8())
                    .field("pin9", &self.pin9())
                    .field("pin10", &self.pin10())
                    .field("pin11", &self.pin11())
                    .field("pin12", &self.pin12())
                    .field("pin13", &self.pin13())
                    .field("pin14", &self.pin14())
                    .field("pin15", &self.pin15())
                    .field("pin16", &self.pin16())
                    .field("pin17", &self.pin17())
                    .field("pin18", &self.pin18())
                    .field("pin19", &self.pin19())
                    .field("pin20", &self.pin20())
                    .field("pin21", &self.pin21())
                    .field("pin22", &self.pin22())
                    .field("pin23", &self.pin23())
                    .field("pin24", &self.pin24())
                    .field("pin25", &self.pin25())
                    .field("pin26", &self.pin26())
                    .field("pin27", &self.pin27())
                    .field("pin28", &self.pin28())
                    .field("pin29", &self.pin29())
                    .field("pin30", &self.pin30())
                    .field("pin31", &self.pin31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioportPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GpioportPerm {{ pin0: {=bool:?}, pin1: {=bool:?}, pin2: {=bool:?}, pin3: {=bool:?}, pin4: {=bool:?}, pin5: {=bool:?}, pin6: {=bool:?}, pin7: {=bool:?}, pin8: {=bool:?}, pin9: {=bool:?}, pin10: {=bool:?}, pin11: {=bool:?}, pin12: {=bool:?}, pin13: {=bool:?}, pin14: {=bool:?}, pin15: {=bool:?}, pin16: {=bool:?}, pin17: {=bool:?}, pin18: {=bool:?}, pin19: {=bool:?}, pin20: {=bool:?}, pin21: {=bool:?}, pin22: {=bool:?}, pin23: {=bool:?}, pin24: {=bool:?}, pin25: {=bool:?}, pin26: {=bool:?}, pin27: {=bool:?}, pin28: {=bool:?}, pin29: {=bool:?}, pin30: {=bool:?}, pin31: {=bool:?} }}" , self . pin0 () , self . pin1 () , self . pin2 () , self . pin3 () , self . pin4 () , self . pin5 () , self . pin6 () , self . pin7 () , self . pin8 () , self . pin9 () , self . pin10 () , self . pin11 () , self . pin12 () , self . pin13 () , self . pin14 () , self . pin15 () , self . pin16 () , self . pin17 () , self . pin18 () , self . pin19 () , self . pin20 () , self . pin21 () , self . pin22 () , self . pin23 () , self . pin24 () , self . pin25 () , self . pin26 () , self . pin27 () , self . pin28 () , self . pin29 () , self . pin30 () , self . pin31 ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RAMACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn ramaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RAMACCERR"]
            #[inline(always)]
            pub const fn set_ramaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FLASHACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn flashaccerr(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FLASHACCERR"]
            #[inline(always)]
            pub const fn set_flashaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn periphaccerr(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[inline(always)]
            pub const fn set_periphaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ramaccerr", &self.ramaccerr())
                    .field("flashaccerr", &self.flashaccerr())
                    .field("periphaccerr", &self.periphaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ ramaccerr: {=bool:?}, flashaccerr: {=bool:?}, periphaccerr: {=bool:?} }}" , self . ramaccerr () , self . flashaccerr () , self . periphaccerr ())
            }
        }
        #[doc = "Description cluster: List capabilities and access permissions for the peripheral with ID n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PeriphidPerm(pub u32);
        impl PeriphidPerm {
            #[doc = "Define configuration capabilities for TrustZone Cortex-M secure attribute"]
            #[must_use]
            #[inline(always)]
            pub const fn securemapping(&self) -> super::vals::PeriphidPermSecuremapping {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::PeriphidPermSecuremapping::from_bits(val as u8)
            }
            #[doc = "Define configuration capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub const fn set_securemapping(&mut self, val: super::vals::PeriphidPermSecuremapping) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Indicate if the peripheral has DMA capabilities and if DMA transfer can be assigned to a different security attribute than the peripheral itself"]
            #[must_use]
            #[inline(always)]
            pub const fn dma(&self) -> super::vals::Dma {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Dma::from_bits(val as u8)
            }
            #[doc = "Indicate if the peripheral has DMA capabilities and if DMA transfer can be assigned to a different security attribute than the peripheral itself"]
            #[inline(always)]
            pub const fn set_dma(&mut self, val: super::vals::Dma) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Peripheral security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn dmasec(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[inline(always)]
            pub const fn set_dmasec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicate if a peripheral is present with ID n"]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "Indicate if a peripheral is present with ID n"]
            #[inline(always)]
            pub const fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for PeriphidPerm {
            #[inline(always)]
            fn default() -> PeriphidPerm {
                PeriphidPerm(0)
            }
        }
        impl core::fmt::Debug for PeriphidPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PeriphidPerm")
                    .field("securemapping", &self.securemapping())
                    .field("dma", &self.dma())
                    .field("secattr", &self.secattr())
                    .field("dmasec", &self.dmasec())
                    .field("lock", &self.lock())
                    .field("present", &self.present())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PeriphidPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PeriphidPerm {{ securemapping: {:?}, dma: {:?}, secattr: {=bool:?}, dmasec: {=bool:?}, lock: {=bool:?}, present: {:?} }}" , self . securemapping () , self . dma () , self . secattr () , self . dmasec () , self . lock () , self . present ())
            }
        }
        #[doc = "Description cluster: Define which RAM region can contain the non-secure callable (NSC) region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RamnscRegion(pub u32);
        impl RamnscRegion {
            #[doc = "Region number"]
            #[must_use]
            #[inline(always)]
            pub const fn region(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Region number"]
            #[inline(always)]
            pub const fn set_region(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for RamnscRegion {
            #[inline(always)]
            fn default() -> RamnscRegion {
                RamnscRegion(0)
            }
        }
        impl core::fmt::Debug for RamnscRegion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RamnscRegion")
                    .field("region", &self.region())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RamnscRegion {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RamnscRegion {{ region: {=u8:?}, lock: {=bool:?} }}",
                    self.region(),
                    self.lock()
                )
            }
        }
        #[doc = "Description cluster: Define the size of the non-secure callable (NSC) region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RamnscSize(pub u32);
        impl RamnscSize {
            #[doc = "Size of the non-secure callable (NSC) region n"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> super::vals::RamnscSizeSize {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::RamnscSizeSize::from_bits(val as u8)
            }
            #[doc = "Size of the non-secure callable (NSC) region n"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: super::vals::RamnscSizeSize) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for RamnscSize {
            #[inline(always)]
            fn default() -> RamnscSize {
                RamnscSize(0)
            }
        }
        impl core::fmt::Debug for RamnscSize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RamnscSize")
                    .field("size", &self.size())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RamnscSize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RamnscSize {{ size: {:?}, lock: {=bool:?} }}",
                    self.size(),
                    self.lock()
                )
            }
        }
        #[doc = "Description cluster: Access permissions for RAM region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RamregionPerm(pub u32);
        impl RamregionPerm {
            #[doc = "Configure instruction fetch permissions from RAM region n"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure instruction fetch permissions from RAM region n"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure write permission for RAM region n"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Configure write permission for RAM region n"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Configure read permissions for RAM region n"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Configure read permissions for RAM region n"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Security attribute for RAM region n"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribute for RAM region n"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for RamregionPerm {
            #[inline(always)]
            fn default() -> RamregionPerm {
                RamregionPerm(0)
            }
        }
        impl core::fmt::Debug for RamregionPerm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RamregionPerm")
                    .field("execute", &self.execute())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RamregionPerm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RamregionPerm {{ execute: {=bool:?}, write: {=bool:?}, read: {=bool:?}, secattr: {=bool:?}, lock: {=bool:?} }}" , self . execute () , self . write () , self . read () , self . secattr () , self . lock ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dma {
            #[doc = "Peripheral has no DMA capability"]
            NO_DMA = 0x0,
            #[doc = "Peripheral has DMA and DMA transfers always have the same security attribute as assigned to the peripheral"]
            NO_SEPARATE_ATTRIBUTE = 0x01,
            #[doc = "Peripheral has DMA and DMA transfers can have a different security attribute than the one assigned to the peripheral"]
            SEPARATE_ATTRIBUTE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dma {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dma {
            #[inline(always)]
            fn from(val: u8) -> Dma {
                Dma::from_bits(val)
            }
        }
        impl From<Dma> for u8 {
            #[inline(always)]
            fn from(val: Dma) -> u8 {
                Dma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtdomainPermSecuremapping {
            #[doc = "The bus access from this external domain always have the non-secure attribute set"]
            NON_SECURE = 0x0,
            #[doc = "The bus access from this external domain always have the secure attribute set"]
            SECURE = 0x01,
            #[doc = "Non-secure or secure attribute for bus access from this domain is defined by the EXTDOMAIN\\[n\\].PERM register"]
            USER_SELECTABLE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl ExtdomainPermSecuremapping {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtdomainPermSecuremapping {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtdomainPermSecuremapping {
            #[inline(always)]
            fn from(val: u8) -> ExtdomainPermSecuremapping {
                ExtdomainPermSecuremapping::from_bits(val)
            }
        }
        impl From<ExtdomainPermSecuremapping> for u8 {
            #[inline(always)]
            fn from(val: ExtdomainPermSecuremapping) -> u8 {
                ExtdomainPermSecuremapping::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum FlashnscSizeSize {
            #[doc = "The region n is not defined as a non-secure callable region. Normal security attributes (secure or non-secure) are enforced."]
            DISABLED = 0x0,
            #[doc = "The region n is defined as non-secure callable with a 32-byte size"]
            _32 = 0x01,
            #[doc = "The region n is defined as non-secure callable with a 64-byte size"]
            _64 = 0x02,
            #[doc = "The region n is defined as non-secure callable with a 128-byte size"]
            _128 = 0x03,
            #[doc = "The region n is defined as non-secure callable with a 256-byte size"]
            _256 = 0x04,
            #[doc = "The region n is defined as non-secure callable with a 512-byte size"]
            _512 = 0x05,
            #[doc = "The region n is defined as non-secure callable with a 1024-byte size"]
            _1024 = 0x06,
            #[doc = "The region n is defined as non-secure callable with a 2048-byte size"]
            _2048 = 0x07,
            #[doc = "The region n is defined as non-secure callable with a 4096-byte size"]
            _4096 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl FlashnscSizeSize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> FlashnscSizeSize {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for FlashnscSizeSize {
            #[inline(always)]
            fn from(val: u8) -> FlashnscSizeSize {
                FlashnscSizeSize::from_bits(val)
            }
        }
        impl From<FlashnscSizeSize> for u8 {
            #[inline(always)]
            fn from(val: FlashnscSizeSize) -> u8 {
                FlashnscSizeSize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PeriphidPermSecuremapping {
            #[doc = "This peripheral is always accessible as a non-secure peripheral"]
            NON_SECURE = 0x0,
            #[doc = "This peripheral is always accessible as a secure peripheral"]
            SECURE = 0x01,
            #[doc = "Non-secure or secure attribute for this peripheral is defined by the PERIPHID\\[n\\].PERM register"]
            USER_SELECTABLE = 0x02,
            #[doc = "This peripheral implements the split security mechanism. Non-secure or secure attribute for this peripheral is defined by the PERIPHID\\[n\\].PERM register."]
            SPLIT = 0x03,
        }
        impl PeriphidPermSecuremapping {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PeriphidPermSecuremapping {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PeriphidPermSecuremapping {
            #[inline(always)]
            fn from(val: u8) -> PeriphidPermSecuremapping {
                PeriphidPermSecuremapping::from_bits(val)
            }
        }
        impl From<PeriphidPermSecuremapping> for u8 {
            #[inline(always)]
            fn from(val: PeriphidPermSecuremapping) -> u8 {
                PeriphidPermSecuremapping::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "Peripheral is not present"]
            NOT_PRESENT = 0x0,
            #[doc = "Peripheral is present"]
            IS_PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RamnscSizeSize {
            #[doc = "The region n is not defined as a non-secure callable region. Normal security attributes (secure or non-secure) are enforced."]
            DISABLED = 0x0,
            #[doc = "The region n is defined as non-secure callable with a 32-byte size"]
            _32 = 0x01,
            #[doc = "The region n is defined as non-secure callable with a 64-byte size"]
            _64 = 0x02,
            #[doc = "The region n is defined as non-secure callable with a 128-byte size"]
            _128 = 0x03,
            #[doc = "The region n is defined as non-secure callable with a 256-byte size"]
            _256 = 0x04,
            #[doc = "The region n is defined as non-secure callable with a 512-byte size"]
            _512 = 0x05,
            #[doc = "The region n is defined as non-secure callable with a 1024-byte size"]
            _1024 = 0x06,
            #[doc = "The region n is defined as non-secure callable with a 2048-byte size"]
            _2048 = 0x07,
            #[doc = "The region n is defined as non-secure callable with a 4096-byte size"]
            _4096 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl RamnscSizeSize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RamnscSizeSize {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RamnscSizeSize {
            #[inline(always)]
            fn from(val: u8) -> RamnscSizeSize {
                RamnscSizeSize::from_bits(val)
            }
        }
        impl From<RamnscSizeSize> for u8 {
            #[inline(always)]
            fn from(val: RamnscSizeSize) -> u8 {
                RamnscSizeSize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tzm {
            #[doc = "ARM TrustZone support not available"]
            NOT_AVAILABLE = 0x0,
            #[doc = "ARM TrustZone support is available"]
            ENABLED = 0x01,
        }
        impl Tzm {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tzm {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tzm {
            #[inline(always)]
            fn from(val: u8) -> Tzm {
                Tzm::from_bits(val)
            }
        }
        impl From<Tzm> for u8 {
            #[inline(always)]
            fn from(val: Tzm) -> u8 {
                Tzm::to_bits(val)
            }
        }
    }
}
pub mod tad {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin configuration for TRACECLK"]
        #[inline(always)]
        pub const fn traceclk(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin configuration for TRACEDATA\\[0\\]"]
        #[inline(always)]
        pub const fn tracedata0(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin configuration for TRACEDATA\\[1\\]"]
        #[inline(always)]
        pub const fn tracedata1(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin configuration for TRACEDATA\\[2\\]"]
        #[inline(always)]
        pub const fn tracedata2(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Pin configuration for TRACEDATA\\[3\\]"]
        #[inline(always)]
        pub const fn tracedata3(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "Trace and debug control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tad {
        ptr: *mut u8,
    }
    unsafe impl Send for Tad {}
    unsafe impl Sync for Tad {}
    impl Tad {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start all trace and debug clocks."]
        #[inline(always)]
        pub const fn tasks_clockstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop all trace and debug clocks."]
        #[inline(always)]
        pub const fn tasks_clockstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Clocking options for the Trace Port debug interface Reset behavior is the same as debug components"]
        #[inline(always)]
        pub const fn traceportspeed(
            self,
        ) -> crate::common::Reg<regs::Traceportspeed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0518usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Clocking options for the Trace Port debug interface Reset behavior is the same as debug components"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Traceportspeed(pub u32);
        impl Traceportspeed {
            #[doc = "Speed of Trace Port clock. Note that the TRACECLK pin output will be divided again by two from the Trace Port clock."]
            #[must_use]
            #[inline(always)]
            pub const fn traceportspeed(&self) -> super::vals::Traceportspeed {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Traceportspeed::from_bits(val as u8)
            }
            #[doc = "Speed of Trace Port clock. Note that the TRACECLK pin output will be divided again by two from the Trace Port clock."]
            #[inline(always)]
            pub const fn set_traceportspeed(&mut self, val: super::vals::Traceportspeed) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Traceportspeed {
            #[inline(always)]
            fn default() -> Traceportspeed {
                Traceportspeed(0)
            }
        }
        impl core::fmt::Debug for Traceportspeed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Traceportspeed")
                    .field("traceportspeed", &self.traceportspeed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Traceportspeed {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Traceportspeed {{ traceportspeed: {:?} }}",
                    self.traceportspeed()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselTraceclkPin {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            #[doc = "TRACECLK pin"]
            TRACECLK = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl PselTraceclkPin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselTraceclkPin {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselTraceclkPin {
            #[inline(always)]
            fn from(val: u8) -> PselTraceclkPin {
                PselTraceclkPin::from_bits(val)
            }
        }
        impl From<PselTraceclkPin> for u8 {
            #[inline(always)]
            fn from(val: PselTraceclkPin) -> u8 {
                PselTraceclkPin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselTracedata0Pin {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            #[doc = "TRACEDATA0 pin"]
            TRACEDATA0 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl PselTracedata0Pin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselTracedata0Pin {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselTracedata0Pin {
            #[inline(always)]
            fn from(val: u8) -> PselTracedata0Pin {
                PselTracedata0Pin::from_bits(val)
            }
        }
        impl From<PselTracedata0Pin> for u8 {
            #[inline(always)]
            fn from(val: PselTracedata0Pin) -> u8 {
                PselTracedata0Pin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselTracedata1Pin {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            #[doc = "TRACEDATA1 pin"]
            TRACEDATA1 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl PselTracedata1Pin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselTracedata1Pin {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselTracedata1Pin {
            #[inline(always)]
            fn from(val: u8) -> PselTracedata1Pin {
                PselTracedata1Pin::from_bits(val)
            }
        }
        impl From<PselTracedata1Pin> for u8 {
            #[inline(always)]
            fn from(val: PselTracedata1Pin) -> u8 {
                PselTracedata1Pin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselTracedata2Pin {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            #[doc = "TRACEDATA2 pin"]
            TRACEDATA2 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl PselTracedata2Pin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselTracedata2Pin {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselTracedata2Pin {
            #[inline(always)]
            fn from(val: u8) -> PselTracedata2Pin {
                PselTracedata2Pin::from_bits(val)
            }
        }
        impl From<PselTracedata2Pin> for u8 {
            #[inline(always)]
            fn from(val: PselTracedata2Pin) -> u8 {
                PselTracedata2Pin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselTracedata3Pin {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            #[doc = "TRACEDATA3 pin"]
            TRACEDATA3 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl PselTracedata3Pin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselTracedata3Pin {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselTracedata3Pin {
            #[inline(always)]
            fn from(val: u8) -> PselTracedata3Pin {
                PselTracedata3Pin::from_bits(val)
            }
        }
        impl From<PselTracedata3Pin> for u8 {
            #[inline(always)]
            fn from(val: PselTracedata3Pin) -> u8 {
                PselTracedata3Pin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Traceportspeed {
            #[doc = "Trace Port clock is: 32MHz"]
            _32MHZ = 0x0,
            #[doc = "Trace Port clock is: 16MHz"]
            _16MHZ = 0x01,
            #[doc = "Trace Port clock is: 8MHz"]
            _8MHZ = 0x02,
            #[doc = "Trace Port clock is: 4MHz"]
            _4MHZ = 0x03,
        }
        impl Traceportspeed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Traceportspeed {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Traceportspeed {
            #[inline(always)]
            fn from(val: u8) -> Traceportspeed {
                Traceportspeed::from_bits(val)
            }
        }
        impl From<Traceportspeed> for u8 {
            #[inline(always)]
            fn from(val: Traceportspeed) -> u8 {
                Traceportspeed::to_bits(val)
            }
        }
    }
}
pub mod timer {
    #[doc = "Timer/Counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer {}
    unsafe impl Sync for Timer {}
    impl Timer {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start Timer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop Timer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Increment Timer (Counter mode only)"]
        #[inline(always)]
        pub const fn tasks_count(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Clear time"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
        #[doc = "Deprecated register - Shut down timer"]
        #[inline(always)]
        pub const fn tasks_shutdown(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
        #[doc = "Description collection: Capture Timer value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x40usize + n * 4usize) as _)
            }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task COUNT"]
        #[inline(always)]
        pub const fn subscribe_count(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Deprecated register - Subscribe configuration for task SHUTDOWN"]
        #[inline(always)]
        pub const fn subscribe_shutdown(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x90usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xc0usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0140usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c0usize + n * 4usize) as _)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Timer mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Configure the number of bits used by the TIMER"]
        #[inline(always)]
        pub const fn bitmode(self) -> crate::common::Reg<regs::Bitmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Timer prescaler register"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0510usize) as _) }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[inline(always)]
        pub const fn oneshoten(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Oneshoten, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0514usize + n * 4usize) as _)
            }
        }
        #[doc = "Description collection: Capture/Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0540usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Configure the number of bits used by the TIMER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bitmode(pub u32);
        impl Bitmode {
            #[doc = "Timer bit width"]
            #[must_use]
            #[inline(always)]
            pub const fn bitmode(&self) -> super::vals::Bitmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bitmode::from_bits(val as u8)
            }
            #[doc = "Timer bit width"]
            #[inline(always)]
            pub const fn set_bitmode(&mut self, val: super::vals::Bitmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Bitmode {
            #[inline(always)]
            fn default() -> Bitmode {
                Bitmode(0)
            }
        }
        impl core::fmt::Debug for Bitmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bitmode")
                    .field("bitmode", &self.bitmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bitmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bitmode {{ bitmode: {:?} }}", self.bitmode())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 6usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 6usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .field("compare[4]", &self.compare(4usize))
                    .field("compare[5]", &self.compare(5usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?}, compare[4]: {=bool:?}, compare[5]: {=bool:?} }}" , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize) , self . compare (4usize) , self . compare (5usize))
            }
        }
        #[doc = "Timer mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Timer mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Timer mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oneshoten(pub u32);
        impl Oneshoten {
            #[doc = "Enable one-shot operation"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshoten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable one-shot operation"]
            #[inline(always)]
            pub const fn set_oneshoten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Oneshoten {
            #[inline(always)]
            fn default() -> Oneshoten {
                Oneshoten(0)
            }
        }
        impl core::fmt::Debug for Oneshoten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oneshoten")
                    .field("oneshoten", &self.oneshoten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oneshoten {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oneshoten {{ oneshoten: {=bool:?} }}", self.oneshoten())
            }
        }
        #[doc = "Timer prescaler register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {=u8:?} }}", self.prescaler())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_clear(&self, n: usize) -> bool {
                assert!(n < 6usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn set_compare_clear(&mut self, n: usize, val: bool) {
                assert!(n < 6usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_stop(&self, n: usize) -> bool {
                assert!(n < 6usize);
                let offs = 8usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[inline(always)]
            pub const fn set_compare_stop(&mut self, n: usize, val: bool) {
                assert!(n < 6usize);
                let offs = 8usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("compare_clear[0]", &self.compare_clear(0usize))
                    .field("compare_clear[1]", &self.compare_clear(1usize))
                    .field("compare_clear[2]", &self.compare_clear(2usize))
                    .field("compare_clear[3]", &self.compare_clear(3usize))
                    .field("compare_clear[4]", &self.compare_clear(4usize))
                    .field("compare_clear[5]", &self.compare_clear(5usize))
                    .field("compare_stop[0]", &self.compare_stop(0usize))
                    .field("compare_stop[1]", &self.compare_stop(1usize))
                    .field("compare_stop[2]", &self.compare_stop(2usize))
                    .field("compare_stop[3]", &self.compare_stop(3usize))
                    .field("compare_stop[4]", &self.compare_stop(4usize))
                    .field("compare_stop[5]", &self.compare_stop(5usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ compare_clear[0]: {=bool:?}, compare_clear[1]: {=bool:?}, compare_clear[2]: {=bool:?}, compare_clear[3]: {=bool:?}, compare_clear[4]: {=bool:?}, compare_clear[5]: {=bool:?}, compare_stop[0]: {=bool:?}, compare_stop[1]: {=bool:?}, compare_stop[2]: {=bool:?}, compare_stop[3]: {=bool:?}, compare_stop[4]: {=bool:?}, compare_stop[5]: {=bool:?} }}" , self . compare_clear (0usize) , self . compare_clear (1usize) , self . compare_clear (2usize) , self . compare_clear (3usize) , self . compare_clear (4usize) , self . compare_clear (5usize) , self . compare_stop (0usize) , self . compare_stop (1usize) , self . compare_stop (2usize) , self . compare_stop (3usize) , self . compare_stop (4usize) , self . compare_stop (5usize))
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitmode {
            #[doc = "16 bit timer bit width"]
            _16BIT = 0x0,
            #[doc = "8 bit timer bit width"]
            _08BIT = 0x01,
            #[doc = "24 bit timer bit width"]
            _24BIT = 0x02,
            #[doc = "32 bit timer bit width"]
            _32BIT = 0x03,
        }
        impl Bitmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitmode {
            #[inline(always)]
            fn from(val: u8) -> Bitmode {
                Bitmode::from_bits(val)
            }
        }
        impl From<Bitmode> for u8 {
            #[inline(always)]
            fn from(val: Bitmode) -> u8 {
                Bitmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Select Timer mode"]
            TIMER = 0x0,
            #[doc = "Deprecated enumerator - Select Counter mode"]
            COUNTER = 0x01,
            #[doc = "Select Low Power Counter mode"]
            LOW_POWER_COUNTER = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod tpiu {
    #[doc = "Trace Port Interface Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tpiu {
        ptr: *mut u8,
    }
    unsafe impl Send for Tpiu {}
    unsafe impl Sync for Tpiu {}
    impl Tpiu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[inline(always)]
        pub const fn supportedportsizes(
            self,
        ) -> crate::common::Reg<regs::Supportedportsizes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[inline(always)]
        pub const fn currentportsize(
            self,
        ) -> crate::common::Reg<regs::Currentportsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[inline(always)]
        pub const fn supportedtriggermodes(
            self,
        ) -> crate::common::Reg<regs::Supportedtriggermodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[inline(always)]
        pub const fn triggercountervalue(
            self,
        ) -> crate::common::Reg<regs::Triggercountervalue, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[inline(always)]
        pub const fn triggermultiplier(
            self,
        ) -> crate::common::Reg<regs::Triggermultiplier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[inline(always)]
        pub const fn suppportedtestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Suppportedtestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[inline(always)]
        pub const fn currenttestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Currenttestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0204usize) as _) }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[inline(always)]
        pub const fn tprcr(self) -> crate::common::Reg<regs::Tprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0208usize) as _) }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[inline(always)]
        pub const fn ffsr(self) -> crate::common::Reg<regs::Ffsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[inline(always)]
        pub const fn ffcr(self) -> crate::common::Reg<regs::Ffcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[inline(always)]
        pub const fn fscr(self) -> crate::common::Reg<regs::Fscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[inline(always)]
        pub const fn extctlinport(
            self,
        ) -> crate::common::Reg<regs::Extctlinport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[inline(always)]
        pub const fn extctloutport(
            self,
        ) -> crate::common::Reg<regs::Extctloutport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[inline(always)]
        pub const fn ittrflinack(self) -> crate::common::Reg<regs::Ittrflinack, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee4usize) as _) }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[inline(always)]
        pub const fn ittrflin(self) -> crate::common::Reg<regs::Ittrflin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ee8usize) as _) }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbdata0(self) -> crate::common::Reg<regs::Itatbdata0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0eecusize) as _) }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[inline(always)]
        pub const fn itatbctr2(self) -> crate::common::Reg<regs::Itatbctr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef0usize) as _) }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef4usize) as _) }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ef8usize) as _) }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0f00usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa0usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fa4usize) as _) }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<regs::Lar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb0usize) as _) }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fb8usize) as _) }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fc8usize) as _) }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fccusize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fd0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe4usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fe8usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0fecusize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff0usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff4usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ff8usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Authstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "Read or clear claim bit 0."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimclrBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimclrBit0::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimclrBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Read or clear claim bit 1."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimclrBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimclrBit1::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimclrBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Read or clear claim bit 2."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimclrBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimclrBit2::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimclrBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Read or clear claim bit 3."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimclrBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimclrBit3::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimclrBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimclr {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimsetBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimsetBit0::from_bits(val as u8)
            }
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimsetBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimsetBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimsetBit1::from_bits(val as u8)
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimsetBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimsetBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimsetBit2::from_bits(val as u8)
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimsetBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimsetBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimsetBit3::from_bits(val as u8)
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimsetBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimset {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentportsize(pub u32);
        impl Currentportsize {
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Currentportsize {
            #[inline(always)]
            fn default() -> Currentportsize {
                Currentportsize(0)
            }
        }
        impl core::fmt::Debug for Currentportsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentportsize")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentportsize {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Currentportsize {{ port_size_1: {=bool:?}, port_size_2: {=bool:?}, port_size_3: {=bool:?}, port_size_4: {=bool:?}, port_size_5: {=bool:?}, port_size_6: {=bool:?}, port_size_7: {=bool:?}, port_size_8: {=bool:?}, port_size_9: {=bool:?}, port_size_10: {=bool:?}, port_size_11: {=bool:?}, port_size_12: {=bool:?}, port_size_13: {=bool:?}, port_size_14: {=bool:?}, port_size_15: {=bool:?}, port_size_16: {=bool:?}, port_size_17: {=bool:?}, port_size_18: {=bool:?}, port_size_19: {=bool:?}, port_size_20: {=bool:?}, port_size_21: {=bool:?}, port_size_22: {=bool:?}, port_size_23: {=bool:?}, port_size_24: {=bool:?}, port_size_25: {=bool:?}, port_size_26: {=bool:?}, port_size_27: {=bool:?}, port_size_28: {=bool:?}, port_size_29: {=bool:?}, port_size_30: {=bool:?}, port_size_31: {=bool:?}, port_size_32: {=bool:?} }}" , self . port_size_1 () , self . port_size_2 () , self . port_size_3 () , self . port_size_4 () , self . port_size_5 () , self . port_size_6 () , self . port_size_7 () , self . port_size_8 () , self . port_size_9 () , self . port_size_10 () , self . port_size_11 () , self . port_size_12 () , self . port_size_13 () , self . port_size_14 () , self . port_size_15 () , self . port_size_16 () , self . port_size_17 () , self . port_size_18 () , self . port_size_19 () , self . port_size_20 () , self . port_size_21 () , self . port_size_22 () , self . port_size_23 () , self . port_size_24 () , self . port_size_25 () , self . port_size_26 () , self . port_size_27 () , self . port_size_28 () , self . port_size_29 () , self . port_size_30 () , self . port_size_31 () , self . port_size_32 ())
            }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currenttestpatternmodes(pub u32);
        impl Currenttestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Currenttestpatternmodes {
            #[inline(always)]
            fn default() -> Currenttestpatternmodes {
                Currenttestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Currenttestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currenttestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currenttestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Currenttestpatternmodes {{ patw1: {=bool:?}, patw0: {=bool:?}, pata5: {=bool:?}, patf0: {=bool:?}, ptimeen: {=bool:?}, pconten: {=bool:?} }}" , self . patw1 () , self . patw0 () , self . pata5 () , self . patf0 () , self . ptimeen () , self . pconten ())
            }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[must_use]
            #[inline(always)]
            pub const fn muxnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[inline(always)]
            pub const fn set_muxnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[must_use]
            #[inline(always)]
            pub const fn clkrelat(&self) -> super::vals::Clkrelat {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clkrelat::from_bits(val as u8)
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[inline(always)]
            pub const fn set_clkrelat(&mut self, val: super::vals::Clkrelat) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "FIFO size in powers of 2."]
            #[must_use]
            #[inline(always)]
            pub const fn fifosize(&self) -> super::vals::Fifosize {
                let val = (self.0 >> 6usize) & 0x07;
                super::vals::Fifosize::from_bits(val as u8)
            }
            #[doc = "FIFO size in powers of 2."]
            #[inline(always)]
            pub const fn set_fifosize(&mut self, val: super::vals::Fifosize) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val.to_bits() as u32) & 0x07) << 6usize);
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn tclkdata(&self) -> super::vals::Tclkdata {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tclkdata::from_bits(val as u8)
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[inline(always)]
            pub const fn set_tclkdata(&mut self, val: super::vals::Tclkdata) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn swoman(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[inline(always)]
            pub const fn set_swoman(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn swouartnrz(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[inline(always)]
            pub const fn set_swouartnrz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("muxnum", &self.muxnum())
                    .field("clkrelat", &self.clkrelat())
                    .field("fifosize", &self.fifosize())
                    .field("tclkdata", &self.tclkdata())
                    .field("swoman", &self.swoman())
                    .field("swouartnrz", &self.swouartnrz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Devid {{ muxnum: {=u8:?}, clkrelat: {:?}, fifosize: {:?}, tclkdata: {:?}, swoman: {=bool:?}, swouartnrz: {=bool:?} }}" , self . muxnum () , self . clkrelat () , self . fifosize () , self . tclkdata () , self . swoman () , self . swouartnrz ())
            }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctlinport(pub u32);
        impl Extctlinport {
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_0(&self) -> super::vals::Extctlin0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlin0::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_0(&mut self, val: super::vals::Extctlin0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_1(&self) -> super::vals::Extctlin1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlin1::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_1(&mut self, val: super::vals::Extctlin1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_2(&self) -> super::vals::Extctlin2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlin2::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_2(&mut self, val: super::vals::Extctlin2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_3(&self) -> super::vals::Extctlin3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlin3::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_3(&mut self, val: super::vals::Extctlin3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_4(&self) -> super::vals::Extctlin4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlin4::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_4(&mut self, val: super::vals::Extctlin4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_5(&self) -> super::vals::Extctlin5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlin5::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_5(&mut self, val: super::vals::Extctlin5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_6(&self) -> super::vals::Extctlin6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlin6::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_6(&mut self, val: super::vals::Extctlin6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_7(&self) -> super::vals::Extctlin7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlin7::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_7(&mut self, val: super::vals::Extctlin7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctlinport {
            #[inline(always)]
            fn default() -> Extctlinport {
                Extctlinport(0)
            }
        }
        impl core::fmt::Debug for Extctlinport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctlinport")
                    .field("extctlin_0", &self.extctlin_0())
                    .field("extctlin_1", &self.extctlin_1())
                    .field("extctlin_2", &self.extctlin_2())
                    .field("extctlin_3", &self.extctlin_3())
                    .field("extctlin_4", &self.extctlin_4())
                    .field("extctlin_5", &self.extctlin_5())
                    .field("extctlin_6", &self.extctlin_6())
                    .field("extctlin_7", &self.extctlin_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctlinport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Extctlinport {{ extctlin_0: {:?}, extctlin_1: {:?}, extctlin_2: {:?}, extctlin_3: {:?}, extctlin_4: {:?}, extctlin_5: {:?}, extctlin_6: {:?}, extctlin_7: {:?} }}" , self . extctlin_0 () , self . extctlin_1 () , self . extctlin_2 () , self . extctlin_3 () , self . extctlin_4 () , self . extctlin_5 () , self . extctlin_6 () , self . extctlin_7 ())
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctloutport(pub u32);
        impl Extctloutport {
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_0(&self) -> super::vals::Extctlout0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlout0::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_0(&mut self, val: super::vals::Extctlout0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_1(&self) -> super::vals::Extctlout1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlout1::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_1(&mut self, val: super::vals::Extctlout1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_2(&self) -> super::vals::Extctlout2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlout2::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_2(&mut self, val: super::vals::Extctlout2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_3(&self) -> super::vals::Extctlout3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlout3::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_3(&mut self, val: super::vals::Extctlout3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_4(&self) -> super::vals::Extctlout4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlout4::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_4(&mut self, val: super::vals::Extctlout4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_5(&self) -> super::vals::Extctlout5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlout5::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_5(&mut self, val: super::vals::Extctlout5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_6(&self) -> super::vals::Extctlout6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlout6::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_6(&mut self, val: super::vals::Extctlout6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_7(&self) -> super::vals::Extctlout7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlout7::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_7(&mut self, val: super::vals::Extctlout7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctloutport {
            #[inline(always)]
            fn default() -> Extctloutport {
                Extctloutport(0)
            }
        }
        impl core::fmt::Debug for Extctloutport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctloutport")
                    .field("extctlout_0", &self.extctlout_0())
                    .field("extctlout_1", &self.extctlout_1())
                    .field("extctlout_2", &self.extctlout_2())
                    .field("extctlout_3", &self.extctlout_3())
                    .field("extctlout_4", &self.extctlout_4())
                    .field("extctlout_5", &self.extctlout_5())
                    .field("extctlout_6", &self.extctlout_6())
                    .field("extctlout_7", &self.extctlout_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctloutport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Extctloutport {{ extctlout_0: {:?}, extctlout_1: {:?}, extctlout_2: {:?}, extctlout_3: {:?}, extctlout_4: {:?}, extctlout_5: {:?}, extctlout_6: {:?}, extctlout_7: {:?} }}" , self . extctlout_0 () , self . extctlout_1 () , self . extctlout_2 () , self . extctlout_3 () , self . extctlout_4 () , self . extctlout_5 () , self . extctlout_6 () , self . extctlout_7 ())
            }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffcr(pub u32);
        impl Ffcr {
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[must_use]
            #[inline(always)]
            pub const fn enftc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[inline(always)]
            pub const fn set_enftc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[must_use]
            #[inline(always)]
            pub const fn enfcont(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[inline(always)]
            pub const fn set_enfcont(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enables the use of the flushin connection."]
            #[must_use]
            #[inline(always)]
            pub const fn fonflin(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the use of the flushin connection."]
            #[inline(always)]
            pub const fn set_fonflin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[must_use]
            #[inline(always)]
            pub const fn fontrig(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[inline(always)]
            pub const fn set_fontrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[must_use]
            #[inline(always)]
            pub const fn fonmanr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[inline(always)]
            pub const fn set_fonmanr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[must_use]
            #[inline(always)]
            pub const fn fonmanw(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[inline(always)]
            pub const fn set_fonmanw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[must_use]
            #[inline(always)]
            pub const fn trigevt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[inline(always)]
            pub const fn set_trigevt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[must_use]
            #[inline(always)]
            pub const fn trigfl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[inline(always)]
            pub const fn set_trigfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[must_use]
            #[inline(always)]
            pub const fn stopfl(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[inline(always)]
            pub const fn set_stopfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[must_use]
            #[inline(always)]
            pub const fn stoptrig(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[inline(always)]
            pub const fn set_stoptrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Ffcr {
            #[inline(always)]
            fn default() -> Ffcr {
                Ffcr(0)
            }
        }
        impl core::fmt::Debug for Ffcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffcr")
                    .field("enftc", &self.enftc())
                    .field("enfcont", &self.enfcont())
                    .field("fonflin", &self.fonflin())
                    .field("fontrig", &self.fontrig())
                    .field("fonmanr", &self.fonmanr())
                    .field("fonmanw", &self.fonmanw())
                    .field("trigin", &self.trigin())
                    .field("trigevt", &self.trigevt())
                    .field("trigfl", &self.trigfl())
                    .field("stopfl", &self.stopfl())
                    .field("stoptrig", &self.stoptrig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ffcr {{ enftc: {=bool:?}, enfcont: {=bool:?}, fonflin: {=bool:?}, fontrig: {=bool:?}, fonmanr: {=bool:?}, fonmanw: {=bool:?}, trigin: {=bool:?}, trigevt: {=bool:?}, trigfl: {=bool:?}, stopfl: {=bool:?}, stoptrig: {=bool:?} }}" , self . enftc () , self . enfcont () , self . fonflin () , self . fontrig () , self . fonmanr () , self . fonmanw () , self . trigin () , self . trigevt () , self . trigfl () , self . stopfl () , self . stoptrig ())
            }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffsr(pub u32);
        impl Ffsr {
            #[doc = "Flush in progress."]
            #[must_use]
            #[inline(always)]
            pub const fn flinprog(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flush in progress."]
            #[inline(always)]
            pub const fn set_flinprog(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[must_use]
            #[inline(always)]
            pub const fn ftstopped(&self) -> super::vals::Ftstopped {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ftstopped::from_bits(val as u8)
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[inline(always)]
            pub const fn set_ftstopped(&mut self, val: super::vals::Ftstopped) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[must_use]
            #[inline(always)]
            pub const fn tcpresent(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[inline(always)]
            pub const fn set_tcpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Ffsr {
            #[inline(always)]
            fn default() -> Ffsr {
                Ffsr(0)
            }
        }
        impl core::fmt::Debug for Ffsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffsr")
                    .field("flinprog", &self.flinprog())
                    .field("ftstopped", &self.ftstopped())
                    .field("tcpresent", &self.tcpresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ffsr {{ flinprog: {=bool:?}, ftstopped: {:?}, tcpresent: {=bool:?} }}",
                    self.flinprog(),
                    self.ftstopped(),
                    self.tcpresent()
                )
            }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscr(pub u32);
        impl Fscr {
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[must_use]
            #[inline(always)]
            pub const fn cyccount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[inline(always)]
            pub const fn set_cyccount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Fscr {
            #[inline(always)]
            fn default() -> Fscr {
                Fscr(0)
            }
        }
        impl core::fmt::Debug for Fscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscr")
                    .field("cyccount", &self.cyccount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fscr {{ cyccount: {=u16:?} }}", self.cyccount())
            }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "Reads the value of atvalids."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> super::vals::Atvalid {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atvalid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atvalids."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: super::vals::Atvalid) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of afreadys."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> super::vals::Afready {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Afready::from_bits(val as u8)
            }
            #[doc = "Reads the value of afreadys."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: super::vals::Afready) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Reads the value of atbytess."]
            #[must_use]
            #[inline(always)]
            pub const fn atbytes(&self) -> super::vals::Atbytes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Atbytes::from_bits(val as u8)
            }
            #[doc = "Reads the value of atbytess."]
            #[inline(always)]
            pub const fn set_atbytes(&mut self, val: super::vals::Atbytes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .field("atbytes", &self.atbytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr0 {{ atvalid: {:?}, afready: {:?}, atbytes: {:?} }}",
                    self.atvalid(),
                    self.afready(),
                    self.atbytes()
                )
            }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "Reads the value of atids."]
            #[must_use]
            #[inline(always)]
            pub const fn atid(&self) -> super::vals::Atid {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Atid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atids."]
            #[inline(always)]
            pub const fn set_atid(&mut self, val: super::vals::Atid) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atid", &self.atid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itatbctr1 {{ atid: {:?} }}", self.atid())
            }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr2(pub u32);
        impl Itatbctr2 {
            #[doc = "Sets the value of afvalid."]
            #[must_use]
            #[inline(always)]
            pub const fn atready(&self) -> super::vals::Atready {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atready::from_bits(val as u8)
            }
            #[doc = "Sets the value of afvalid."]
            #[inline(always)]
            pub const fn set_atready(&mut self, val: super::vals::Atready) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of atready."]
            #[must_use]
            #[inline(always)]
            pub const fn afvalid(&self) -> super::vals::Afvalid {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Afvalid::from_bits(val as u8)
            }
            #[doc = "Sets the value of atready."]
            #[inline(always)]
            pub const fn set_afvalid(&mut self, val: super::vals::Afvalid) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itatbctr2 {
            #[inline(always)]
            fn default() -> Itatbctr2 {
                Itatbctr2(0)
            }
        }
        impl core::fmt::Debug for Itatbctr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr2")
                    .field("atready", &self.atready())
                    .field("afvalid", &self.afvalid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr2 {{ atready: {:?}, afvalid: {:?} }}",
                    self.atready(),
                    self.afvalid()
                )
            }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbdata0(pub u32);
        impl Itatbdata0 {
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_0(&self) -> super::vals::Atdata0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atdata0::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_0(&mut self, val: super::vals::Atdata0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_1(&self) -> super::vals::Atdata1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Atdata1::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_1(&mut self, val: super::vals::Atdata1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_2(&self) -> super::vals::Atdata2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Atdata2::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_2(&mut self, val: super::vals::Atdata2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_3(&self) -> super::vals::Atdata3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atdata3::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_3(&mut self, val: super::vals::Atdata3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_4(&self) -> super::vals::Atdata4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Atdata4::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_4(&mut self, val: super::vals::Atdata4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Itatbdata0 {
            #[inline(always)]
            fn default() -> Itatbdata0 {
                Itatbdata0(0)
            }
        }
        impl core::fmt::Debug for Itatbdata0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbdata0")
                    .field("atdata_0", &self.atdata_0())
                    .field("atdata_1", &self.atdata_1())
                    .field("atdata_2", &self.atdata_2())
                    .field("atdata_3", &self.atdata_3())
                    .field("atdata_4", &self.atdata_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbdata0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Itatbdata0 {{ atdata_0: {:?}, atdata_1: {:?}, atdata_2: {:?}, atdata_3: {:?}, atdata_4: {:?} }}" , self . atdata_0 () , self . atdata_1 () , self . atdata_2 () , self . atdata_3 () , self . atdata_4 ())
            }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[must_use]
            #[inline(always)]
            pub const fn integrationmode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[inline(always)]
            pub const fn set_integrationmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl")
                    .field("integrationmode", &self.integrationmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itctrl {{ integrationmode: {=bool:?} }}",
                    self.integrationmode()
                )
            }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflin(pub u32);
        impl Ittrflin {
            #[doc = "Reads the value of trigin."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> super::vals::IttrflinTrigin {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IttrflinTrigin::from_bits(val as u8)
            }
            #[doc = "Reads the value of trigin."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: super::vals::IttrflinTrigin) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of flushin."]
            #[must_use]
            #[inline(always)]
            pub const fn flushin(&self) -> super::vals::Flushin {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushin::from_bits(val as u8)
            }
            #[doc = "Reads the value of flushin."]
            #[inline(always)]
            pub const fn set_flushin(&mut self, val: super::vals::Flushin) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflin {
            #[inline(always)]
            fn default() -> Ittrflin {
                Ittrflin(0)
            }
        }
        impl core::fmt::Debug for Ittrflin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflin")
                    .field("trigin", &self.trigin())
                    .field("flushin", &self.flushin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflin {{ trigin: {:?}, flushin: {:?} }}",
                    self.trigin(),
                    self.flushin()
                )
            }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflinack(pub u32);
        impl Ittrflinack {
            #[doc = "Sets the value of triginack."]
            #[must_use]
            #[inline(always)]
            pub const fn triginack(&self) -> super::vals::Triginack {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Triginack::from_bits(val as u8)
            }
            #[doc = "Sets the value of triginack."]
            #[inline(always)]
            pub const fn set_triginack(&mut self, val: super::vals::Triginack) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of flushinack."]
            #[must_use]
            #[inline(always)]
            pub const fn flushinack(&self) -> super::vals::Flushinack {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushinack::from_bits(val as u8)
            }
            #[doc = "Sets the value of flushinack."]
            #[inline(always)]
            pub const fn set_flushinack(&mut self, val: super::vals::Flushinack) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflinack {
            #[inline(always)]
            fn default() -> Ittrflinack {
                Ittrflinack(0)
            }
        }
        impl core::fmt::Debug for Ittrflinack {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflinack")
                    .field("triginack", &self.triginack())
                    .field("flushinack", &self.flushinack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflinack {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflinack {{ triginack: {:?}, flushinack: {:?} }}",
                    self.triginack(),
                    self.flushinack()
                )
            }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lar(pub u32);
        impl Lar {
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[must_use]
            #[inline(always)]
            pub const fn access(&self) -> super::vals::Access {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Access::from_bits(val as u32)
            }
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub const fn set_access(&mut self, val: super::vals::Access) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Lar {
            #[inline(always)]
            fn default() -> Lar {
                Lar(0)
            }
        }
        impl core::fmt::Debug for Lar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lar")
                    .field("access", &self.access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lar {{ access: {:?} }}", self.access())
            }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub const fn set_present(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock."]
            #[must_use]
            #[inline(always)]
            pub const fn locked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub const fn set_locked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::Type) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("present", &self.present())
                    .field("locked", &self.locked())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ present: {=bool:?}, locked: {=bool:?}, type_: {:?} }}",
                    self.present(),
                    self.locked(),
                    self.type_()
                )
            }
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedportsizes(pub u32);
        impl Supportedportsizes {
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[inline(always)]
            pub const fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[inline(always)]
            pub const fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[inline(always)]
            pub const fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[inline(always)]
            pub const fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[inline(always)]
            pub const fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[inline(always)]
            pub const fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[inline(always)]
            pub const fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[inline(always)]
            pub const fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[inline(always)]
            pub const fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[inline(always)]
            pub const fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[inline(always)]
            pub const fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[inline(always)]
            pub const fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[inline(always)]
            pub const fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[inline(always)]
            pub const fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[inline(always)]
            pub const fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[inline(always)]
            pub const fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[inline(always)]
            pub const fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[inline(always)]
            pub const fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[inline(always)]
            pub const fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[inline(always)]
            pub const fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[inline(always)]
            pub const fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[inline(always)]
            pub const fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[inline(always)]
            pub const fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[inline(always)]
            pub const fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[inline(always)]
            pub const fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[inline(always)]
            pub const fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[inline(always)]
            pub const fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[inline(always)]
            pub const fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[inline(always)]
            pub const fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[inline(always)]
            pub const fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[inline(always)]
            pub const fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[inline(always)]
            pub const fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Supportedportsizes {
            #[inline(always)]
            fn default() -> Supportedportsizes {
                Supportedportsizes(0)
            }
        }
        impl core::fmt::Debug for Supportedportsizes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedportsizes")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedportsizes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Supportedportsizes {{ port_size_1: {=bool:?}, port_size_2: {=bool:?}, port_size_3: {=bool:?}, port_size_4: {=bool:?}, port_size_5: {=bool:?}, port_size_6: {=bool:?}, port_size_7: {=bool:?}, port_size_8: {=bool:?}, port_size_9: {=bool:?}, port_size_10: {=bool:?}, port_size_11: {=bool:?}, port_size_12: {=bool:?}, port_size_13: {=bool:?}, port_size_14: {=bool:?}, port_size_15: {=bool:?}, port_size_16: {=bool:?}, port_size_17: {=bool:?}, port_size_18: {=bool:?}, port_size_19: {=bool:?}, port_size_20: {=bool:?}, port_size_21: {=bool:?}, port_size_22: {=bool:?}, port_size_23: {=bool:?}, port_size_24: {=bool:?}, port_size_25: {=bool:?}, port_size_26: {=bool:?}, port_size_27: {=bool:?}, port_size_28: {=bool:?}, port_size_29: {=bool:?}, port_size_30: {=bool:?}, port_size_31: {=bool:?}, port_size_32: {=bool:?} }}" , self . port_size_1 () , self . port_size_2 () , self . port_size_3 () , self . port_size_4 () , self . port_size_5 () , self . port_size_6 () , self . port_size_7 () , self . port_size_8 () , self . port_size_9 () , self . port_size_10 () , self . port_size_11 () , self . port_size_12 () , self . port_size_13 () , self . port_size_14 () , self . port_size_15 () , self . port_size_16 () , self . port_size_17 () , self . port_size_18 () , self . port_size_19 () , self . port_size_20 () , self . port_size_21 () , self . port_size_22 () , self . port_size_23 () , self . port_size_24 () , self . port_size_25 () , self . port_size_26 () , self . port_size_27 () , self . port_size_28 () , self . port_size_29 () , self . port_size_30 () , self . port_size_31 () , self . port_size_32 ())
            }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedtriggermodes(pub u32);
        impl Supportedtriggermodes {
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[must_use]
            #[inline(always)]
            pub const fn tcount8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[inline(always)]
            pub const fn set_tcount8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[inline(always)]
            pub const fn set_triggered(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[must_use]
            #[inline(always)]
            pub const fn trgrun(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[inline(always)]
            pub const fn set_trgrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Supportedtriggermodes {
            #[inline(always)]
            fn default() -> Supportedtriggermodes {
                Supportedtriggermodes(0)
            }
        }
        impl core::fmt::Debug for Supportedtriggermodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedtriggermodes")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .field("tcount8", &self.tcount8())
                    .field("triggered", &self.triggered())
                    .field("trgrun", &self.trgrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedtriggermodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Supportedtriggermodes {{ mult_0: {=bool:?}, mult_1: {=bool:?}, mult_2: {=bool:?}, mult_3: {=bool:?}, mult_4: {=bool:?}, tcount8: {=bool:?}, triggered: {=bool:?}, trgrun: {=bool:?} }}" , self . mult_0 () , self . mult_1 () , self . mult_2 () , self . mult_3 () , self . mult_4 () , self . tcount8 () , self . triggered () , self . trgrun ())
            }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Suppportedtestpatternmodes(pub u32);
        impl Suppportedtestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Suppportedtestpatternmodes {
            #[inline(always)]
            fn default() -> Suppportedtestpatternmodes {
                Suppportedtestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Suppportedtestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Suppportedtestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Suppportedtestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Suppportedtestpatternmodes {{ patw1: {=bool:?}, patw0: {=bool:?}, pata5: {=bool:?}, patf0: {=bool:?}, ptimeen: {=bool:?}, pconten: {=bool:?} }}" , self . patw1 () , self . patw0 () , self . pata5 () , self . patf0 () , self . ptimeen () , self . pconten ())
            }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tprcr(pub u32);
        impl Tprcr {
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[must_use]
            #[inline(always)]
            pub const fn pattcount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[inline(always)]
            pub const fn set_pattcount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Tprcr {
            #[inline(always)]
            fn default() -> Tprcr {
                Tprcr(0)
            }
        }
        impl core::fmt::Debug for Tprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tprcr")
                    .field("pattcount", &self.pattcount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tprcr {{ pattcount: {=u8:?} }}", self.pattcount())
            }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggercountervalue(pub u32);
        impl Triggercountervalue {
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[must_use]
            #[inline(always)]
            pub const fn trig_count(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[inline(always)]
            pub const fn set_trig_count(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Triggercountervalue {
            #[inline(always)]
            fn default() -> Triggercountervalue {
                Triggercountervalue(0)
            }
        }
        impl core::fmt::Debug for Triggercountervalue {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggercountervalue")
                    .field("trig_count", &self.trig_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggercountervalue {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Triggercountervalue {{ trig_count: {=u8:?} }}",
                    self.trig_count()
                )
            }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggermultiplier(pub u32);
        impl Triggermultiplier {
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Triggermultiplier {
            #[inline(always)]
            fn default() -> Triggermultiplier {
                Triggermultiplier(0)
            }
        }
        impl core::fmt::Debug for Triggermultiplier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggermultiplier")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggermultiplier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Triggermultiplier {{ mult_0: {=bool:?}, mult_1: {=bool:?}, mult_2: {=bool:?}, mult_3: {=bool:?}, mult_4: {=bool:?} }}" , self . mult_0 () , self . mult_1 () , self . mult_2 () , self . mult_3 () , self . mult_4 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Access(u32);
        impl Access {
            #[doc = "Unlock register interface."]
            pub const UN_LOCK: Self = Self(0xc5ac_ce55);
        }
        impl Access {
            pub const fn from_bits(val: u32) -> Access {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Access {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xc5ac_ce55 => f.write_str("UN_LOCK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Access {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xc5ac_ce55 => defmt::write!(f, "UN_LOCK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Access {
            #[inline(always)]
            fn from(val: u32) -> Access {
                Access::from_bits(val)
            }
        }
        impl From<Access> for u32 {
            #[inline(always)]
            fn from(val: Access) -> u32 {
                Access::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afready {
            #[inline(always)]
            fn from(val: u8) -> Afready {
                Afready::from_bits(val)
            }
        }
        impl From<Afready> for u8 {
            #[inline(always)]
            fn from(val: Afready) -> u8 {
                Afready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afvalid {
            #[inline(always)]
            fn from(val: u8) -> Afvalid {
                Afvalid::from_bits(val)
            }
        }
        impl From<Afvalid> for u8 {
            #[inline(always)]
            fn from(val: Afvalid) -> u8 {
                Afvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atbytes {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Atbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atbytes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atbytes {
            #[inline(always)]
            fn from(val: u8) -> Atbytes {
                Atbytes::from_bits(val)
            }
        }
        impl From<Atbytes> for u8 {
            #[inline(always)]
            fn from(val: Atbytes) -> u8 {
                Atbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata0 {
            #[inline(always)]
            fn from(val: u8) -> Atdata0 {
                Atdata0::from_bits(val)
            }
        }
        impl From<Atdata0> for u8 {
            #[inline(always)]
            fn from(val: Atdata0) -> u8 {
                Atdata0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata1 {
            #[inline(always)]
            fn from(val: u8) -> Atdata1 {
                Atdata1::from_bits(val)
            }
        }
        impl From<Atdata1> for u8 {
            #[inline(always)]
            fn from(val: Atdata1) -> u8 {
                Atdata1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata2 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata2 {
            #[inline(always)]
            fn from(val: u8) -> Atdata2 {
                Atdata2::from_bits(val)
            }
        }
        impl From<Atdata2> for u8 {
            #[inline(always)]
            fn from(val: Atdata2) -> u8 {
                Atdata2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata3 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata3 {
            #[inline(always)]
            fn from(val: u8) -> Atdata3 {
                Atdata3::from_bits(val)
            }
        }
        impl From<Atdata3> for u8 {
            #[inline(always)]
            fn from(val: Atdata3) -> u8 {
                Atdata3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata4 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata4 {
            #[inline(always)]
            fn from(val: u8) -> Atdata4 {
                Atdata4::from_bits(val)
            }
        }
        impl From<Atdata4> for u8 {
            #[inline(always)]
            fn from(val: Atdata4) -> u8 {
                Atdata4::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Atid(u8);
        impl Atid {
            #[doc = "Pin is logic 0."]
            pub const LOW: Self = Self(0x0);
            #[doc = "Pin is logic 1."]
            pub const HIGH: Self = Self(0x01);
        }
        impl Atid {
            pub const fn from_bits(val: u8) -> Atid {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Atid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("LOW"),
                    0x01 => f.write_str("HIGH"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Atid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "LOW"),
                    0x01 => defmt::write!(f, "HIGH"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Atid {
            #[inline(always)]
            fn from(val: u8) -> Atid {
                Atid::from_bits(val)
            }
        }
        impl From<Atid> for u8 {
            #[inline(always)]
            fn from(val: Atid) -> u8 {
                Atid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atready {
            #[inline(always)]
            fn from(val: u8) -> Atready {
                Atready::from_bits(val)
            }
        }
        impl From<Atready> for u8 {
            #[inline(always)]
            fn from(val: Atready) -> u8 {
                Atready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalid {
            #[inline(always)]
            fn from(val: u8) -> Atvalid {
                Atvalid::from_bits(val)
            }
        }
        impl From<Atvalid> for u8 {
            #[inline(always)]
            fn from(val: Atvalid) -> u8 {
                Atvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit0 {
            #[doc = "Claim bit 0 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit0 {
                ClaimclrBit0::from_bits(val)
            }
        }
        impl From<ClaimclrBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit0) -> u8 {
                ClaimclrBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit1 {
            #[doc = "Claim bit 1 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit1 {
                ClaimclrBit1::from_bits(val)
            }
        }
        impl From<ClaimclrBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit1) -> u8 {
                ClaimclrBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit2 {
            #[doc = "Claim bit 2 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit2 {
                ClaimclrBit2::from_bits(val)
            }
        }
        impl From<ClaimclrBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit2) -> u8 {
                ClaimclrBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit3 {
            #[doc = "Claim bit 3 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit3 {
                ClaimclrBit3::from_bits(val)
            }
        }
        impl From<ClaimclrBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit3) -> u8 {
                ClaimclrBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit0 {
            #[doc = "Claim bit 0 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 0 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit0 {
                ClaimsetBit0::from_bits(val)
            }
        }
        impl From<ClaimsetBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit0) -> u8 {
                ClaimsetBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit1 {
            #[doc = "Claim bit 1 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 1 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit1 {
                ClaimsetBit1::from_bits(val)
            }
        }
        impl From<ClaimsetBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit1) -> u8 {
                ClaimsetBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit2 {
            #[doc = "Claim bit 2 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 2 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit2 {
                ClaimsetBit2::from_bits(val)
            }
        }
        impl From<ClaimsetBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit2) -> u8 {
                ClaimsetBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit3 {
            #[doc = "Claim bit 3 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 3 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit3 {
                ClaimsetBit3::from_bits(val)
            }
        }
        impl From<ClaimsetBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit3) -> u8 {
                ClaimsetBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clkrelat {
            #[doc = "atclk and traceclkin are synchronous."]
            SYNCHRONOUS = 0x0,
            #[doc = "atclk and traceclkin are asynchronous."]
            ASYNCHRONOUS = 0x01,
        }
        impl Clkrelat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clkrelat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clkrelat {
            #[inline(always)]
            fn from(val: u8) -> Clkrelat {
                Clkrelat::from_bits(val)
            }
        }
        impl From<Clkrelat> for u8 {
            #[inline(always)]
            fn from(val: Clkrelat) -> u8 {
                Clkrelat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin0 {
            #[doc = "Input EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlin0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin0 {
                Extctlin0::from_bits(val)
            }
        }
        impl From<Extctlin0> for u8 {
            #[inline(always)]
            fn from(val: Extctlin0) -> u8 {
                Extctlin0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin1 {
            #[doc = "Input EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlin1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin1 {
                Extctlin1::from_bits(val)
            }
        }
        impl From<Extctlin1> for u8 {
            #[inline(always)]
            fn from(val: Extctlin1) -> u8 {
                Extctlin1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin2 {
            #[doc = "Input EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlin2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin2 {
                Extctlin2::from_bits(val)
            }
        }
        impl From<Extctlin2> for u8 {
            #[inline(always)]
            fn from(val: Extctlin2) -> u8 {
                Extctlin2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin3 {
            #[doc = "Input EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlin3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin3 {
                Extctlin3::from_bits(val)
            }
        }
        impl From<Extctlin3> for u8 {
            #[inline(always)]
            fn from(val: Extctlin3) -> u8 {
                Extctlin3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin4 {
            #[doc = "Input EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlin4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin4 {
                Extctlin4::from_bits(val)
            }
        }
        impl From<Extctlin4> for u8 {
            #[inline(always)]
            fn from(val: Extctlin4) -> u8 {
                Extctlin4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin5 {
            #[doc = "Input EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlin5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin5 {
                Extctlin5::from_bits(val)
            }
        }
        impl From<Extctlin5> for u8 {
            #[inline(always)]
            fn from(val: Extctlin5) -> u8 {
                Extctlin5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin6 {
            #[doc = "Input EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlin6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin6 {
                Extctlin6::from_bits(val)
            }
        }
        impl From<Extctlin6> for u8 {
            #[inline(always)]
            fn from(val: Extctlin6) -> u8 {
                Extctlin6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin7 {
            #[doc = "Input EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlin7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin7 {
                Extctlin7::from_bits(val)
            }
        }
        impl From<Extctlin7> for u8 {
            #[inline(always)]
            fn from(val: Extctlin7) -> u8 {
                Extctlin7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout0 {
            #[doc = "Output EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlout0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout0 {
                Extctlout0::from_bits(val)
            }
        }
        impl From<Extctlout0> for u8 {
            #[inline(always)]
            fn from(val: Extctlout0) -> u8 {
                Extctlout0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout1 {
            #[doc = "Output EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlout1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout1 {
                Extctlout1::from_bits(val)
            }
        }
        impl From<Extctlout1> for u8 {
            #[inline(always)]
            fn from(val: Extctlout1) -> u8 {
                Extctlout1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout2 {
            #[doc = "Output EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlout2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout2 {
                Extctlout2::from_bits(val)
            }
        }
        impl From<Extctlout2> for u8 {
            #[inline(always)]
            fn from(val: Extctlout2) -> u8 {
                Extctlout2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout3 {
            #[doc = "Output EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlout3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout3 {
                Extctlout3::from_bits(val)
            }
        }
        impl From<Extctlout3> for u8 {
            #[inline(always)]
            fn from(val: Extctlout3) -> u8 {
                Extctlout3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout4 {
            #[doc = "Output EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlout4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout4 {
                Extctlout4::from_bits(val)
            }
        }
        impl From<Extctlout4> for u8 {
            #[inline(always)]
            fn from(val: Extctlout4) -> u8 {
                Extctlout4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout5 {
            #[doc = "Output EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlout5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout5 {
                Extctlout5::from_bits(val)
            }
        }
        impl From<Extctlout5> for u8 {
            #[inline(always)]
            fn from(val: Extctlout5) -> u8 {
                Extctlout5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout6 {
            #[doc = "Output EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlout6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout6 {
                Extctlout6::from_bits(val)
            }
        }
        impl From<Extctlout6> for u8 {
            #[inline(always)]
            fn from(val: Extctlout6) -> u8 {
                Extctlout6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout7 {
            #[doc = "Output EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlout7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout7 {
                Extctlout7::from_bits(val)
            }
        }
        impl From<Extctlout7> for u8 {
            #[inline(always)]
            fn from(val: Extctlout7) -> u8 {
                Extctlout7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fifosize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "FIFO size of 4 entries, that is, 16 bytes."]
            ENTRIES4 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fifosize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fifosize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fifosize {
            #[inline(always)]
            fn from(val: u8) -> Fifosize {
                Fifosize::from_bits(val)
            }
        }
        impl From<Fifosize> for u8 {
            #[inline(always)]
            fn from(val: Fifosize) -> u8 {
                Fifosize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushin {
            #[inline(always)]
            fn from(val: u8) -> Flushin {
                Flushin::from_bits(val)
            }
        }
        impl From<Flushin> for u8 {
            #[inline(always)]
            fn from(val: Flushin) -> u8 {
                Flushin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushinack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushinack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushinack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushinack {
            #[inline(always)]
            fn from(val: u8) -> Flushinack {
                Flushinack::from_bits(val)
            }
        }
        impl From<Flushinack> for u8 {
            #[inline(always)]
            fn from(val: Flushinack) -> u8 {
                Flushinack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ftstopped {
            #[doc = "Formatter has not stopped."]
            RUNNING = 0x0,
            #[doc = "Formatter has stopped."]
            STOPPED = 0x01,
        }
        impl Ftstopped {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ftstopped {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ftstopped {
            #[inline(always)]
            fn from(val: u8) -> Ftstopped {
                Ftstopped::from_bits(val)
            }
        }
        impl From<Ftstopped> for u8 {
            #[inline(always)]
            fn from(val: Ftstopped) -> u8 {
                Ftstopped::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IttrflinTrigin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl IttrflinTrigin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IttrflinTrigin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IttrflinTrigin {
            #[inline(always)]
            fn from(val: u8) -> IttrflinTrigin {
                IttrflinTrigin::from_bits(val)
            }
        }
        impl From<IttrflinTrigin> for u8 {
            #[inline(always)]
            fn from(val: IttrflinTrigin) -> u8 {
                IttrflinTrigin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a trace sink."]
            TRACE_SOURCE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Indicates that this component is a trace port component."]
            TRACE_PORT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tclkdata {
            #[doc = "Trace clock and data is supported."]
            SUPPORTED = 0x0,
            #[doc = "Trace clock and data is not supported."]
            NOT_SUPPORTED = 0x01,
        }
        impl Tclkdata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tclkdata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tclkdata {
            #[inline(always)]
            fn from(val: u8) -> Tclkdata {
                Tclkdata::from_bits(val)
            }
        }
        impl From<Tclkdata> for u8 {
            #[inline(always)]
            fn from(val: Tclkdata) -> u8 {
                Tclkdata::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Triginack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Triginack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Triginack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Triginack {
            #[inline(always)]
            fn from(val: u8) -> Triginack {
                Triginack::from_bits(val)
            }
        }
        impl From<Triginack> for u8 {
            #[inline(always)]
            fn from(val: Triginack) -> u8 {
                Triginack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            #[doc = "This component implements a 32-bit Lock Access Register."]
            BITS32 = 0x0,
            #[doc = "This component implements an 8-bit Lock Access Register."]
            BITS8 = 0x01,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
    }
}
pub mod twim {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD EasyDMA channel"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "TXD EasyDMA channel"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "RXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "TXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start TWI receive sequence"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start TWI transmit sequence"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twim {
        ptr: *mut u8,
    }
    unsafe impl Send for Twim {}
    unsafe impl Sync for Twim {}
    impl Twim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTRX"]
        #[inline(always)]
        pub const fn subscribe_startrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTTX"]
        #[inline(always)]
        pub const fn subscribe_starttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "SUSPEND task has been issued, TWI traffic is now suspended."]
        #[inline(always)]
        pub const fn events_suspended(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0148usize) as _) }
        }
        #[doc = "Receive sequence started"]
        #[inline(always)]
        pub const fn events_rxstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Transmit sequence started"]
        #[inline(always)]
        pub const fn events_txstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0150usize) as _) }
        }
        #[doc = "Byte boundary, starting to receive the last byte"]
        #[inline(always)]
        pub const fn events_lastrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x015cusize) as _) }
        }
        #[doc = "Byte boundary, starting to transmit the last byte"]
        #[inline(always)]
        pub const fn events_lasttx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0160usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event SUSPENDED"]
        #[inline(always)]
        pub const fn publish_suspended(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c8usize) as _) }
        }
        #[doc = "Publish configuration for event RXSTARTED"]
        #[inline(always)]
        pub const fn publish_rxstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event TXSTARTED"]
        #[inline(always)]
        pub const fn publish_txstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d0usize) as _) }
        }
        #[doc = "Publish configuration for event LASTRX"]
        #[inline(always)]
        pub const fn publish_lastrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01dcusize) as _) }
        }
        #[doc = "Publish configuration for event LASTTX"]
        #[inline(always)]
        pub const fn publish_lasttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01e0usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04c4usize) as _) }
        }
        #[doc = "Enable TWIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Address used in the TWI transfer"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0588usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address used in the TWI transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address used in the TWI transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Address used in the TWI transfer"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Enable TWIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn anack(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_anack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("anack", &self.anack())
                    .field("dnack", &self.dnack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overrun: {=bool:?}, anack: {=bool:?}, dnack: {=bool:?} }}",
                    self.overrun(),
                    self.anack(),
                    self.dnack()
                )
            }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "TWI master clock frequency"]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> super::vals::Frequency {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Frequency::from_bits(val as u32)
            }
            #[doc = "TWI master clock frequency"]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: super::vals::Frequency) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frequency {{ frequency: {:?} }}", self.frequency())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[must_use]
            #[inline(always)]
            pub const fn suspended(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[inline(always)]
            pub const fn set_suspended(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn rxstarted(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[inline(always)]
            pub const fn set_rxstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn txstarted(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[inline(always)]
            pub const fn set_txstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[inline(always)]
            pub const fn set_lastrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[inline(always)]
            pub const fn set_lasttx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("suspended", &self.suspended())
                    .field("rxstarted", &self.rxstarted())
                    .field("txstarted", &self.txstarted())
                    .field("lastrx", &self.lastrx())
                    .field("lasttx", &self.lasttx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, suspended: {=bool:?}, rxstarted: {=bool:?}, txstarted: {=bool:?}, lastrx: {=bool:?}, lasttx: {=bool:?} }}" , self . stopped () , self . error () , self . suspended () , self . rxstarted () , self . txstarted () , self . lastrx () , self . lasttx ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdList(pub u32);
        impl RxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::RxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::RxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::RxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for RxdList {
            #[inline(always)]
            fn default() -> RxdList {
                RxdList(0)
            }
        }
        impl core::fmt::Debug for RxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in receive buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in receive buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event LASTTX and task STARTRX"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task STARTRX"]
            #[inline(always)]
            pub const fn set_lasttx_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_suspend(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[inline(always)]
            pub const fn set_lasttx_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_stop(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[inline(always)]
            pub const fn set_lasttx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Shortcut between event LASTRX and task STARTTX"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_dma_tx_start(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task STARTTX"]
            #[inline(always)]
            pub const fn set_lastrx_dma_tx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_stop(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[inline(always)]
            pub const fn set_lastrx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("lasttx_dma_rx_start", &self.lasttx_dma_rx_start())
                    .field("lasttx_suspend", &self.lasttx_suspend())
                    .field("lasttx_stop", &self.lasttx_stop())
                    .field("lastrx_dma_tx_start", &self.lastrx_dma_tx_start())
                    .field("lastrx_stop", &self.lastrx_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ lasttx_dma_rx_start: {=bool:?}, lasttx_suspend: {=bool:?}, lasttx_stop: {=bool:?}, lastrx_dma_tx_start: {=bool:?}, lastrx_stop: {=bool:?} }}" , self . lasttx_dma_rx_start () , self . lasttx_suspend () , self . lasttx_stop () , self . lastrx_dma_tx_start () , self . lastrx_stop ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdList(pub u32);
        impl TxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::TxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::TxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TxdList {
            #[inline(always)]
            fn default() -> TxdList {
                TxdList(0)
            }
        }
        impl core::fmt::Debug for TxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            #[doc = "Enable TWIM"]
            ENABLED = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frequency(u32);
        impl Frequency {
            #[doc = "100 kbps"]
            pub const K100: Self = Self(0x0198_0000);
            #[doc = "250 kbps"]
            pub const K250: Self = Self(0x0400_0000);
            #[doc = "400 kbps"]
            pub const K400: Self = Self(0x0640_0000);
        }
        impl Frequency {
            pub const fn from_bits(val: u32) -> Frequency {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0198_0000 => f.write_str("K100"),
                    0x0400_0000 => f.write_str("K250"),
                    0x0640_0000 => f.write_str("K400"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0198_0000 => defmt::write!(f, "K100"),
                    0x0400_0000 => defmt::write!(f, "K250"),
                    0x0640_0000 => defmt::write!(f, "K400"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Frequency {
            #[inline(always)]
            fn from(val: u32) -> Frequency {
                Frequency::from_bits(val)
            }
        }
        impl From<Frequency> for u32 {
            #[inline(always)]
            fn from(val: Frequency) -> u32 {
                Frequency::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl RxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxdListList {
            #[inline(always)]
            fn from(val: u8) -> RxdListList {
                RxdListList::from_bits(val)
            }
        }
        impl From<RxdListList> for u8 {
            #[inline(always)]
            fn from(val: RxdListList) -> u8 {
                RxdListList::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl TxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxdListList {
            #[inline(always)]
            fn from(val: u8) -> TxdListList {
                TxdListList::from_bits(val)
            }
        }
        impl From<TxdListList> for u8 {
            #[inline(always)]
            fn from(val: TxdListList) -> u8 {
                TxdListList::to_bits(val)
            }
        }
    }
}
pub mod twis {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD EasyDMA channel"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "TXD EasyDMA channel"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "RXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in RXD buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last RXD transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "TXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "TXD Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in TXD buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last TXD transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxdList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twis {
        ptr: *mut u8,
    }
    unsafe impl Send for Twis {}
    unsafe impl Sync for Twis {}
    impl Twis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a write command"]
        #[inline(always)]
        pub const fn tasks_preparerx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a read command"]
        #[inline(always)]
        pub const fn tasks_preparetx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x34usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xa0usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARERX"]
        #[inline(always)]
        pub const fn subscribe_preparerx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb0usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARETX"]
        #[inline(always)]
        pub const fn subscribe_preparetx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xb4usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "Receive sequence started"]
        #[inline(always)]
        pub const fn events_rxstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x014cusize) as _) }
        }
        #[doc = "Transmit sequence started"]
        #[inline(always)]
        pub const fn events_txstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0150usize) as _) }
        }
        #[doc = "Write command received"]
        #[inline(always)]
        pub const fn events_write(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0164usize) as _) }
        }
        #[doc = "Read command received"]
        #[inline(always)]
        pub const fn events_read(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0168usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event RXSTARTED"]
        #[inline(always)]
        pub const fn publish_rxstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event TXSTARTED"]
        #[inline(always)]
        pub const fn publish_txstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d0usize) as _) }
        }
        #[doc = "Publish configuration for event WRITE"]
        #[inline(always)]
        pub const fn publish_write(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01e4usize) as _) }
        }
        #[doc = "Publish configuration for event READ"]
        #[inline(always)]
        pub const fn publish_read(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01e8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04d0usize) as _) }
        }
        #[doc = "Status register indicating which address had a match"]
        #[inline(always)]
        pub const fn match_(self) -> crate::common::Reg<regs::Match, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04d4usize) as _) }
        }
        #[doc = "Enable TWIS"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Description collection: TWI slave address n"]
        #[inline(always)]
        pub const fn address(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Address, crate::common::RW> {
            assert!(n < 2usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0588usize + n * 4usize) as _)
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0594usize) as _) }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x05c0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: TWI slave address n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "TWI slave address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "TWI slave address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[inline(always)]
            pub const fn set_address0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[inline(always)]
            pub const fn set_address1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("address0", &self.address0())
                    .field("address1", &self.address1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ address0: {=bool:?}, address1: {=bool:?} }}",
                    self.address0(),
                    self.address1()
                )
            }
        }
        #[doc = "Enable TWIS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIS"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIS"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overflow", &self.overflow())
                    .field("dnack", &self.dnack())
                    .field("overread", &self.overread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overflow: {=bool:?}, dnack: {=bool:?}, overread: {=bool:?} }}",
                    self.overflow(),
                    self.dnack(),
                    self.overread()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn rxstarted(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[inline(always)]
            pub const fn set_rxstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn txstarted(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[inline(always)]
            pub const fn set_txstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("rxstarted", &self.rxstarted())
                    .field("txstarted", &self.txstarted())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, rxstarted: {=bool:?}, txstarted: {=bool:?}, write: {=bool:?}, read: {=bool:?} }}" , self . stopped () , self . error () , self . rxstarted () , self . txstarted () , self . write () , self . read ())
            }
        }
        #[doc = "Status register indicating which address had a match"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Match(pub u32);
        impl Match {
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[must_use]
            #[inline(always)]
            pub const fn match_(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[inline(always)]
            pub const fn set_match_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Match {
            #[inline(always)]
            fn default() -> Match {
                Match(0)
            }
        }
        impl core::fmt::Debug for Match {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Match")
                    .field("match_", &self.match_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Match {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Match {{ match_: {=bool:?} }}", self.match_())
            }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last RXD transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes transferred in the last RXD transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last RXD transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdList(pub u32);
        impl RxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::RxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::RxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::RxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for RxdList {
            #[inline(always)]
            fn default() -> RxdList {
                RxdList(0)
            }
        }
        impl core::fmt::Debug for RxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in RXD buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in RXD buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in RXD buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn write_suspend(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[inline(always)]
            pub const fn set_write_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn read_suspend(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[inline(always)]
            pub const fn set_read_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("write_suspend", &self.write_suspend())
                    .field("read_suspend", &self.read_suspend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Shorts {{ write_suspend: {=bool:?}, read_suspend: {=bool:?} }}",
                    self.write_suspend(),
                    self.read_suspend()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last TXD transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transferred in the last TXD transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last TXD transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdList(pub u32);
        impl TxdList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn list(&self) -> super::vals::TxdListList {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::TxdListList::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_list(&mut self, val: super::vals::TxdListList) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for TxdList {
            #[inline(always)]
            fn default() -> TxdList {
                TxdList(0)
            }
        }
        impl core::fmt::Debug for TxdList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdList")
                    .field("list", &self.list())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdList {{ list: {:?} }}", self.list())
            }
        }
        #[doc = "Maximum number of bytes in TXD buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in TXD buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in TXD buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIS"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "Enable TWIS"]
            ENABLED = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl RxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxdListList {
            #[inline(always)]
            fn from(val: u8) -> RxdListList {
                RxdListList::from_bits(val)
            }
        }
        impl From<RxdListList> for u8 {
            #[inline(always)]
            fn from(val: RxdListList) -> u8 {
                RxdListList::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxdListList {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl TxdListList {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxdListList {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxdListList {
            #[inline(always)]
            fn from(val: u8) -> TxdListList {
                TxdListList::from_bits(val)
            }
        }
        impl From<TxdListList> for u8 {
            #[inline(always)]
            fn from(val: TxdListList) -> u8 {
                TxdListList::to_bits(val)
            }
        }
    }
}
pub mod uarte {
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXD EasyDMA channel"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "TXD EasyDMA channel"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[doc = "RXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "TXD EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxdMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.wrapping_add(0x10usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Receive buffer is filled up"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "UART receiver has started"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x3cusize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Last TX byte transmitted"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "UART transmitter has started"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for RTS signal"]
        #[inline(always)]
        pub const fn rts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Pin select for TXD signal"]
        #[inline(always)]
        pub const fn txd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Pin select for CTS signal"]
        #[inline(always)]
        pub const fn cts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
        #[doc = "Pin select for RXD signal"]
        #[inline(always)]
        pub const fn rxd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0cusize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start UART receiver"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop UART receiver"]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start UART transmitter"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Stop UART transmitter"]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "UART with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uarte {
        ptr: *mut u8,
    }
    unsafe impl Send for Uarte {}
    unsafe impl Sync for Uarte {}
    impl Uarte {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Flush RX FIFO into RX buffer"]
        #[inline(always)]
        pub const fn tasks_flushrx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTRX"]
        #[inline(always)]
        pub const fn subscribe_startrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOPRX"]
        #[inline(always)]
        pub const fn subscribe_stoprx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTTX"]
        #[inline(always)]
        pub const fn subscribe_starttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOPTX"]
        #[inline(always)]
        pub const fn subscribe_stoptx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task FLUSHRX"]
        #[inline(always)]
        pub const fn subscribe_flushrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0xacusize) as _) }
        }
        #[doc = "CTS is activated (set low). Clear To Send."]
        #[inline(always)]
        pub const fn events_cts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "CTS is deactivated (set high). Not Clear To Send."]
        #[inline(always)]
        pub const fn events_ncts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0104usize) as _) }
        }
        #[doc = "Data received in RXD (but potentially not yet transferred to Data RAM)"]
        #[inline(always)]
        pub const fn events_rxdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize) as _) }
        }
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.wrapping_add(0x0110usize) as _) }
        }
        #[doc = "Data sent from TXD"]
        #[inline(always)]
        pub const fn events_txdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x011cusize) as _) }
        }
        #[doc = "Error detected"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0124usize) as _) }
        }
        #[doc = "Receiver timeout"]
        #[inline(always)]
        pub const fn events_rxto(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0144usize) as _) }
        }
        #[doc = "Transmitter stopped"]
        #[inline(always)]
        pub const fn events_txstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0158usize) as _) }
        }
        #[doc = "Publish configuration for event CTS"]
        #[inline(always)]
        pub const fn publish_cts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event NCTS"]
        #[inline(always)]
        pub const fn publish_ncts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event RXDRDY"]
        #[inline(always)]
        pub const fn publish_rxdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event TXDRDY"]
        #[inline(always)]
        pub const fn publish_txdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event ENDTX"]
        #[inline(always)]
        pub const fn publish_endtx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a0usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event RXTO"]
        #[inline(always)]
        pub const fn publish_rxto(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01c4usize) as _) }
        }
        #[doc = "Publish configuration for event RXSTARTED"]
        #[inline(always)]
        pub const fn publish_rxstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event TXSTARTED"]
        #[inline(always)]
        pub const fn publish_txstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d0usize) as _) }
        }
        #[doc = "Publish configuration for event TXSTOPPED"]
        #[inline(always)]
        pub const fn publish_txstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x01d8usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Error source This register is read/write one to clear."]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0480usize) as _) }
        }
        #[doc = "Enable UART"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn baudrate(self) -> crate::common::Reg<regs::Baudrate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0524usize) as _) }
        }
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.wrapping_add(0x0534usize) as _) }
        }
        #[doc = "Configuration of parity and hardware flow control"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x056cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Baudrate(pub u32);
        impl Baudrate {
            #[doc = "Baud rate"]
            #[must_use]
            #[inline(always)]
            pub const fn baudrate(&self) -> super::vals::Baudrate {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Baudrate::from_bits(val as u32)
            }
            #[doc = "Baud rate"]
            #[inline(always)]
            pub const fn set_baudrate(&mut self, val: super::vals::Baudrate) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Baudrate {
            #[inline(always)]
            fn default() -> Baudrate {
                Baudrate(0)
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Baudrate")
                    .field("baudrate", &self.baudrate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Baudrate {{ baudrate: {:?} }}", self.baudrate())
            }
        }
        #[doc = "Configuration of parity and hardware flow control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Hardware flow control"]
            #[must_use]
            #[inline(always)]
            pub const fn hwfc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware flow control"]
            #[inline(always)]
            pub const fn set_hwfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> super::vals::ConfigParity {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::ConfigParity::from_bits(val as u8)
            }
            #[doc = "Parity"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: super::vals::ConfigParity) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "Stop bits"]
            #[must_use]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::Stop {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Stop::from_bits(val as u8)
            }
            #[doc = "Stop bits"]
            #[inline(always)]
            pub const fn set_stop(&mut self, val: super::vals::Stop) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("hwfc", &self.hwfc())
                    .field("parity", &self.parity())
                    .field("stop", &self.stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ hwfc: {=bool:?}, parity: {:?}, stop: {:?} }}",
                    self.hwfc(),
                    self.parity(),
                    self.stop()
                )
            }
        }
        #[doc = "Enable UART"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable UARTE"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable UARTE"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source This register is read/write one to clear."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity error"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Parity error"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Framing error occurred"]
            #[must_use]
            #[inline(always)]
            pub const fn framing(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Framing error occurred"]
            #[inline(always)]
            pub const fn set_framing(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Break condition"]
            #[must_use]
            #[inline(always)]
            pub const fn break_(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Break condition"]
            #[inline(always)]
            pub const fn set_break_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("parity", &self.parity())
                    .field("framing", &self.framing())
                    .field("break_", &self.break_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Errorsrc {{ overrun: {=bool:?}, parity: {=bool:?}, framing: {=bool:?}, break_: {=bool:?} }}" , self . overrun () , self . parity () , self . framing () , self . break_ ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CTS"]
            #[must_use]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CTS"]
            #[inline(always)]
            pub const fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[must_use]
            #[inline(always)]
            pub const fn ncts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[inline(always)]
            pub const fn set_ncts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdrdy(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[inline(always)]
            pub const fn set_rxdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn txdrdy(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[inline(always)]
            pub const fn set_txdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[must_use]
            #[inline(always)]
            pub const fn rxto(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[inline(always)]
            pub const fn set_rxto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXSTARTED"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTARTED"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn txstopped(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[inline(always)]
            pub const fn set_txstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cts", &self.cts())
                    .field("ncts", &self.ncts())
                    .field("rxdrdy", &self.rxdrdy())
                    .field("dmarxend", &self.dmarxend())
                    .field("txdrdy", &self.txdrdy())
                    .field("dmatxend", &self.dmatxend())
                    .field("error", &self.error())
                    .field("rxto", &self.rxto())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmatxready", &self.dmatxready())
                    .field("txstopped", &self.txstopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ cts: {=bool:?}, ncts: {=bool:?}, rxdrdy: {=bool:?}, dmarxend: {=bool:?}, txdrdy: {=bool:?}, dmatxend: {=bool:?}, error: {=bool:?}, rxto: {=bool:?}, dmarxready: {=bool:?}, dmatxready: {=bool:?}, txstopped: {=bool:?} }}" , self . cts () , self . ncts () , self . rxdrdy () , self . dmarxend () , self . txdrdy () , self . dmatxend () , self . error () , self . rxto () , self . dmarxready () , self . dmatxready () , self . txstopped ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in receive buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdMaxcnt(pub u32);
        impl RxdMaxcnt {
            #[doc = "Maximum number of bytes in receive buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in receive buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for RxdMaxcnt {
            #[inline(always)]
            fn default() -> RxdMaxcnt {
                RxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event ENDRX and task STARTRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx_startrx(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ENDRX and task STARTRX"]
            #[inline(always)]
            pub const fn set_endrx_startrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event ENDRX and task STOPRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx_stoprx(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ENDRX and task STOPRX"]
            #[inline(always)]
            pub const fn set_endrx_stoprx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("endrx_startrx", &self.endrx_startrx())
                    .field("endrx_stoprx", &self.endrx_stoprx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Shorts {{ endrx_startrx: {=bool:?}, endrx_stoprx: {=bool:?} }}",
                    self.endrx_startrx(),
                    self.endrx_stoprx()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in transmit buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdMaxcnt(pub u32);
        impl TxdMaxcnt {
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Maximum number of bytes in transmit buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for TxdMaxcnt {
            #[inline(always)]
            fn default() -> TxdMaxcnt {
                TxdMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxdMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxdMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Baudrate(u32);
        impl Baudrate {
            #[doc = "1200 baud (actual rate: 1205)"]
            pub const BAUD1200: Self = Self(0x0004_f000);
            #[doc = "2400 baud (actual rate: 2396)"]
            pub const BAUD2400: Self = Self(0x0009_d000);
            #[doc = "4800 baud (actual rate: 4808)"]
            pub const BAUD4800: Self = Self(0x0013_b000);
            #[doc = "9600 baud (actual rate: 9598)"]
            pub const BAUD9600: Self = Self(0x0027_5000);
            #[doc = "14400 baud (actual rate: 14401)"]
            pub const BAUD14400: Self = Self(0x003a_f000);
            #[doc = "19200 baud (actual rate: 19208)"]
            pub const BAUD19200: Self = Self(0x004e_a000);
            #[doc = "28800 baud (actual rate: 28777)"]
            pub const BAUD28800: Self = Self(0x0075_c000);
            #[doc = "31250 baud"]
            pub const BAUD31250: Self = Self(0x0080_0000);
            #[doc = "38400 baud (actual rate: 38369)"]
            pub const BAUD38400: Self = Self(0x009d_0000);
            #[doc = "56000 baud (actual rate: 55944)"]
            pub const BAUD56000: Self = Self(0x00e5_0000);
            #[doc = "57600 baud (actual rate: 57554)"]
            pub const BAUD57600: Self = Self(0x00eb_0000);
            #[doc = "76800 baud (actual rate: 76923)"]
            pub const BAUD76800: Self = Self(0x013a_9000);
            #[doc = "115200 baud (actual rate: 115108)"]
            pub const BAUD115200: Self = Self(0x01d6_0000);
            #[doc = "230400 baud (actual rate: 231884)"]
            pub const BAUD230400: Self = Self(0x03b0_0000);
            #[doc = "250000 baud"]
            pub const BAUD250000: Self = Self(0x0400_0000);
            #[doc = "460800 baud (actual rate: 457143)"]
            pub const BAUD460800: Self = Self(0x0740_0000);
            #[doc = "921600 baud (actual rate: 941176)"]
            pub const BAUD921600: Self = Self(0x0f00_0000);
            #[doc = "1 megabaud"]
            pub const BAUD1M: Self = Self(0x1000_0000);
        }
        impl Baudrate {
            pub const fn from_bits(val: u32) -> Baudrate {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0004_f000 => f.write_str("BAUD1200"),
                    0x0009_d000 => f.write_str("BAUD2400"),
                    0x0013_b000 => f.write_str("BAUD4800"),
                    0x0027_5000 => f.write_str("BAUD9600"),
                    0x003a_f000 => f.write_str("BAUD14400"),
                    0x004e_a000 => f.write_str("BAUD19200"),
                    0x0075_c000 => f.write_str("BAUD28800"),
                    0x0080_0000 => f.write_str("BAUD31250"),
                    0x009d_0000 => f.write_str("BAUD38400"),
                    0x00e5_0000 => f.write_str("BAUD56000"),
                    0x00eb_0000 => f.write_str("BAUD57600"),
                    0x013a_9000 => f.write_str("BAUD76800"),
                    0x01d6_0000 => f.write_str("BAUD115200"),
                    0x03b0_0000 => f.write_str("BAUD230400"),
                    0x0400_0000 => f.write_str("BAUD250000"),
                    0x0740_0000 => f.write_str("BAUD460800"),
                    0x0f00_0000 => f.write_str("BAUD921600"),
                    0x1000_0000 => f.write_str("BAUD1M"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0004_f000 => defmt::write!(f, "BAUD1200"),
                    0x0009_d000 => defmt::write!(f, "BAUD2400"),
                    0x0013_b000 => defmt::write!(f, "BAUD4800"),
                    0x0027_5000 => defmt::write!(f, "BAUD9600"),
                    0x003a_f000 => defmt::write!(f, "BAUD14400"),
                    0x004e_a000 => defmt::write!(f, "BAUD19200"),
                    0x0075_c000 => defmt::write!(f, "BAUD28800"),
                    0x0080_0000 => defmt::write!(f, "BAUD31250"),
                    0x009d_0000 => defmt::write!(f, "BAUD38400"),
                    0x00e5_0000 => defmt::write!(f, "BAUD56000"),
                    0x00eb_0000 => defmt::write!(f, "BAUD57600"),
                    0x013a_9000 => defmt::write!(f, "BAUD76800"),
                    0x01d6_0000 => defmt::write!(f, "BAUD115200"),
                    0x03b0_0000 => defmt::write!(f, "BAUD230400"),
                    0x0400_0000 => defmt::write!(f, "BAUD250000"),
                    0x0740_0000 => defmt::write!(f, "BAUD460800"),
                    0x0f00_0000 => defmt::write!(f, "BAUD921600"),
                    0x1000_0000 => defmt::write!(f, "BAUD1M"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Baudrate {
            #[inline(always)]
            fn from(val: u32) -> Baudrate {
                Baudrate::from_bits(val)
            }
        }
        impl From<Baudrate> for u32 {
            #[inline(always)]
            fn from(val: Baudrate) -> u32 {
                Baudrate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigParity {
            #[doc = "Exclude parity bit"]
            EXCLUDED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Include even parity bit"]
            INCLUDED = 0x07,
        }
        impl ConfigParity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigParity {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigParity {
            #[inline(always)]
            fn from(val: u8) -> ConfigParity {
                ConfigParity::from_bits(val)
            }
        }
        impl From<ConfigParity> for u8 {
            #[inline(always)]
            fn from(val: ConfigParity) -> u8 {
                ConfigParity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable UARTE"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "Enable UARTE"]
            ENABLED = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Stop {
            #[doc = "One stop bit"]
            ONE = 0x0,
            #[doc = "Two stop bits"]
            TWO = 0x01,
        }
        impl Stop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Stop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Stop {
            #[inline(always)]
            fn from(val: u8) -> Stop {
                Stop::from_bits(val)
            }
        }
        impl From<Stop> for u8 {
            #[inline(always)]
            fn from(val: Stop) -> u8 {
                Stop::to_bits(val)
            }
        }
    }
}
pub mod uicr {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Destination address where content of the key value registers (KEYSLOT.KEYn.VALUE\\[0-3\\]) will be pushed by KMU. Note that this address must match that of a peripheral's APB mapped write-only key registers, otherwise the KMU can push this key value into an address range which the CPU can potentially read."]
        #[inline(always)]
        pub const fn dest(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Define permissions for the key slot. Bits 0-15 and 16-31 can only be written when equal to 0xFFFF."]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Define bits \\[31+o*32:0+o*32\\] of value assigned to KMU key slot."]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize + n * 4usize) as _)
            }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Keyslot {
        ptr: *mut u8,
    }
    unsafe impl Send for Keyslot {}
    unsafe impl Sync for Keyslot {}
    impl Keyslot {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self, n: usize) -> Config {
            assert!(n < 128usize);
            unsafe { Config::from_ptr(self.ptr.wrapping_add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self, n: usize) -> Key {
            assert!(n < 128usize);
            unsafe { Key::from_ptr(self.ptr.wrapping_add(0x0400usize + n * 16usize) as _) }
        }
    }
    #[doc = "User information configuration registers User information configuration registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Uicr {}
    unsafe impl Sync for Uicr {}
    impl Uicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Access port protection"]
        #[inline(always)]
        pub const fn approtect(self) -> crate::common::Reg<regs::Approtect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Oscillator control"]
        #[inline(always)]
        pub const fn xosc32m(self) -> crate::common::Reg<regs::Xosc32m, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x14usize) as _) }
        }
        #[doc = "HFXO clock source selection"]
        #[inline(always)]
        pub const fn hfxosrc(self) -> crate::common::Reg<regs::Hfxosrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x1cusize) as _) }
        }
        #[doc = "HFXO startup counter"]
        #[inline(always)]
        pub const fn hfxocnt(self) -> crate::common::Reg<regs::Hfxocnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x20usize) as _) }
        }
        #[doc = "Enable blocking NVM WRITE and aborting NVM ERASE for Application NVM in POFWARN condition."]
        #[inline(always)]
        pub const fn appnvmcpofguard(
            self,
        ) -> crate::common::Reg<regs::Appnvmcpofguard, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x24usize) as _) }
        }
        #[doc = "Secure access port protection"]
        #[inline(always)]
        pub const fn secureapprotect(
            self,
        ) -> crate::common::Reg<regs::Secureapprotect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x2cusize) as _) }
        }
        #[doc = "Erase protection"]
        #[inline(always)]
        pub const fn eraseprotect(
            self,
        ) -> crate::common::Reg<regs::Eraseprotect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x30usize) as _) }
        }
        #[doc = "Description collection: One time programmable memory"]
        #[inline(always)]
        pub const fn otp(self, n: usize) -> crate::common::Reg<regs::Otp, crate::common::RW> {
            assert!(n < 190usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0108usize + n * 4usize) as _)
            }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn keyslot(self) -> Keyslot {
            unsafe { Keyslot::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable blocking NVM WRITE and aborting NVM ERASE for Application NVM in POFWARN condition."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Appnvmcpofguard(pub u32);
        impl Appnvmcpofguard {
            #[doc = "Enable blocking NVM WRITE and aborting NVM ERASE in POFWARN condition"]
            #[must_use]
            #[inline(always)]
            pub const fn nvmcpofguarden(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable blocking NVM WRITE and aborting NVM ERASE in POFWARN condition"]
            #[inline(always)]
            pub const fn set_nvmcpofguarden(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Appnvmcpofguard {
            #[inline(always)]
            fn default() -> Appnvmcpofguard {
                Appnvmcpofguard(0)
            }
        }
        impl core::fmt::Debug for Appnvmcpofguard {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Appnvmcpofguard")
                    .field("nvmcpofguarden", &self.nvmcpofguarden())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Appnvmcpofguard {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Appnvmcpofguard {{ nvmcpofguarden: {=bool:?} }}",
                    self.nvmcpofguarden()
                )
            }
        }
        #[doc = "Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Approtect(pub u32);
        impl Approtect {
            #[doc = "Blocks debugger read/write access to all CPU registers and memory mapped addresses"]
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectPall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectPall::from_bits(val as u32)
            }
            #[doc = "Blocks debugger read/write access to all CPU registers and memory mapped addresses"]
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::ApprotectPall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Approtect {
            #[inline(always)]
            fn default() -> Approtect {
                Approtect(0)
            }
        }
        impl core::fmt::Debug for Approtect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Approtect")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Approtect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Approtect {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eraseprotect(pub u32);
        impl Eraseprotect {
            #[doc = "Blocks NVMC ERASEALL and CTRLAP ERASEALL functionality"]
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectPall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectPall::from_bits(val as u32)
            }
            #[doc = "Blocks NVMC ERASEALL and CTRLAP ERASEALL functionality"]
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::EraseprotectPall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Eraseprotect {
            #[inline(always)]
            fn default() -> Eraseprotect {
                Eraseprotect(0)
            }
        }
        impl core::fmt::Debug for Eraseprotect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eraseprotect")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eraseprotect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eraseprotect {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "HFXO startup counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfxocnt(pub u32);
        impl Hfxocnt {
            #[doc = "HFXO startup counter. Total debounce time = HFXOCNT*64 us + 0.5 us"]
            #[must_use]
            #[inline(always)]
            pub const fn hfxocnt(&self) -> super::vals::Hfxocnt {
                let val = (self.0 >> 0usize) & 0xff;
                super::vals::Hfxocnt::from_bits(val as u8)
            }
            #[doc = "HFXO startup counter. Total debounce time = HFXOCNT*64 us + 0.5 us"]
            #[inline(always)]
            pub const fn set_hfxocnt(&mut self, val: super::vals::Hfxocnt) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Hfxocnt {
            #[inline(always)]
            fn default() -> Hfxocnt {
                Hfxocnt(0)
            }
        }
        impl core::fmt::Debug for Hfxocnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfxocnt")
                    .field("hfxocnt", &self.hfxocnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfxocnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hfxocnt {{ hfxocnt: {:?} }}", self.hfxocnt())
            }
        }
        #[doc = "HFXO clock source selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hfxosrc(pub u32);
        impl Hfxosrc {
            #[doc = "HFXO clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn hfxosrc(&self) -> super::vals::Hfxosrc {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hfxosrc::from_bits(val as u8)
            }
            #[doc = "HFXO clock source selection"]
            #[inline(always)]
            pub const fn set_hfxosrc(&mut self, val: super::vals::Hfxosrc) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hfxosrc {
            #[inline(always)]
            fn default() -> Hfxosrc {
                Hfxosrc(0)
            }
        }
        impl core::fmt::Debug for Hfxosrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hfxosrc")
                    .field("hfxosrc", &self.hfxosrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfxosrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hfxosrc {{ hfxosrc: {:?} }}", self.hfxosrc())
            }
        }
        #[doc = "Description collection: One time programmable memory"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Otp(pub u32);
        impl Otp {
            #[doc = "Lower half word"]
            #[must_use]
            #[inline(always)]
            pub const fn lower(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Lower half word"]
            #[inline(always)]
            pub const fn set_lower(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Upper half word"]
            #[must_use]
            #[inline(always)]
            pub const fn upper(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Upper half word"]
            #[inline(always)]
            pub const fn set_upper(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Otp {
            #[inline(always)]
            fn default() -> Otp {
                Otp(0)
            }
        }
        impl core::fmt::Debug for Otp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Otp")
                    .field("lower", &self.lower())
                    .field("upper", &self.upper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Otp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Otp {{ lower: {=u16:?}, upper: {=u16:?} }}",
                    self.lower(),
                    self.upper()
                )
            }
        }
        #[doc = "Description cluster: Define permissions for the key slot. Bits 0-15 and 16-31 can only be written when equal to 0xFFFF."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Write permission for key slot"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write permission for key slot"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Read permission for key slot"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Read permission for key slot"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Push permission for key slot"]
            #[must_use]
            #[inline(always)]
            pub const fn push(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Push permission for key slot"]
            #[inline(always)]
            pub const fn set_push(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Revocation state for the key slot"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Revocation state for the key slot"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("push", &self.push())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Perm {{ write: {=bool:?}, read: {=bool:?}, push: {=bool:?}, state: {:?} }}",
                    self.write(),
                    self.read(),
                    self.push(),
                    self.state()
                )
            }
        }
        #[doc = "Secure access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Secureapprotect(pub u32);
        impl Secureapprotect {
            #[doc = "Blocks debugger read/write access to all secure CPU registers and secure memory mapped addresses"]
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectPall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectPall::from_bits(val as u32)
            }
            #[doc = "Blocks debugger read/write access to all secure CPU registers and secure memory mapped addresses"]
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::SecureapprotectPall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Secureapprotect {
            #[inline(always)]
            fn default() -> Secureapprotect {
                Secureapprotect(0)
            }
        }
        impl core::fmt::Debug for Secureapprotect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Secureapprotect")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Secureapprotect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Secureapprotect {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Oscillator control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32m(pub u32);
        impl Xosc32m {
            #[doc = "Pierce current DAC control signals"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Pierce current DAC control signals"]
            #[inline(always)]
            pub const fn set_ctrl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Xosc32m {
            #[inline(always)]
            fn default() -> Xosc32m {
                Xosc32m(0)
            }
        }
        impl core::fmt::Debug for Xosc32m {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32m")
                    .field("ctrl", &self.ctrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32m {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Xosc32m {{ ctrl: {=u8:?} }}", self.ctrl())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectPall(u32);
        impl ApprotectPall {
            #[doc = "Protected"]
            pub const PROTECTED: Self = Self(0x0);
            #[doc = "Unprotected"]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectPall {
            pub const fn from_bits(val: u32) -> ApprotectPall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectPall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("PROTECTED"),
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectPall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "PROTECTED"),
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectPall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectPall {
                ApprotectPall::from_bits(val)
            }
        }
        impl From<ApprotectPall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectPall) -> u32 {
                ApprotectPall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectPall(u32);
        impl EraseprotectPall {
            #[doc = "Protected"]
            pub const PROTECTED: Self = Self(0x0);
            #[doc = "Unprotected"]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl EraseprotectPall {
            pub const fn from_bits(val: u32) -> EraseprotectPall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectPall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("PROTECTED"),
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectPall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "PROTECTED"),
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectPall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectPall {
                EraseprotectPall::from_bits(val)
            }
        }
        impl From<EraseprotectPall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectPall) -> u32 {
                EraseprotectPall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Hfxocnt(u8);
        impl Hfxocnt {
            #[doc = "Min debounce time = (0*64 us + 0.5 us)"]
            pub const MIN_DEBOUNCE_TIME: Self = Self(0x0);
            #[doc = "Max debounce time = (255*64 us + 0.5 us)"]
            pub const MAX_DEBOUNCE_TIME: Self = Self(0xff);
        }
        impl Hfxocnt {
            pub const fn from_bits(val: u8) -> Hfxocnt {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Hfxocnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_DEBOUNCE_TIME"),
                    0xff => f.write_str("MAX_DEBOUNCE_TIME"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hfxocnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_DEBOUNCE_TIME"),
                    0xff => defmt::write!(f, "MAX_DEBOUNCE_TIME"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Hfxocnt {
            #[inline(always)]
            fn from(val: u8) -> Hfxocnt {
                Hfxocnt::from_bits(val)
            }
        }
        impl From<Hfxocnt> for u8 {
            #[inline(always)]
            fn from(val: Hfxocnt) -> u8 {
                Hfxocnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hfxosrc {
            #[doc = "32 MHz temperature compensated crystal oscillator (TCXO)"]
            TCXO = 0x0,
            #[doc = "32 MHz crystal oscillator"]
            XTAL = 0x01,
        }
        impl Hfxosrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hfxosrc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hfxosrc {
            #[inline(always)]
            fn from(val: u8) -> Hfxosrc {
                Hfxosrc::from_bits(val)
            }
        }
        impl From<Hfxosrc> for u8 {
            #[inline(always)]
            fn from(val: Hfxosrc) -> u8 {
                Hfxosrc::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectPall(u32);
        impl SecureapprotectPall {
            #[doc = "Protected"]
            pub const PROTECTED: Self = Self(0x0);
            #[doc = "Unprotected"]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectPall {
            pub const fn from_bits(val: u32) -> SecureapprotectPall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectPall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("PROTECTED"),
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectPall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "PROTECTED"),
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectPall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectPall {
                SecureapprotectPall::from_bits(val)
            }
        }
        impl From<SecureapprotectPall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectPall) -> u32 {
                SecureapprotectPall::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "Key value registers can no longer be read or pushed"]
            REVOKED = 0x0,
            #[doc = "Key value registers are readable (if enabled) and can be pushed (if enabled)"]
            ACTIVE = 0x01,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
    }
}
pub mod vmc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ram {
        ptr: *mut u8,
    }
    unsafe impl Send for Ram {}
    unsafe impl Sync for Ram {}
    impl Ram {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: RAMn power control register"]
        #[inline(always)]
        pub const fn power(self) -> crate::common::Reg<regs::Power, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Description cluster: RAMn power control set register"]
        #[inline(always)]
        pub const fn powerset(self) -> crate::common::Reg<regs::Power, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x04usize) as _) }
        }
        #[doc = "Description cluster: RAMn power control clear register"]
        #[inline(always)]
        pub const fn powerclr(self) -> crate::common::Reg<regs::Power, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x08usize) as _) }
        }
    }
    #[doc = "Volatile Memory controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vmc {
        ptr: *mut u8,
    }
    unsafe impl Send for Vmc {}
    unsafe impl Sync for Vmc {}
    impl Vmc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ram(self, n: usize) -> Ram {
            assert!(n < 8usize);
            unsafe { Ram::from_ptr(self.ptr.wrapping_add(0x0600usize + n * 16usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: RAMn power control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Power(pub u32);
        impl Power {
            #[doc = "Keep RAM section S0 of RAM n on or off in System ON mode"]
            #[must_use]
            #[inline(always)]
            pub const fn spower(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Keep RAM section S0 of RAM n on or off in System ON mode"]
            #[inline(always)]
            pub const fn set_spower(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Keep retention on RAM section S0 of RAM n when RAM section is switched off"]
            #[must_use]
            #[inline(always)]
            pub const fn sretention(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Keep retention on RAM section S0 of RAM n when RAM section is switched off"]
            #[inline(always)]
            pub const fn set_sretention(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Power {
            #[inline(always)]
            fn default() -> Power {
                Power(0)
            }
        }
        impl core::fmt::Debug for Power {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Power")
                    .field("spower[0]", &self.spower(0usize))
                    .field("spower[1]", &self.spower(1usize))
                    .field("spower[2]", &self.spower(2usize))
                    .field("spower[3]", &self.spower(3usize))
                    .field("sretention[0]", &self.sretention(0usize))
                    .field("sretention[1]", &self.sretention(1usize))
                    .field("sretention[2]", &self.sretention(2usize))
                    .field("sretention[3]", &self.sretention(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Power {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Power {{ spower[0]: {=bool:?}, spower[1]: {=bool:?}, spower[2]: {=bool:?}, spower[3]: {=bool:?}, sretention[0]: {=bool:?}, sretention[1]: {=bool:?}, sretention[2]: {=bool:?}, sretention[3]: {=bool:?} }}" , self . spower (0usize) , self . spower (1usize) , self . spower (2usize) , self . spower (3usize) , self . sretention (0usize) , self . sretention (1usize) , self . sretention (2usize) , self . sretention (3usize))
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the watchdog"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x80usize) as _) }
        }
        #[doc = "Watchdog timeout"]
        #[inline(always)]
        pub const fn events_timeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0100usize) as _) }
        }
        #[doc = "Publish configuration for event TIMEOUT"]
        #[inline(always)]
        pub const fn publish_timeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0180usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0308usize) as _) }
        }
        #[doc = "Run status"]
        #[inline(always)]
        pub const fn runstatus(self) -> crate::common::Reg<regs::Runstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0400usize) as _) }
        }
        #[doc = "Request status"]
        #[inline(always)]
        pub const fn reqstatus(self) -> crate::common::Reg<regs::Reqstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0404usize) as _) }
        }
        #[doc = "Counter reload value"]
        #[inline(always)]
        pub const fn crv(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0504usize) as _) }
        }
        #[doc = "Enable register for reload request registers"]
        #[inline(always)]
        pub const fn rren(self) -> crate::common::Reg<regs::Rren, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0508usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x050cusize) as _) }
        }
        #[doc = "Description collection: Reload request n"]
        #[inline(always)]
        pub const fn rr(self, n: usize) -> crate::common::Reg<regs::Rr, crate::common::W> {
            assert!(n < 8usize);
            unsafe {
                crate::common::Reg::from_ptr(self.ptr.wrapping_add(0x0600usize + n * 4usize) as _)
            }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Configure the watchdog to either be paused, or kept running, while the CPU is sleeping"]
            #[must_use]
            #[inline(always)]
            pub const fn sleep(&self) -> super::vals::Sleep {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleep::from_bits(val as u8)
            }
            #[doc = "Configure the watchdog to either be paused, or kept running, while the CPU is sleeping"]
            #[inline(always)]
            pub const fn set_sleep(&mut self, val: super::vals::Sleep) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[must_use]
            #[inline(always)]
            pub const fn halt(&self) -> super::vals::Halt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Halt::from_bits(val as u8)
            }
            #[doc = "Configure the watchdog to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[inline(always)]
            pub const fn set_halt(&mut self, val: super::vals::Halt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("sleep", &self.sleep())
                    .field("halt", &self.halt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ sleep: {:?}, halt: {:?} }}",
                    self.sleep(),
                    self.halt()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("timeout", &self.timeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ timeout: {=bool:?} }}", self.timeout())
            }
        }
        #[doc = "Request status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reqstatus(pub u32);
        impl Reqstatus {
            #[doc = "Request status for RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Request status for RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Reqstatus {
            #[inline(always)]
            fn default() -> Reqstatus {
                Reqstatus(0)
            }
        }
        impl core::fmt::Debug for Reqstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reqstatus")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reqstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Reqstatus {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Description collection: Reload request n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rr(pub u32);
        impl Rr {
            #[doc = "Reload request register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self) -> super::vals::Rr {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rr::from_bits(val as u32)
            }
            #[doc = "Reload request register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, val: super::vals::Rr) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rr {
            #[inline(always)]
            fn default() -> Rr {
                Rr(0)
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rr").field("rr", &self.rr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rr {{ rr: {:?} }}", self.rr())
            }
        }
        #[doc = "Enable register for reload request registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rren(pub u32);
        impl Rren {
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Rren {
            #[inline(always)]
            fn default() -> Rren {
                Rren(0)
            }
        }
        impl core::fmt::Debug for Rren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rren")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rren {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rren {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Run status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Runstatus(pub u32);
        impl Runstatus {
            #[doc = "Indicates whether or not the watchdog is running"]
            #[must_use]
            #[inline(always)]
            pub const fn runstatuswdt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether or not the watchdog is running"]
            #[inline(always)]
            pub const fn set_runstatuswdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Runstatus {
            #[inline(always)]
            fn default() -> Runstatus {
                Runstatus(0)
            }
        }
        impl core::fmt::Debug for Runstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Runstatus")
                    .field("runstatuswdt", &self.runstatuswdt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Runstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Runstatus {{ runstatuswdt: {=bool:?} }}",
                    self.runstatuswdt()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Halt {
            #[doc = "Pause watchdog while the CPU is halted by the debugger"]
            PAUSE = 0x0,
            #[doc = "Keep the watchdog running while the CPU is halted by the debugger"]
            RUN = 0x01,
        }
        impl Halt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Halt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Halt {
            #[inline(always)]
            fn from(val: u8) -> Halt {
                Halt::from_bits(val)
            }
        }
        impl From<Halt> for u8 {
            #[inline(always)]
            fn from(val: Halt) -> u8 {
                Halt::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rr(u32);
        impl Rr {
            #[doc = "Value to request a reload of the watchdog timer"]
            pub const RELOAD: Self = Self(0x6e52_4635);
        }
        impl Rr {
            pub const fn from_bits(val: u32) -> Rr {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("RELOAD"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "RELOAD"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rr {
            #[inline(always)]
            fn from(val: u32) -> Rr {
                Rr::from_bits(val)
            }
        }
        impl From<Rr> for u32 {
            #[inline(always)]
            fn from(val: Rr) -> u32 {
                Rr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleep {
            #[doc = "Pause watchdog while the CPU is sleeping"]
            PAUSE = 0x0,
            #[doc = "Keep the watchdog running while the CPU is sleeping"]
            RUN = 0x01,
        }
        impl Sleep {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleep {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleep {
            #[inline(always)]
            fn from(val: u8) -> Sleep {
                Sleep::from_bits(val)
            }
        }
        impl From<Sleep> for u8 {
            #[inline(always)]
            fn from(val: Sleep) -> u8 {
                Sleep::to_bits(val)
            }
        }
    }
}
