#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![doc = "Peripheral access API (generated using chiptool v0.1.0 (26983da 2025-01-02))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "28 - SWI00"]
    SWI00 = 28,
    #[doc = "29 - SWI01"]
    SWI01 = 29,
    #[doc = "30 - SWI02"]
    SWI02 = 30,
    #[doc = "31 - SWI03"]
    SWI03 = 31,
    #[doc = "64 - SPU00"]
    SPU00 = 64,
    #[doc = "65 - MPC00"]
    MPC00 = 65,
    #[doc = "70 - AAR00_CCM00"]
    AAR00_CCM00 = 70,
    #[doc = "71 - ECB00"]
    ECB00 = 71,
    #[doc = "72 - CRACEN"]
    CRACEN = 72,
    #[doc = "74 - SERIAL00"]
    SERIAL00 = 74,
    #[doc = "75 - RRAMC"]
    RRAMC = 75,
    #[doc = "76 - VPR00"]
    VPR00 = 76,
    #[doc = "82 - CTRLAP"]
    CTRLAP = 82,
    #[doc = "85 - TIMER00"]
    TIMER00 = 85,
    #[doc = "128 - SPU10"]
    SPU10 = 128,
    #[doc = "133 - TIMER10"]
    TIMER10 = 133,
    #[doc = "134 - RTC10"]
    RTC10 = 134,
    #[doc = "135 - EGU10"]
    EGU10 = 135,
    #[doc = "138 - RADIO_0"]
    RADIO_0 = 138,
    #[doc = "139 - RADIO_1"]
    RADIO_1 = 139,
    #[doc = "192 - SPU20"]
    SPU20 = 192,
    #[doc = "198 - SERIAL20"]
    SERIAL20 = 198,
    #[doc = "199 - SERIAL21"]
    SERIAL21 = 199,
    #[doc = "200 - SERIAL22"]
    SERIAL22 = 200,
    #[doc = "201 - EGU20"]
    EGU20 = 201,
    #[doc = "202 - TIMER20"]
    TIMER20 = 202,
    #[doc = "203 - TIMER21"]
    TIMER21 = 203,
    #[doc = "204 - TIMER22"]
    TIMER22 = 204,
    #[doc = "205 - TIMER23"]
    TIMER23 = 205,
    #[doc = "206 - TIMER24"]
    TIMER24 = 206,
    #[doc = "208 - PDM20"]
    PDM20 = 208,
    #[doc = "209 - PDM21"]
    PDM21 = 209,
    #[doc = "210 - PWM20"]
    PWM20 = 210,
    #[doc = "211 - PWM21"]
    PWM21 = 211,
    #[doc = "212 - PWM22"]
    PWM22 = 212,
    #[doc = "213 - SAADC"]
    SAADC = 213,
    #[doc = "214 - NFCT"]
    NFCT = 214,
    #[doc = "215 - TEMP"]
    TEMP = 215,
    #[doc = "218 - GPIOTE20_0"]
    GPIOTE20_0 = 218,
    #[doc = "219 - GPIOTE20_1"]
    GPIOTE20_1 = 219,
    #[doc = "220 - TAMPC"]
    TAMPC = 220,
    #[doc = "221 - I2S20"]
    I2S20 = 221,
    #[doc = "224 - QDEC20"]
    QDEC20 = 224,
    #[doc = "225 - QDEC21"]
    QDEC21 = 225,
    #[doc = "226 - GRTC_0"]
    GRTC_0 = 226,
    #[doc = "227 - GRTC_1"]
    GRTC_1 = 227,
    #[doc = "228 - GRTC_2"]
    GRTC_2 = 228,
    #[doc = "229 - GRTC_3"]
    GRTC_3 = 229,
    #[doc = "256 - SPU30"]
    SPU30 = 256,
    #[doc = "260 - SERIAL30"]
    SERIAL30 = 260,
    #[doc = "261 - RTC30"]
    RTC30 = 261,
    #[doc = "262 - COMP_LPCOMP"]
    COMP_LPCOMP = 262,
    #[doc = "264 - WDT30"]
    WDT30 = 264,
    #[doc = "265 - WDT31"]
    WDT31 = 265,
    #[doc = "268 - GPIOTE30_0"]
    GPIOTE30_0 = 268,
    #[doc = "269 - GPIOTE30_1"]
    GPIOTE30_1 = 269,
    #[doc = "270 - CLOCK_POWER"]
    CLOCK_POWER = 270,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    unsafe extern "C" {
        fn SWI00();
        fn SWI01();
        fn SWI02();
        fn SWI03();
        fn SPU00();
        fn MPC00();
        fn AAR00_CCM00();
        fn ECB00();
        fn CRACEN();
        fn SERIAL00();
        fn RRAMC();
        fn VPR00();
        fn CTRLAP();
        fn TIMER00();
        fn SPU10();
        fn TIMER10();
        fn RTC10();
        fn EGU10();
        fn RADIO_0();
        fn RADIO_1();
        fn SPU20();
        fn SERIAL20();
        fn SERIAL21();
        fn SERIAL22();
        fn EGU20();
        fn TIMER20();
        fn TIMER21();
        fn TIMER22();
        fn TIMER23();
        fn TIMER24();
        fn PDM20();
        fn PDM21();
        fn PWM20();
        fn PWM21();
        fn PWM22();
        fn SAADC();
        fn NFCT();
        fn TEMP();
        fn GPIOTE20_0();
        fn GPIOTE20_1();
        fn TAMPC();
        fn I2S20();
        fn QDEC20();
        fn QDEC21();
        fn GRTC_0();
        fn GRTC_1();
        fn GRTC_2();
        fn GRTC_3();
        fn SPU30();
        fn SERIAL30();
        fn RTC30();
        fn COMP_LPCOMP();
        fn WDT30();
        fn WDT31();
        fn GPIOTE30_0();
        fn GPIOTE30_1();
        fn CLOCK_POWER();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[unsafe(link_section = ".vector_table.interrupts")]
    #[unsafe(no_mangle)]
    pub static __INTERRUPTS: [Vector; 271] = [
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SWI00 },
        Vector { _handler: SWI01 },
        Vector { _handler: SWI02 },
        Vector { _handler: SWI03 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU00 },
        Vector { _handler: MPC00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: AAR00_CCM00,
        },
        Vector { _handler: ECB00 },
        Vector { _handler: CRACEN },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL00 },
        Vector { _handler: RRAMC },
        Vector { _handler: VPR00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: CTRLAP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER10 },
        Vector { _handler: RTC10 },
        Vector { _handler: EGU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: RADIO_0 },
        Vector { _handler: RADIO_1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU20 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL20 },
        Vector { _handler: SERIAL21 },
        Vector { _handler: SERIAL22 },
        Vector { _handler: EGU20 },
        Vector { _handler: TIMER20 },
        Vector { _handler: TIMER21 },
        Vector { _handler: TIMER22 },
        Vector { _handler: TIMER23 },
        Vector { _handler: TIMER24 },
        Vector { _reserved: 0 },
        Vector { _handler: PDM20 },
        Vector { _handler: PDM21 },
        Vector { _handler: PWM20 },
        Vector { _handler: PWM21 },
        Vector { _handler: PWM22 },
        Vector { _handler: SAADC },
        Vector { _handler: NFCT },
        Vector { _handler: TEMP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE20_0,
        },
        Vector {
            _handler: GPIOTE20_1,
        },
        Vector { _handler: TAMPC },
        Vector { _handler: I2S20 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: QDEC20 },
        Vector { _handler: QDEC21 },
        Vector { _handler: GRTC_0 },
        Vector { _handler: GRTC_1 },
        Vector { _handler: GRTC_2 },
        Vector { _handler: GRTC_3 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU30 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL30 },
        Vector { _handler: RTC30 },
        Vector {
            _handler: COMP_LPCOMP,
        },
        Vector { _reserved: 0 },
        Vector { _handler: WDT30 },
        Vector { _handler: WDT31 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE30_0,
        },
        Vector {
            _handler: GPIOTE30_1,
        },
        Vector {
            _handler: CLOCK_POWER,
        },
    ];
}
#[doc = "Factory Information Configuration Registers"]
pub const FICR_NS: ficr::Ficr = unsafe { ficr::Ficr::from_ptr(0x00ff_c000usize as _) };
#[doc = "User Information Configuration Registers"]
pub const UICR_S: uicr::Uicr = unsafe { uicr::Uicr::from_ptr(0x00ff_d000usize as _) };
#[doc = "Factory Information Configuration Registers"]
pub const SICR_S: sicr::Sicr = unsafe { sicr::Sicr::from_ptr(0x00ff_e000usize as _) };
#[doc = "CACHEDATA"]
pub const ICACHEDATA_S: cachedata::Cachedata =
    unsafe { cachedata::Cachedata::from_ptr(0x12f0_0000usize as _) };
#[doc = "CACHEINFO"]
pub const ICACHEINFO_S: cacheinfo::Cacheinfo =
    unsafe { cacheinfo::Cacheinfo::from_ptr(0x12f1_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub const DPPIC00_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4004_2000usize as _) };
#[doc = "PPIB APB registers 0"]
pub const PPIB00_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_3000usize as _) };
#[doc = "PPIB APB registers 2"]
pub const PPIB01_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_4000usize as _) };
#[doc = "Accelerated Address Resolver 0"]
pub const AAR00_NS: aar::Aar = unsafe { aar::Aar::from_ptr(0x4004_6000usize as _) };
#[doc = "AES CCM Mode Encryption 0"]
pub const CCM00_NS: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x4004_6000usize as _) };
#[doc = "AES ECB Mode Encryption 0"]
pub const ECB00_NS: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x4004_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub const SPIM00_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4004_a000usize as _) };
#[doc = "SPI Slave 0"]
pub const SPIS00_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4004_a000usize as _) };
#[doc = "UART with EasyDMA 0"]
pub const UARTE00_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4004_a000usize as _) };
#[doc = "VPR peripheral registers 0"]
pub const VPR00_NS: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x4004_c000usize as _) };
#[doc = "GPIO Port 0"]
pub const P2_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4005_0400usize as _) };
#[doc = "Control access port 0"]
pub const CTRLAP_NS: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x4005_2000usize as _) };
#[doc = "Trace and debug control 0"]
pub const TAD_NS: tad::Tad = unsafe { tad::Tad::from_ptr(0x4005_3000usize as _) };
#[doc = "Timer/Counter 0"]
pub const TIMER00_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4005_5000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 2"]
pub const DPPIC10_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4008_2000usize as _) };
#[doc = "PPIB APB registers 4"]
pub const PPIB10_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_3000usize as _) };
#[doc = "PPIB APB registers 6"]
pub const PPIB11_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_4000usize as _) };
#[doc = "Timer/Counter 2"]
pub const TIMER10_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4008_5000usize as _) };
#[doc = "Real-time counter 0"]
pub const RTC10_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4008_6000usize as _) };
#[doc = "Event generator unit 0"]
pub const EGU10_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4008_7000usize as _) };
#[doc = "2.4 GHz radio 0"]
pub const RADIO_NS: radio::Radio = unsafe { radio::Radio::from_ptr(0x4008_a000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 4"]
pub const DPPIC20_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x400c_2000usize as _) };
#[doc = "PPIB APB registers 8"]
pub const PPIB20_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_3000usize as _) };
#[doc = "PPIB APB registers 10"]
pub const PPIB21_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_4000usize as _) };
#[doc = "PPIB APB registers 12"]
pub const PPIB22_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub const SPIM20_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_6000usize as _) };
#[doc = "SPI Slave 2"]
pub const SPIS20_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub const TWIM20_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub const TWIS20_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_6000usize as _) };
#[doc = "UART with EasyDMA 2"]
pub const UARTE20_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub const SPIM21_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_7000usize as _) };
#[doc = "SPI Slave 4"]
pub const SPIS21_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub const TWIM21_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub const TWIS21_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_7000usize as _) };
#[doc = "UART with EasyDMA 4"]
pub const UARTE21_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub const SPIM22_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_8000usize as _) };
#[doc = "SPI Slave 6"]
pub const SPIS22_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub const TWIM22_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub const TWIS22_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_8000usize as _) };
#[doc = "UART with EasyDMA 6"]
pub const UARTE22_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_8000usize as _) };
#[doc = "Event generator unit 2"]
pub const EGU20_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x400c_9000usize as _) };
#[doc = "Timer/Counter 4"]
pub const TIMER20_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_a000usize as _) };
#[doc = "Timer/Counter 6"]
pub const TIMER21_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_b000usize as _) };
#[doc = "Timer/Counter 8"]
pub const TIMER22_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_c000usize as _) };
#[doc = "Timer/Counter 10"]
pub const TIMER23_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_d000usize as _) };
#[doc = "Timer/Counter 12"]
pub const TIMER24_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_e000usize as _) };
#[doc = "Memory configuration 0"]
pub const MEMCONF_NS: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x400c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub const PDM20_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 2"]
pub const PDM21_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_1000usize as _) };
#[doc = "Pulse width modulation unit 0"]
pub const PWM20_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_2000usize as _) };
#[doc = "Pulse width modulation unit 2"]
pub const PWM21_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_3000usize as _) };
#[doc = "Pulse width modulation unit 4"]
pub const PWM22_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_4000usize as _) };
#[doc = "Analog to Digital Converter 0"]
pub const SAADC_NS: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x400d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
pub const NFCT_NS: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x400d_6000usize as _) };
#[doc = "Temperature Sensor 0"]
pub const TEMP_NS: temp::Temp = unsafe { temp::Temp::from_ptr(0x400d_7000usize as _) };
#[doc = "GPIO Port 2"]
pub const P1_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x400d_8200usize as _) };
#[doc = "GPIO Tasks and Events 0"]
pub const GPIOTE20_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x400d_a000usize as _) };
#[doc = "Inter-IC Sound 0"]
pub const I2S20_NS: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x400d_d000usize as _) };
#[doc = "Quadrature Decoder 0"]
pub const QDEC20_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_0000usize as _) };
#[doc = "Quadrature Decoder 2"]
pub const QDEC21_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_1000usize as _) };
#[doc = "Global Real-time counter 0"]
pub const GRTC_NS: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x400e_2000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 6"]
pub const DPPIC30_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4010_2000usize as _) };
#[doc = "PPIB APB registers 14"]
pub const PPIB30_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 8"]
pub const SPIM30_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4010_4000usize as _) };
#[doc = "SPI Slave 8"]
pub const SPIS30_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub const TWIM30_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub const TWIS30_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4010_4000usize as _) };
#[doc = "UART with EasyDMA 8"]
pub const UARTE30_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4010_4000usize as _) };
#[doc = "Real-time counter 2"]
pub const RTC30_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4010_5000usize as _) };
#[doc = "Comparator 0"]
pub const COMP_NS: comp::Comp = unsafe { comp::Comp::from_ptr(0x4010_6000usize as _) };
#[doc = "Low-power comparator 0"]
pub const LPCOMP_NS: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x4010_6000usize as _) };
#[doc = "Watchdog Timer 1"]
pub const WDT31_NS: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4010_9000usize as _) };
#[doc = "GPIO Port 4"]
pub const P0_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4010_a000usize as _) };
#[doc = "GPIO Tasks and Events 2"]
pub const GPIOTE30_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x4010_c000usize as _) };
#[doc = "Clock management 0"]
pub const CLOCK_NS: clock::Clock = unsafe { clock::Clock::from_ptr(0x4010_e000usize as _) };
#[doc = "Power control 0"]
pub const POWER_NS: power::Power = unsafe { power::Power::from_ptr(0x4010_e000usize as _) };
#[doc = "Reset control 0"]
pub const RESET_NS: reset::Reset = unsafe { reset::Reset::from_ptr(0x4010_e000usize as _) };
#[doc = "Oscillator control 0"]
pub const OSCILLATORS_NS: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x4012_0000usize as _) };
#[doc = "Voltage regulators 0"]
pub const REGULATORS_NS: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x4012_0000usize as _) };
#[doc = "Software interrupt 0"]
pub const SWI00_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_c000usize as _) };
#[doc = "Software interrupt 1"]
pub const SWI01_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_d000usize as _) };
#[doc = "Software interrupt 2"]
pub const SWI02_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_e000usize as _) };
#[doc = "Software interrupt 3"]
pub const SWI03_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_f000usize as _) };
#[doc = "System protection unit 0"]
pub const SPU00_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5004_0000usize as _) };
#[doc = "Memory Privilege Controller"]
pub const MPC00_S: mpc::Mpc = unsafe { mpc::Mpc::from_ptr(0x5004_1000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub const DPPIC00_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5004_2000usize as _) };
#[doc = "PPIB APB registers 1"]
pub const PPIB00_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_3000usize as _) };
#[doc = "PPIB APB registers 3"]
pub const PPIB01_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_4000usize as _) };
#[doc = "Key management unit"]
pub const KMU_S: kmu::Kmu = unsafe { kmu::Kmu::from_ptr(0x5004_5000usize as _) };
#[doc = "Accelerated Address Resolver 1"]
pub const AAR00_S: aar::Aar = unsafe { aar::Aar::from_ptr(0x5004_6000usize as _) };
#[doc = "AES CCM Mode Encryption 1"]
pub const CCM00_S: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x5004_6000usize as _) };
#[doc = "AES ECB Mode Encryption 1"]
pub const ECB00_S: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x5004_7000usize as _) };
#[doc = "CRACEN"]
pub const CRACEN_S: cracen::Cracen = unsafe { cracen::Cracen::from_ptr(0x5004_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub const SPIM00_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5004_a000usize as _) };
#[doc = "SPI Slave 1"]
pub const SPIS00_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5004_a000usize as _) };
#[doc = "UART with EasyDMA 1"]
pub const UARTE00_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5004_a000usize as _) };
#[doc = "Voltage glitch detectors"]
pub const GLITCHDET_S: glitchdet::Glitchdet =
    unsafe { glitchdet::Glitchdet::from_ptr(0x5004_b000usize as _) };
#[doc = "RRAM controller GLITCH detector"]
pub const RRAMC_S: rramc::Rramc = unsafe { rramc::Rramc::from_ptr(0x5004_b000usize as _) };
#[doc = "VPR peripheral registers 1"]
pub const VPR00_S: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x5004_c000usize as _) };
#[doc = "GPIO Port 1"]
pub const P2_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5005_0400usize as _) };
#[doc = "Control access port 1"]
pub const CTRLAP_S: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x5005_2000usize as _) };
#[doc = "Trace and debug control 1"]
pub const TAD_S: tad::Tad = unsafe { tad::Tad::from_ptr(0x5005_3000usize as _) };
#[doc = "Timer/Counter 1"]
pub const TIMER00_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5005_5000usize as _) };
#[doc = "System protection unit 1"]
pub const SPU10_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5008_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 3"]
pub const DPPIC10_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5008_2000usize as _) };
#[doc = "PPIB APB registers 5"]
pub const PPIB10_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_3000usize as _) };
#[doc = "PPIB APB registers 7"]
pub const PPIB11_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_4000usize as _) };
#[doc = "Timer/Counter 3"]
pub const TIMER10_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5008_5000usize as _) };
#[doc = "Real-time counter 1"]
pub const RTC10_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5008_6000usize as _) };
#[doc = "Event generator unit 1"]
pub const EGU10_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5008_7000usize as _) };
#[doc = "2.4 GHz radio 1"]
pub const RADIO_S: radio::Radio = unsafe { radio::Radio::from_ptr(0x5008_a000usize as _) };
#[doc = "System protection unit 2"]
pub const SPU20_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x500c_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 5"]
pub const DPPIC20_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x500c_2000usize as _) };
#[doc = "PPIB APB registers 9"]
pub const PPIB20_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_3000usize as _) };
#[doc = "PPIB APB registers 11"]
pub const PPIB21_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_4000usize as _) };
#[doc = "PPIB APB registers 13"]
pub const PPIB22_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub const SPIM20_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_6000usize as _) };
#[doc = "SPI Slave 3"]
pub const SPIS20_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub const TWIM20_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub const TWIS20_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_6000usize as _) };
#[doc = "UART with EasyDMA 3"]
pub const UARTE20_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub const SPIM21_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_7000usize as _) };
#[doc = "SPI Slave 5"]
pub const SPIS21_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub const TWIM21_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub const TWIS21_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_7000usize as _) };
#[doc = "UART with EasyDMA 5"]
pub const UARTE21_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub const SPIM22_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_8000usize as _) };
#[doc = "SPI Slave 7"]
pub const SPIS22_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub const TWIM22_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub const TWIS22_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_8000usize as _) };
#[doc = "UART with EasyDMA 7"]
pub const UARTE22_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_8000usize as _) };
#[doc = "Event generator unit 3"]
pub const EGU20_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x500c_9000usize as _) };
#[doc = "Timer/Counter 5"]
pub const TIMER20_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_a000usize as _) };
#[doc = "Timer/Counter 7"]
pub const TIMER21_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_b000usize as _) };
#[doc = "Timer/Counter 9"]
pub const TIMER22_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_c000usize as _) };
#[doc = "Timer/Counter 11"]
pub const TIMER23_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_d000usize as _) };
#[doc = "Timer/Counter 13"]
pub const TIMER24_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_e000usize as _) };
#[doc = "Memory configuration 1"]
pub const MEMCONF_S: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x500c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub const PDM20_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 3"]
pub const PDM21_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_1000usize as _) };
#[doc = "Pulse width modulation unit 1"]
pub const PWM20_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_2000usize as _) };
#[doc = "Pulse width modulation unit 3"]
pub const PWM21_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_3000usize as _) };
#[doc = "Pulse width modulation unit 5"]
pub const PWM22_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_4000usize as _) };
#[doc = "Analog to Digital Converter 1"]
pub const SAADC_S: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x500d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 1"]
pub const NFCT_S: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x500d_6000usize as _) };
#[doc = "Temperature Sensor 1"]
pub const TEMP_S: temp::Temp = unsafe { temp::Temp::from_ptr(0x500d_7000usize as _) };
#[doc = "GPIO Port 3"]
pub const P1_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x500d_8200usize as _) };
#[doc = "GPIO Tasks and Events 1"]
pub const GPIOTE20_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x500d_a000usize as _) };
#[doc = "Tamper controller"]
pub const TAMPC_S: tampc::Tampc = unsafe { tampc::Tampc::from_ptr(0x500d_c000usize as _) };
#[doc = "Inter-IC Sound 1"]
pub const I2S20_S: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x500d_d000usize as _) };
#[doc = "Quadrature Decoder 1"]
pub const QDEC20_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_0000usize as _) };
#[doc = "Quadrature Decoder 3"]
pub const QDEC21_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_1000usize as _) };
#[doc = "Global Real-time counter 1"]
pub const GRTC_S: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x500e_2000usize as _) };
#[doc = "System protection unit 3"]
pub const SPU30_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5010_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 7"]
pub const DPPIC30_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5010_2000usize as _) };
#[doc = "PPIB APB registers 15"]
pub const PPIB30_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 9"]
pub const SPIM30_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5010_4000usize as _) };
#[doc = "SPI Slave 9"]
pub const SPIS30_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub const TWIM30_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub const TWIS30_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5010_4000usize as _) };
#[doc = "UART with EasyDMA 9"]
pub const UARTE30_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5010_4000usize as _) };
#[doc = "Real-time counter 3"]
pub const RTC30_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5010_5000usize as _) };
#[doc = "Comparator 1"]
pub const COMP_S: comp::Comp = unsafe { comp::Comp::from_ptr(0x5010_6000usize as _) };
#[doc = "Low-power comparator 1"]
pub const LPCOMP_S: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x5010_6000usize as _) };
#[doc = "Watchdog Timer 0"]
pub const WDT30_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_8000usize as _) };
#[doc = "Watchdog Timer 2"]
pub const WDT31_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_9000usize as _) };
#[doc = "GPIO Port 5"]
pub const P0_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5010_a000usize as _) };
#[doc = "GPIO Tasks and Events 3"]
pub const GPIOTE30_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x5010_c000usize as _) };
#[doc = "Clock management 1"]
pub const CLOCK_S: clock::Clock = unsafe { clock::Clock::from_ptr(0x5010_e000usize as _) };
#[doc = "Power control 1"]
pub const POWER_S: power::Power = unsafe { power::Power::from_ptr(0x5010_e000usize as _) };
#[doc = "Reset control 1"]
pub const RESET_S: reset::Reset = unsafe { reset::Reset::from_ptr(0x5010_e000usize as _) };
#[doc = "Oscillator control 1"]
pub const OSCILLATORS_S: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x5012_0000usize as _) };
#[doc = "Voltage regulators 1"]
pub const REGULATORS_S: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x5012_0000usize as _) };
#[doc = "CRACENCORE"]
pub const CRACENCORE_S: cracencore::Cracencore =
    unsafe { cracencore::Cracencore::from_ptr(0x5180_0000usize as _) };
#[doc = "Trace Port Interface Unit"]
pub const TPIU_NS: tpiu::Tpiu = unsafe { tpiu::Tpiu::from_ptr(0xe004_0000usize as _) };
#[doc = "Embedded Trace Macrocell"]
pub const ETM_NS: etm::Etm = unsafe { etm::Etm::from_ptr(0xe004_1000usize as _) };
#[doc = "CPU control"]
pub const CPUC_S: cpuc::Cpuc = unsafe { cpuc::Cpuc::from_ptr(0xe008_0000usize as _) };
#[doc = "Cache"]
pub const ICACHE_S: cache::Cache = unsafe { cache::Cache::from_ptr(0xe008_2000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
#[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod aar {
    #[doc = "Accelerated Address Resolver 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Aar {
        ptr: *mut u8,
    }
    unsafe impl Send for Aar {}
    unsafe impl Sync for Aar {}
    impl Aar {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start resolving addresses based on IRKs specified in the IRK data structure"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop resolving addresses"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Address resolution procedure complete or ended due to an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Address resolved"]
        #[inline(always)]
        pub const fn events_resolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Address not resolved"]
        #[inline(always)]
        pub const fn events_notresolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Operation aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event RESOLVED"]
        #[inline(always)]
        pub const fn publish_resolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event NOTRESOLVED"]
        #[inline(always)]
        pub const fn publish_notresolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable AAR"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[inline(always)]
        pub const fn maxresolved(self) -> crate::common::Reg<regs::Maxresolved, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u8:?} }}", self.amount())
            }
        }
        #[doc = "Enable AAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable AAR"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable AAR"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[must_use]
            #[inline(always)]
            pub const fn resolved(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[inline(always)]
            pub const fn set_resolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[must_use]
            #[inline(always)]
            pub const fn notresolved(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[inline(always)]
            pub const fn set_notresolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("resolved", &self.resolved())
                    .field("notresolved", &self.notresolved())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ end: {=bool:?}, resolved: {=bool:?}, notresolved: {=bool:?}, error: {=bool:?} }}" , self . end () , self . resolved () , self . notresolved () , self . error ())
            }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxresolved(pub u32);
        impl Maxresolved {
            #[doc = "The maximum number of IRKs to resolve"]
            #[must_use]
            #[inline(always)]
            pub const fn maxresolved(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The maximum number of IRKs to resolve"]
            #[inline(always)]
            pub const fn set_maxresolved(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Maxresolved {
            #[inline(always)]
            fn default() -> Maxresolved {
                Maxresolved(0)
            }
        }
        impl core::fmt::Debug for Maxresolved {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxresolved")
                    .field("maxresolved", &self.maxresolved())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxresolved {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Maxresolved {{ maxresolved: {=u16:?} }}",
                    self.maxresolved()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Enable"]
            ENABLED = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod cache {
    #[doc = "Cache"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cache {
        ptr: *mut u8,
    }
    unsafe impl Send for Cache {}
    unsafe impl Sync for Cache {}
    impl Cache {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Invalidate the cache."]
        #[inline(always)]
        pub const fn tasks_invalidatecache(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Invalidate the line."]
        #[inline(always)]
        pub const fn tasks_invalidateline(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Erase the cache."]
        #[inline(always)]
        pub const fn tasks_erase(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Status of the cache activities."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable cache."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::CacheEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Cache mode."]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Memory address covered by the line to be maintained."]
        #[inline(always)]
        pub const fn lineaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn profiling(self) -> Profiling {
            unsafe { Profiling::from_ptr(self.ptr.add(0x0414usize) as _) }
        }
        #[doc = "Lock debug mode."]
        #[inline(always)]
        pub const fn debuglock(self) -> crate::common::Reg<regs::Debuglock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0430usize) as _) }
        }
        #[doc = "Lock cache updates."]
        #[inline(always)]
        pub const fn writelock(self) -> crate::common::Reg<regs::Writelock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0434usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Profiling {
        ptr: *mut u8,
    }
    unsafe impl Send for Profiling {}
    unsafe impl Sync for Profiling {}
    impl Profiling {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable the profiling counters."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::ProfilingEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Clear the profiling counters."]
        #[inline(always)]
        pub const fn clear(self) -> crate::common::Reg<regs::Clear, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The cache hit counter for cache region."]
        #[inline(always)]
        pub const fn hit(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The cache miss counter for cache region."]
        #[inline(always)]
        pub const fn miss(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "The cache line miss counter for cache region."]
        #[inline(always)]
        pub const fn lmiss(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Number of reads for cache region."]
        #[inline(always)]
        pub const fn reads(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Number of writes for cache region."]
        #[inline(always)]
        pub const fn writes(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable cache."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CacheEnable(pub u32);
        impl CacheEnable {
            #[doc = "Enable cache"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable cache"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CacheEnable {
            #[inline(always)]
            fn default() -> CacheEnable {
                CacheEnable(0)
            }
        }
        impl core::fmt::Debug for CacheEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CacheEnable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CacheEnable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CacheEnable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Clear the profiling counters."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clear(pub u32);
        impl Clear {
            #[doc = "Clearing the profiling counters"]
            #[must_use]
            #[inline(always)]
            pub const fn clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Clearing the profiling counters"]
            #[inline(always)]
            pub const fn set_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clear {
            #[inline(always)]
            fn default() -> Clear {
                Clear(0)
            }
        }
        impl core::fmt::Debug for Clear {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clear")
                    .field("clear", &self.clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clear {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Clear {{ clear: {=bool:?} }}", self.clear())
            }
        }
        #[doc = "Lock debug mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Debuglock(pub u32);
        impl Debuglock {
            #[doc = "Lock debug mode"]
            #[must_use]
            #[inline(always)]
            pub const fn debuglock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock debug mode"]
            #[inline(always)]
            pub const fn set_debuglock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Debuglock {
            #[inline(always)]
            fn default() -> Debuglock {
                Debuglock(0)
            }
        }
        impl core::fmt::Debug for Debuglock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Debuglock")
                    .field("debuglock", &self.debuglock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Debuglock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Debuglock {{ debuglock: {=bool:?} }}", self.debuglock())
            }
        }
        #[doc = "Cache mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Cache mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Cache mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "RAM size"]
            #[must_use]
            #[inline(always)]
            pub const fn ramsize(&self) -> super::vals::Ramsize {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Ramsize::from_bits(val as u8)
            }
            #[doc = "RAM size"]
            #[inline(always)]
            pub const fn set_ramsize(&mut self, val: super::vals::Ramsize) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("mode", &self.mode())
                    .field("ramsize", &self.ramsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ mode: {:?}, ramsize: {:?} }}",
                    self.mode(),
                    self.ramsize()
                )
            }
        }
        #[doc = "Enable the profiling counters."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ProfilingEnable(pub u32);
        impl ProfilingEnable {
            #[doc = "Enable the profiling counters"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the profiling counters"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ProfilingEnable {
            #[inline(always)]
            fn default() -> ProfilingEnable {
                ProfilingEnable(0)
            }
        }
        impl core::fmt::Debug for ProfilingEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ProfilingEnable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ProfilingEnable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ProfilingEnable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Status of the cache activities."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Ready status."]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Ready status."]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Lock cache updates."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writelock(pub u32);
        impl Writelock {
            #[doc = "Lock cache updates"]
            #[must_use]
            #[inline(always)]
            pub const fn writelock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock cache updates"]
            #[inline(always)]
            pub const fn set_writelock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Writelock {
            #[inline(always)]
            fn default() -> Writelock {
                Writelock(0)
            }
        }
        impl core::fmt::Debug for Writelock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writelock")
                    .field("writelock", &self.writelock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writelock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Writelock {{ writelock: {=bool:?} }}", self.writelock())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Cache mode"]
            CACHE = 0x0,
            #[doc = "RAM mode"]
            RAM = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ramsize {
            #[doc = "All RAM is used for cache memory"]
            ALL = 0x0,
            #[doc = "Half of the RAM is used for cache memory"]
            HALF = 0x01,
            #[doc = "Quarter of the RAM is used for cache memory"]
            QUARTER = 0x02,
            #[doc = "None of the RAM is used for cache memory"]
            NONE = 0x03,
        }
        impl Ramsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ramsize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ramsize {
            #[inline(always)]
            fn from(val: u8) -> Ramsize {
                Ramsize::from_bits(val)
            }
        }
        impl From<Ramsize> for u8 {
            #[inline(always)]
            fn from(val: Ramsize) -> u8 {
                Ramsize::to_bits(val)
            }
        }
    }
}
pub mod cachedata {
    #[doc = "CACHEDATA"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cachedata {
        ptr: *mut u8,
    }
    unsafe impl Send for Cachedata {}
    unsafe impl Sync for Cachedata {}
    impl Cachedata {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn set(self, n: usize) -> Set {
            assert!(n < 128usize);
            unsafe { Set::from_ptr(self.ptr.add(0x0usize + n * 64usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Du {
        ptr: *mut u8,
    }
    unsafe impl Send for Du {}
    unsafe impl Sync for Du {}
    impl Du {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Cache data bits for DATA\\[q\\] in DU\\[p\\] (DataUnit) of SET\\[n\\], WAY\\[o\\]."]
        #[inline(always)]
        pub const fn data(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Set {
        ptr: *mut u8,
    }
    unsafe impl Send for Set {}
    unsafe impl Sync for Set {}
    impl Set {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn way(self, n: usize) -> Way {
            assert!(n < 2usize);
            unsafe { Way::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Way {
        ptr: *mut u8,
    }
    unsafe impl Send for Way {}
    unsafe impl Sync for Way {}
    impl Way {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn du(self, n: usize) -> Du {
            assert!(n < 4usize);
            unsafe { Du::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
}
pub mod cacheinfo {
    #[doc = "CACHEINFO"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cacheinfo {
        ptr: *mut u8,
    }
    unsafe impl Send for Cacheinfo {}
    unsafe impl Sync for Cacheinfo {}
    impl Cacheinfo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn set(self, n: usize) -> Set {
            assert!(n < 128usize);
            unsafe { Set::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Set {
        ptr: *mut u8,
    }
    unsafe impl Send for Set {}
    unsafe impl Sync for Set {}
    impl Set {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn way(self, n: usize) -> Way {
            assert!(n < 2usize);
            unsafe { Way::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Way {
        ptr: *mut u8,
    }
    unsafe impl Send for Way {}
    unsafe impl Sync for Way {}
    impl Way {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Cache information for SET\\[n\\], WAY\\[o\\]."]
        #[inline(always)]
        pub const fn info(self) -> crate::common::Reg<regs::Info, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Cache information for SET\\[n\\], WAY\\[o\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Info(pub u32);
        impl Info {
            #[doc = "Cache tag."]
            #[must_use]
            #[inline(always)]
            pub const fn tag(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Cache tag."]
            #[inline(always)]
            pub const fn set_tag(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Data unit valid info."]
            #[must_use]
            #[inline(always)]
            pub const fn duv_0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn set_duv_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Data unit valid info."]
            #[must_use]
            #[inline(always)]
            pub const fn duv_1(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn set_duv_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Data unit valid info."]
            #[must_use]
            #[inline(always)]
            pub const fn duv_2(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn set_duv_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Data unit valid info."]
            #[must_use]
            #[inline(always)]
            pub const fn duv_3(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn set_duv_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Line valid bit."]
            #[must_use]
            #[inline(always)]
            pub const fn v(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Line valid bit."]
            #[inline(always)]
            pub const fn set_v(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Most recently used way."]
            #[must_use]
            #[inline(always)]
            pub const fn mru(&self) -> super::vals::Mru {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mru::from_bits(val as u8)
            }
            #[doc = "Most recently used way."]
            #[inline(always)]
            pub const fn set_mru(&mut self, val: super::vals::Mru) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Info {
            #[inline(always)]
            fn default() -> Info {
                Info(0)
            }
        }
        impl core::fmt::Debug for Info {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Info")
                    .field("tag", &self.tag())
                    .field("duv_0", &self.duv_0())
                    .field("duv_1", &self.duv_1())
                    .field("duv_2", &self.duv_2())
                    .field("duv_3", &self.duv_3())
                    .field("v", &self.v())
                    .field("mru", &self.mru())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Info {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Info {{ tag: {=u32:?}, duv_0: {=bool:?}, duv_1: {=bool:?}, duv_2: {=bool:?}, duv_3: {=bool:?}, v: {=bool:?}, mru: {:?} }}" , self . tag () , self . duv_0 () , self . duv_1 () , self . duv_2 () , self . duv_3 () , self . v () , self . mru ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mru {
            #[doc = "Way0 was most recently used"]
            WAY0 = 0x0,
            #[doc = "Way1 was most recently used"]
            WAY1 = 0x01,
        }
        impl Mru {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mru {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mru {
            #[inline(always)]
            fn from(val: u8) -> Mru {
                Mru::from_bits(val)
            }
        }
        impl From<Mru> for u8 {
            #[inline(always)]
            fn from(val: Mru) -> u8 {
                Mru::to_bits(val)
            }
        }
    }
}
pub mod ccm {
    #[doc = "AES CCM Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccm {
        ptr: *mut u8,
    }
    unsafe impl Send for Ccm {}
    unsafe impl Sync for Ccm {}
    impl Ccm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start encryption/decryption. This operation will stop by itself when completed."]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_rateoverride(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task RATEOVERRIDE"]
        #[inline(always)]
        pub const fn subscribe_rateoverride(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Encrypt/decrypt complete or ended because of an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "CCM error event"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "MAC check result"]
        #[inline(always)]
        pub const fn macstatus(self) -> crate::common::Reg<regs::Macstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Operation mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nonce(self) -> Nonce {
            unsafe { Nonce::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Data rate override setting."]
        #[inline(always)]
        pub const fn rateoverride(
            self,
        ) -> crate::common::Reg<regs::Rateoverride, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0544usize) as _) }
        }
        #[doc = "CCM adata mask."]
        #[inline(always)]
        pub const fn adatamask(self) -> crate::common::Reg<regs::Adatamask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0548usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer Points to a job list containing unencrypted CCM data structure in Encryption mode Points to a job list containing encrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nonce {
        ptr: *mut u8,
    }
    unsafe impl Send for Nonce {}
    unsafe impl Sync for Nonce {}
    impl Nonce {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 13-byte NONCE vector Only the lower 13 bytes are used"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted CCM data structure in Encryption mode Points to a job list containing decrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CCM adata mask."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adatamask(pub u32);
        impl Adatamask {
            #[doc = "CCM adata mask."]
            #[must_use]
            #[inline(always)]
            pub const fn adatamask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CCM adata mask."]
            #[inline(always)]
            pub const fn set_adatamask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Adatamask {
            #[inline(always)]
            fn default() -> Adatamask {
                Adatamask(0)
            }
        }
        impl core::fmt::Debug for Adatamask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adatamask")
                    .field("adatamask", &self.adatamask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adatamask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Adatamask {{ adatamask: {=u8:?} }}", self.adatamask())
            }
        }
        #[doc = "Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable CCM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable CCM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ end: {=bool:?}, error: {=bool:?} }}",
                    self.end(),
                    self.error()
                )
            }
        }
        #[doc = "MAC check result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Macstatus(pub u32);
        impl Macstatus {
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[must_use]
            #[inline(always)]
            pub const fn macstatus(&self) -> super::vals::Macstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Macstatus::from_bits(val as u8)
            }
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[inline(always)]
            pub const fn set_macstatus(&mut self, val: super::vals::Macstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Macstatus {
            #[inline(always)]
            fn default() -> Macstatus {
                Macstatus(0)
            }
        }
        impl core::fmt::Debug for Macstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Macstatus")
                    .field("macstatus", &self.macstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Macstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Macstatus {{ macstatus: {:?} }}", self.macstatus())
            }
        }
        #[doc = "Operation mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Protocol and packet format selection"]
            #[must_use]
            #[inline(always)]
            pub const fn protocol(&self) -> super::vals::Protocol {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Protocol::from_bits(val as u8)
            }
            #[doc = "Protocol and packet format selection"]
            #[inline(always)]
            pub const fn set_protocol(&mut self, val: super::vals::Protocol) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[must_use]
            #[inline(always)]
            pub const fn datarate(&self) -> super::vals::Datarate {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Datarate::from_bits(val as u8)
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[inline(always)]
            pub const fn set_datarate(&mut self, val: super::vals::Datarate) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "CCM MAC length (bytes)"]
            #[must_use]
            #[inline(always)]
            pub const fn maclen(&self) -> super::vals::Maclen {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Maclen::from_bits(val as u8)
            }
            #[doc = "CCM MAC length (bytes)"]
            #[inline(always)]
            pub const fn set_maclen(&mut self, val: super::vals::Maclen) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("mode", &self.mode())
                    .field("protocol", &self.protocol())
                    .field("datarate", &self.datarate())
                    .field("maclen", &self.maclen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ mode: {:?}, protocol: {:?}, datarate: {:?}, maclen: {:?} }}",
                    self.mode(),
                    self.protocol(),
                    self.datarate(),
                    self.maclen()
                )
            }
        }
        #[doc = "Data rate override setting."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rateoverride(pub u32);
        impl Rateoverride {
            #[doc = "Data rate override setting."]
            #[must_use]
            #[inline(always)]
            pub const fn rateoverride(&self) -> super::vals::Rateoverride {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Rateoverride::from_bits(val as u8)
            }
            #[doc = "Data rate override setting."]
            #[inline(always)]
            pub const fn set_rateoverride(&mut self, val: super::vals::Rateoverride) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rateoverride {
            #[inline(always)]
            fn default() -> Rateoverride {
                Rateoverride(0)
            }
        }
        impl core::fmt::Debug for Rateoverride {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rateoverride")
                    .field("rateoverride", &self.rateoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rateoverride {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rateoverride {{ rateoverride: {:?} }}",
                    self.rateoverride()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Datarate {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            #[doc = "250 Kbps"]
            _250KBIT = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Datarate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Datarate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Datarate {
            #[inline(always)]
            fn from(val: u8) -> Datarate {
                Datarate::from_bits(val)
            }
        }
        impl From<Datarate> for u8 {
            #[inline(always)]
            fn from(val: Datarate) -> u8 {
                Datarate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before CCM data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before CCM data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Encryption of the unencrypted CCM data structure did not complete in time."]
            ENCRYPTION_TOO_SLOW = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Maclen {
            #[doc = "M = 0 This is a special case for CCM* where encryption is required but not authentication"]
            M0 = 0x0,
            #[doc = "M = 4"]
            M4 = 0x01,
            #[doc = "M = 6"]
            M6 = 0x02,
            #[doc = "M = 8"]
            M8 = 0x03,
            #[doc = "M = 10"]
            M10 = 0x04,
            #[doc = "M = 12"]
            M12 = 0x05,
            #[doc = "M = 14"]
            M14 = 0x06,
            #[doc = "M = 16"]
            M16 = 0x07,
        }
        impl Maclen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Maclen {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Maclen {
            #[inline(always)]
            fn from(val: u8) -> Maclen {
                Maclen::from_bits(val)
            }
        }
        impl From<Maclen> for u8 {
            #[inline(always)]
            fn from(val: Maclen) -> u8 {
                Maclen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macstatus {
            #[doc = "MAC check failed"]
            CHECK_FAILED = 0x0,
            #[doc = "MAC check passed"]
            CHECK_PASSED = 0x01,
        }
        impl Macstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macstatus {
            #[inline(always)]
            fn from(val: u8) -> Macstatus {
                Macstatus::from_bits(val)
            }
        }
        impl From<Macstatus> for u8 {
            #[inline(always)]
            fn from(val: Macstatus) -> u8 {
                Macstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "AES CCM packet encryption mode"]
            ENCRYPTION = 0x0,
            #[doc = "Deprecated enumerator - This mode will run CCM decryption in the speed of the DATARATE field."]
            DECRYPTION = 0x01,
            #[doc = "AES CCM decryption mode."]
            FAST_DECRYPTION = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Protocol {
            #[doc = "Bluetooth Low Energy packet format"]
            BLE = 0x0,
            #[doc = "802.15.4 packet format"]
            IEEE802154 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Protocol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Protocol {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Protocol {
            #[inline(always)]
            fn from(val: u8) -> Protocol {
                Protocol::from_bits(val)
            }
        }
        impl From<Protocol> for u8 {
            #[inline(always)]
            fn from(val: Protocol) -> u8 {
                Protocol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rateoverride {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rateoverride {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rateoverride {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rateoverride {
            #[inline(always)]
            fn from(val: u8) -> Rateoverride {
                Rateoverride::from_bits(val)
            }
        }
        impl From<Rateoverride> for u8 {
            #[inline(always)]
            fn from(val: Rateoverride) -> u8 {
                Rateoverride::to_bits(val)
            }
        }
    }
}
pub mod clock {
    #[doc = "Clock management 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clock {
        ptr: *mut u8,
    }
    unsafe impl Send for Clock {}
    unsafe impl Sync for Clock {}
    impl Clock {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Start PLL and keep it running, regardless of the automatic clock requests"]
        #[inline(always)]
        pub const fn tasks_pllstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Stop PLL"]
        #[inline(always)]
        pub const fn tasks_pllstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Start LFCLK source as selected in LFCLK.SRC"]
        #[inline(always)]
        pub const fn tasks_lfclkstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Stop LFCLK source"]
        #[inline(always)]
        pub const fn tasks_lfclkstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Start calibration of LFRC oscillator"]
        #[inline(always)]
        pub const fn tasks_cal(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Request tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotune(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Abort tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotuneabort(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTART"]
        #[inline(always)]
        pub const fn subscribe_xostart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTOP"]
        #[inline(always)]
        pub const fn subscribe_xostop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTART"]
        #[inline(always)]
        pub const fn subscribe_pllstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTOP"]
        #[inline(always)]
        pub const fn subscribe_pllstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTART"]
        #[inline(always)]
        pub const fn subscribe_lfclkstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTOP"]
        #[inline(always)]
        pub const fn subscribe_lfclkstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task CAL"]
        #[inline(always)]
        pub const fn subscribe_cal(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNE"]
        #[inline(always)]
        pub const fn subscribe_xotune(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNEABORT"]
        #[inline(always)]
        pub const fn subscribe_xotuneabort(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Crystal oscillator has started"]
        #[inline(always)]
        pub const fn events_xostarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "PLL started"]
        #[inline(always)]
        pub const fn events_pllstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "LFCLK source started"]
        #[inline(always)]
        pub const fn events_lfclkstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Calibration of LFRC oscillator complete event"]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "HFXO tuning is done. XOTUNED is generated after TASKS_XOSTART or after TASKS_XOTUNE has completed"]
        #[inline(always)]
        pub const fn events_xotuned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "HFXO quality issue detected, XOTUNE is needed"]
        #[inline(always)]
        pub const fn events_xotuneerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "HFXO tuning could not be completed"]
        #[inline(always)]
        pub const fn events_xotunefailed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Publish configuration for event XOSTARTED"]
        #[inline(always)]
        pub const fn publish_xostarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event PLLSTARTED"]
        #[inline(always)]
        pub const fn publish_pllstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event LFCLKSTARTED"]
        #[inline(always)]
        pub const fn publish_lfclkstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNED"]
        #[inline(always)]
        pub const fn publish_xotuned(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEERROR"]
        #[inline(always)]
        pub const fn publish_xotuneerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEFAILED"]
        #[inline(always)]
        pub const fn publish_xotunefailed(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn xo(self) -> Xo {
            unsafe { Xo::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn lfclk(self) -> Lfclk {
            unsafe { Lfclk::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lfclk {
        ptr: *mut u8,
    }
    unsafe impl Send for Lfclk {}
    unsafe impl Sync for Lfclk {}
    impl Lfclk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock source for LFCLK"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<regs::Src, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::LfclkRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::LfclkStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[inline(always)]
        pub const fn srccopy(self) -> crate::common::Reg<regs::Srccopy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::PllRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::PllStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xo {
        ptr: *mut u8,
    }
    unsafe impl Send for Xo {}
    unsafe impl Sync for Xo {}
    impl Xo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::XoRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "XO status"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::XoStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn xostarted(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[inline(always)]
            pub const fn set_xostarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn pllstarted(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[inline(always)]
            pub const fn set_pllstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn lfclkstarted(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[inline(always)]
            pub const fn set_lfclkstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[must_use]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[must_use]
            #[inline(always)]
            pub const fn xotuned(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[inline(always)]
            pub const fn set_xotuned(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn xotuneerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[inline(always)]
            pub const fn set_xotuneerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[must_use]
            #[inline(always)]
            pub const fn xotunefailed(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[inline(always)]
            pub const fn set_xotunefailed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("xostarted", &self.xostarted())
                    .field("pllstarted", &self.pllstarted())
                    .field("lfclkstarted", &self.lfclkstarted())
                    .field("done", &self.done())
                    .field("xotuned", &self.xotuned())
                    .field("xotuneerror", &self.xotuneerror())
                    .field("xotunefailed", &self.xotunefailed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ xostarted: {=bool:?}, pllstarted: {=bool:?}, lfclkstarted: {=bool:?}, done: {=bool:?}, xotuned: {=bool:?}, xotuneerror: {=bool:?}, xotunefailed: {=bool:?} }}" , self . xostarted () , self . pllstarted () , self . lfclkstarted () , self . done () , self . xotuned () , self . xotuneerror () , self . xotunefailed ())
            }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkRun(pub u32);
        impl LfclkRun {
            #[doc = "LFCLKSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLKSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for LfclkRun {
            #[inline(always)]
            fn default() -> LfclkRun {
                LfclkRun(0)
            }
        }
        impl core::fmt::Debug for LfclkRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "LfclkRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkStat(pub u32);
        impl LfclkStat {
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "ALWAYSRUN activated"]
            #[must_use]
            #[inline(always)]
            pub const fn alwaysrunning(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "ALWAYSRUN activated"]
            #[inline(always)]
            pub const fn set_alwaysrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for LfclkStat {
            #[inline(always)]
            fn default() -> LfclkStat {
                LfclkStat(0)
            }
        }
        impl core::fmt::Debug for LfclkStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkStat")
                    .field("src", &self.src())
                    .field("alwaysrunning", &self.alwaysrunning())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "LfclkStat {{ src: {:?}, alwaysrunning: {=bool:?}, state: {=bool:?} }}",
                    self.src(),
                    self.alwaysrunning(),
                    self.state()
                )
            }
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllRun(pub u32);
        impl PllRun {
            #[doc = "PLLSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PLLSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PllRun {
            #[inline(always)]
            fn default() -> PllRun {
                PllRun(0)
            }
        }
        impl core::fmt::Debug for PllRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PllRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllStat(pub u32);
        impl PllStat {
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PllStat {
            #[inline(always)]
            fn default() -> PllStat {
                PllStat(0)
            }
        }
        impl core::fmt::Debug for PllStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PllStat {{ state: {=bool:?} }}", self.state())
            }
        }
        #[doc = "Clock source for LFCLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src(pub u32);
        impl Src {
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Src {
            #[inline(always)]
            fn default() -> Src {
                Src(0)
            }
        }
        impl core::fmt::Debug for Src {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Src {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Srccopy(pub u32);
        impl Srccopy {
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[must_use]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[inline(always)]
            pub const fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Srccopy {
            #[inline(always)]
            fn default() -> Srccopy {
                Srccopy(0)
            }
        }
        impl core::fmt::Debug for Srccopy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Srccopy").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Srccopy {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Srccopy {{ src: {:?} }}", self.src())
            }
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoRun(pub u32);
        impl XoRun {
            #[doc = "XOSTART task triggered or not"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "XOSTART task triggered or not"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for XoRun {
            #[inline(always)]
            fn default() -> XoRun {
                XoRun(0)
            }
        }
        impl core::fmt::Debug for XoRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoRun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "XoRun {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "XO status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoStat(pub u32);
        impl XoStat {
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for XoStat {
            #[inline(always)]
            fn default() -> XoStat {
                XoStat(0)
            }
        }
        impl core::fmt::Debug for XoStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoStat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "XoStat {{ state: {=bool:?} }}", self.state())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lfclksrc {
            #[doc = "32.768 kHz RC oscillator"]
            LFRC = 0x0,
            #[doc = "32.768 kHz crystal oscillator"]
            LFXO = 0x01,
            #[doc = "32.768 kHz synthesized from HFCLK"]
            LFSYNT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lfclksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lfclksrc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lfclksrc {
            #[inline(always)]
            fn from(val: u8) -> Lfclksrc {
                Lfclksrc::from_bits(val)
            }
        }
        impl From<Lfclksrc> for u8 {
            #[inline(always)]
            fn from(val: Lfclksrc) -> u8 {
                Lfclksrc::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write(&self, f: impl FnOnce(&mut T)) {
            let mut val = Default::default();
            f(&mut val);
            self.write_value(val);
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify(&self, f: impl FnOnce(&mut T)) {
            let mut val = self.read();
            f(&mut val);
            self.write_value(val);
        }
    }
}
pub mod comp {
    #[doc = "Comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Comp {
        ptr: *mut u8,
    }
    unsafe impl Send for Comp {}
    unsafe impl Sync for Comp {}
    impl Comp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that COMP has been started by the START Task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "COMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "COMP enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[inline(always)]
        pub const fn th(self) -> crate::common::Reg<regs::Th, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "Mode configuration"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Current source select on analog input"]
        #[inline(always)]
        pub const fn isource(self) -> crate::common::Reg<regs::Isource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x053cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "COMP enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable COMP"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable COMP"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Extrefsel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis"]
            #[must_use]
            #[inline(always)]
            pub const fn hyst(&self) -> super::vals::Hyst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hyst::from_bits(val as u8)
            }
            #[doc = "Comparator hysteresis"]
            #[inline(always)]
            pub const fn set_hyst(&mut self, val: super::vals::Hyst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hyst {{ hyst: {:?} }}", self.hyst())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[must_use]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[must_use]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[must_use]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ ready: {=bool:?}, down: {=bool:?}, up: {=bool:?}, cross: {=bool:?} }}",
                    self.ready(),
                    self.down(),
                    self.up(),
                    self.cross()
                )
            }
        }
        #[doc = "Current source select on analog input"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Isource(pub u32);
        impl Isource {
            #[doc = "Current source select on analog input"]
            #[must_use]
            #[inline(always)]
            pub const fn isource(&self) -> super::vals::Isource {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Isource::from_bits(val as u8)
            }
            #[doc = "Current source select on analog input"]
            #[inline(always)]
            pub const fn set_isource(&mut self, val: super::vals::Isource) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Isource {
            #[inline(always)]
            fn default() -> Isource {
                Isource(0)
            }
        }
        impl core::fmt::Debug for Isource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Isource")
                    .field("isource", &self.isource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Isource {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Isource {{ isource: {:?} }}", self.isource())
            }
        }
        #[doc = "Mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Speed and power modes"]
            #[must_use]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Speed and power modes"]
            #[inline(always)]
            pub const fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Main operation modes"]
            #[must_use]
            #[inline(always)]
            pub const fn main(&self) -> super::vals::Main {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Main::from_bits(val as u8)
            }
            #[doc = "Main operation modes"]
            #[inline(always)]
            pub const fn set_main(&mut self, val: super::vals::Main) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("sp", &self.sp())
                    .field("main", &self.main())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ sp: {:?}, main: {:?} }}", self.sp(), self.main())
            }
        }
        #[doc = "Pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refsel {{ refsel: {:?} }}", self.refsel())
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[must_use]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Result {{ result: {:?} }}", self.result())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_sample: {=bool:?}, ready_stop: {=bool:?}, down_stop: {=bool:?}, up_stop: {=bool:?}, cross_stop: {=bool:?} }}" , self . ready_sample () , self . ready_stop () , self . down_stop () , self . up_stop () , self . cross_stop ())
            }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Th(pub u32);
        impl Th {
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[must_use]
            #[inline(always)]
            pub const fn thdown(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[inline(always)]
            pub const fn set_thdown(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[must_use]
            #[inline(always)]
            pub const fn thup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[inline(always)]
            pub const fn set_thup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for Th {
            #[inline(always)]
            fn default() -> Th {
                Th(0)
            }
        }
        impl core::fmt::Debug for Th {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Th")
                    .field("thdown", &self.thdown())
                    .field("thup", &self.thup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Th {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Th {{ thdown: {=u8:?}, thup: {=u8:?} }}",
                    self.thdown(),
                    self.thup()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hyst {
            #[doc = "Comparator hysteresis disabled"]
            NO_HYST = 0x0,
            #[doc = "Comparator hysteresis enabled"]
            HYST40M_V = 0x01,
        }
        impl Hyst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hyst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hyst {
            #[inline(always)]
            fn from(val: u8) -> Hyst {
                Hyst::from_bits(val)
            }
        }
        impl From<Hyst> for u8 {
            #[inline(always)]
            fn from(val: Hyst) -> u8 {
                Hyst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isource {
            #[doc = "Current source disabled"]
            OFF = 0x0,
            #[doc = "Current source enabled (+/- 2.5 uA)"]
            IEN2U_A5 = 0x01,
            #[doc = "Current source enabled (+/- 5 uA)"]
            IEN5U_A = 0x02,
            #[doc = "Current source enabled (+/- 10 uA)"]
            IEN10U_A = 0x03,
        }
        impl Isource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isource {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isource {
            #[inline(always)]
            fn from(val: u8) -> Isource {
                Isource::from_bits(val)
            }
        }
        impl From<Isource> for u8 {
            #[inline(always)]
            fn from(val: Isource) -> u8 {
                Isource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Main {
            #[doc = "Single-ended mode"]
            SE = 0x0,
            #[doc = "Differential mode"]
            DIFF = 0x01,
        }
        impl Main {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Main {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Main {
            #[inline(always)]
            fn from(val: u8) -> Main {
                Main::from_bits(val)
            }
        }
        impl From<Main> for u8 {
            #[inline(always)]
            fn from(val: Main) -> u8 {
                Main::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VREF = internal 1.2 V reference"]
            INT1V2 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "VREF = VDD"]
            VDD = 0x04,
            #[doc = "VREF = AREF"]
            AREF = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            #[doc = "Low-power mode"]
            LOW = 0x0,
            #[doc = "Normal mode"]
            NORMAL = 0x01,
            #[doc = "High-speed mode"]
            HIGH = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
    }
}
pub mod cpuc {
    #[doc = "CPU control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cpuc {
        ptr: *mut u8,
    }
    unsafe impl Send for Cpuc {}
    unsafe impl Sync for Cpuc {}
    impl Cpuc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "An invalid operation exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuioc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "A floating-point divide-by-zero exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpudzc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "A floating-point overflow exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuofc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "A floating-point underflow exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuufc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "A floating-point inexact exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuixc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "A floating-point input denormal exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuidc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Register to lock the certain parts of the CPU from being modified."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "The identifier for the CPU in this subsystem."]
        #[inline(always)]
        pub const fn cpuid(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event FPUIOC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpuioc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIOC"]
            #[inline(always)]
            pub const fn set_fpuioc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FPUDZC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpudzc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUDZC"]
            #[inline(always)]
            pub const fn set_fpudzc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event FPUOFC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpuofc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUOFC"]
            #[inline(always)]
            pub const fn set_fpuofc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event FPUUFC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpuufc(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUUFC"]
            #[inline(always)]
            pub const fn set_fpuufc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event FPUIXC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpuixc(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIXC"]
            #[inline(always)]
            pub const fn set_fpuixc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event FPUIDC"]
            #[must_use]
            #[inline(always)]
            pub const fn fpuidc(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIDC"]
            #[inline(always)]
            pub const fn set_fpuidc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("fpuioc", &self.fpuioc())
                    .field("fpudzc", &self.fpudzc())
                    .field("fpuofc", &self.fpuofc())
                    .field("fpuufc", &self.fpuufc())
                    .field("fpuixc", &self.fpuixc())
                    .field("fpuidc", &self.fpuidc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ fpuioc: {=bool:?}, fpudzc: {=bool:?}, fpuofc: {=bool:?}, fpuufc: {=bool:?}, fpuixc: {=bool:?}, fpuidc: {=bool:?} }}" , self . fpuioc () , self . fpudzc () , self . fpuofc () , self . fpuufc () , self . fpuixc () , self . fpuidc ())
            }
        }
        #[doc = "Register to lock the certain parts of the CPU from being modified."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Locks both the Vector table Offset Register (VTOR) and Application Interrupt and Reset Control Register (AIRCR) for secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn lockvtoraircrs(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Locks both the Vector table Offset Register (VTOR) and Application Interrupt and Reset Control Register (AIRCR) for secure mode."]
            #[inline(always)]
            pub const fn set_lockvtoraircrs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Locks the Vector table Offset Register (VTOR) for non-secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn lockvtorns(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Vector table Offset Register (VTOR) for non-secure mode."]
            #[inline(always)]
            pub const fn set_lockvtorns(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn lockmpus(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for secure mode."]
            #[inline(always)]
            pub const fn set_lockmpus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for non secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn lockmpuns(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for non secure mode."]
            #[inline(always)]
            pub const fn set_lockmpuns(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Locks the Security Attribution Unit (SAU)"]
            #[must_use]
            #[inline(always)]
            pub const fn locksau(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Security Attribution Unit (SAU)"]
            #[inline(always)]
            pub const fn set_locksau(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock")
                    .field("lockvtoraircrs", &self.lockvtoraircrs())
                    .field("lockvtorns", &self.lockvtorns())
                    .field("lockmpus", &self.lockmpus())
                    .field("lockmpuns", &self.lockmpuns())
                    .field("locksau", &self.locksau())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Lock {{ lockvtoraircrs: {=bool:?}, lockvtorns: {=bool:?}, lockmpus: {=bool:?}, lockmpuns: {=bool:?}, locksau: {=bool:?} }}" , self . lockvtoraircrs () , self . lockvtorns () , self . lockmpus () , self . lockmpuns () , self . locksau ())
            }
        }
    }
}
pub mod cracen {
    #[doc = "CRACEN"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracen {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracen {}
    unsafe impl Sync for Cracen {}
    impl Cracen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event indicating that interrupt triggered at Cryptomaster"]
        #[inline(always)]
        pub const fn events_cryptomaster(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at RNG"]
        #[inline(always)]
        pub const fn events_rng(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at PKE or IKG"]
        #[inline(always)]
        pub const fn events_pkeikg(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Enable CRACEN peripheral modules."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Marks the SEED register as valid"]
        #[inline(always)]
        pub const fn seedvalid(self) -> crate::common::Reg<regs::Seedvalid, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Description collection: Seed word \\[n\\] for symmetric and asymmetric key generation. This register is only writable from KMU."]
        #[inline(always)]
        pub const fn seed(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize + n * 4usize) as _) }
        }
        #[doc = "Lock the access to the SEED register."]
        #[inline(always)]
        pub const fn seedlock(self) -> crate::common::Reg<regs::Seedlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[inline(always)]
        pub const fn protectedramlock(
            self,
        ) -> crate::common::Reg<regs::Protectedramlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0444usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable CRACEN peripheral modules."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable cryptomaster"]
            #[must_use]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable cryptomaster"]
            #[inline(always)]
            pub const fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable RNG"]
            #[must_use]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RNG"]
            #[inline(always)]
            pub const fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable PKE and IKG"]
            #[must_use]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable PKE and IKG"]
            #[inline(always)]
            pub const fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Enable {{ cryptomaster: {=bool:?}, rng: {=bool:?}, pkeikg: {=bool:?} }}",
                    self.cryptomaster(),
                    self.rng(),
                    self.pkeikg()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[must_use]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[inline(always)]
            pub const fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[must_use]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[inline(always)]
            pub const fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[must_use]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[inline(always)]
            pub const fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ cryptomaster: {=bool:?}, rng: {=bool:?}, pkeikg: {=bool:?} }}",
                    self.cryptomaster(),
                    self.rng(),
                    self.pkeikg()
                )
            }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Protectedramlock(pub u32);
        impl Protectedramlock {
            #[doc = "Enable the lock"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Protectedramlock {
            #[inline(always)]
            fn default() -> Protectedramlock {
                Protectedramlock(0)
            }
        }
        impl core::fmt::Debug for Protectedramlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Protectedramlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Protectedramlock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Protectedramlock {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Lock the access to the SEED register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedlock(pub u32);
        impl Seedlock {
            #[doc = "Enable the lock"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedlock {
            #[inline(always)]
            fn default() -> Seedlock {
                Seedlock(0)
            }
        }
        impl core::fmt::Debug for Seedlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedlock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Seedlock {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Marks the SEED register as valid"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedvalid(pub u32);
        impl Seedvalid {
            #[doc = "Marks the SEED as valid"]
            #[must_use]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Marks the SEED as valid"]
            #[inline(always)]
            pub const fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedvalid {
            #[inline(always)]
            fn default() -> Seedvalid {
                Seedvalid(0)
            }
        }
        impl core::fmt::Debug for Seedvalid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedvalid")
                    .field("valid", &self.valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedvalid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Seedvalid {{ valid: {=bool:?} }}", self.valid())
            }
        }
    }
}
pub mod cracencore {
    #[doc = "CRACENCORE"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracencore {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracencore {}
    unsafe impl Sync for Cracencore {}
    impl Cracencore {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrdma(self) -> Cryptmstrdma {
            unsafe { Cryptmstrdma::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrhw(self) -> Cryptmstrhw {
            unsafe { Cryptmstrhw::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rngcontrol(self) -> Rngcontrol {
            unsafe { Rngcontrol::from_ptr(self.ptr.add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pk(self) -> Pk {
            unsafe { Pk::from_ptr(self.ptr.add(0x2000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ikg(self) -> Ikg {
            unsafe { Ikg::from_ptr(self.ptr.add(0x3000usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrdma {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrdma {}
    unsafe impl Sync for Cryptmstrdma {}
    impl Cryptmstrdma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Fetch Address Least Significant Bit"]
        #[inline(always)]
        pub const fn fetchaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Fetch Address Most Significant Bit"]
        #[inline(always)]
        pub const fn fetchaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Fetch Length"]
        #[inline(always)]
        pub const fn fetchlen(self) -> crate::common::Reg<regs::Fetchlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Fetch Tag"]
        #[inline(always)]
        pub const fn fetchtag(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Push Address Least Significant Bit"]
        #[inline(always)]
        pub const fn pushaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Push Address Most Significant Bit"]
        #[inline(always)]
        pub const fn pushaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Push Length"]
        #[inline(always)]
        pub const fn pushlen(self) -> crate::common::Reg<regs::Pushlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Interrupt Enable"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Interrupt Set"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Interrupt Clear"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Interrupt Status Raw"]
        #[inline(always)]
        pub const fn intstatraw(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Interrupt Status"]
        #[inline(always)]
        pub const fn intstat(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Interrupt Status Clear"]
        #[inline(always)]
        pub const fn intstatclr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Start"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::CryptmstrdmaStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::CryptmstrdmaStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrhw {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrhw {}
    unsafe impl Sync for Cryptmstrhw {}
    impl Cryptmstrhw {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[inline(always)]
        pub const fn inclipshwcfg(
            self,
        ) -> crate::common::Reg<regs::Inclipshwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg1(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Generic g_CtrSize value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg2(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Generic g_Hash value"]
        #[inline(always)]
        pub const fn ba413hashhwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba413hashhwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[inline(always)]
        pub const fn ba418sha3hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba418sha3hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[inline(always)]
        pub const fn ba419sm4hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba419sm4hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[inline(always)]
        pub const fn ba424ariahwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba424ariahwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ikg {
        ptr: *mut u8,
    }
    unsafe impl Send for Ikg {}
    unsafe impl Sync for Ikg {}
    impl Ikg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start register."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::IkgStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IkgStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "InitData register."]
        #[inline(always)]
        pub const fn initdata(self) -> crate::common::Reg<regs::Initdata, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Nonce register."]
        #[inline(always)]
        pub const fn nonce(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Personalisation String register."]
        #[inline(always)]
        pub const fn personalisationstring(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Reseed Interval LSB register."]
        #[inline(always)]
        pub const fn reseedintervallsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Reseed Interval MSB register."]
        #[inline(always)]
        pub const fn reseedintervalmsb(
            self,
        ) -> crate::common::Reg<regs::Reseedintervalmsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "PKE Control register."]
        #[inline(always)]
        pub const fn pkecontrol(self) -> crate::common::Reg<regs::Pkecontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "PKE Command register."]
        #[inline(always)]
        pub const fn pkecommand(self) -> crate::common::Reg<regs::Pkecommand, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "PKE Status register."]
        #[inline(always)]
        pub const fn pkestatus(self) -> crate::common::Reg<regs::Pkestatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "SoftRst register."]
        #[inline(always)]
        pub const fn softrst(self) -> crate::common::Reg<regs::Softrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "HwConfig register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::IkgHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pk {
        ptr: *mut u8,
    }
    unsafe impl Send for Pk {}
    unsafe impl Sync for Pk {}
    impl Pk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pointers register."]
        #[inline(always)]
        pub const fn pointers(self) -> crate::common::Reg<regs::Pointers, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn command(self) -> crate::common::Reg<regs::Command, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::PkControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::PkStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer register."]
        #[inline(always)]
        pub const fn timer(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::PkHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Operand size register."]
        #[inline(always)]
        pub const fn opsize(self) -> crate::common::Reg<regs::Opsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "RAM error injection register."]
        #[inline(always)]
        pub const fn ramerrorinject(
            self,
        ) -> crate::common::Reg<regs::Ramerrorinject, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "RAM error status register."]
        #[inline(always)]
        pub const fn ramerrorstatus(
            self,
        ) -> crate::common::Reg<regs::Ramerrorstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rngcontrol {
        ptr: *mut u8,
    }
    unsafe impl Send for Rngcontrol {}
    unsafe impl Sync for Rngcontrol {}
    impl Rngcontrol {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register"]
        #[inline(always)]
        pub const fn control(
            self,
        ) -> crate::common::Reg<regs::RngcontrolControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "FIFO level register."]
        #[inline(always)]
        pub const fn fifolevel(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "FIFO threshold register."]
        #[inline(always)]
        pub const fn fifothreshold(
            self,
        ) -> crate::common::Reg<regs::Fifothreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "FIFO depth register."]
        #[inline(always)]
        pub const fn fifodepth(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Key register."]
        #[inline(always)]
        pub const fn key(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Test data register."]
        #[inline(always)]
        pub const fn testdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Repetition Test Count Cut-Off value."]
        #[inline(always)]
        pub const fn repeatthreshold(
            self,
        ) -> crate::common::Reg<regs::Repeatthreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
        #[inline(always)]
        pub const fn propthreshold(
            self,
        ) -> crate::common::Reg<regs::Propthreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::RngcontrolStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Initial wait counter value."]
        #[inline(always)]
        pub const fn initwaitval(self) -> crate::common::Reg<regs::Initwaitval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Description collection: Disable oscillator rings #n*32 to #((n+1)*32)-1."]
        #[inline(always)]
        pub const fn disableosc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize + n * 4usize) as _) }
        }
        #[doc = "Switch off timer value."]
        #[inline(always)]
        pub const fn swofftmrval(self) -> crate::common::Reg<regs::Swofftmrval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Sample clock divider."]
        #[inline(always)]
        pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "AIS31 configuration register 0."]
        #[inline(always)]
        pub const fn ais31conf0(self) -> crate::common::Reg<regs::Ais31conf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "AIS31 configuration register 1."]
        #[inline(always)]
        pub const fn ais31conf1(self) -> crate::common::Reg<regs::Ais31conf1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "AIS31 configuration register 2."]
        #[inline(always)]
        pub const fn ais31conf2(self) -> crate::common::Reg<regs::Ais31conf2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "AIS31 status register."]
        #[inline(always)]
        pub const fn ais31status(self) -> crate::common::Reg<regs::Ais31status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(
            self,
        ) -> crate::common::Reg<regs::RngcontrolHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Description collection: FIFO data"]
        #[inline(always)]
        pub const fn fifo(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AIS31 configuration register 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf0(pub u32);
        impl Ais31conf0 {
            #[doc = "Start-up test threshold."]
            #[must_use]
            #[inline(always)]
            pub const fn startupthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Start-up test threshold."]
            #[inline(always)]
            pub const fn set_startupthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Online threshold."]
            #[must_use]
            #[inline(always)]
            pub const fn onlinethreshold(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Online threshold."]
            #[inline(always)]
            pub const fn set_onlinethreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf0 {
            #[inline(always)]
            fn default() -> Ais31conf0 {
                Ais31conf0(0)
            }
        }
        impl core::fmt::Debug for Ais31conf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf0")
                    .field("startupthreshold", &self.startupthreshold())
                    .field("onlinethreshold", &self.onlinethreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ais31conf0 {{ startupthreshold: {=u16:?}, onlinethreshold: {=u16:?} }}",
                    self.startupthreshold(),
                    self.onlinethreshold()
                )
            }
        }
        #[doc = "AIS31 configuration register 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf1(pub u32);
        impl Ais31conf1 {
            #[doc = "Online repeat threshold."]
            #[must_use]
            #[inline(always)]
            pub const fn onlinerepthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Online repeat threshold."]
            #[inline(always)]
            pub const fn set_onlinerepthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Expected history value."]
            #[must_use]
            #[inline(always)]
            pub const fn hexpectedvalue(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Expected history value."]
            #[inline(always)]
            pub const fn set_hexpectedvalue(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf1 {
            #[inline(always)]
            fn default() -> Ais31conf1 {
                Ais31conf1(0)
            }
        }
        impl core::fmt::Debug for Ais31conf1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf1")
                    .field("onlinerepthreshold", &self.onlinerepthreshold())
                    .field("hexpectedvalue", &self.hexpectedvalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ais31conf1 {{ onlinerepthreshold: {=u16:?}, hexpectedvalue: {=u16:?} }}",
                    self.onlinerepthreshold(),
                    self.hexpectedvalue()
                )
            }
        }
        #[doc = "AIS31 configuration register 2."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf2(pub u32);
        impl Ais31conf2 {
            #[doc = "Minimum allowed history value."]
            #[must_use]
            #[inline(always)]
            pub const fn hmin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Minimum allowed history value."]
            #[inline(always)]
            pub const fn set_hmin(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Maximum allowed history value."]
            #[must_use]
            #[inline(always)]
            pub const fn hmax(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum allowed history value."]
            #[inline(always)]
            pub const fn set_hmax(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf2 {
            #[inline(always)]
            fn default() -> Ais31conf2 {
                Ais31conf2(0)
            }
        }
        impl core::fmt::Debug for Ais31conf2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf2")
                    .field("hmin", &self.hmin())
                    .field("hmax", &self.hmax())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ais31conf2 {{ hmin: {=u16:?}, hmax: {=u16:?} }}",
                    self.hmin(),
                    self.hmax()
                )
            }
        }
        #[doc = "AIS31 status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31status(pub u32);
        impl Ais31status {
            #[doc = "Number of preliminary noise alarms since counter was last cleared."]
            #[must_use]
            #[inline(always)]
            pub const fn numprelimalarms(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of preliminary noise alarms since counter was last cleared."]
            #[inline(always)]
            pub const fn set_numprelimalarms(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Last preliminary noise alarm occurred due to history value out of range."]
            #[must_use]
            #[inline(always)]
            pub const fn prelimnoisealarmrng(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Last preliminary noise alarm occurred due to history value out of range."]
            #[inline(always)]
            pub const fn set_prelimnoisealarmrng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Last preliminary noise alarm occurred due to consecutive high Χ**2."]
            #[must_use]
            #[inline(always)]
            pub const fn prelimnoisealarmrep(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Last preliminary noise alarm occurred due to consecutive high Χ**2."]
            #[inline(always)]
            pub const fn set_prelimnoisealarmrep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Ais31status {
            #[inline(always)]
            fn default() -> Ais31status {
                Ais31status(0)
            }
        }
        impl core::fmt::Debug for Ais31status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31status")
                    .field("numprelimalarms", &self.numprelimalarms())
                    .field("prelimnoisealarmrng", &self.prelimnoisealarmrng())
                    .field("prelimnoisealarmrep", &self.prelimnoisealarmrep())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31status {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ais31status {{ numprelimalarms: {=u16:?}, prelimnoisealarmrng: {=bool:?}, prelimnoisealarmrep: {=bool:?} }}" , self . numprelimalarms () , self . prelimnoisealarmrng () , self . prelimnoisealarmrep ())
            }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg1(pub u32);
        impl Ba411eaeshwcfg1 {
            #[doc = "Generic g_AesModesPoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmode(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_AesModesPoss value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgmode(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Generic g_CS value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgcs(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_CS value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgcs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_UseMasking value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_UseMasking value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgmasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_Keysize value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfgkeysize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "Generic g_Keysize value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfgkeysize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Ba411eaeshwcfg1 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg1 {
                Ba411eaeshwcfg1(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg1")
                    .field("ba411eaeshwcfgmode", &self.ba411eaeshwcfgmode())
                    .field("ba411eaeshwcfgcs", &self.ba411eaeshwcfgcs())
                    .field("ba411eaeshwcfgmasking", &self.ba411eaeshwcfgmasking())
                    .field("ba411eaeshwcfgkeysize", &self.ba411eaeshwcfgkeysize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba411eaeshwcfg1 {{ ba411eaeshwcfgmode: {=u16:?}, ba411eaeshwcfgcs: {=bool:?}, ba411eaeshwcfgmasking: {=bool:?}, ba411eaeshwcfgkeysize: {=u8:?} }}" , self . ba411eaeshwcfgmode () , self . ba411eaeshwcfgcs () , self . ba411eaeshwcfgmasking () , self . ba411eaeshwcfgkeysize ())
            }
        }
        #[doc = "Generic g_CtrSize value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg2(pub u32);
        impl Ba411eaeshwcfg2 {
            #[doc = "Generic g_CtrSize value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411eaeshwcfg2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Generic g_CtrSize value."]
            #[inline(always)]
            pub const fn set_ba411eaeshwcfg2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Ba411eaeshwcfg2 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg2 {
                Ba411eaeshwcfg2(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg2")
                    .field("ba411eaeshwcfg2", &self.ba411eaeshwcfg2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba411eaeshwcfg2 {{ ba411eaeshwcfg2: {=u16:?} }}",
                    self.ba411eaeshwcfg2()
                )
            }
        }
        #[doc = "Generic g_Hash value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba413hashhwcfg(pub u32);
        impl Ba413hashhwcfg {
            #[doc = "Generic g_HashMaskFunc value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgmask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Generic g_HashMaskFunc value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgmask(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Generic g_HashPadding value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgpadding(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashPadding value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfghmac(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfghmac(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashhwcfgverifydigest(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[inline(always)]
            pub const fn set_ba413hashhwcfgverifydigest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Ba413hashhwcfg {
            #[inline(always)]
            fn default() -> Ba413hashhwcfg {
                Ba413hashhwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba413hashhwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba413hashhwcfg")
                    .field("ba413hashhwcfgmask", &self.ba413hashhwcfgmask())
                    .field("ba413hashhwcfgpadding", &self.ba413hashhwcfgpadding())
                    .field("ba413hashhwcfghmac", &self.ba413hashhwcfghmac())
                    .field(
                        "ba413hashhwcfgverifydigest",
                        &self.ba413hashhwcfgverifydigest(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba413hashhwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ba413hashhwcfg {{ ba413hashhwcfgmask: {=u8:?}, ba413hashhwcfgpadding: {=bool:?}, ba413hashhwcfghmac: {=bool:?}, ba413hashhwcfgverifydigest: {=bool:?} }}" , self . ba413hashhwcfgmask () , self . ba413hashhwcfgpadding () , self . ba413hashhwcfghmac () , self . ba413hashhwcfgverifydigest ())
            }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba418sha3hwcfg(pub u32);
        impl Ba418sha3hwcfg {
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba418sha3hwcfg(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[inline(always)]
            pub const fn set_ba418sha3hwcfg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ba418sha3hwcfg {
            #[inline(always)]
            fn default() -> Ba418sha3hwcfg {
                Ba418sha3hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba418sha3hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba418sha3hwcfg")
                    .field("ba418sha3hwcfg", &self.ba418sha3hwcfg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba418sha3hwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba418sha3hwcfg {{ ba418sha3hwcfg: {=bool:?} }}",
                    self.ba418sha3hwcfg()
                )
            }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba419sm4hwcfg(pub u32);
        impl Ba419sm4hwcfg {
            #[doc = "Generic g_SM4ModesPoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba419sm4hwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Generic g_SM4ModesPoss value."]
            #[inline(always)]
            pub const fn set_ba419sm4hwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[must_use]
            #[inline(always)]
            pub const fn usemasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[inline(always)]
            pub const fn set_usemasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Ba419sm4hwcfg {
            #[inline(always)]
            fn default() -> Ba419sm4hwcfg {
                Ba419sm4hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba419sm4hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba419sm4hwcfg")
                    .field("ba419sm4hwcfg", &self.ba419sm4hwcfg())
                    .field("usemasking", &self.usemasking())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba419sm4hwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba419sm4hwcfg {{ ba419sm4hwcfg: {=u16:?}, usemasking: {=bool:?} }}",
                    self.ba419sm4hwcfg(),
                    self.usemasking()
                )
            }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba424ariahwcfg(pub u32);
        impl Ba424ariahwcfg {
            #[doc = "Generic g_aria_modePoss value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba424ariahwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_aria_modePoss value."]
            #[inline(always)]
            pub const fn set_ba424ariahwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ba424ariahwcfg {
            #[inline(always)]
            fn default() -> Ba424ariahwcfg {
                Ba424ariahwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba424ariahwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba424ariahwcfg")
                    .field("ba424ariahwcfg", &self.ba424ariahwcfg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba424ariahwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ba424ariahwcfg {{ ba424ariahwcfg: {=u16:?} }}",
                    self.ba424ariahwcfg()
                )
            }
        }
        #[doc = "Sample clock divider."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkdiv(pub u32);
        impl Clkdiv {
            #[doc = "Sample clock divider."]
            #[must_use]
            #[inline(always)]
            pub const fn clkdiv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sample clock divider."]
            #[inline(always)]
            pub const fn set_clkdiv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Clkdiv {
            #[inline(always)]
            fn default() -> Clkdiv {
                Clkdiv(0)
            }
        }
        impl core::fmt::Debug for Clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkdiv")
                    .field("clkdiv", &self.clkdiv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkdiv {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Clkdiv {{ clkdiv: {=u8:?} }}", self.clkdiv())
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Command(pub u32);
        impl Command {
            #[doc = "This field defines the operation to be performed."]
            #[must_use]
            #[inline(always)]
            pub const fn opeaddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "This field defines the operation to be performed."]
            #[inline(always)]
            pub const fn set_opeaddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldf(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[inline(always)]
            pub const fn set_fieldf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[must_use]
            #[inline(always)]
            pub const fn opbytesm1(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x03ff;
                val as u16
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[inline(always)]
            pub const fn set_opbytesm1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 8usize)) | (((val as u32) & 0x03ff) << 8usize);
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randmod(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[inline(always)]
            pub const fn set_randmod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[must_use]
            #[inline(always)]
            pub const fn selcurve(&self) -> super::vals::Selcurve {
                let val = (self.0 >> 20usize) & 0x07;
                super::vals::Selcurve::from_bits(val as u8)
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[inline(always)]
            pub const fn set_selcurve(&mut self, val: super::vals::Selcurve) {
                self.0 =
                    (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randke(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[inline(always)]
            pub const fn set_randke(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[must_use]
            #[inline(always)]
            pub const fn randproj(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[inline(always)]
            pub const fn set_randproj(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable Edwards curve."]
            #[must_use]
            #[inline(always)]
            pub const fn edwards(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Edwards curve."]
            #[inline(always)]
            pub const fn set_edwards(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[must_use]
            #[inline(always)]
            pub const fn swapbytes(&self) -> super::vals::Swapbytes {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Swapbytes::from_bits(val as u8)
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[inline(always)]
            pub const fn set_swapbytes(&mut self, val: super::vals::Swapbytes) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Flag A."]
            #[must_use]
            #[inline(always)]
            pub const fn flaga(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Flag A."]
            #[inline(always)]
            pub const fn set_flaga(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Flag B."]
            #[must_use]
            #[inline(always)]
            pub const fn flagb(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Flag B."]
            #[inline(always)]
            pub const fn set_flagb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[must_use]
            #[inline(always)]
            pub const fn calcr2(&self) -> super::vals::Calcr2 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Calcr2::from_bits(val as u8)
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[inline(always)]
            pub const fn set_calcr2(&mut self, val: super::vals::Calcr2) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Command {
            #[inline(always)]
            fn default() -> Command {
                Command(0)
            }
        }
        impl core::fmt::Debug for Command {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Command")
                    .field("opeaddr", &self.opeaddr())
                    .field("fieldf", &self.fieldf())
                    .field("opbytesm1", &self.opbytesm1())
                    .field("randmod", &self.randmod())
                    .field("selcurve", &self.selcurve())
                    .field("randke", &self.randke())
                    .field("randproj", &self.randproj())
                    .field("edwards", &self.edwards())
                    .field("swapbytes", &self.swapbytes())
                    .field("flaga", &self.flaga())
                    .field("flagb", &self.flagb())
                    .field("calcr2", &self.calcr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Command {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Command {{ opeaddr: {=u8:?}, fieldf: {=bool:?}, opbytesm1: {=u16:?}, randmod: {=bool:?}, selcurve: {:?}, randke: {=bool:?}, randproj: {=bool:?}, edwards: {=bool:?}, swapbytes: {:?}, flaga: {=bool:?}, flagb: {=bool:?}, calcr2: {:?} }}" , self . opeaddr () , self . fieldf () , self . opbytesm1 () , self . randmod () , self . selcurve () , self . randke () , self . randproj () , self . edwards () , self . swapbytes () , self . flaga () , self . flagb () , self . calcr2 ())
            }
        }
        #[doc = "Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[must_use]
            #[inline(always)]
            pub const fn fetchctrlindirect(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushctrlindirect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchstop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushstop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("fetchctrlindirect", &self.fetchctrlindirect())
                    .field("pushctrlindirect", &self.pushctrlindirect())
                    .field("fetchstop", &self.fetchstop())
                    .field("pushstop", &self.pushstop())
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ fetchctrlindirect: {=bool:?}, pushctrlindirect: {=bool:?}, fetchstop: {=bool:?}, pushstop: {=bool:?}, softrst: {=bool:?} }}" , self . fetchctrlindirect () , self . pushctrlindirect () , self . fetchstop () , self . pushstop () , self . softrst ())
            }
        }
        #[doc = "Start"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStart(pub u32);
        impl CryptmstrdmaStart {
            #[must_use]
            #[inline(always)]
            pub const fn startfetch(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_startfetch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn startpush(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_startpush(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CryptmstrdmaStart {
            #[inline(always)]
            fn default() -> CryptmstrdmaStart {
                CryptmstrdmaStart(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStart")
                    .field("startfetch", &self.startfetch())
                    .field("startpush", &self.startpush())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CryptmstrdmaStart {{ startfetch: {=bool:?}, startpush: {=bool:?} }}",
                    self.startfetch(),
                    self.startpush()
                )
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStatus(pub u32);
        impl CryptmstrdmaStatus {
            #[must_use]
            #[inline(always)]
            pub const fn fetchbusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushbusy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchnotempty(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchnotempty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushwaitingfifo(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushwaitingfifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn softrstbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_softrstbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushnbdata(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_pushnbdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CryptmstrdmaStatus {
            #[inline(always)]
            fn default() -> CryptmstrdmaStatus {
                CryptmstrdmaStatus(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStatus")
                    .field("fetchbusy", &self.fetchbusy())
                    .field("pushbusy", &self.pushbusy())
                    .field("fetchnotempty", &self.fetchnotempty())
                    .field("pushwaitingfifo", &self.pushwaitingfifo())
                    .field("softrstbusy", &self.softrstbusy())
                    .field("pushnbdata", &self.pushnbdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CryptmstrdmaStatus {{ fetchbusy: {=bool:?}, pushbusy: {=bool:?}, fetchnotempty: {=bool:?}, pushwaitingfifo: {=bool:?}, softrstbusy: {=bool:?}, pushnbdata: {=u16:?} }}" , self . fetchbusy () , self . pushbusy () , self . fetchnotempty () , self . pushwaitingfifo () , self . softrstbusy () , self . pushnbdata ())
            }
        }
        #[doc = "Fetch Length"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fetchlen(pub u32);
        impl Fetchlen {
            #[must_use]
            #[inline(always)]
            pub const fn fetchlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[inline(always)]
            pub const fn set_fetchlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn fetchzpadding(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_fetchzpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Fetchlen {
            #[inline(always)]
            fn default() -> Fetchlen {
                Fetchlen(0)
            }
        }
        impl core::fmt::Debug for Fetchlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fetchlen")
                    .field("fetchlen", &self.fetchlen())
                    .field("fetchcstaddr", &self.fetchcstaddr())
                    .field("fetchrealign", &self.fetchrealign())
                    .field("fetchzpadding", &self.fetchzpadding())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fetchlen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Fetchlen {{ fetchlen: {=u32:?}, fetchcstaddr: {=bool:?}, fetchrealign: {=bool:?}, fetchzpadding: {=bool:?} }}" , self . fetchlen () , self . fetchcstaddr () , self . fetchrealign () , self . fetchzpadding ())
            }
        }
        #[doc = "FIFO threshold register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fifothreshold(pub u32);
        impl Fifothreshold {
            #[doc = "FIFO level below which the module leaves the idle state to refill the FIFO, expressed in number of 128bit blocks."]
            #[must_use]
            #[inline(always)]
            pub const fn fifothreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "FIFO level below which the module leaves the idle state to refill the FIFO, expressed in number of 128bit blocks."]
            #[inline(always)]
            pub const fn set_fifothreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Fifothreshold {
            #[inline(always)]
            fn default() -> Fifothreshold {
                Fifothreshold(0)
            }
        }
        impl core::fmt::Debug for Fifothreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fifothreshold")
                    .field("fifothreshold", &self.fifothreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fifothreshold {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fifothreshold {{ fifothreshold: {=u8:?} }}",
                    self.fifothreshold()
                )
            }
        }
        #[doc = "HwConfig register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgHwconfig(pub u32);
        impl IkgHwconfig {
            #[doc = "Number of Symmetric Keys generated."]
            #[must_use]
            #[inline(always)]
            pub const fn nbsymkeys(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Symmetric Keys generated."]
            #[inline(always)]
            pub const fn set_nbsymkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Number of Private Keys generated."]
            #[must_use]
            #[inline(always)]
            pub const fn nbprivkeys(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Private Keys generated."]
            #[inline(always)]
            pub const fn set_nbprivkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn ikgcm(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[inline(always)]
            pub const fn set_ikgcm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn hwhealthtest(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[inline(always)]
            pub const fn set_hwhealthtest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "ECC curve for IKG (input)."]
            #[must_use]
            #[inline(always)]
            pub const fn curve(&self) -> super::vals::Curve {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Curve::from_bits(val as u8)
            }
            #[doc = "ECC curve for IKG (input)."]
            #[inline(always)]
            pub const fn set_curve(&mut self, val: super::vals::Curve) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[must_use]
            #[inline(always)]
            pub const fn df(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[inline(always)]
            pub const fn set_df(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[must_use]
            #[inline(always)]
            pub const fn keysize(&self) -> super::vals::Keysize {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Keysize::from_bits(val as u8)
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[inline(always)]
            pub const fn set_keysize(&mut self, val: super::vals::Keysize) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn entropyinputlength(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[inline(always)]
            pub const fn set_entropyinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Value of g_nonce_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn noncelength(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_nonce_length/32."]
            #[inline(always)]
            pub const fn set_noncelength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn personalizationstringlength(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[inline(always)]
            pub const fn set_personalizationstringlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[must_use]
            #[inline(always)]
            pub const fn additionalinputlength(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[inline(always)]
            pub const fn set_additionalinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for IkgHwconfig {
            #[inline(always)]
            fn default() -> IkgHwconfig {
                IkgHwconfig(0)
            }
        }
        impl core::fmt::Debug for IkgHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgHwconfig")
                    .field("nbsymkeys", &self.nbsymkeys())
                    .field("nbprivkeys", &self.nbprivkeys())
                    .field("ikgcm", &self.ikgcm())
                    .field("hwhealthtest", &self.hwhealthtest())
                    .field("curve", &self.curve())
                    .field("df", &self.df())
                    .field("keysize", &self.keysize())
                    .field("entropyinputlength", &self.entropyinputlength())
                    .field("noncelength", &self.noncelength())
                    .field(
                        "personalizationstringlength",
                        &self.personalizationstringlength(),
                    )
                    .field("additionalinputlength", &self.additionalinputlength())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IkgHwconfig {{ nbsymkeys: {=u8:?}, nbprivkeys: {=u8:?}, ikgcm: {=bool:?}, hwhealthtest: {=bool:?}, curve: {:?}, df: {=bool:?}, keysize: {:?}, entropyinputlength: {=u8:?}, noncelength: {=u8:?}, personalizationstringlength: {=u8:?}, additionalinputlength: {=u8:?} }}" , self . nbsymkeys () , self . nbprivkeys () , self . ikgcm () , self . hwhealthtest () , self . curve () , self . df () , self . keysize () , self . entropyinputlength () , self . noncelength () , self . personalizationstringlength () , self . additionalinputlength ())
            }
        }
        #[doc = "Start register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStart(pub u32);
        impl IkgStart {
            #[doc = "Start the Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IkgStart {
            #[inline(always)]
            fn default() -> IkgStart {
                IkgStart(0)
            }
        }
        impl core::fmt::Debug for IkgStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStart")
                    .field("start", &self.start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStart {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IkgStart {{ start: {=bool:?} }}", self.start())
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStatus(pub u32);
        impl IkgStatus {
            #[doc = "Seed Error during Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn seederror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Seed Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_seederror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[must_use]
            #[inline(always)]
            pub const fn entropyerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn set_entropyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Isolated Key Generation is okay."]
            #[must_use]
            #[inline(always)]
            pub const fn okay(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Isolated Key Generation is okay."]
            #[inline(always)]
            pub const fn set_okay(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[must_use]
            #[inline(always)]
            pub const fn ctrdrbgbusy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn set_ctrdrbgbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[must_use]
            #[inline(always)]
            pub const fn catastrophicerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn set_catastrophicerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Symmetric Keys are stored."]
            #[must_use]
            #[inline(always)]
            pub const fn symkeystored(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Symmetric Keys are stored."]
            #[inline(always)]
            pub const fn set_symkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Private Keys are stored."]
            #[must_use]
            #[inline(always)]
            pub const fn privkeystored(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Private Keys are stored."]
            #[inline(always)]
            pub const fn set_privkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for IkgStatus {
            #[inline(always)]
            fn default() -> IkgStatus {
                IkgStatus(0)
            }
        }
        impl core::fmt::Debug for IkgStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStatus")
                    .field("seederror", &self.seederror())
                    .field("entropyerror", &self.entropyerror())
                    .field("okay", &self.okay())
                    .field("ctrdrbgbusy", &self.ctrdrbgbusy())
                    .field("catastrophicerror", &self.catastrophicerror())
                    .field("symkeystored", &self.symkeystored())
                    .field("privkeystored", &self.privkeystored())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IkgStatus {{ seederror: {=bool:?}, entropyerror: {=bool:?}, okay: {=bool:?}, ctrdrbgbusy: {=bool:?}, catastrophicerror: {=bool:?}, symkeystored: {=bool:?}, privkeystored: {=bool:?} }}" , self . seederror () , self . entropyerror () , self . okay () , self . ctrdrbgbusy () , self . catastrophicerror () , self . symkeystored () , self . privkeystored ())
            }
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inclipshwcfg(pub u32);
        impl Inclipshwcfg {
            #[doc = "Generic g_IncludeAES value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba411aesincluded(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAES value."]
            #[inline(always)]
            pub const fn set_ba411aesincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba415hpaesgcmincluded(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[inline(always)]
            pub const fn set_ba415hpaesgcmincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba416hpaesxtsincluded(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[inline(always)]
            pub const fn set_ba416hpaesxtsincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Generic g_IncludeDES value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba412desincluded(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeDES value."]
            #[inline(always)]
            pub const fn set_ba412desincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba413hashincluded(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[inline(always)]
            pub const fn set_ba413hashincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba417chachapolyincluded(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[inline(always)]
            pub const fn set_ba417chachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba418sha3included(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[inline(always)]
            pub const fn set_ba418sha3included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba421zucincluded(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[inline(always)]
            pub const fn set_ba421zucincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba419sm4included(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[inline(always)]
            pub const fn set_ba419sm4included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Generic g_IncludePKE value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba414eppkeincluded(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludePKE value."]
            #[inline(always)]
            pub const fn set_ba414eppkeincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba431ndrngincluded(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[inline(always)]
            pub const fn set_ba431ndrngincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba420hpchachapolyincluded(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[inline(always)]
            pub const fn set_ba420hpchachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba423snow3gincluded(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[inline(always)]
            pub const fn set_ba423snow3gincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[must_use]
            #[inline(always)]
            pub const fn ba422kasumiincluded(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[inline(always)]
            pub const fn set_ba422kasumiincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Inclipshwcfg {
            #[inline(always)]
            fn default() -> Inclipshwcfg {
                Inclipshwcfg(0)
            }
        }
        impl core::fmt::Debug for Inclipshwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inclipshwcfg")
                    .field("ba411aesincluded", &self.ba411aesincluded())
                    .field("ba415hpaesgcmincluded", &self.ba415hpaesgcmincluded())
                    .field("ba416hpaesxtsincluded", &self.ba416hpaesxtsincluded())
                    .field("ba412desincluded", &self.ba412desincluded())
                    .field("ba413hashincluded", &self.ba413hashincluded())
                    .field("ba417chachapolyincluded", &self.ba417chachapolyincluded())
                    .field("ba418sha3included", &self.ba418sha3included())
                    .field("ba421zucincluded", &self.ba421zucincluded())
                    .field("ba419sm4included", &self.ba419sm4included())
                    .field("ba414eppkeincluded", &self.ba414eppkeincluded())
                    .field("ba431ndrngincluded", &self.ba431ndrngincluded())
                    .field(
                        "ba420hpchachapolyincluded",
                        &self.ba420hpchachapolyincluded(),
                    )
                    .field("ba423snow3gincluded", &self.ba423snow3gincluded())
                    .field("ba422kasumiincluded", &self.ba422kasumiincluded())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inclipshwcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Inclipshwcfg {{ ba411aesincluded: {=bool:?}, ba415hpaesgcmincluded: {=bool:?}, ba416hpaesxtsincluded: {=bool:?}, ba412desincluded: {=bool:?}, ba413hashincluded: {=bool:?}, ba417chachapolyincluded: {=bool:?}, ba418sha3included: {=bool:?}, ba421zucincluded: {=bool:?}, ba419sm4included: {=bool:?}, ba414eppkeincluded: {=bool:?}, ba431ndrngincluded: {=bool:?}, ba420hpchachapolyincluded: {=bool:?}, ba423snow3gincluded: {=bool:?}, ba422kasumiincluded: {=bool:?} }}" , self . ba411aesincluded () , self . ba415hpaesgcmincluded () , self . ba416hpaesxtsincluded () , self . ba412desincluded () , self . ba413hashincluded () , self . ba417chachapolyincluded () , self . ba418sha3included () , self . ba421zucincluded () , self . ba419sm4included () , self . ba414eppkeincluded () , self . ba431ndrngincluded () , self . ba420hpchachapolyincluded () , self . ba423snow3gincluded () , self . ba422kasumiincluded ())
            }
        }
        #[doc = "InitData register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Initdata(pub u32);
        impl Initdata {
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[must_use]
            #[inline(always)]
            pub const fn initdata(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[inline(always)]
            pub const fn set_initdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Initdata {
            #[inline(always)]
            fn default() -> Initdata {
                Initdata(0)
            }
        }
        impl core::fmt::Debug for Initdata {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Initdata")
                    .field("initdata", &self.initdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Initdata {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Initdata {{ initdata: {=bool:?} }}", self.initdata())
            }
        }
        #[doc = "Initial wait counter value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Initwaitval(pub u32);
        impl Initwaitval {
            #[doc = "Number of clock cycles to wait before sampling data from the noise source."]
            #[must_use]
            #[inline(always)]
            pub const fn initwaitval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of clock cycles to wait before sampling data from the noise source."]
            #[inline(always)]
            pub const fn set_initwaitval(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Initwaitval {
            #[inline(always)]
            fn default() -> Initwaitval {
                Initwaitval(0)
            }
        }
        impl core::fmt::Debug for Initwaitval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Initwaitval")
                    .field("initwaitval", &self.initwaitval())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Initwaitval {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Initwaitval {{ initwaitval: {=u16:?} }}",
                    self.initwaitval()
                )
            }
        }
        #[doc = "Interrupt Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[must_use]
            #[inline(always)]
            pub const fn int(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[inline(always)]
            pub const fn set_int(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int").field("int", &self.int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ int: {=u8:?} }}", self.int())
            }
        }
        #[doc = "Operand size register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opsize(pub u32);
        impl Opsize {
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[must_use]
            #[inline(always)]
            pub const fn opsize(&self) -> super::vals::Opsize {
                let val = (self.0 >> 0usize) & 0x1fff;
                super::vals::Opsize::from_bits(val as u16)
            }
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[inline(always)]
            pub const fn set_opsize(&mut self, val: super::vals::Opsize) {
                self.0 =
                    (self.0 & !(0x1fff << 0usize)) | (((val.to_bits() as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Opsize {
            #[inline(always)]
            fn default() -> Opsize {
                Opsize(0)
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opsize")
                    .field("opsize", &self.opsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Opsize {{ opsize: {:?} }}", self.opsize())
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkControl(pub u32);
        impl PkControl {
            #[doc = "Writing a 1 starts the processing."]
            #[must_use]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 starts the processing."]
            #[inline(always)]
            pub const fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[must_use]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[inline(always)]
            pub const fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for PkControl {
            #[inline(always)]
            fn default() -> PkControl {
                PkControl(0)
            }
        }
        impl core::fmt::Debug for PkControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkControl")
                    .field("start", &self.start())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkControl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PkControl {{ start: {=bool:?}, clearirq: {=bool:?} }}",
                    self.start(),
                    self.clearirq()
                )
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkHwconfig(pub u32);
        impl PkHwconfig {
            #[doc = "Maximum operand size (number of bytes)."]
            #[must_use]
            #[inline(always)]
            pub const fn maxopsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Maximum operand size (number of bytes)."]
            #[inline(always)]
            pub const fn set_maxopsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Number of multipliers:"]
            #[must_use]
            #[inline(always)]
            pub const fn nbmult(&self) -> super::vals::Nbmult {
                let val = (self.0 >> 12usize) & 0x0f;
                super::vals::Nbmult::from_bits(val as u8)
            }
            #[doc = "Number of multipliers:"]
            #[inline(always)]
            pub const fn set_nbmult(&mut self, val: super::vals::Nbmult) {
                self.0 =
                    (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u32) & 0x0f) << 12usize);
            }
            #[doc = "Support prime field."]
            #[must_use]
            #[inline(always)]
            pub const fn primefield(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Support prime field."]
            #[inline(always)]
            pub const fn set_primefield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Support binary field."]
            #[must_use]
            #[inline(always)]
            pub const fn binaryfield(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Support binary field."]
            #[inline(always)]
            pub const fn set_binaryfield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Support error correction."]
            #[must_use]
            #[inline(always)]
            pub const fn ecc(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Support error correction."]
            #[inline(always)]
            pub const fn set_ecc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Support ECC P256 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p256(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P256 acceleration."]
            #[inline(always)]
            pub const fn set_p256(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Support ECC P384 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p384(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P384 acceleration."]
            #[inline(always)]
            pub const fn set_p384(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Support ECC P521 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p521(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P521 acceleration."]
            #[inline(always)]
            pub const fn set_p521(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Support ECC P192 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn p192(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P192 acceleration."]
            #[inline(always)]
            pub const fn set_p192(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[must_use]
            #[inline(always)]
            pub const fn x25519(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[inline(always)]
            pub const fn set_x25519(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Memory access"]
            #[must_use]
            #[inline(always)]
            pub const fn ahbmaster(&self) -> super::vals::Ahbmaster {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Ahbmaster::from_bits(val as u8)
            }
            #[doc = "Memory access"]
            #[inline(always)]
            pub const fn set_ahbmaster(&mut self, val: super::vals::Ahbmaster) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disablesmx(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[inline(always)]
            pub const fn set_disablesmx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disableclrmem(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[inline(always)]
            pub const fn set_disableclrmem(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[must_use]
            #[inline(always)]
            pub const fn disablecm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[inline(always)]
            pub const fn set_disablecm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for PkHwconfig {
            #[inline(always)]
            fn default() -> PkHwconfig {
                PkHwconfig(0)
            }
        }
        impl core::fmt::Debug for PkHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkHwconfig")
                    .field("maxopsize", &self.maxopsize())
                    .field("nbmult", &self.nbmult())
                    .field("primefield", &self.primefield())
                    .field("binaryfield", &self.binaryfield())
                    .field("ecc", &self.ecc())
                    .field("p256", &self.p256())
                    .field("p384", &self.p384())
                    .field("p521", &self.p521())
                    .field("p192", &self.p192())
                    .field("x25519", &self.x25519())
                    .field("ahbmaster", &self.ahbmaster())
                    .field("disablesmx", &self.disablesmx())
                    .field("disableclrmem", &self.disableclrmem())
                    .field("disablecm", &self.disablecm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PkHwconfig {{ maxopsize: {=u16:?}, nbmult: {:?}, primefield: {=bool:?}, binaryfield: {=bool:?}, ecc: {=bool:?}, p256: {=bool:?}, p384: {=bool:?}, p521: {=bool:?}, p192: {=bool:?}, x25519: {=bool:?}, ahbmaster: {:?}, disablesmx: {=bool:?}, disableclrmem: {=bool:?}, disablecm: {=bool:?} }}" , self . maxopsize () , self . nbmult () , self . primefield () , self . binaryfield () , self . ecc () , self . p256 () , self . p384 () , self . p521 () , self . p192 () , self . x25519 () , self . ahbmaster () , self . disablesmx () , self . disableclrmem () , self . disablecm ())
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkStatus(pub u32);
        impl PkStatus {
            #[doc = "These bits indicate an error condition."]
            #[must_use]
            #[inline(always)]
            pub const fn errorflags(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits indicate an error condition."]
            #[inline(always)]
            pub const fn set_errorflags(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u32) & 0x0fff) << 4usize);
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[must_use]
            #[inline(always)]
            pub const fn pkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[inline(always)]
            pub const fn set_pkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[must_use]
            #[inline(always)]
            pub const fn intrptstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[inline(always)]
            pub const fn set_intrptstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[must_use]
            #[inline(always)]
            pub const fn failptr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[inline(always)]
            pub const fn set_failptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for PkStatus {
            #[inline(always)]
            fn default() -> PkStatus {
                PkStatus(0)
            }
        }
        impl core::fmt::Debug for PkStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkStatus")
                    .field("errorflags", &self.errorflags())
                    .field("pkbusy", &self.pkbusy())
                    .field("intrptstatus", &self.intrptstatus())
                    .field("failptr", &self.failptr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PkStatus {{ errorflags: {=u16:?}, pkbusy: {=bool:?}, intrptstatus: {=bool:?}, failptr: {=u8:?} }}" , self . errorflags () , self . pkbusy () , self . intrptstatus () , self . failptr ())
            }
        }
        #[doc = "PKE Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecommand(pub u32);
        impl Pkecommand {
            #[doc = "Secure mode."]
            #[must_use]
            #[inline(always)]
            pub const fn securemode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Secure mode."]
            #[inline(always)]
            pub const fn set_securemode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[must_use]
            #[inline(always)]
            pub const fn selectedkey(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[inline(always)]
            pub const fn set_selectedkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[must_use]
            #[inline(always)]
            pub const fn opsel(&self) -> super::vals::Opsel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Opsel::from_bits(val as u8)
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[inline(always)]
            pub const fn set_opsel(&mut self, val: super::vals::Opsel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Pkecommand {
            #[inline(always)]
            fn default() -> Pkecommand {
                Pkecommand(0)
            }
        }
        impl core::fmt::Debug for Pkecommand {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecommand")
                    .field("securemode", &self.securemode())
                    .field("selectedkey", &self.selectedkey())
                    .field("opsel", &self.opsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecommand {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pkecommand {{ securemode: {=bool:?}, selectedkey: {=u8:?}, opsel: {:?} }}",
                    self.securemode(),
                    self.selectedkey(),
                    self.opsel()
                )
            }
        }
        #[doc = "PKE Control register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecontrol(pub u32);
        impl Pkecontrol {
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[must_use]
            #[inline(always)]
            pub const fn pkestart(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[inline(always)]
            pub const fn set_pkestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Clear the IRQ output."]
            #[must_use]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the IRQ output."]
            #[inline(always)]
            pub const fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Pkecontrol {
            #[inline(always)]
            fn default() -> Pkecontrol {
                Pkecontrol(0)
            }
        }
        impl core::fmt::Debug for Pkecontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecontrol")
                    .field("pkestart", &self.pkestart())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecontrol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pkecontrol {{ pkestart: {=bool:?}, clearirq: {=bool:?} }}",
                    self.pkestart(),
                    self.clearirq()
                )
            }
        }
        #[doc = "PKE Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkestatus(pub u32);
        impl Pkestatus {
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[must_use]
            #[inline(always)]
            pub const fn starterror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[inline(always)]
            pub const fn set_starterror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[must_use]
            #[inline(always)]
            pub const fn ikgpkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[inline(always)]
            pub const fn set_ikgpkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[must_use]
            #[inline(always)]
            pub const fn irqstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[inline(always)]
            pub const fn set_irqstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[must_use]
            #[inline(always)]
            pub const fn erasebusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[inline(always)]
            pub const fn set_erasebusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Pkestatus {
            #[inline(always)]
            fn default() -> Pkestatus {
                Pkestatus(0)
            }
        }
        impl core::fmt::Debug for Pkestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkestatus")
                    .field("error", &self.error())
                    .field("starterror", &self.starterror())
                    .field("ikgpkbusy", &self.ikgpkbusy())
                    .field("irqstatus", &self.irqstatus())
                    .field("erasebusy", &self.erasebusy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pkestatus {{ error: {=bool:?}, starterror: {=bool:?}, ikgpkbusy: {=bool:?}, irqstatus: {=bool:?}, erasebusy: {=bool:?} }}" , self . error () , self . starterror () , self . ikgpkbusy () , self . irqstatus () , self . erasebusy ())
            }
        }
        #[doc = "Pointers register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pointers(pub u32);
        impl Pointers {
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptra(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptra(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrb(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptrb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrc(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[inline(always)]
            pub const fn set_opptrc(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[must_use]
            #[inline(always)]
            pub const fn opptrn(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn set_opptrn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Pointers {
            #[inline(always)]
            fn default() -> Pointers {
                Pointers(0)
            }
        }
        impl core::fmt::Debug for Pointers {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pointers")
                    .field("opptra", &self.opptra())
                    .field("opptrb", &self.opptrb())
                    .field("opptrc", &self.opptrc())
                    .field("opptrn", &self.opptrn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pointers {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pointers {{ opptra: {=u8:?}, opptrb: {=u8:?}, opptrc: {=u8:?}, opptrn: {=u8:?} }}" , self . opptra () , self . opptrb () , self . opptrc () , self . opptrn ())
            }
        }
        #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Propthreshold(pub u32);
        impl Propthreshold {
            #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
            #[must_use]
            #[inline(always)]
            pub const fn propthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
            #[inline(always)]
            pub const fn set_propthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Propthreshold {
            #[inline(always)]
            fn default() -> Propthreshold {
                Propthreshold(0)
            }
        }
        impl core::fmt::Debug for Propthreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Propthreshold")
                    .field("propthreshold", &self.propthreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Propthreshold {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Propthreshold {{ propthreshold: {=u16:?} }}",
                    self.propthreshold()
                )
            }
        }
        #[doc = "Push Length"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pushlen(pub u32);
        impl Pushlen {
            #[must_use]
            #[inline(always)]
            pub const fn pushlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[inline(always)]
            pub const fn set_pushlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn pushdiscard(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_pushdiscard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Pushlen {
            #[inline(always)]
            fn default() -> Pushlen {
                Pushlen(0)
            }
        }
        impl core::fmt::Debug for Pushlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pushlen")
                    .field("pushlen", &self.pushlen())
                    .field("pushcstaddr", &self.pushcstaddr())
                    .field("pushrealign", &self.pushrealign())
                    .field("pushdiscard", &self.pushdiscard())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pushlen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pushlen {{ pushlen: {=u32:?}, pushcstaddr: {=bool:?}, pushrealign: {=bool:?}, pushdiscard: {=bool:?} }}" , self . pushlen () , self . pushcstaddr () , self . pushrealign () , self . pushdiscard ())
            }
        }
        #[doc = "RAM error injection register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ramerrorinject(pub u32);
        impl Ramerrorinject {
            #[doc = "Bit position of first error"]
            #[must_use]
            #[inline(always)]
            pub const fn biterror1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Bit position of first error"]
            #[inline(always)]
            pub const fn set_biterror1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Bit position of second error"]
            #[must_use]
            #[inline(always)]
            pub const fn biterror2(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Bit position of second error"]
            #[inline(always)]
            pub const fn set_biterror2(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Ramerrorinject {
            #[inline(always)]
            fn default() -> Ramerrorinject {
                Ramerrorinject(0)
            }
        }
        impl core::fmt::Debug for Ramerrorinject {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ramerrorinject")
                    .field("biterror1", &self.biterror1())
                    .field("biterror2", &self.biterror2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ramerrorinject {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ramerrorinject {{ biterror1: {=u16:?}, biterror2: {=u16:?} }}",
                    self.biterror1(),
                    self.biterror2()
                )
            }
        }
        #[doc = "RAM error status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ramerrorstatus(pub u32);
        impl Ramerrorstatus {
            #[doc = "This bit indicates that a 1-bit error has been detected and corrected on RAM interface"]
            #[must_use]
            #[inline(always)]
            pub const fn ramcorrection(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a 1-bit error has been detected and corrected on RAM interface"]
            #[inline(always)]
            pub const fn set_ramcorrection(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit indicates that an uncorrectable error has been detected on the data RAM interface"]
            #[must_use]
            #[inline(always)]
            pub const fn ramfailure(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an uncorrectable error has been detected on the data RAM interface"]
            #[inline(always)]
            pub const fn set_ramfailure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ramerrorstatus {
            #[inline(always)]
            fn default() -> Ramerrorstatus {
                Ramerrorstatus(0)
            }
        }
        impl core::fmt::Debug for Ramerrorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ramerrorstatus")
                    .field("ramcorrection", &self.ramcorrection())
                    .field("ramfailure", &self.ramfailure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ramerrorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ramerrorstatus {{ ramcorrection: {=bool:?}, ramfailure: {=bool:?} }}",
                    self.ramcorrection(),
                    self.ramfailure()
                )
            }
        }
        #[doc = "Repetition Test Count Cut-Off value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Repeatthreshold(pub u32);
        impl Repeatthreshold {
            #[doc = "Repetition Test Count Cut-Off value."]
            #[must_use]
            #[inline(always)]
            pub const fn repeatthreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Repetition Test Count Cut-Off value."]
            #[inline(always)]
            pub const fn set_repeatthreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Repeatthreshold {
            #[inline(always)]
            fn default() -> Repeatthreshold {
                Repeatthreshold(0)
            }
        }
        impl core::fmt::Debug for Repeatthreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Repeatthreshold")
                    .field("repeatthreshold", &self.repeatthreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Repeatthreshold {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Repeatthreshold {{ repeatthreshold: {=u8:?} }}",
                    self.repeatthreshold()
                )
            }
        }
        #[doc = "Reseed Interval MSB register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reseedintervalmsb(pub u32);
        impl Reseedintervalmsb {
            #[doc = "Reseed Interval MSB."]
            #[must_use]
            #[inline(always)]
            pub const fn reseedintervalmsb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Reseed Interval MSB."]
            #[inline(always)]
            pub const fn set_reseedintervalmsb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Reseedintervalmsb {
            #[inline(always)]
            fn default() -> Reseedintervalmsb {
                Reseedintervalmsb(0)
            }
        }
        impl core::fmt::Debug for Reseedintervalmsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reseedintervalmsb")
                    .field("reseedintervalmsb", &self.reseedintervalmsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reseedintervalmsb {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Reseedintervalmsb {{ reseedintervalmsb: {=u16:?} }}",
                    self.reseedintervalmsb()
                )
            }
        }
        #[doc = "Control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolControl(pub u32);
        impl RngcontrolControl {
            #[doc = "Enable the NDRNG."]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the NDRNG."]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[must_use]
            #[inline(always)]
            pub const fn lfsren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[inline(always)]
            pub const fn set_lfsren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[must_use]
            #[inline(always)]
            pub const fn testen(&self) -> super::vals::Testen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Testen::from_bits(val as u8)
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[inline(always)]
            pub const fn set_testen(&mut self, val: super::vals::Testen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Conditioning function bypass."]
            #[must_use]
            #[inline(always)]
            pub const fn condbypass(&self) -> super::vals::Condbypass {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Condbypass::from_bits(val as u8)
            }
            #[doc = "Conditioning function bypass."]
            #[inline(always)]
            pub const fn set_condbypass(&mut self, val: super::vals::Condbypass) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Interrupt enable for Repetition Count Test failure."]
            #[must_use]
            #[inline(always)]
            pub const fn intenrep(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for Repetition Count Test failure."]
            #[inline(always)]
            pub const fn set_intenrep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Interrupt enable for Adaptive Proportion Test failure (1024-sample window)."]
            #[must_use]
            #[inline(always)]
            pub const fn intenprop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for Adaptive Proportion Test failure (1024-sample window)."]
            #[inline(always)]
            pub const fn set_intenprop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Interrupt enable for FIFO full."]
            #[must_use]
            #[inline(always)]
            pub const fn intenfull(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for FIFO full."]
            #[inline(always)]
            pub const fn set_intenfull(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Software reset:"]
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> super::vals::ControlSoftrst {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::ControlSoftrst::from_bits(val as u8)
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: super::vals::ControlSoftrst) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Interrupt enable for AIS31 preliminary noise alarm."]
            #[must_use]
            #[inline(always)]
            pub const fn intenpre(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for AIS31 preliminary noise alarm."]
            #[inline(always)]
            pub const fn set_intenpre(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Interrupt enable for AIS31 noise alarm."]
            #[must_use]
            #[inline(always)]
            pub const fn intenalm(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for AIS31 noise alarm."]
            #[inline(always)]
            pub const fn set_intenalm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[must_use]
            #[inline(always)]
            pub const fn forceactiveros(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[inline(always)]
            pub const fn set_forceactiveros(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Bypass NIST tests such that the results of the start-up and online test do not affect the FSM state."]
            #[must_use]
            #[inline(always)]
            pub const fn healthtestbypass(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass NIST tests such that the results of the start-up and online test do not affect the FSM state."]
            #[inline(always)]
            pub const fn set_healthtestbypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Bypass AIS31 tests such that the results of the start-up and online tests do not affect the FSM state."]
            #[must_use]
            #[inline(always)]
            pub const fn ais31bypass(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass AIS31 tests such that the results of the start-up and online tests do not affect the FSM state."]
            #[inline(always)]
            pub const fn set_ais31bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Select input to health test module:"]
            #[must_use]
            #[inline(always)]
            pub const fn healthtestsel(&self) -> super::vals::Healthtestsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Healthtestsel::from_bits(val as u8)
            }
            #[doc = "Select input to health test module:"]
            #[inline(always)]
            pub const fn set_healthtestsel(&mut self, val: super::vals::Healthtestsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Select input to the AIS31 test module:"]
            #[must_use]
            #[inline(always)]
            pub const fn ais31testsel(&self) -> super::vals::Ais31testsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ais31testsel::from_bits(val as u8)
            }
            #[doc = "Select input to the AIS31 test module:"]
            #[inline(always)]
            pub const fn set_ais31testsel(&mut self, val: super::vals::Ais31testsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Number of 128 bit blocks used in AES-CBCMAC post-processing."]
            #[must_use]
            #[inline(always)]
            pub const fn nb128bitblocks(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 128 bit blocks used in AES-CBCMAC post-processing."]
            #[inline(always)]
            pub const fn set_nb128bitblocks(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[must_use]
            #[inline(always)]
            pub const fn fifowritestartup(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[inline(always)]
            pub const fn set_fifowritestartup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for RngcontrolControl {
            #[inline(always)]
            fn default() -> RngcontrolControl {
                RngcontrolControl(0)
            }
        }
        impl core::fmt::Debug for RngcontrolControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolControl")
                    .field("enable", &self.enable())
                    .field("lfsren", &self.lfsren())
                    .field("testen", &self.testen())
                    .field("condbypass", &self.condbypass())
                    .field("intenrep", &self.intenrep())
                    .field("intenprop", &self.intenprop())
                    .field("intenfull", &self.intenfull())
                    .field("softrst", &self.softrst())
                    .field("intenpre", &self.intenpre())
                    .field("intenalm", &self.intenalm())
                    .field("forceactiveros", &self.forceactiveros())
                    .field("healthtestbypass", &self.healthtestbypass())
                    .field("ais31bypass", &self.ais31bypass())
                    .field("healthtestsel", &self.healthtestsel())
                    .field("ais31testsel", &self.ais31testsel())
                    .field("nb128bitblocks", &self.nb128bitblocks())
                    .field("fifowritestartup", &self.fifowritestartup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolControl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolControl {{ enable: {=bool:?}, lfsren: {=bool:?}, testen: {:?}, condbypass: {:?}, intenrep: {=bool:?}, intenprop: {=bool:?}, intenfull: {=bool:?}, softrst: {:?}, intenpre: {=bool:?}, intenalm: {=bool:?}, forceactiveros: {=bool:?}, healthtestbypass: {=bool:?}, ais31bypass: {=bool:?}, healthtestsel: {:?}, ais31testsel: {:?}, nb128bitblocks: {=u8:?}, fifowritestartup: {=bool:?} }}" , self . enable () , self . lfsren () , self . testen () , self . condbypass () , self . intenrep () , self . intenprop () , self . intenfull () , self . softrst () , self . intenpre () , self . intenalm () , self . forceactiveros () , self . healthtestbypass () , self . ais31bypass () , self . healthtestsel () , self . ais31testsel () , self . nb128bitblocks () , self . fifowritestartup ())
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolHwconfig(pub u32);
        impl RngcontrolHwconfig {
            #[doc = "Generic g_NumRings value."]
            #[must_use]
            #[inline(always)]
            pub const fn numbofrings(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Generic g_NumRings value."]
            #[inline(always)]
            pub const fn set_numbofrings(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Generic g_AIS31 value."]
            #[must_use]
            #[inline(always)]
            pub const fn ais31(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_AIS31 value."]
            #[inline(always)]
            pub const fn set_ais31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Generic g_AIS31Full value."]
            #[must_use]
            #[inline(always)]
            pub const fn ais31full(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_AIS31Full value."]
            #[inline(always)]
            pub const fn set_ais31full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for RngcontrolHwconfig {
            #[inline(always)]
            fn default() -> RngcontrolHwconfig {
                RngcontrolHwconfig(0)
            }
        }
        impl core::fmt::Debug for RngcontrolHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolHwconfig")
                    .field("numbofrings", &self.numbofrings())
                    .field("ais31", &self.ais31())
                    .field("ais31full", &self.ais31full())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolHwconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolHwconfig {{ numbofrings: {=u8:?}, ais31: {=bool:?}, ais31full: {=bool:?} }}" , self . numbofrings () , self . ais31 () , self . ais31full ())
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolStatus(pub u32);
        impl RngcontrolStatus {
            #[doc = "High when data written to TestData register is being processed."]
            #[must_use]
            #[inline(always)]
            pub const fn testdatabusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "High when data written to TestData register is being processed."]
            #[inline(always)]
            pub const fn set_testdatabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "State of the control FSM:"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "State of the control FSM:"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "NIST-800-90B repetition Count Test interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn repfail(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "NIST-800-90B repetition Count Test interrupt status."]
            #[inline(always)]
            pub const fn set_repfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "NIST-800-90B adaptive Proportion Test (1024-sample window) interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn propfail(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "NIST-800-90B adaptive Proportion Test (1024-sample window) interrupt status."]
            #[inline(always)]
            pub const fn set_propfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "FIFO full status."]
            #[must_use]
            #[inline(always)]
            pub const fn fullint(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO full status."]
            #[inline(always)]
            pub const fn set_fullint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "AIS31 preliminary noise alarm interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn preint(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "AIS31 preliminary noise alarm interrupt status."]
            #[inline(always)]
            pub const fn set_preint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "AIS31 noise alarm interrupt status."]
            #[must_use]
            #[inline(always)]
            pub const fn almint(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "AIS31 noise alarm interrupt status."]
            #[inline(always)]
            pub const fn set_almint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Start-up test failure."]
            #[must_use]
            #[inline(always)]
            pub const fn startupfail(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Start-up test failure."]
            #[inline(always)]
            pub const fn set_startupfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Set when a FIFO data read is performed while the NDRNG is disabled AND has its FIFO empty (FIFOLevel = 0)."]
            #[must_use]
            #[inline(always)]
            pub const fn fifoaccfail(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Set when a FIFO data read is performed while the NDRNG is disabled AND has its FIFO empty (FIFOLevel = 0)."]
            #[inline(always)]
            pub const fn set_fifoaccfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for RngcontrolStatus {
            #[inline(always)]
            fn default() -> RngcontrolStatus {
                RngcontrolStatus(0)
            }
        }
        impl core::fmt::Debug for RngcontrolStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolStatus")
                    .field("testdatabusy", &self.testdatabusy())
                    .field("state", &self.state())
                    .field("repfail", &self.repfail())
                    .field("propfail", &self.propfail())
                    .field("fullint", &self.fullint())
                    .field("preint", &self.preint())
                    .field("almint", &self.almint())
                    .field("startupfail", &self.startupfail())
                    .field("fifoaccfail", &self.fifoaccfail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RngcontrolStatus {{ testdatabusy: {=bool:?}, state: {:?}, repfail: {=bool:?}, propfail: {=bool:?}, fullint: {=bool:?}, preint: {=bool:?}, almint: {=bool:?}, startupfail: {=bool:?}, fifoaccfail: {=bool:?} }}" , self . testdatabusy () , self . state () , self . repfail () , self . propfail () , self . fullint () , self . preint () , self . almint () , self . startupfail () , self . fifoaccfail ())
            }
        }
        #[doc = "SoftRst register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softrst(pub u32);
        impl Softrst {
            #[doc = "Software reset:"]
            #[must_use]
            #[inline(always)]
            pub const fn softrst(&self) -> super::vals::SoftrstSoftrst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SoftrstSoftrst::from_bits(val as u8)
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub const fn set_softrst(&mut self, val: super::vals::SoftrstSoftrst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Softrst {
            #[inline(always)]
            fn default() -> Softrst {
                Softrst(0)
            }
        }
        impl core::fmt::Debug for Softrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softrst")
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softrst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Softrst {{ softrst: {:?} }}", self.softrst())
            }
        }
        #[doc = "Switch off timer value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swofftmrval(pub u32);
        impl Swofftmrval {
            #[doc = "Number of clk cycles to wait before stopping the rings after the FIFO is full."]
            #[must_use]
            #[inline(always)]
            pub const fn swofftmrval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of clk cycles to wait before stopping the rings after the FIFO is full."]
            #[inline(always)]
            pub const fn set_swofftmrval(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Swofftmrval {
            #[inline(always)]
            fn default() -> Swofftmrval {
                Swofftmrval(0)
            }
        }
        impl core::fmt::Debug for Swofftmrval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swofftmrval")
                    .field("swofftmrval", &self.swofftmrval())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swofftmrval {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Swofftmrval {{ swofftmrval: {=u16:?} }}",
                    self.swofftmrval()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ahbmaster {
            #[doc = "Memory access through AHB Slave and internally in the PKE."]
            SLAVE = 0x0,
            #[doc = "Memory access through AHB Master, outside the PKE."]
            MASTER = 0x01,
        }
        impl Ahbmaster {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ahbmaster {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ahbmaster {
            #[inline(always)]
            fn from(val: u8) -> Ahbmaster {
                Ahbmaster::from_bits(val)
            }
        }
        impl From<Ahbmaster> for u8 {
            #[inline(always)]
            fn from(val: Ahbmaster) -> u8 {
                Ahbmaster::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ais31testsel {
            #[doc = "Before conditioning."]
            BEFORE = 0x0,
            #[doc = "After conditioning."]
            AFTER = 0x01,
        }
        impl Ais31testsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ais31testsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ais31testsel {
            #[inline(always)]
            fn from(val: u8) -> Ais31testsel {
                Ais31testsel::from_bits(val)
            }
        }
        impl From<Ais31testsel> for u8 {
            #[inline(always)]
            fn from(val: Ais31testsel) -> u8 {
                Ais31testsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Calcr2 {
            #[doc = "don't recalculate R² mod N"]
            NRECALCULATE = 0x0,
            #[doc = "re-calculate R² mod N"]
            RECALCULATE = 0x01,
        }
        impl Calcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Calcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Calcr2 {
            #[inline(always)]
            fn from(val: u8) -> Calcr2 {
                Calcr2::from_bits(val)
            }
        }
        impl From<Calcr2> for u8 {
            #[inline(always)]
            fn from(val: Calcr2) -> u8 {
                Calcr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Condbypass {
            #[doc = "the conditioning function is used (normal mode)."]
            NORMAL = 0x0,
            #[doc = "the conditioning function is bypassed (to observe entropy source directly)."]
            BYPASS = 0x01,
        }
        impl Condbypass {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Condbypass {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Condbypass {
            #[inline(always)]
            fn from(val: u8) -> Condbypass {
                Condbypass::from_bits(val)
            }
        }
        impl From<Condbypass> for u8 {
            #[inline(always)]
            fn from(val: Condbypass) -> u8 {
                Condbypass::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ControlSoftrst {
            #[doc = "Normal mode."]
            NORMAL = 0x0,
            #[doc = "The continuous test, the conditioning function and the FIFO are reset."]
            CTEST = 0x01,
        }
        impl ControlSoftrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ControlSoftrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ControlSoftrst {
            #[inline(always)]
            fn from(val: u8) -> ControlSoftrst {
                ControlSoftrst::from_bits(val)
            }
        }
        impl From<ControlSoftrst> for u8 {
            #[inline(always)]
            fn from(val: ControlSoftrst) -> u8 {
                ControlSoftrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Curve {
            #[doc = "P256."]
            P256 = 0x0,
            #[doc = "P384."]
            P384 = 0x01,
            #[doc = "P521."]
            P521 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Curve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Curve {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Curve {
            #[inline(always)]
            fn from(val: u8) -> Curve {
                Curve::from_bits(val)
            }
        }
        impl From<Curve> for u8 {
            #[inline(always)]
            fn from(val: Curve) -> u8 {
                Curve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Healthtestsel {
            #[doc = "Before conditioning."]
            BEFORE = 0x0,
            #[doc = "After conditioning."]
            AFTER = 0x01,
        }
        impl Healthtestsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Healthtestsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Healthtestsel {
            #[inline(always)]
            fn from(val: u8) -> Healthtestsel {
                Healthtestsel::from_bits(val)
            }
        }
        impl From<Healthtestsel> for u8 {
            #[inline(always)]
            fn from(val: Healthtestsel) -> u8 {
                Healthtestsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Keysize {
            _RESERVED_0 = 0x0,
            #[doc = "supports AES128"]
            AES128 = 0x01,
            #[doc = "supports AES192"]
            AES192 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "supports AES256"]
            AES256 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Keysize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Keysize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Keysize {
            #[inline(always)]
            fn from(val: u8) -> Keysize {
                Keysize::from_bits(val)
            }
        }
        impl From<Keysize> for u8 {
            #[inline(always)]
            fn from(val: Keysize) -> u8 {
                Keysize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nbmult {
            #[doc = "1 multiplier"]
            MULT1 = 0x0,
            #[doc = "4 multipliers"]
            MULT4 = 0x01,
            #[doc = "16 multipliers"]
            MULT16 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "64 multipliers"]
            MULT64 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "256 multipliers"]
            MULT256 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Nbmult {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nbmult {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nbmult {
            #[inline(always)]
            fn from(val: u8) -> Nbmult {
                Nbmult::from_bits(val)
            }
        }
        impl From<Nbmult> for u8 {
            #[inline(always)]
            fn from(val: Nbmult) -> u8 {
                Nbmult::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opsel {
            #[doc = "Public Key Generation"]
            PUBKEY = 0x0,
            #[doc = "ECDSA Signature"]
            ECDSA = 0x01,
            #[doc = "Point Multiplication"]
            PTMUL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opsel {
            #[inline(always)]
            fn from(val: u8) -> Opsel {
                Opsel::from_bits(val)
            }
        }
        impl From<Opsel> for u8 {
            #[inline(always)]
            fn from(val: Opsel) -> u8 {
                Opsel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Opsize(u16);
        impl Opsize {
            #[doc = "256 bytes."]
            pub const OPSIZE256: Self = Self(0x0100);
            #[doc = "521 bytes."]
            pub const OPSIZE521: Self = Self(0x0209);
            #[doc = "2048 bytes."]
            pub const OPSIZE2048: Self = Self(0x0800);
            #[doc = "3072 bytes."]
            pub const OPSIZE3072: Self = Self(0x0c00);
            #[doc = "4096 bytes."]
            pub const OPSIZE4096: Self = Self(0x1000);
        }
        impl Opsize {
            pub const fn from_bits(val: u16) -> Opsize {
                Self(val & 0x1fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("OPSIZE256"),
                    0x0209 => f.write_str("OPSIZE521"),
                    0x0800 => f.write_str("OPSIZE2048"),
                    0x0c00 => f.write_str("OPSIZE3072"),
                    0x1000 => f.write_str("OPSIZE4096"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "OPSIZE256"),
                    0x0209 => defmt::write!(f, "OPSIZE521"),
                    0x0800 => defmt::write!(f, "OPSIZE2048"),
                    0x0c00 => defmt::write!(f, "OPSIZE3072"),
                    0x1000 => defmt::write!(f, "OPSIZE4096"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Opsize {
            #[inline(always)]
            fn from(val: u16) -> Opsize {
                Opsize::from_bits(val)
            }
        }
        impl From<Opsize> for u16 {
            #[inline(always)]
            fn from(val: Opsize) -> u16 {
                Opsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Selcurve {
            #[doc = "Unspecified"]
            NOACCEL = 0x0,
            #[doc = "Unspecified"]
            P256 = 0x01,
            #[doc = "Unspecified"]
            P384 = 0x02,
            #[doc = "Unspecified"]
            P521 = 0x03,
            #[doc = "Unspecified"]
            P192 = 0x04,
            #[doc = "Unspecified"]
            CURVE25519 = 0x05,
            #[doc = "Unspecified"]
            ED25519 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Selcurve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Selcurve {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Selcurve {
            #[inline(always)]
            fn from(val: u8) -> Selcurve {
                Selcurve::from_bits(val)
            }
        }
        impl From<Selcurve> for u8 {
            #[inline(always)]
            fn from(val: Selcurve) -> u8 {
                Selcurve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SoftrstSoftrst {
            #[doc = "Normal mode."]
            NORMAL = 0x0,
            #[doc = "The Isolated Key Generation logic and the keys are reset."]
            KEY = 0x01,
        }
        impl SoftrstSoftrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SoftrstSoftrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SoftrstSoftrst {
            #[inline(always)]
            fn from(val: u8) -> SoftrstSoftrst {
                SoftrstSoftrst::from_bits(val)
            }
        }
        impl From<SoftrstSoftrst> for u8 {
            #[inline(always)]
            fn from(val: SoftrstSoftrst) -> u8 {
                SoftrstSoftrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "Reset"]
            RESET = 0x0,
            #[doc = "Startup"]
            STARTUP = 0x01,
            #[doc = "Idle (Rings On)"]
            IDLERON = 0x02,
            #[doc = "Idle (Rings Off)"]
            IDLEROFF = 0x03,
            #[doc = "Fill FIFO"]
            FILLFIFO = 0x04,
            #[doc = "Error"]
            ERROR = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swapbytes {
            #[doc = "Native format (little endian)."]
            NATIVE = 0x0,
            #[doc = "Byte swapped (big endian)."]
            SWAPPED = 0x01,
        }
        impl Swapbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swapbytes {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swapbytes {
            #[inline(always)]
            fn from(val: u8) -> Swapbytes {
                Swapbytes::from_bits(val)
            }
        }
        impl From<Swapbytes> for u8 {
            #[inline(always)]
            fn from(val: Swapbytes) -> u8 {
                Swapbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Testen {
            #[doc = "Noise source (normal mode)."]
            NORMAL = 0x0,
            #[doc = "Test data register (test mode)."]
            TEST = 0x01,
        }
        impl Testen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Testen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Testen {
            #[inline(always)]
            fn from(val: u8) -> Testen {
                Testen::from_bits(val)
            }
        }
        impl From<Testen> for u8 {
            #[inline(always)]
            fn from(val: Testen) -> u8 {
                Testen::to_bits(val)
            }
        }
    }
}
pub mod ctrlapperi {
    #[doc = "Control access port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctrlapperi {
        ptr: *mut u8,
    }
    unsafe impl Send for Ctrlapperi {}
    unsafe impl Sync for Ctrlapperi {}
    impl Ctrlapperi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXSTATUS is changed to DataPending."]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "TXSTATUS is changed to NoDataPending."]
        #[inline(always)]
        pub const fn events_txdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn mailbox(self) -> Mailbox {
            unsafe { Mailbox::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "System reset request."]
        #[inline(always)]
        pub const fn reset(self) -> crate::common::Reg<regs::Reset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This register disables the ERASEPROTECT register and performs an ERASEALL operation."]
        #[inline(always)]
        pub const fn disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mailbox {
        ptr: *mut u8,
    }
    unsafe impl Send for Mailbox {}
    unsafe impl Sync for Mailbox {}
    impl Mailbox {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data sent from the debugger to the CPU."]
        #[inline(always)]
        pub const fn rxdata(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[inline(always)]
        pub const fn rxstatus(self) -> crate::common::Reg<regs::Rxstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Data sent from the CPU to the debugger."]
        #[inline(always)]
        pub const fn txdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[inline(always)]
        pub const fn txstatus(self) -> crate::common::Reg<regs::Txstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn txdone(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[inline(always)]
            pub const fn set_txdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxready", &self.rxready())
                    .field("txdone", &self.txdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ rxready: {=bool:?}, txdone: {=bool:?} }}",
                    self.rxready(),
                    self.txdone()
                )
            }
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "System reset request."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reset(pub u32);
        impl Reset {
            #[doc = "Reset request"]
            #[must_use]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Reset {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Reset::from_bits(val as u8)
            }
            #[doc = "Reset request"]
            #[inline(always)]
            pub const fn set_reset(&mut self, val: super::vals::Reset) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Reset {
            #[inline(always)]
            fn default() -> Reset {
                Reset(0)
            }
        }
        impl core::fmt::Debug for Reset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Reset {{ reset: {:?} }}", self.reset())
            }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxstatus(pub u32);
        impl Rxstatus {
            #[doc = "Status of data in register RXDATA."]
            #[must_use]
            #[inline(always)]
            pub const fn rxstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register RXDATA."]
            #[inline(always)]
            pub const fn set_rxstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxstatus {
            #[inline(always)]
            fn default() -> Rxstatus {
                Rxstatus(0)
            }
        }
        impl core::fmt::Debug for Rxstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxstatus")
                    .field("rxstatus", &self.rxstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxstatus {{ rxstatus: {=bool:?} }}", self.rxstatus())
            }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txstatus(pub u32);
        impl Txstatus {
            #[doc = "Status of data in register TXDATA."]
            #[must_use]
            #[inline(always)]
            pub const fn txstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register TXDATA."]
            #[inline(always)]
            pub const fn set_txstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txstatus {
            #[inline(always)]
            fn default() -> Txstatus {
                Txstatus(0)
            }
        }
        impl core::fmt::Debug for Txstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txstatus")
                    .field("txstatus", &self.txstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txstatus {{ txstatus: {=bool:?} }}", self.txstatus())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reset {
            #[doc = "No reset is generated"]
            NO_RESET = 0x0,
            #[doc = "Perform a device soft reset"]
            SOFT_RESET = 0x01,
            #[doc = "Perform a device hard reset"]
            HARD_RESET = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Perform a device pin reset"]
            PIN_RESET = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Reset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reset {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reset {
            #[inline(always)]
            fn from(val: u8) -> Reset {
                Reset::from_bits(val)
            }
        }
        impl From<Reset> for u8 {
            #[inline(always)]
            fn from(val: Reset) -> u8 {
                Reset::to_bits(val)
            }
        }
    }
}
pub mod dppic {
    #[doc = "Distributed programmable peripheral interconnect controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Channel group tasks"]
        #[inline(always)]
        pub const fn tasks_chg(self, n: usize) -> TasksChg {
            assert!(n < 6usize);
            unsafe { TasksChg::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_chg(self, n: usize) -> SubscribeChg {
            assert!(n < 6usize);
            unsafe { SubscribeChg::from_ptr(self.ptr.add(0x80usize + n * 8usize) as _) }
        }
        #[doc = "Channel enable register"]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Channel enable set register"]
        #[inline(always)]
        pub const fn chenset(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Channel enable clear register"]
        #[inline(always)]
        pub const fn chenclr(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeChg {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeChg {}
    unsafe impl Sync for SubscribeChg {}
    impl SubscribeChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].EN"]
        #[inline(always)]
        pub const fn en(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].DIS"]
        #[inline(always)]
        pub const fn dis(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Channel group tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksChg {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksChg {}
    unsafe impl Sync for TasksChg {}
    impl TasksChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Enable channel group n"]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Disable channel group n"]
        #[inline(always)]
        pub const fn dis(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Channel enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .field("ch[16]", &self.ch(16usize))
                    .field("ch[17]", &self.ch(17usize))
                    .field("ch[18]", &self.ch(18usize))
                    .field("ch[19]", &self.ch(19usize))
                    .field("ch[20]", &self.ch(20usize))
                    .field("ch[21]", &self.ch(21usize))
                    .field("ch[22]", &self.ch(22usize))
                    .field("ch[23]", &self.ch(23usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chen {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?}, ch[16]: {=bool:?}, ch[17]: {=bool:?}, ch[18]: {=bool:?}, ch[19]: {=bool:?}, ch[20]: {=bool:?}, ch[21]: {=bool:?}, ch[22]: {=bool:?}, ch[23]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize) , self . ch (16usize) , self . ch (17usize) , self . ch (18usize) , self . ch (19usize) , self . ch (20usize) , self . ch (21usize) , self . ch (22usize) , self . ch (23usize))
            }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "Include or exclude channel 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Include or exclude channel 0"]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .field("ch[4]", &self.ch(4usize))
                    .field("ch[5]", &self.ch(5usize))
                    .field("ch[6]", &self.ch(6usize))
                    .field("ch[7]", &self.ch(7usize))
                    .field("ch[8]", &self.ch(8usize))
                    .field("ch[9]", &self.ch(9usize))
                    .field("ch[10]", &self.ch(10usize))
                    .field("ch[11]", &self.ch(11usize))
                    .field("ch[12]", &self.ch(12usize))
                    .field("ch[13]", &self.ch(13usize))
                    .field("ch[14]", &self.ch(14usize))
                    .field("ch[15]", &self.ch(15usize))
                    .field("ch[16]", &self.ch(16usize))
                    .field("ch[17]", &self.ch(17usize))
                    .field("ch[18]", &self.ch(18usize))
                    .field("ch[19]", &self.ch(19usize))
                    .field("ch[20]", &self.ch(20usize))
                    .field("ch[21]", &self.ch(21usize))
                    .field("ch[22]", &self.ch(22usize))
                    .field("ch[23]", &self.ch(23usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chg {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?}, ch[4]: {=bool:?}, ch[5]: {=bool:?}, ch[6]: {=bool:?}, ch[7]: {=bool:?}, ch[8]: {=bool:?}, ch[9]: {=bool:?}, ch[10]: {=bool:?}, ch[11]: {=bool:?}, ch[12]: {=bool:?}, ch[13]: {=bool:?}, ch[14]: {=bool:?}, ch[15]: {=bool:?}, ch[16]: {=bool:?}, ch[17]: {=bool:?}, ch[18]: {=bool:?}, ch[19]: {=bool:?}, ch[20]: {=bool:?}, ch[21]: {=bool:?}, ch[22]: {=bool:?}, ch[23]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize) , self . ch (4usize) , self . ch (5usize) , self . ch (6usize) , self . ch (7usize) , self . ch (8usize) , self . ch (9usize) , self . ch (10usize) , self . ch (11usize) , self . ch (12usize) , self . ch (13usize) , self . ch (14usize) , self . ch (15usize) , self . ch (16usize) , self . ch (17usize) , self . ch (18usize) , self . ch (19usize) , self . ch (20usize) , self . ch (21usize) , self . ch (22usize) , self . ch (23usize))
            }
        }
    }
}
pub mod ecb {
    #[doc = "AES ECB Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecb {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecb {}
    unsafe impl Sync for Ecb {}
    impl Ecb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start ECB block encrypt"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Abort a possible executing ECB operation"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "ECB block encrypt complete"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "ECB block encrypt aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted ECB data structure"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[must_use]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Errorstatus {{ errorstatus: {:?} }}", self.errorstatus())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ end: {=bool:?}, error: {=bool:?} }}",
                    self.end(),
                    self.error()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Deprecated enumerator - Encryption aborted due to higher priority peripheral requesting or using the AES module."]
            ENCRYPTION_TOO_SLOW = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod egu {
    #[doc = "Event generator unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Egu {
        ptr: *mut u8,
    }
    unsafe impl Send for Egu {}
    unsafe impl Sync for Egu {}
    impl Egu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Trigger n for triggering the corresponding TRIGGERED\\[n\\] event"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Event number n generated by triggering the corresponding TRIGGER\\[n\\] task"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[inline(always)]
            pub const fn set_triggered(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered[0]", &self.triggered(0usize))
                    .field("triggered[1]", &self.triggered(1usize))
                    .field("triggered[2]", &self.triggered(2usize))
                    .field("triggered[3]", &self.triggered(3usize))
                    .field("triggered[4]", &self.triggered(4usize))
                    .field("triggered[5]", &self.triggered(5usize))
                    .field("triggered[6]", &self.triggered(6usize))
                    .field("triggered[7]", &self.triggered(7usize))
                    .field("triggered[8]", &self.triggered(8usize))
                    .field("triggered[9]", &self.triggered(9usize))
                    .field("triggered[10]", &self.triggered(10usize))
                    .field("triggered[11]", &self.triggered(11usize))
                    .field("triggered[12]", &self.triggered(12usize))
                    .field("triggered[13]", &self.triggered(13usize))
                    .field("triggered[14]", &self.triggered(14usize))
                    .field("triggered[15]", &self.triggered(15usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ triggered[0]: {=bool:?}, triggered[1]: {=bool:?}, triggered[2]: {=bool:?}, triggered[3]: {=bool:?}, triggered[4]: {=bool:?}, triggered[5]: {=bool:?}, triggered[6]: {=bool:?}, triggered[7]: {=bool:?}, triggered[8]: {=bool:?}, triggered[9]: {=bool:?}, triggered[10]: {=bool:?}, triggered[11]: {=bool:?}, triggered[12]: {=bool:?}, triggered[13]: {=bool:?}, triggered[14]: {=bool:?}, triggered[15]: {=bool:?} }}" , self . triggered (0usize) , self . triggered (1usize) , self . triggered (2usize) , self . triggered (3usize) , self . triggered (4usize) , self . triggered (5usize) , self . triggered (6usize) , self . triggered (7usize) , self . triggered (8usize) , self . triggered (9usize) , self . triggered (10usize) , self . triggered (11usize) , self . triggered (12usize) , self . triggered (13usize) , self . triggered (14usize) , self . triggered (15usize))
            }
        }
    }
}
pub mod etm {
    #[doc = "Embedded Trace Macrocell"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Etm {
        ptr: *mut u8,
    }
    unsafe impl Send for Etm {}
    unsafe impl Sync for Etm {}
    impl Etm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enables the trace unit."]
        #[inline(always)]
        pub const fn trcprgctlr(self) -> crate::common::Reg<regs::Trcprgctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[inline(always)]
        pub const fn trcprocselr(self) -> crate::common::Reg<regs::Trcprocselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Idle status bit"]
        #[inline(always)]
        pub const fn trcstatr(self) -> crate::common::Reg<regs::Trcstatr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trcconfigr(self) -> crate::common::Reg<regs::Trcconfigr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[inline(always)]
        pub const fn trceventctl0r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl0r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trceventctl1r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl1r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[inline(always)]
        pub const fn trcstallctlr(
            self,
        ) -> crate::common::Reg<regs::Trcstallctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[inline(always)]
        pub const fn trctsctlr(self) -> crate::common::Reg<regs::Trctsctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[inline(always)]
        pub const fn trcsyncpr(self) -> crate::common::Reg<regs::Trcsyncpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[inline(always)]
        pub const fn trcccctlr(self) -> crate::common::Reg<regs::Trcccctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[inline(always)]
        pub const fn trcbbctlr(self) -> crate::common::Reg<regs::Trcbbctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trctraceidr(self) -> crate::common::Reg<regs::Trctraceidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[inline(always)]
        pub const fn trcqctlr(self) -> crate::common::Reg<regs::Trcqctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[inline(always)]
        pub const fn trcvictlr(self) -> crate::common::Reg<regs::Trcvictlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcviiectlr(self) -> crate::common::Reg<regs::Trcviiectlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvissctlr(self) -> crate::common::Reg<regs::Trcvissctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvipcssctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvipcssctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[inline(always)]
        pub const fn trcvdctlr(self) -> crate::common::Reg<regs::Trcvdctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdsacctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdsacctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdarcctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdarcctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqevr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcseqevr, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqrstevr(
            self,
        ) -> crate::common::Reg<regs::Trcseqrstevr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqstr(self) -> crate::common::Reg<regs::Trcseqstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcextinselr(
            self,
        ) -> crate::common::Reg<regs::Trcextinselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntrldvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntrldvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntctlr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[inline(always)]
        pub const fn trcrsctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcrsctlr, crate::common::RW> {
            assert!(n < 30usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 4usize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcssccr0(self) -> crate::common::Reg<regs::Trcssccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0280usize) as _) }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[inline(always)]
        pub const fn trcsscsr0(self) -> crate::common::Reg<regs::Trcsscsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[inline(always)]
        pub const fn trcsspcicr0(self) -> crate::common::Reg<regs::Trcsspcicr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02c0usize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcpdcr(self) -> crate::common::Reg<regs::Trcpdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0310usize) as _) }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[inline(always)]
        pub const fn trcpdsr(self) -> crate::common::Reg<regs::Trcpdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
        #[doc = "Sets the state of output pins."]
        #[inline(always)]
        pub const fn trcitatbidr(self) -> crate::common::Reg<regs::Trcitatbidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee4usize) as _) }
        }
        #[doc = "Reads the state of the input pins."]
        #[inline(always)]
        pub const fn trcitiatbinr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatbinr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef4usize) as _) }
        }
        #[doc = "Sets the state of the output pins."]
        #[inline(always)]
        pub const fn trcitiatboutr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatboutr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0efcusize) as _) }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[inline(always)]
        pub const fn trcitctrl(self) -> crate::common::Reg<regs::Trcitctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f00usize) as _) }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[inline(always)]
        pub const fn trcclaimset(self) -> crate::common::Reg<regs::Trcclaimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa0usize) as _) }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn trcclaimclr(self) -> crate::common::Reg<regs::Trcclaimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn trcauthstatus(
            self,
        ) -> crate::common::Reg<regs::Trcauthstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb8usize) as _) }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[inline(always)]
        pub const fn trcdevarch(self) -> crate::common::Reg<regs::Trcdevarch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fbcusize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcdevtype(self) -> crate::common::Reg<regs::Trcdevtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fccusize) as _) }
        }
        #[doc = "Description collection: Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn trcpidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fd0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Coresight component identification registers."]
        #[inline(always)]
        pub const fn trccidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff0usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcauthstatus(pub u32);
        impl Trcauthstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Trcauthstatus {
            #[inline(always)]
            fn default() -> Trcauthstatus {
                Trcauthstatus(0)
            }
        }
        impl core::fmt::Debug for Trcauthstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcauthstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcauthstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcauthstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcbbctlr(pub u32);
        impl Trcbbctlr {
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[must_use]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[inline(always)]
            pub const fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[must_use]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[inline(always)]
            pub const fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[must_use]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[inline(always)]
            pub const fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[must_use]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[inline(always)]
            pub const fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[must_use]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[inline(always)]
            pub const fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[must_use]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[inline(always)]
            pub const fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[must_use]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[inline(always)]
            pub const fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[must_use]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[inline(always)]
            pub const fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Trcbbctlr {
            #[inline(always)]
            fn default() -> Trcbbctlr {
                Trcbbctlr(0)
            }
        }
        impl core::fmt::Debug for Trcbbctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcbbctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcbbctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcbbctlr {{ range_0: {=bool:?}, range_1: {=bool:?}, range_2: {=bool:?}, range_3: {=bool:?}, range_4: {=bool:?}, range_5: {=bool:?}, range_6: {=bool:?}, range_7: {=bool:?} }}" , self . range_0 () , self . range_1 () , self . range_2 () , self . range_3 () , self . range_4 () , self . range_5 () , self . range_6 () , self . range_7 ())
            }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcccctlr(pub u32);
        impl Trcccctlr {
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[must_use]
            #[inline(always)]
            pub const fn threshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[inline(always)]
            pub const fn set_threshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Trcccctlr {
            #[inline(always)]
            fn default() -> Trcccctlr {
                Trcccctlr(0)
            }
        }
        impl core::fmt::Debug for Trcccctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcccctlr")
                    .field("threshold", &self.threshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcccctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcccctlr {{ threshold: {=u16:?} }}", self.threshold())
            }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimclr(pub u32);
        impl Trcclaimclr {
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_0(&self) -> super::vals::Clr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clr0::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_0(&mut self, val: super::vals::Clr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_1(&self) -> super::vals::Clr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Clr1::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_1(&mut self, val: super::vals::Clr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_2(&self) -> super::vals::Clr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clr2::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_2(&mut self, val: super::vals::Clr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag clear register"]
            #[must_use]
            #[inline(always)]
            pub const fn clr_3(&self) -> super::vals::Clr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Clr3::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn set_clr_3(&mut self, val: super::vals::Clr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimclr {
            #[inline(always)]
            fn default() -> Trcclaimclr {
                Trcclaimclr(0)
            }
        }
        impl core::fmt::Debug for Trcclaimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimclr")
                    .field("clr_0", &self.clr_0())
                    .field("clr_1", &self.clr_1())
                    .field("clr_2", &self.clr_2())
                    .field("clr_3", &self.clr_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcclaimclr {{ clr_0: {:?}, clr_1: {:?}, clr_2: {:?}, clr_3: {:?} }}",
                    self.clr_0(),
                    self.clr_1(),
                    self.clr_2(),
                    self.clr_3()
                )
            }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimset(pub u32);
        impl Trcclaimset {
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_0(&self) -> super::vals::Set0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Set0::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_0(&mut self, val: super::vals::Set0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_1(&self) -> super::vals::Set1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Set1::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_1(&mut self, val: super::vals::Set1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_2(&self) -> super::vals::Set2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Set2::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_2(&mut self, val: super::vals::Set2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag set register"]
            #[must_use]
            #[inline(always)]
            pub const fn set_3(&self) -> super::vals::Set3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Set3::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_set_3(&mut self, val: super::vals::Set3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimset {
            #[inline(always)]
            fn default() -> Trcclaimset {
                Trcclaimset(0)
            }
        }
        impl core::fmt::Debug for Trcclaimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimset")
                    .field("set_0", &self.set_0())
                    .field("set_1", &self.set_1())
                    .field("set_2", &self.set_2())
                    .field("set_3", &self.set_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcclaimset {{ set_0: {:?}, set_1: {:?}, set_2: {:?}, set_3: {:?} }}",
                    self.set_0(),
                    self.set_1(),
                    self.set_2(),
                    self.set_3()
                )
            }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntctlr(pub u32);
        impl Trccntctlr {
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[must_use]
            #[inline(always)]
            pub const fn cntevent(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[inline(always)]
            pub const fn set_cntevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn rldevent(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[inline(always)]
            pub const fn set_rldevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[must_use]
            #[inline(always)]
            pub const fn rldself(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[inline(always)]
            pub const fn set_rldself(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[must_use]
            #[inline(always)]
            pub const fn cntchain(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[inline(always)]
            pub const fn set_cntchain(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trccntctlr {
            #[inline(always)]
            fn default() -> Trccntctlr {
                Trccntctlr(0)
            }
        }
        impl core::fmt::Debug for Trccntctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntctlr")
                    .field("cntevent", &self.cntevent())
                    .field("rldevent", &self.rldevent())
                    .field("rldself", &self.rldself())
                    .field("cntchain", &self.cntchain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trccntctlr {{ cntevent: {=u8:?}, rldevent: {=u8:?}, rldself: {=bool:?}, cntchain: {=bool:?} }}" , self . cntevent () , self . rldevent () , self . rldself () , self . cntchain ())
            }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntrldvr(pub u32);
        impl Trccntrldvr {
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntrldvr {
            #[inline(always)]
            fn default() -> Trccntrldvr {
                Trccntrldvr(0)
            }
        }
        impl core::fmt::Debug for Trccntrldvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntrldvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntrldvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trccntrldvr {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntvr(pub u32);
        impl Trccntvr {
            #[doc = "Contains the count value of counter n."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the count value of counter n."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntvr {
            #[inline(always)]
            fn default() -> Trccntvr {
                Trccntvr(0)
            }
        }
        impl core::fmt::Debug for Trccntvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntvr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trccntvr {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcconfigr(pub u32);
        impl Trcconfigr {
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[must_use]
            #[inline(always)]
            pub const fn loadasp0inst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn set_loadasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[must_use]
            #[inline(always)]
            pub const fn storeasp0inst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn set_storeasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Branch broadcast mode bit."]
            #[must_use]
            #[inline(always)]
            pub const fn bb(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Branch broadcast mode bit."]
            #[inline(always)]
            pub const fn set_bb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cci(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[inline(always)]
            pub const fn set_cci(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Context ID tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cid(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Context ID tracing bit."]
            #[inline(always)]
            pub const fn set_cid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn vmid(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[inline(always)]
            pub const fn set_vmid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Conditional instruction tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn cond(&self) -> super::vals::Cond {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cond::from_bits(val as u8)
            }
            #[doc = "Conditional instruction tracing bit."]
            #[inline(always)]
            pub const fn set_cond(&mut self, val: super::vals::Cond) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Global timestamp tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn ts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Global timestamp tracing bit."]
            #[inline(always)]
            pub const fn set_ts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Return stack enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn rs(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Return stack enable bit."]
            #[inline(always)]
            pub const fn set_rs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Q element enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn qe(&self) -> super::vals::Qe {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Qe::from_bits(val as u8)
            }
            #[doc = "Q element enable field."]
            #[inline(always)]
            pub const fn set_qe(&mut self, val: super::vals::Qe) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u32) & 0x03) << 13usize);
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[must_use]
            #[inline(always)]
            pub const fn vmidopt(&self) -> super::vals::Vmidopt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vmidopt::from_bits(val as u8)
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[inline(always)]
            pub const fn set_vmidopt(&mut self, val: super::vals::Vmidopt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Data address tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data address tracing bit."]
            #[inline(always)]
            pub const fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Data value tracing bit."]
            #[must_use]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Data value tracing bit."]
            #[inline(always)]
            pub const fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trcconfigr {
            #[inline(always)]
            fn default() -> Trcconfigr {
                Trcconfigr(0)
            }
        }
        impl core::fmt::Debug for Trcconfigr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcconfigr")
                    .field("loadasp0inst", &self.loadasp0inst())
                    .field("storeasp0inst", &self.storeasp0inst())
                    .field("bb", &self.bb())
                    .field("cci", &self.cci())
                    .field("cid", &self.cid())
                    .field("vmid", &self.vmid())
                    .field("cond", &self.cond())
                    .field("ts", &self.ts())
                    .field("rs", &self.rs())
                    .field("qe", &self.qe())
                    .field("vmidopt", &self.vmidopt())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcconfigr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcconfigr {{ loadasp0inst: {=bool:?}, storeasp0inst: {=bool:?}, bb: {=bool:?}, cci: {=bool:?}, cid: {=bool:?}, vmid: {=bool:?}, cond: {:?}, ts: {=bool:?}, rs: {=bool:?}, qe: {:?}, vmidopt: {:?}, da: {=bool:?}, dv: {=bool:?} }}" , self . loadasp0inst () , self . storeasp0inst () , self . bb () , self . cci () , self . cid () , self . vmid () , self . cond () , self . ts () , self . rs () , self . qe () , self . vmidopt () , self . da () , self . dv ())
            }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevarch(pub u32);
        impl Trcdevarch {
            #[doc = "Architecture ID"]
            #[must_use]
            #[inline(always)]
            pub const fn archid(&self) -> super::vals::Archid {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Archid::from_bits(val as u16)
            }
            #[doc = "Architecture ID"]
            #[inline(always)]
            pub const fn set_archid(&mut self, val: super::vals::Archid) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
            #[doc = "Architecture revision"]
            #[must_use]
            #[inline(always)]
            pub const fn revision(&self) -> super::vals::Revision {
                let val = (self.0 >> 16usize) & 0x0f;
                super::vals::Revision::from_bits(val as u8)
            }
            #[doc = "Architecture revision"]
            #[inline(always)]
            pub const fn set_revision(&mut self, val: super::vals::Revision) {
                self.0 =
                    (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
            }
            #[doc = "This register is implemented"]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "This register is implemented"]
            #[inline(always)]
            pub const fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Defines the architect of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn architect(&self) -> super::vals::Architect {
                let val = (self.0 >> 21usize) & 0x07ff;
                super::vals::Architect::from_bits(val as u16)
            }
            #[doc = "Defines the architect of the component"]
            #[inline(always)]
            pub const fn set_architect(&mut self, val: super::vals::Architect) {
                self.0 = (self.0 & !(0x07ff << 21usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 21usize);
            }
        }
        impl Default for Trcdevarch {
            #[inline(always)]
            fn default() -> Trcdevarch {
                Trcdevarch(0)
            }
        }
        impl core::fmt::Debug for Trcdevarch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevarch")
                    .field("archid", &self.archid())
                    .field("revision", &self.revision())
                    .field("present", &self.present())
                    .field("architect", &self.architect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevarch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcdevarch {{ archid: {:?}, revision: {:?}, present: {:?}, architect: {:?} }}",
                    self.archid(),
                    self.revision(),
                    self.present(),
                    self.architect()
                )
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevtype(pub u32);
        impl Trcdevtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Trcdevtype {
            #[inline(always)]
            fn default() -> Trcdevtype {
                Trcdevtype(0)
            }
        }
        impl core::fmt::Debug for Trcdevtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcdevtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl0r(pub u32);
        impl Trceventctl0r {
            #[doc = "Select which event should generate trace elements."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate trace elements."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trceventctl0r {
            #[inline(always)]
            fn default() -> Trceventctl0r {
                Trceventctl0r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl0r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl0r")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl0r {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trceventctl0r {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl1r(pub u32);
        impl Trceventctl1r {
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Instruction event enable field."]
            #[must_use]
            #[inline(always)]
            pub const fn insten_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn set_insten_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Data event enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn dataen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Data event enable bit."]
            #[inline(always)]
            pub const fn set_dataen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn atb(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[inline(always)]
            pub const fn set_atb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[must_use]
            #[inline(always)]
            pub const fn lpoverride(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[inline(always)]
            pub const fn set_lpoverride(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trceventctl1r {
            #[inline(always)]
            fn default() -> Trceventctl1r {
                Trceventctl1r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl1r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl1r")
                    .field("insten_0", &self.insten_0())
                    .field("insten_1", &self.insten_1())
                    .field("insten_2", &self.insten_2())
                    .field("insten_3", &self.insten_3())
                    .field("dataen", &self.dataen())
                    .field("atb", &self.atb())
                    .field("lpoverride", &self.lpoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl1r {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trceventctl1r {{ insten_0: {=bool:?}, insten_1: {=bool:?}, insten_2: {=bool:?}, insten_3: {=bool:?}, dataen: {=bool:?}, atb: {=bool:?}, lpoverride: {=bool:?} }}" , self . insten_0 () , self . insten_1 () , self . insten_2 () , self . insten_3 () , self . dataen () , self . atb () , self . lpoverride ())
            }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcextinselr(pub u32);
        impl Trcextinselr {
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[must_use]
            #[inline(always)]
            pub const fn sel_3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn set_sel_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Trcextinselr {
            #[inline(always)]
            fn default() -> Trcextinselr {
                Trcextinselr(0)
            }
        }
        impl core::fmt::Debug for Trcextinselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcextinselr")
                    .field("sel_0", &self.sel_0())
                    .field("sel_1", &self.sel_1())
                    .field("sel_2", &self.sel_2())
                    .field("sel_3", &self.sel_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcextinselr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcextinselr {{ sel_0: {=u8:?}, sel_1: {=u8:?}, sel_2: {=u8:?}, sel_3: {=u8:?} }}" , self . sel_0 () , self . sel_1 () , self . sel_2 () , self . sel_3 ())
            }
        }
        #[doc = "Sets the state of output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitatbidr(pub u32);
        impl Trcitatbidr {
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[inline(always)]
            pub const fn set_id_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[inline(always)]
            pub const fn set_id_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[inline(always)]
            pub const fn set_id_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[inline(always)]
            pub const fn set_id_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[inline(always)]
            pub const fn set_id_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[inline(always)]
            pub const fn set_id_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn id_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[inline(always)]
            pub const fn set_id_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Trcitatbidr {
            #[inline(always)]
            fn default() -> Trcitatbidr {
                Trcitatbidr(0)
            }
        }
        impl core::fmt::Debug for Trcitatbidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitatbidr")
                    .field("id_0", &self.id_0())
                    .field("id_1", &self.id_1())
                    .field("id_2", &self.id_2())
                    .field("id_3", &self.id_3())
                    .field("id_4", &self.id_4())
                    .field("id_5", &self.id_5())
                    .field("id_6", &self.id_6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitatbidr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcitatbidr {{ id_0: {=bool:?}, id_1: {=bool:?}, id_2: {=bool:?}, id_3: {=bool:?}, id_4: {=bool:?}, id_5: {=bool:?}, id_6: {=bool:?} }}" , self . id_0 () , self . id_1 () , self . id_2 () , self . id_3 () , self . id_4 () , self . id_5 () , self . id_6 ())
            }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitctrl(pub u32);
        impl Trcitctrl {
            #[doc = "Integration mode enable"]
            #[must_use]
            #[inline(always)]
            pub const fn ime(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Integration mode enable"]
            #[inline(always)]
            pub const fn set_ime(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcitctrl {
            #[inline(always)]
            fn default() -> Trcitctrl {
                Trcitctrl(0)
            }
        }
        impl core::fmt::Debug for Trcitctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitctrl")
                    .field("ime", &self.ime())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcitctrl {{ ime: {=bool:?} }}", self.ime())
            }
        }
        #[doc = "Reads the state of the input pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatbinr(pub u32);
        impl Trcitiatbinr {
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatbinr {
            #[inline(always)]
            fn default() -> Trcitiatbinr {
                Trcitiatbinr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatbinr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatbinr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatbinr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcitiatbinr {{ atvalid: {=bool:?}, afready: {=bool:?} }}",
                    self.atvalid(),
                    self.afready()
                )
            }
        }
        #[doc = "Sets the state of the output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatboutr(pub u32);
        impl Trcitiatboutr {
            #[doc = "Drives the ATVALIDMI output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATVALIDMI output pin."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatboutr {
            #[inline(always)]
            fn default() -> Trcitiatboutr {
                Trcitiatboutr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatboutr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatboutr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatboutr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcitiatboutr {{ atvalid: {=bool:?}, afready: {=bool:?} }}",
                    self.atvalid(),
                    self.afready()
                )
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdcr(pub u32);
        impl Trcpdcr {
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[must_use]
            #[inline(always)]
            pub const fn pu(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[inline(always)]
            pub const fn set_pu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcpdcr {
            #[inline(always)]
            fn default() -> Trcpdcr {
                Trcpdcr(0)
            }
        }
        impl core::fmt::Debug for Trcpdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdcr").field("pu", &self.pu()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcpdcr {{ pu: {=bool:?} }}", self.pu())
            }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdsr(pub u32);
        impl Trcpdsr {
            #[doc = "Indicates ETM is powered up"]
            #[must_use]
            #[inline(always)]
            pub const fn power(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates ETM is powered up"]
            #[inline(always)]
            pub const fn set_power(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[must_use]
            #[inline(always)]
            pub const fn stickypd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[inline(always)]
            pub const fn set_stickypd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcpdsr {
            #[inline(always)]
            fn default() -> Trcpdsr {
                Trcpdsr(0)
            }
        }
        impl core::fmt::Debug for Trcpdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdsr")
                    .field("power", &self.power())
                    .field("stickypd", &self.stickypd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcpdsr {{ power: {=bool:?}, stickypd: {=bool:?} }}",
                    self.power(),
                    self.stickypd()
                )
            }
        }
        #[doc = "Enables the trace unit."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprgctlr(pub u32);
        impl Trcprgctlr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcprgctlr {
            #[inline(always)]
            fn default() -> Trcprgctlr {
                Trcprgctlr(0)
            }
        }
        impl core::fmt::Debug for Trcprgctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprgctlr")
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprgctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcprgctlr {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprocselr(pub u32);
        impl Trcprocselr {
            #[doc = "PE select bits that select the PE to trace."]
            #[must_use]
            #[inline(always)]
            pub const fn procsel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "PE select bits that select the PE to trace."]
            #[inline(always)]
            pub const fn set_procsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcprocselr {
            #[inline(always)]
            fn default() -> Trcprocselr {
                Trcprocselr(0)
            }
        }
        impl core::fmt::Debug for Trcprocselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprocselr")
                    .field("procsel", &self.procsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprocselr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcprocselr {{ procsel: {=u8:?} }}", self.procsel())
            }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcqctlr(pub u32);
        impl Trcqctlr {
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[must_use]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Trcqctlr {
            #[inline(always)]
            fn default() -> Trcqctlr {
                Trcqctlr(0)
            }
        }
        impl core::fmt::Debug for Trcqctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcqctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcqctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcqctlr {{ range_0: {=bool:?}, range_1: {=bool:?}, range_2: {=bool:?}, range_3: {=bool:?}, range_4: {=bool:?}, range_5: {=bool:?}, range_6: {=bool:?}, range_7: {=bool:?}, mode: {:?} }}" , self . range_0 () , self . range_1 () , self . range_2 () , self . range_3 () , self . range_4 () , self . range_5 () , self . range_6 () , self . range_7 () , self . mode ())
            }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcrsctlr(pub u32);
        impl Trcrsctlr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcrsctlr {
            #[inline(always)]
            fn default() -> Trcrsctlr {
                Trcrsctlr(0)
            }
        }
        impl core::fmt::Debug for Trcrsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcrsctlr").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcrsctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcrsctlr {{ en: {=bool:?} }}", self.en())
            }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqevr(pub u32);
        impl Trcseqevr {
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Forward field."]
            #[must_use]
            #[inline(always)]
            pub const fn f_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn set_f_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Backward field."]
            #[must_use]
            #[inline(always)]
            pub const fn b_7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn set_b_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Trcseqevr {
            #[inline(always)]
            fn default() -> Trcseqevr {
                Trcseqevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqevr")
                    .field("f_0", &self.f_0())
                    .field("f_1", &self.f_1())
                    .field("f_2", &self.f_2())
                    .field("f_3", &self.f_3())
                    .field("f_4", &self.f_4())
                    .field("f_5", &self.f_5())
                    .field("f_6", &self.f_6())
                    .field("f_7", &self.f_7())
                    .field("b_0", &self.b_0())
                    .field("b_1", &self.b_1())
                    .field("b_2", &self.b_2())
                    .field("b_3", &self.b_3())
                    .field("b_4", &self.b_4())
                    .field("b_5", &self.b_5())
                    .field("b_6", &self.b_6())
                    .field("b_7", &self.b_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqevr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcseqevr {{ f_0: {=bool:?}, f_1: {=bool:?}, f_2: {=bool:?}, f_3: {=bool:?}, f_4: {=bool:?}, f_5: {=bool:?}, f_6: {=bool:?}, f_7: {=bool:?}, b_0: {=bool:?}, b_1: {=bool:?}, b_2: {=bool:?}, b_3: {=bool:?}, b_4: {=bool:?}, b_5: {=bool:?}, b_6: {=bool:?}, b_7: {=bool:?} }}" , self . f_0 () , self . f_1 () , self . f_2 () , self . f_3 () , self . f_4 () , self . f_5 () , self . f_6 () , self . f_7 () , self . b_0 () , self . b_1 () , self . b_2 () , self . b_3 () , self . b_4 () , self . b_5 () , self . b_6 () , self . b_7 ())
            }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqrstevr(pub u32);
        impl Trcseqrstevr {
            #[doc = "Select which event should reset the sequencer."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should reset the sequencer."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trcseqrstevr {
            #[inline(always)]
            fn default() -> Trcseqrstevr {
                Trcseqrstevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqrstevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqrstevr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqrstevr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcseqrstevr {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqstr(pub u32);
        impl Trcseqstr {
            #[doc = "Sets or returns the state of the sequencer."]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Sets or returns the state of the sequencer."]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Trcseqstr {
            #[inline(always)]
            fn default() -> Trcseqstr {
                Trcseqstr(0)
            }
        }
        impl core::fmt::Debug for Trcseqstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqstr")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqstr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcseqstr {{ state: {:?} }}", self.state())
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcssccr0(pub u32);
        impl Trcssccr0 {
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[must_use]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[inline(always)]
            pub const fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcssccr0 {
            #[inline(always)]
            fn default() -> Trcssccr0 {
                Trcssccr0(0)
            }
        }
        impl core::fmt::Debug for Trcssccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcssccr0")
                    .field("rst", &self.rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcssccr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcssccr0 {{ rst: {=bool:?} }}", self.rst())
            }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsscsr0(pub u32);
        impl Trcsscsr0 {
            #[doc = "Instruction address comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn inst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction address comparator support"]
            #[inline(always)]
            pub const fn set_inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Data address comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Data address comparator support"]
            #[inline(always)]
            pub const fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Data value comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Data value comparator support"]
            #[inline(always)]
            pub const fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Process counter value comparator support"]
            #[must_use]
            #[inline(always)]
            pub const fn pc(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Process counter value comparator support"]
            #[inline(always)]
            pub const fn set_pc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Trcsscsr0 {
            #[inline(always)]
            fn default() -> Trcsscsr0 {
                Trcsscsr0(0)
            }
        }
        impl core::fmt::Debug for Trcsscsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsscsr0")
                    .field("inst", &self.inst())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .field("pc", &self.pc())
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsscsr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcsscsr0 {{ inst: {=bool:?}, da: {=bool:?}, dv: {=bool:?}, pc: {=bool:?}, status: {=bool:?} }}" , self . inst () , self . da () , self . dv () , self . pc () , self . status ())
            }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsspcicr0(pub u32);
        impl Trcsspcicr0 {
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[must_use]
            #[inline(always)]
            pub const fn pc_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn set_pc_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcsspcicr0 {
            #[inline(always)]
            fn default() -> Trcsspcicr0 {
                Trcsspcicr0(0)
            }
        }
        impl core::fmt::Debug for Trcsspcicr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsspcicr0")
                    .field("pc_0", &self.pc_0())
                    .field("pc_1", &self.pc_1())
                    .field("pc_2", &self.pc_2())
                    .field("pc_3", &self.pc_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsspcicr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcsspcicr0 {{ pc_0: {=bool:?}, pc_1: {=bool:?}, pc_2: {=bool:?}, pc_3: {=bool:?} }}" , self . pc_0 () , self . pc_1 () , self . pc_2 () , self . pc_3 ())
            }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstallctlr(pub u32);
        impl Trcstallctlr {
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[must_use]
            #[inline(always)]
            pub const fn level(&self) -> super::vals::Level {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Level::from_bits(val as u8)
            }
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[inline(always)]
            pub const fn set_level(&mut self, val: super::vals::Level) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn istall(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_istall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn dstall(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_dstall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn instpriority(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_instpriority(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn datadiscardload(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_datadiscardload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[must_use]
            #[inline(always)]
            pub const fn datadiscardstore(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn set_datadiscardstore(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Trace overflow prevention bit."]
            #[must_use]
            #[inline(always)]
            pub const fn nooverflow(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Trace overflow prevention bit."]
            #[inline(always)]
            pub const fn set_nooverflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Trcstallctlr {
            #[inline(always)]
            fn default() -> Trcstallctlr {
                Trcstallctlr(0)
            }
        }
        impl core::fmt::Debug for Trcstallctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstallctlr")
                    .field("level", &self.level())
                    .field("istall", &self.istall())
                    .field("dstall", &self.dstall())
                    .field("instpriority", &self.instpriority())
                    .field("datadiscardload", &self.datadiscardload())
                    .field("datadiscardstore", &self.datadiscardstore())
                    .field("nooverflow", &self.nooverflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstallctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcstallctlr {{ level: {:?}, istall: {=bool:?}, dstall: {=bool:?}, instpriority: {=bool:?}, datadiscardload: {=bool:?}, datadiscardstore: {=bool:?}, nooverflow: {=bool:?} }}" , self . level () , self . istall () , self . dstall () , self . instpriority () , self . datadiscardload () , self . datadiscardstore () , self . nooverflow ())
            }
        }
        #[doc = "Idle status bit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstatr(pub u32);
        impl Trcstatr {
            #[doc = "Trace unit enable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Programmers' model stable bit"]
            #[must_use]
            #[inline(always)]
            pub const fn pmstable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Programmers' model stable bit"]
            #[inline(always)]
            pub const fn set_pmstable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcstatr {
            #[inline(always)]
            fn default() -> Trcstatr {
                Trcstatr(0)
            }
        }
        impl core::fmt::Debug for Trcstatr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstatr")
                    .field("idle", &self.idle())
                    .field("pmstable", &self.pmstable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstatr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Trcstatr {{ idle: {=bool:?}, pmstable: {=bool:?} }}",
                    self.idle(),
                    self.pmstable()
                )
            }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsyncpr(pub u32);
        impl Trcsyncpr {
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[must_use]
            #[inline(always)]
            pub const fn period(&self) -> super::vals::Period {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Period::from_bits(val as u8)
            }
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[inline(always)]
            pub const fn set_period(&mut self, val: super::vals::Period) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcsyncpr {
            #[inline(always)]
            fn default() -> Trcsyncpr {
                Trcsyncpr(0)
            }
        }
        impl core::fmt::Debug for Trcsyncpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsyncpr")
                    .field("period", &self.period())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsyncpr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trcsyncpr {{ period: {:?} }}", self.period())
            }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctraceidr(pub u32);
        impl Trctraceidr {
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[must_use]
            #[inline(always)]
            pub const fn traceid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[inline(always)]
            pub const fn set_traceid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Trctraceidr {
            #[inline(always)]
            fn default() -> Trctraceidr {
                Trctraceidr(0)
            }
        }
        impl core::fmt::Debug for Trctraceidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctraceidr")
                    .field("traceid", &self.traceid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctraceidr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trctraceidr {{ traceid: {=u8:?} }}", self.traceid())
            }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctsctlr(pub u32);
        impl Trctsctlr {
            #[doc = "Select which event should generate time stamps."]
            #[must_use]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate time stamps."]
            #[inline(always)]
            pub const fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trctsctlr {
            #[inline(always)]
            fn default() -> Trctsctlr {
                Trctsctlr(0)
            }
        }
        impl core::fmt::Debug for Trctsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctsctlr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctsctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Trctsctlr {{ event: {=u8:?} }}", self.event())
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdarcctlr(pub u32);
        impl Trcvdarcctlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdarcctlr {
            #[inline(always)]
            fn default() -> Trcvdarcctlr {
                Trcvdarcctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdarcctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdarcctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdarcctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdarcctlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdctlr(pub u32);
        impl Trcvdctlr {
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Event unit enable bit."]
            #[must_use]
            #[inline(always)]
            pub const fn event_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn set_event_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[must_use]
            #[inline(always)]
            pub const fn sprel(&self) -> super::vals::Sprel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Sprel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[inline(always)]
            pub const fn set_sprel(&mut self, val: super::vals::Sprel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[must_use]
            #[inline(always)]
            pub const fn pcrel(&self) -> super::vals::Pcrel {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcrel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[inline(always)]
            pub const fn set_pcrel(&mut self, val: super::vals::Pcrel) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[must_use]
            #[inline(always)]
            pub const fn tbi(&self) -> super::vals::Tbi {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tbi::from_bits(val as u8)
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[inline(always)]
            pub const fn set_tbi(&mut self, val: super::vals::Tbi) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[must_use]
            #[inline(always)]
            pub const fn trcexdata(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[inline(always)]
            pub const fn set_trcexdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trcvdctlr {
            #[inline(always)]
            fn default() -> Trcvdctlr {
                Trcvdctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdctlr")
                    .field("event_0", &self.event_0())
                    .field("event_1", &self.event_1())
                    .field("event_2", &self.event_2())
                    .field("event_3", &self.event_3())
                    .field("event_4", &self.event_4())
                    .field("event_5", &self.event_5())
                    .field("event_6", &self.event_6())
                    .field("event_7", &self.event_7())
                    .field("sprel", &self.sprel())
                    .field("pcrel", &self.pcrel())
                    .field("tbi", &self.tbi())
                    .field("trcexdata", &self.trcexdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdctlr {{ event_0: {=bool:?}, event_1: {=bool:?}, event_2: {=bool:?}, event_3: {=bool:?}, event_4: {=bool:?}, event_5: {=bool:?}, event_6: {=bool:?}, event_7: {=bool:?}, sprel: {:?}, pcrel: {:?}, tbi: {:?}, trcexdata: {=bool:?} }}" , self . event_0 () , self . event_1 () , self . event_2 () , self . event_3 () , self . event_4 () , self . event_5 () , self . event_6 () , self . event_7 () , self . sprel () , self . pcrel () , self . tbi () , self . trcexdata ())
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdsacctlr(pub u32);
        impl Trcvdsacctlr {
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdsacctlr {
            #[inline(always)]
            fn default() -> Trcvdsacctlr {
                Trcvdsacctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdsacctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdsacctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdsacctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvdsacctlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvictlr(pub u32);
        impl Trcvictlr {
            #[doc = "Select which resource number should be filtered."]
            #[must_use]
            #[inline(always)]
            pub const fn event_sel(&self) -> super::vals::EventSel {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::EventSel::from_bits(val as u8)
            }
            #[doc = "Select which resource number should be filtered."]
            #[inline(always)]
            pub const fn set_event_sel(&mut self, val: super::vals::EventSel) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[must_use]
            #[inline(always)]
            pub const fn ssstatus(&self) -> super::vals::Ssstatus {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ssstatus::from_bits(val as u8)
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[inline(always)]
            pub const fn set_ssstatus(&mut self, val: super::vals::Ssstatus) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[must_use]
            #[inline(always)]
            pub const fn trcreset(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[inline(always)]
            pub const fn set_trcreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[must_use]
            #[inline(always)]
            pub const fn trcerr(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[inline(always)]
            pub const fn set_trcerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel0_s(&self) -> super::vals::Exlevel0S {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Exlevel0S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn set_exlevel0_s(&mut self, val: super::vals::Exlevel0S) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel1_s(&self) -> super::vals::Exlevel1S {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Exlevel1S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn set_exlevel1_s(&mut self, val: super::vals::Exlevel1S) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel2_s(&self) -> super::vals::Exlevel2S {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Exlevel2S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn set_exlevel2_s(&mut self, val: super::vals::Exlevel2S) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel3_s(&self) -> super::vals::Exlevel3S {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Exlevel3S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn set_exlevel3_s(&mut self, val: super::vals::Exlevel3S) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel0_ns(&self) -> super::vals::Exlevel0Ns {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Exlevel0Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn set_exlevel0_ns(&mut self, val: super::vals::Exlevel0Ns) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel1_ns(&self) -> super::vals::Exlevel1Ns {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Exlevel1Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn set_exlevel1_ns(&mut self, val: super::vals::Exlevel1Ns) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel2_ns(&self) -> super::vals::Exlevel2Ns {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Exlevel2Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn set_exlevel2_ns(&mut self, val: super::vals::Exlevel2Ns) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[must_use]
            #[inline(always)]
            pub const fn exlevel3_ns(&self) -> super::vals::Exlevel3Ns {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Exlevel3Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn set_exlevel3_ns(&mut self, val: super::vals::Exlevel3Ns) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvictlr {
            #[inline(always)]
            fn default() -> Trcvictlr {
                Trcvictlr(0)
            }
        }
        impl core::fmt::Debug for Trcvictlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvictlr")
                    .field("event_sel", &self.event_sel())
                    .field("ssstatus", &self.ssstatus())
                    .field("trcreset", &self.trcreset())
                    .field("trcerr", &self.trcerr())
                    .field("exlevel0_s", &self.exlevel0_s())
                    .field("exlevel1_s", &self.exlevel1_s())
                    .field("exlevel2_s", &self.exlevel2_s())
                    .field("exlevel3_s", &self.exlevel3_s())
                    .field("exlevel0_ns", &self.exlevel0_ns())
                    .field("exlevel1_ns", &self.exlevel1_ns())
                    .field("exlevel2_ns", &self.exlevel2_ns())
                    .field("exlevel3_ns", &self.exlevel3_ns())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvictlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvictlr {{ event_sel: {:?}, ssstatus: {:?}, trcreset: {=bool:?}, trcerr: {=bool:?}, exlevel0_s: {:?}, exlevel1_s: {:?}, exlevel2_s: {:?}, exlevel3_s: {:?}, exlevel0_ns: {:?}, exlevel1_ns: {:?}, exlevel2_ns: {:?}, exlevel3_ns: {:?} }}" , self . event_sel () , self . ssstatus () , self . trcreset () , self . trcerr () , self . exlevel0_s () , self . exlevel1_s () , self . exlevel2_s () , self . exlevel3_s () , self . exlevel0_ns () , self . exlevel1_ns () , self . exlevel2_ns () , self . exlevel3_ns ())
            }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcviiectlr(pub u32);
        impl Trcviiectlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[must_use]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[must_use]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcviiectlr {
            #[inline(always)]
            fn default() -> Trcviiectlr {
                Trcviiectlr(0)
            }
        }
        impl core::fmt::Debug for Trcviiectlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcviiectlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcviiectlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcviiectlr {{ include_0: {=bool:?}, include_1: {=bool:?}, include_2: {=bool:?}, include_3: {=bool:?}, include_4: {=bool:?}, include_5: {=bool:?}, include_6: {=bool:?}, include_7: {=bool:?}, exclude_0: {=bool:?}, exclude_1: {=bool:?}, exclude_2: {=bool:?}, exclude_3: {=bool:?}, exclude_4: {=bool:?}, exclude_5: {=bool:?}, exclude_6: {=bool:?}, exclude_7: {=bool:?} }}" , self . include_0 () , self . include_1 () , self . include_2 () , self . include_3 () , self . include_4 () , self . include_5 () , self . include_6 () , self . include_7 () , self . exclude_0 () , self . exclude_1 () , self . exclude_2 () , self . exclude_3 () , self . exclude_4 () , self . exclude_5 () , self . exclude_6 () , self . exclude_7 ())
            }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvipcssctlr(pub u32);
        impl Trcvipcssctlr {
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[must_use]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[must_use]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvipcssctlr {
            #[inline(always)]
            fn default() -> Trcvipcssctlr {
                Trcvipcssctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvipcssctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvipcssctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvipcssctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvipcssctlr {{ start_0: {=bool:?}, start_1: {=bool:?}, start_2: {=bool:?}, start_3: {=bool:?}, start_4: {=bool:?}, start_5: {=bool:?}, start_6: {=bool:?}, start_7: {=bool:?}, stop_0: {=bool:?}, stop_1: {=bool:?}, stop_2: {=bool:?}, stop_3: {=bool:?}, stop_4: {=bool:?}, stop_5: {=bool:?}, stop_6: {=bool:?}, stop_7: {=bool:?} }}" , self . start_0 () , self . start_1 () , self . start_2 () , self . start_3 () , self . start_4 () , self . start_5 () , self . start_6 () , self . start_7 () , self . stop_0 () , self . stop_1 () , self . stop_2 () , self . stop_3 () , self . stop_4 () , self . stop_5 () , self . stop_6 () , self . stop_7 ())
            }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvissctlr(pub u32);
        impl Trcvissctlr {
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[must_use]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[must_use]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvissctlr {
            #[inline(always)]
            fn default() -> Trcvissctlr {
                Trcvissctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvissctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvissctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvissctlr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Trcvissctlr {{ start_0: {=bool:?}, start_1: {=bool:?}, start_2: {=bool:?}, start_3: {=bool:?}, start_4: {=bool:?}, start_5: {=bool:?}, start_6: {=bool:?}, start_7: {=bool:?}, stop_0: {=bool:?}, stop_1: {=bool:?}, stop_2: {=bool:?}, stop_3: {=bool:?}, stop_4: {=bool:?}, stop_5: {=bool:?}, stop_6: {=bool:?}, stop_7: {=bool:?} }}" , self . start_0 () , self . start_1 () , self . start_2 () , self . start_3 () , self . start_4 () , self . start_5 () , self . start_6 () , self . start_7 () , self . stop_0 () , self . stop_1 () , self . stop_2 () , self . stop_3 () , self . stop_4 () , self . stop_5 () , self . stop_6 () , self . stop_7 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Archid(u16);
        impl Archid {
            #[doc = "Component is an ETMv4 component"]
            pub const ETMV42: Self = Self(0x4a13);
        }
        impl Archid {
            pub const fn from_bits(val: u16) -> Archid {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Archid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x4a13 => f.write_str("ETMV42"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Archid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x4a13 => defmt::write!(f, "ETMV42"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Archid {
            #[inline(always)]
            fn from(val: u16) -> Archid {
                Archid::from_bits(val)
            }
        }
        impl From<Archid> for u16 {
            #[inline(always)]
            fn from(val: Archid) -> u16 {
                Archid::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Architect(u16);
        impl Architect {
            #[doc = "This peripheral was architected by Arm."]
            pub const ARM: Self = Self(0x023b);
        }
        impl Architect {
            pub const fn from_bits(val: u16) -> Architect {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Architect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x023b => f.write_str("ARM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Architect {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x023b => defmt::write!(f, "ARM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Architect {
            #[inline(always)]
            fn from(val: u16) -> Architect {
                Architect::from_bits(val)
            }
        }
        impl From<Architect> for u16 {
            #[inline(always)]
            fn from(val: Architect) -> u16 {
                Architect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr0 {
            #[inline(always)]
            fn from(val: u8) -> Clr0 {
                Clr0::from_bits(val)
            }
        }
        impl From<Clr0> for u8 {
            #[inline(always)]
            fn from(val: Clr0) -> u8 {
                Clr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr1 {
            #[inline(always)]
            fn from(val: u8) -> Clr1 {
                Clr1::from_bits(val)
            }
        }
        impl From<Clr1> for u8 {
            #[inline(always)]
            fn from(val: Clr1) -> u8 {
                Clr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr2 {
            #[inline(always)]
            fn from(val: u8) -> Clr2 {
                Clr2::from_bits(val)
            }
        }
        impl From<Clr2> for u8 {
            #[inline(always)]
            fn from(val: Clr2) -> u8 {
                Clr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr3 {
            #[inline(always)]
            fn from(val: u8) -> Clr3 {
                Clr3::from_bits(val)
            }
        }
        impl From<Clr3> for u8 {
            #[inline(always)]
            fn from(val: Clr3) -> u8 {
                Clr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cond {
            #[doc = "Conditional instruction tracing is disabled."]
            DISABLED = 0x0,
            #[doc = "Conditional load instructions are traced."]
            LOAD_ONLY = 0x01,
            #[doc = "Conditional store instructions are traced."]
            STORE_ONLY = 0x02,
            #[doc = "Conditional load and store instructions are traced."]
            LOAD_AND_STORE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "All conditional instructions are traced."]
            ALL = 0x07,
        }
        impl Cond {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cond {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cond {
            #[inline(always)]
            fn from(val: u8) -> Cond {
                Cond::from_bits(val)
            }
        }
        impl From<Cond> for u8 {
            #[inline(always)]
            fn from(val: Cond) -> u8 {
                Cond::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EventSel {
            #[doc = "This event is not filtered."]
            DISABLED = 0x0,
            #[doc = "This event is filtered."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl EventSel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EventSel {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EventSel {
            #[inline(always)]
            fn from(val: u8) -> EventSel {
                EventSel::from_bits(val)
            }
        }
        impl From<EventSel> for u8 {
            #[inline(always)]
            fn from(val: EventSel) -> u8 {
                EventSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0Ns {
                Exlevel0Ns::from_bits(val)
            }
        }
        impl From<Exlevel0Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0Ns) -> u8 {
                Exlevel0Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0S {
                Exlevel0S::from_bits(val)
            }
        }
        impl From<Exlevel0S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0S) -> u8 {
                Exlevel0S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1Ns {
                Exlevel1Ns::from_bits(val)
            }
        }
        impl From<Exlevel1Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1Ns) -> u8 {
                Exlevel1Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1S {
                Exlevel1S::from_bits(val)
            }
        }
        impl From<Exlevel1S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1S) -> u8 {
                Exlevel1S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2Ns {
                Exlevel2Ns::from_bits(val)
            }
        }
        impl From<Exlevel2Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2Ns) -> u8 {
                Exlevel2Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2S {
                Exlevel2S::from_bits(val)
            }
        }
        impl From<Exlevel2S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2S) -> u8 {
                Exlevel2S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3Ns {
                Exlevel3Ns::from_bits(val)
            }
        }
        impl From<Exlevel3Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3Ns) -> u8 {
                Exlevel3Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3S {
                Exlevel3S::from_bits(val)
            }
        }
        impl From<Exlevel3S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3S) -> u8 {
                Exlevel3S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Level {
            #[doc = "Zero invasion. This setting has a greater risk of a FIFO overflow"]
            MIN = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Maximum invasion occurs but there is less risk of a FIFO overflow."]
            MAX = 0x0f,
        }
        impl Level {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Level {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Level {
            #[inline(always)]
            fn from(val: u8) -> Level {
                Level::from_bits(val)
            }
        }
        impl From<Level> for u8 {
            #[inline(always)]
            fn from(val: Level) -> u8 {
                Level::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Peripheral is a trace source."]
            TRACE_SOURCE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Exclude mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit cannot generate Q elements. If no ranges are selected, Q elements are permitted across the entire memory map."]
            EXCLUDE = 0x0,
            #[doc = "Include mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit can generate Q elements. If all the implemented bits in RANGE are set to 0 then Q elements are disabled."]
            INCLUDE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcrel {
            #[doc = "The trace unit does not affect the tracing of PC-relative transfers."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not trace the address or value portions of PC-relative transfers."]
            DISABLED = 0x01,
        }
        impl Pcrel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcrel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcrel {
            #[inline(always)]
            fn from(val: u8) -> Pcrel {
                Pcrel::from_bits(val)
            }
        }
        impl From<Pcrel> for u8 {
            #[inline(always)]
            fn from(val: Pcrel) -> u8 {
                Pcrel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Period {
            #[doc = "Trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request."]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Period {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Period {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Period {
            #[inline(always)]
            fn from(val: u8) -> Period {
                Period::from_bits(val)
            }
        }
        impl From<Period> for u8 {
            #[inline(always)]
            fn from(val: Period) -> u8 {
                Period::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "The register is not implemented."]
            ABSENT = 0x0,
            #[doc = "The register is implemented."]
            PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Qe {
            #[doc = "Q elements are disabled."]
            DISABLED = 0x0,
            #[doc = "Q elements with instruction counts are enabled. Q elements without instruction counts are disabled."]
            ONLY_WITHOUT_INST_COUNTS = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Q elements with and without instruction counts are enabled."]
            ENABLED = 0x03,
        }
        impl Qe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Qe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Qe {
            #[inline(always)]
            fn from(val: u8) -> Qe {
                Qe::from_bits(val)
            }
        }
        impl From<Qe> for u8 {
            #[inline(always)]
            fn from(val: Qe) -> u8 {
                Qe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Revision {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Component is part of architecture 4.2"]
            V2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Revision {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Revision {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Revision {
            #[inline(always)]
            fn from(val: u8) -> Revision {
                Revision::from_bits(val)
            }
        }
        impl From<Revision> for u8 {
            #[inline(always)]
            fn from(val: Revision) -> u8 {
                Revision::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set0 {
            #[inline(always)]
            fn from(val: u8) -> Set0 {
                Set0::from_bits(val)
            }
        }
        impl From<Set0> for u8 {
            #[inline(always)]
            fn from(val: Set0) -> u8 {
                Set0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set1 {
            #[inline(always)]
            fn from(val: u8) -> Set1 {
                Set1::from_bits(val)
            }
        }
        impl From<Set1> for u8 {
            #[inline(always)]
            fn from(val: Set1) -> u8 {
                Set1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set2 {
            #[inline(always)]
            fn from(val: u8) -> Set2 {
                Set2::from_bits(val)
            }
        }
        impl From<Set2> for u8 {
            #[inline(always)]
            fn from(val: Set2) -> u8 {
                Set2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set3 {
            #[inline(always)]
            fn from(val: u8) -> Set3 {
                Set3::from_bits(val)
            }
        }
        impl From<Set3> for u8 {
            #[inline(always)]
            fn from(val: Set3) -> u8 {
                Set3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprel {
            #[doc = "The trace unit does not affect the tracing of SP-relative transfers."]
            ENABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "The trace unit does not trace the address portion of SP-relative transfers. If data value tracing is enabled then the trace unit generates a P1 data address element."]
            DATA_ONLY = 0x02,
            #[doc = "The trace unit does not trace the address or value portions of SP-relative transfers."]
            DISABLED = 0x03,
        }
        impl Sprel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprel {
            #[inline(always)]
            fn from(val: u8) -> Sprel {
                Sprel::from_bits(val)
            }
        }
        impl From<Sprel> for u8 {
            #[inline(always)]
            fn from(val: Sprel) -> u8 {
                Sprel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssstatus {
            #[doc = "The start/stop logic is in the stopped state."]
            STOPPED = 0x0,
            #[doc = "The start/stop logic is in the started state."]
            STARTED = 0x01,
        }
        impl Ssstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssstatus {
            #[inline(always)]
            fn from(val: u8) -> Ssstatus {
                Ssstatus::from_bits(val)
            }
        }
        impl From<Ssstatus> for u8 {
            #[inline(always)]
            fn from(val: Ssstatus) -> u8 {
                Ssstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "The sequencer is in state 0."]
            STATE0 = 0x0,
            #[doc = "The sequencer is in state 1."]
            STATE1 = 0x01,
            #[doc = "The sequencer is in state 2."]
            STATE2 = 0x02,
            #[doc = "The sequencer is in state 3."]
            STATE3 = 0x03,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a processor trace source."]
            PROCESSOR_TRACE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbi {
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bit\\[55\\] of the data address, that is, it sign-extends the value."]
            SIGN_EXTEND = 0x0,
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bits\\[63:56\\] of the data address."]
            COPY = 0x01,
        }
        impl Tbi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbi {
            #[inline(always)]
            fn from(val: u8) -> Tbi {
                Tbi::from_bits(val)
            }
        }
        impl From<Tbi> for u8 {
            #[inline(always)]
            fn from(val: Tbi) -> u8 {
                Tbi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vmidopt {
            #[doc = "VTTBR_EL2.VMID is used. If the trace unit supports a Virtual context identifier larger than the VTTBR_EL2.VMID, the upper unused bits are always zero. If the trace unit supports a Virtual context identifier larger than 8 bits and if the VTCR_EL2.VS bit forces use of an 8-bit Virtual context identifier, bits \\[15:8\\] of the trace unit Virtual context identifier are always zero."]
            VTTBR_EL2 = 0x0,
            #[doc = "CONTEXTIDR_EL2 is used."]
            CONTEXTIDR_EL2 = 0x01,
        }
        impl Vmidopt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vmidopt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vmidopt {
            #[inline(always)]
            fn from(val: u8) -> Vmidopt {
                Vmidopt::from_bits(val)
            }
        }
        impl From<Vmidopt> for u8 {
            #[inline(always)]
            fn from(val: Vmidopt) -> u8 {
                Vmidopt::to_bits(val)
            }
        }
    }
}
pub mod ficr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ficr {
        ptr: *mut u8,
    }
    unsafe impl Send for Ficr {}
    unsafe impl Sync for Ficr {}
    impl Ficr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Device info"]
        #[inline(always)]
        pub const fn info(self) -> Info {
            unsafe { Info::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Description collection: Common encryption root key, word n"]
        #[inline(always)]
        pub const fn er(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Common identity root key, word n"]
        #[inline(always)]
        pub const fn ir(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0390usize + n * 4usize) as _) }
        }
        #[doc = "Device address type"]
        #[inline(always)]
        pub const fn deviceaddrtype(
            self,
        ) -> crate::common::Reg<regs::Deviceaddrtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03a0usize) as _) }
        }
        #[doc = "Description collection: Device address n"]
        #[inline(always)]
        pub const fn deviceaddr(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03a4usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trimcnf(self, n: usize) -> Trimcnf {
            assert!(n < 64usize);
            unsafe { Trimcnf::from_ptr(self.ptr.add(0x0400usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfc(self) -> Nfc {
            unsafe { Nfc::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32mtrim(self) -> crate::common::Reg<regs::Xosc32mtrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0620usize) as _) }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32ktrim(self) -> crate::common::Reg<regs::Xosc32ktrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0624usize) as _) }
        }
    }
    #[doc = "Device info"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Info {
        ptr: *mut u8,
    }
    unsafe impl Send for Info {}
    unsafe impl Sync for Info {}
    impl Info {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration identifier"]
        #[inline(always)]
        pub const fn configid(self) -> crate::common::Reg<regs::Configid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: Device identifier"]
        #[inline(always)]
        pub const fn deviceid(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: 128-bit Universally Unique IDentifier (UUID)."]
        #[inline(always)]
        pub const fn uuid(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
        #[doc = "Part code"]
        #[inline(always)]
        pub const fn part(self) -> crate::common::Reg<regs::Part, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[inline(always)]
        pub const fn variant(self) -> crate::common::Reg<regs::Variant, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Package option"]
        #[inline(always)]
        pub const fn package(self) -> crate::common::Reg<regs::Package, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "RAM size (KB)"]
        #[inline(always)]
        pub const fn ram(self) -> crate::common::Reg<regs::Ram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "RRAM size (KB)"]
        #[inline(always)]
        pub const fn rram(self) -> crate::common::Reg<regs::Rram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfc {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfc {}
    unsafe impl Sync for Nfc {}
    impl Nfc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader0(self) -> crate::common::Reg<regs::Tagheader0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader1(self) -> crate::common::Reg<regs::Tagheader1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader2(self) -> crate::common::Reg<regs::Tagheader2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader3(self) -> crate::common::Reg<regs::Tagheader3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trimcnf {
        ptr: *mut u8,
    }
    unsafe impl Send for Trimcnf {}
    unsafe impl Sync for Trimcnf {}
    impl Trimcnf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Address of the register which will be written"]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Data to be written into the register"]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration identifier"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Configid(pub u32);
        impl Configid {
            #[doc = "Identification number for the HW"]
            #[must_use]
            #[inline(always)]
            pub const fn hwid(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Identification number for the HW"]
            #[inline(always)]
            pub const fn set_hwid(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Configid {
            #[inline(always)]
            fn default() -> Configid {
                Configid(0)
            }
        }
        impl core::fmt::Debug for Configid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Configid")
                    .field("hwid", &self.hwid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Configid {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Configid {{ hwid: {=u16:?} }}", self.hwid())
            }
        }
        #[doc = "Device address type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Deviceaddrtype(pub u32);
        impl Deviceaddrtype {
            #[doc = "Device address type"]
            #[must_use]
            #[inline(always)]
            pub const fn deviceaddrtype(&self) -> super::vals::Deviceaddrtype {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Deviceaddrtype::from_bits(val as u8)
            }
            #[doc = "Device address type"]
            #[inline(always)]
            pub const fn set_deviceaddrtype(&mut self, val: super::vals::Deviceaddrtype) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Deviceaddrtype {
            #[inline(always)]
            fn default() -> Deviceaddrtype {
                Deviceaddrtype(0)
            }
        }
        impl core::fmt::Debug for Deviceaddrtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Deviceaddrtype")
                    .field("deviceaddrtype", &self.deviceaddrtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Deviceaddrtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Deviceaddrtype {{ deviceaddrtype: {:?} }}",
                    self.deviceaddrtype()
                )
            }
        }
        #[doc = "Package option"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Package(pub u32);
        impl Package {
            #[doc = "Package option"]
            #[must_use]
            #[inline(always)]
            pub const fn package(&self) -> super::vals::Package {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Package::from_bits(val as u32)
            }
            #[doc = "Package option"]
            #[inline(always)]
            pub const fn set_package(&mut self, val: super::vals::Package) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Package {
            #[inline(always)]
            fn default() -> Package {
                Package(0)
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Package")
                    .field("package", &self.package())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Package {{ package: {:?} }}", self.package())
            }
        }
        #[doc = "Part code"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Part(pub u32);
        impl Part {
            #[doc = "Part code"]
            #[must_use]
            #[inline(always)]
            pub const fn part(&self) -> super::vals::Part {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Part::from_bits(val as u32)
            }
            #[doc = "Part code"]
            #[inline(always)]
            pub const fn set_part(&mut self, val: super::vals::Part) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Part {
            #[inline(always)]
            fn default() -> Part {
                Part(0)
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Part").field("part", &self.part()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Part {{ part: {:?} }}", self.part())
            }
        }
        #[doc = "RAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ram(pub u32);
        impl Ram {
            #[doc = "RAM size (KB)"]
            #[must_use]
            #[inline(always)]
            pub const fn ram(&self) -> super::vals::Ram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Ram::from_bits(val as u32)
            }
            #[doc = "RAM size (KB)"]
            #[inline(always)]
            pub const fn set_ram(&mut self, val: super::vals::Ram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ram {
            #[inline(always)]
            fn default() -> Ram {
                Ram(0)
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ram").field("ram", &self.ram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ram {{ ram: {:?} }}", self.ram())
            }
        }
        #[doc = "RRAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rram(pub u32);
        impl Rram {
            #[doc = "RRAM size (KB)"]
            #[must_use]
            #[inline(always)]
            pub const fn rram(&self) -> super::vals::Rram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rram::from_bits(val as u32)
            }
            #[doc = "RRAM size (KB)"]
            #[inline(always)]
            pub const fn set_rram(&mut self, val: super::vals::Rram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rram {
            #[inline(always)]
            fn default() -> Rram {
                Rram(0)
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rram").field("rram", &self.rram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rram {{ rram: {:?} }}", self.rram())
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader0(pub u32);
        impl Tagheader0 {
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[must_use]
            #[inline(always)]
            pub const fn mfgid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[inline(always)]
            pub const fn set_mfgid(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ud1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 1"]
            #[inline(always)]
            pub const fn set_ud1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ud2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 2"]
            #[inline(always)]
            pub const fn set_ud2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ud3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 3"]
            #[inline(always)]
            pub const fn set_ud3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader0 {
            #[inline(always)]
            fn default() -> Tagheader0 {
                Tagheader0(0)
            }
        }
        impl core::fmt::Debug for Tagheader0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader0")
                    .field("mfgid", &self.mfgid())
                    .field("ud1", &self.ud1())
                    .field("ud2", &self.ud2())
                    .field("ud3", &self.ud3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader0 {{ mfgid: {=u8:?}, ud1: {=u8:?}, ud2: {=u8:?}, ud3: {=u8:?} }}",
                    self.mfgid(),
                    self.ud1(),
                    self.ud2(),
                    self.ud3()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader1(pub u32);
        impl Tagheader1 {
            #[doc = "Unique identifier byte 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ud4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 4"]
            #[inline(always)]
            pub const fn set_ud4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ud5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 5"]
            #[inline(always)]
            pub const fn set_ud5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ud6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 6"]
            #[inline(always)]
            pub const fn set_ud6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ud7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 7"]
            #[inline(always)]
            pub const fn set_ud7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader1 {
            #[inline(always)]
            fn default() -> Tagheader1 {
                Tagheader1(0)
            }
        }
        impl core::fmt::Debug for Tagheader1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader1")
                    .field("ud4", &self.ud4())
                    .field("ud5", &self.ud5())
                    .field("ud6", &self.ud6())
                    .field("ud7", &self.ud7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader1 {{ ud4: {=u8:?}, ud5: {=u8:?}, ud6: {=u8:?}, ud7: {=u8:?} }}",
                    self.ud4(),
                    self.ud5(),
                    self.ud6(),
                    self.ud7()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader2(pub u32);
        impl Tagheader2 {
            #[doc = "Unique identifier byte 8"]
            #[must_use]
            #[inline(always)]
            pub const fn ud8(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 8"]
            #[inline(always)]
            pub const fn set_ud8(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 9"]
            #[must_use]
            #[inline(always)]
            pub const fn ud9(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 9"]
            #[inline(always)]
            pub const fn set_ud9(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 10"]
            #[must_use]
            #[inline(always)]
            pub const fn ud10(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 10"]
            #[inline(always)]
            pub const fn set_ud10(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 11"]
            #[must_use]
            #[inline(always)]
            pub const fn ud11(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 11"]
            #[inline(always)]
            pub const fn set_ud11(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader2 {
            #[inline(always)]
            fn default() -> Tagheader2 {
                Tagheader2(0)
            }
        }
        impl core::fmt::Debug for Tagheader2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader2")
                    .field("ud8", &self.ud8())
                    .field("ud9", &self.ud9())
                    .field("ud10", &self.ud10())
                    .field("ud11", &self.ud11())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader2 {{ ud8: {=u8:?}, ud9: {=u8:?}, ud10: {=u8:?}, ud11: {=u8:?} }}",
                    self.ud8(),
                    self.ud9(),
                    self.ud10(),
                    self.ud11()
                )
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader3(pub u32);
        impl Tagheader3 {
            #[doc = "Unique identifier byte 12"]
            #[must_use]
            #[inline(always)]
            pub const fn ud12(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 12"]
            #[inline(always)]
            pub const fn set_ud12(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 13"]
            #[must_use]
            #[inline(always)]
            pub const fn ud13(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 13"]
            #[inline(always)]
            pub const fn set_ud13(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 14"]
            #[must_use]
            #[inline(always)]
            pub const fn ud14(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 14"]
            #[inline(always)]
            pub const fn set_ud14(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 15"]
            #[must_use]
            #[inline(always)]
            pub const fn ud15(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 15"]
            #[inline(always)]
            pub const fn set_ud15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader3 {
            #[inline(always)]
            fn default() -> Tagheader3 {
                Tagheader3(0)
            }
        }
        impl core::fmt::Debug for Tagheader3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader3")
                    .field("ud12", &self.ud12())
                    .field("ud13", &self.ud13())
                    .field("ud14", &self.ud14())
                    .field("ud15", &self.ud15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader3 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Tagheader3 {{ ud12: {=u8:?}, ud13: {=u8:?}, ud14: {=u8:?}, ud15: {=u8:?} }}",
                    self.ud12(),
                    self.ud13(),
                    self.ud14(),
                    self.ud15()
                )
            }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Variant(pub u32);
        impl Variant {
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[must_use]
            #[inline(always)]
            pub const fn variant(&self) -> super::vals::Variant {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Variant::from_bits(val as u32)
            }
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[inline(always)]
            pub const fn set_variant(&mut self, val: super::vals::Variant) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Variant {
            #[inline(always)]
            fn default() -> Variant {
                Variant(0)
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Variant")
                    .field("variant", &self.variant())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Variant {{ variant: {:?} }}", self.variant())
            }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32ktrim(pub u32);
        impl Xosc32ktrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[must_use]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[must_use]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32ktrim {
            #[inline(always)]
            fn default() -> Xosc32ktrim {
                Xosc32ktrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32ktrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32ktrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32ktrim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Xosc32ktrim {{ slope: {=u16:?}, offset: {=u16:?} }}",
                    self.slope(),
                    self.offset()
                )
            }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32mtrim(pub u32);
        impl Xosc32mtrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[must_use]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[must_use]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32mtrim {
            #[inline(always)]
            fn default() -> Xosc32mtrim {
                Xosc32mtrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32mtrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32mtrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32mtrim {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Xosc32mtrim {{ slope: {=u16:?}, offset: {=u16:?} }}",
                    self.slope(),
                    self.offset()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Deviceaddrtype {
            #[doc = "Public address"]
            PUBLIC = 0x0,
            #[doc = "Random address"]
            RANDOM = 0x01,
        }
        impl Deviceaddrtype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Deviceaddrtype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Deviceaddrtype {
            #[inline(always)]
            fn from(val: u8) -> Deviceaddrtype {
                Deviceaddrtype::from_bits(val)
            }
        }
        impl From<Deviceaddrtype> for u8 {
            #[inline(always)]
            fn from(val: Deviceaddrtype) -> u8 {
                Deviceaddrtype::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Package(u32);
        impl Package {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Package {
            pub const fn from_bits(val: u32) -> Package {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Package {
            #[inline(always)]
            fn from(val: u32) -> Package {
                Package::from_bits(val)
            }
        }
        impl From<Package> for u32 {
            #[inline(always)]
            fn from(val: Package) -> u32 {
                Package::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Part(u32);
        impl Part {
            #[doc = "nRF54L15"]
            pub const N54L15: Self = Self(0x0005_4b15);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Part {
            pub const fn from_bits(val: u32) -> Part {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0005_4b15 => f.write_str("N54L15"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0005_4b15 => defmt::write!(f, "N54L15"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Part {
            #[inline(always)]
            fn from(val: u32) -> Part {
                Part::from_bits(val)
            }
        }
        impl From<Part> for u32 {
            #[inline(always)]
            fn from(val: Part) -> u32 {
                Part::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ram(u32);
        impl Ram {
            #[doc = "256 kByte RAM"]
            pub const K256: Self = Self(0x0100);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Ram {
            pub const fn from_bits(val: u32) -> Ram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("K256"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "K256"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Ram {
            #[inline(always)]
            fn from(val: u32) -> Ram {
                Ram::from_bits(val)
            }
        }
        impl From<Ram> for u32 {
            #[inline(always)]
            fn from(val: Ram) -> u32 {
                Ram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rram(u32);
        impl Rram {
            #[doc = "1524 KByte RRAM"]
            pub const K1524: Self = Self(0x05f4);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Rram {
            pub const fn from_bits(val: u32) -> Rram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x05f4 => f.write_str("K1524"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x05f4 => defmt::write!(f, "K1524"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rram {
            #[inline(always)]
            fn from(val: u32) -> Rram {
                Rram::from_bits(val)
            }
        }
        impl From<Rram> for u32 {
            #[inline(always)]
            fn from(val: Rram) -> u32 {
                Rram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Variant(u32);
        impl Variant {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Variant {
            pub const fn from_bits(val: u32) -> Variant {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Variant {
            #[inline(always)]
            fn from(val: u32) -> Variant {
                Variant::from_bits(val)
            }
        }
        impl From<Variant> for u32 {
            #[inline(always)]
            fn from(val: Variant) -> u32 {
                Variant::to_bits(val)
            }
        }
    }
}
pub mod glitchdet {
    #[doc = "Voltage glitch detectors"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchdet {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchdet {}
    unsafe impl Sync for Glitchdet {}
    impl Glitchdet {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration for glitch detector"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration for glitch detector"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable glitch detector"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable glitch detector"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Glitch detector mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Glitch detector mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable", &self.enable())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ enable: {=bool:?}, mode: {:?} }}",
                    self.enable(),
                    self.mode()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "High pass filter mode"]
            HIGH_PASS_FILTER = 0x0,
            #[doc = "Cap divider mode"]
            CAP_DIV = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Write GPIO port"]
        #[inline(always)]
        pub const fn out(self) -> crate::common::Reg<regs::Out, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outset(self) -> crate::common::Reg<regs::Outset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outclr(self) -> crate::common::Reg<regs::Outclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read GPIO port"]
        #[inline(always)]
        pub const fn in_(self) -> crate::common::Reg<regs::In, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Direction of GPIO pins"]
        #[inline(always)]
        pub const fn dir(self) -> crate::common::Reg<regs::Dir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DIR set register"]
        #[inline(always)]
        pub const fn dirset(self) -> crate::common::Reg<regs::Dirset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DIR clear register"]
        #[inline(always)]
        pub const fn dirclr(self) -> crate::common::Reg<regs::Dirclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[inline(always)]
        pub const fn latch(self) -> crate::common::Reg<regs::Latch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[inline(always)]
        pub const fn detectmode(self) -> crate::common::Reg<regs::Detectmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[inline(always)]
        pub const fn pin_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PinCnf, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Detectmode(pub u32);
        impl Detectmode {
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[must_use]
            #[inline(always)]
            pub const fn detectmode(&self) -> super::vals::Detectmode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detectmode::from_bits(val as u8)
            }
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub const fn set_detectmode(&mut self, val: super::vals::Detectmode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Detectmode {
            #[inline(always)]
            fn default() -> Detectmode {
                Detectmode(0)
            }
        }
        impl core::fmt::Debug for Detectmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Detectmode")
                    .field("detectmode", &self.detectmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Detectmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Detectmode {{ detectmode: {:?} }}", self.detectmode())
            }
        }
        #[doc = "Direction of GPIO pins"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dir(pub u32);
        impl Dir {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> super::vals::Dir {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: super::vals::Dir) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
            }
        }
        impl Default for Dir {
            #[inline(always)]
            fn default() -> Dir {
                Dir(0)
            }
        }
        impl core::fmt::Debug for Dir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dir")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dir {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dir {{ pin[0]: {:?}, pin[1]: {:?}, pin[2]: {:?}, pin[3]: {:?}, pin[4]: {:?}, pin[5]: {:?}, pin[6]: {:?}, pin[7]: {:?}, pin[8]: {:?}, pin[9]: {:?}, pin[10]: {:?}, pin[11]: {:?}, pin[12]: {:?}, pin[13]: {:?}, pin[14]: {:?}, pin[15]: {:?}, pin[16]: {:?}, pin[17]: {:?}, pin[18]: {:?}, pin[19]: {:?}, pin[20]: {:?}, pin[21]: {:?}, pin[22]: {:?}, pin[23]: {:?}, pin[24]: {:?}, pin[25]: {:?}, pin[26]: {:?}, pin[27]: {:?}, pin[28]: {:?}, pin[29]: {:?}, pin[30]: {:?}, pin[31]: {:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR clear register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirclr(pub u32);
        impl Dirclr {
            #[doc = "Set as input pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as input pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirclr {
            #[inline(always)]
            fn default() -> Dirclr {
                Dirclr(0)
            }
        }
        impl core::fmt::Debug for Dirclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "DIR set register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirset(pub u32);
        impl Dirset {
            #[doc = "Set as output pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as output pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirset {
            #[inline(always)]
            fn default() -> Dirset {
                Dirset(0)
            }
        }
        impl core::fmt::Debug for Dirset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dirset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Read GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct In(pub u32);
        impl In {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for In {
            #[inline(always)]
            fn default() -> In {
                In(0)
            }
        }
        impl core::fmt::Debug for In {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("In")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for In {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "In {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Latch(pub u32);
        impl Latch {
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Latch {
            #[inline(always)]
            fn default() -> Latch {
                Latch(0)
            }
        }
        impl core::fmt::Debug for Latch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Latch")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Latch {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Latch {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Write GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Out(pub u32);
        impl Out {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Out {
            #[inline(always)]
            fn default() -> Out {
                Out(0)
            }
        }
        impl core::fmt::Debug for Out {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Out")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Out {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Out {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outclr(pub u32);
        impl Outclr {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outclr {
            #[inline(always)]
            fn default() -> Outclr {
                Outclr(0)
            }
        }
        impl core::fmt::Debug for Outclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outclr")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outclr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outclr {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outset(pub u32);
        impl Outset {
            #[doc = "Pin 0"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outset {
            #[inline(always)]
            fn default() -> Outset {
                Outset(0)
            }
        }
        impl core::fmt::Debug for Outset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outset")
                    .field("pin[0]", &self.pin(0usize))
                    .field("pin[1]", &self.pin(1usize))
                    .field("pin[2]", &self.pin(2usize))
                    .field("pin[3]", &self.pin(3usize))
                    .field("pin[4]", &self.pin(4usize))
                    .field("pin[5]", &self.pin(5usize))
                    .field("pin[6]", &self.pin(6usize))
                    .field("pin[7]", &self.pin(7usize))
                    .field("pin[8]", &self.pin(8usize))
                    .field("pin[9]", &self.pin(9usize))
                    .field("pin[10]", &self.pin(10usize))
                    .field("pin[11]", &self.pin(11usize))
                    .field("pin[12]", &self.pin(12usize))
                    .field("pin[13]", &self.pin(13usize))
                    .field("pin[14]", &self.pin(14usize))
                    .field("pin[15]", &self.pin(15usize))
                    .field("pin[16]", &self.pin(16usize))
                    .field("pin[17]", &self.pin(17usize))
                    .field("pin[18]", &self.pin(18usize))
                    .field("pin[19]", &self.pin(19usize))
                    .field("pin[20]", &self.pin(20usize))
                    .field("pin[21]", &self.pin(21usize))
                    .field("pin[22]", &self.pin(22usize))
                    .field("pin[23]", &self.pin(23usize))
                    .field("pin[24]", &self.pin(24usize))
                    .field("pin[25]", &self.pin(25usize))
                    .field("pin[26]", &self.pin(26usize))
                    .field("pin[27]", &self.pin(27usize))
                    .field("pin[28]", &self.pin(28usize))
                    .field("pin[29]", &self.pin(29usize))
                    .field("pin[30]", &self.pin(30usize))
                    .field("pin[31]", &self.pin(31usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outset {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Outset {{ pin[0]: {=bool:?}, pin[1]: {=bool:?}, pin[2]: {=bool:?}, pin[3]: {=bool:?}, pin[4]: {=bool:?}, pin[5]: {=bool:?}, pin[6]: {=bool:?}, pin[7]: {=bool:?}, pin[8]: {=bool:?}, pin[9]: {=bool:?}, pin[10]: {=bool:?}, pin[11]: {=bool:?}, pin[12]: {=bool:?}, pin[13]: {=bool:?}, pin[14]: {=bool:?}, pin[15]: {=bool:?}, pin[16]: {=bool:?}, pin[17]: {=bool:?}, pin[18]: {=bool:?}, pin[19]: {=bool:?}, pin[20]: {=bool:?}, pin[21]: {=bool:?}, pin[22]: {=bool:?}, pin[23]: {=bool:?}, pin[24]: {=bool:?}, pin[25]: {=bool:?}, pin[26]: {=bool:?}, pin[27]: {=bool:?}, pin[28]: {=bool:?}, pin[29]: {=bool:?}, pin[30]: {=bool:?}, pin[31]: {=bool:?} }}" , self . pin (0usize) , self . pin (1usize) , self . pin (2usize) , self . pin (3usize) , self . pin (4usize) , self . pin (5usize) , self . pin (6usize) , self . pin (7usize) , self . pin (8usize) , self . pin (9usize) , self . pin (10usize) , self . pin (11usize) , self . pin (12usize) , self . pin (13usize) , self . pin (14usize) , self . pin (15usize) , self . pin (16usize) , self . pin (17usize) , self . pin (18usize) , self . pin (19usize) , self . pin (20usize) , self . pin (21usize) , self . pin (22usize) , self . pin (23usize) , self . pin (24usize) , self . pin (25usize) , self . pin (26usize) , self . pin (27usize) , self . pin (28usize) , self . pin (29usize) , self . pin (30usize) , self . pin (31usize))
            }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PinCnf(pub u32);
        impl PinCnf {
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[must_use]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[inline(always)]
            pub const fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Connect or disconnect input buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn input(&self) -> super::vals::Input {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Input::from_bits(val as u8)
            }
            #[doc = "Connect or disconnect input buffer"]
            #[inline(always)]
            pub const fn set_input(&mut self, val: super::vals::Input) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pull configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn pull(&self) -> super::vals::Pull {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Pull::from_bits(val as u8)
            }
            #[doc = "Pull configuration"]
            #[inline(always)]
            pub const fn set_pull(&mut self, val: super::vals::Pull) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Drive configuration for '0'"]
            #[must_use]
            #[inline(always)]
            pub const fn drive0(&self) -> super::vals::Drive {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '0'"]
            #[inline(always)]
            pub const fn set_drive0(&mut self, val: super::vals::Drive) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Drive configuration for '1'"]
            #[must_use]
            #[inline(always)]
            pub const fn drive1(&self) -> super::vals::Drive {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '1'"]
            #[inline(always)]
            pub const fn set_drive1(&mut self, val: super::vals::Drive) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Pin sensing mechanism"]
            #[must_use]
            #[inline(always)]
            pub const fn sense(&self) -> super::vals::Sense {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Sense::from_bits(val as u8)
            }
            #[doc = "Pin sensing mechanism"]
            #[inline(always)]
            pub const fn set_sense(&mut self, val: super::vals::Sense) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Select which module has direct control over this pin"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlsel(&self) -> super::vals::Ctrlsel {
                let val = (self.0 >> 28usize) & 0x07;
                super::vals::Ctrlsel::from_bits(val as u8)
            }
            #[doc = "Select which module has direct control over this pin"]
            #[inline(always)]
            pub const fn set_ctrlsel(&mut self, val: super::vals::Ctrlsel) {
                self.0 =
                    (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
            }
        }
        impl Default for PinCnf {
            #[inline(always)]
            fn default() -> PinCnf {
                PinCnf(0)
            }
        }
        impl core::fmt::Debug for PinCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PinCnf")
                    .field("dir", &self.dir())
                    .field("input", &self.input())
                    .field("pull", &self.pull())
                    .field("drive0", &self.drive0())
                    .field("drive1", &self.drive1())
                    .field("sense", &self.sense())
                    .field("ctrlsel", &self.ctrlsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PinCnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "PinCnf {{ dir: {:?}, input: {:?}, pull: {:?}, drive0: {:?}, drive1: {:?}, sense: {:?}, ctrlsel: {:?} }}" , self . dir () , self . input () , self . pull () , self . drive0 () , self . drive1 () , self . sense () , self . ctrlsel ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrlsel {
            #[doc = "GPIO or peripherals with PSEL registers"]
            GPIO = 0x0,
            #[doc = "VPR processor"]
            VPR = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "GRTC peripheral"]
            GRTC = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrlsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrlsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrlsel {
            #[inline(always)]
            fn from(val: u8) -> Ctrlsel {
                Ctrlsel::from_bits(val)
            }
        }
        impl From<Ctrlsel> for u8 {
            #[inline(always)]
            fn from(val: Ctrlsel) -> u8 {
                Ctrlsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detectmode {
            #[doc = "DETECT directly connected to PIN DETECT signals"]
            DEFAULT = 0x0,
            #[doc = "Use the latched LDETECT behavior"]
            LDETECT = 0x01,
        }
        impl Detectmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detectmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detectmode {
            #[inline(always)]
            fn from(val: u8) -> Detectmode {
                Detectmode::from_bits(val)
            }
        }
        impl From<Detectmode> for u8 {
            #[inline(always)]
            fn from(val: Detectmode) -> u8 {
                Detectmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            #[doc = "Configure pin as an input pin"]
            INPUT = 0x0,
            #[doc = "Configure pin as an output pin"]
            OUTPUT = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drive {
            #[doc = "Standard '0'"]
            S = 0x0,
            #[doc = "High drive '0'"]
            H = 0x01,
            #[doc = "Disconnect '0'(normally used for wired-or connections)"]
            D = 0x02,
            #[doc = "Extra high drive '0'"]
            E = 0x03,
        }
        impl Drive {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drive {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drive {
            #[inline(always)]
            fn from(val: u8) -> Drive {
                Drive::from_bits(val)
            }
        }
        impl From<Drive> for u8 {
            #[inline(always)]
            fn from(val: Drive) -> u8 {
                Drive::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Input {
            #[doc = "Connect input buffer"]
            CONNECT = 0x0,
            #[doc = "Disconnect input buffer"]
            DISCONNECT = 0x01,
        }
        impl Input {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Input {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Input {
            #[inline(always)]
            fn from(val: u8) -> Input {
                Input::from_bits(val)
            }
        }
        impl From<Input> for u8 {
            #[inline(always)]
            fn from(val: Input) -> u8 {
                Input::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pull {
            #[doc = "No pull"]
            DISABLED = 0x0,
            #[doc = "Pull down on pin"]
            PULLDOWN = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Pull up on pin"]
            PULLUP = 0x03,
        }
        impl Pull {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pull {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pull {
            #[inline(always)]
            fn from(val: u8) -> Pull {
                Pull::from_bits(val)
            }
        }
        impl From<Pull> for u8 {
            #[inline(always)]
            fn from(val: Pull) -> u8 {
                Pull::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sense {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Sense for high level"]
            HIGH = 0x02,
            #[doc = "Sense for low level"]
            LOW = 0x03,
        }
        impl Sense {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sense {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sense {
            #[inline(always)]
            fn from(val: u8) -> Sense {
                Sense::from_bits(val)
            }
        }
        impl From<Sense> for u8 {
            #[inline(always)]
            fn from(val: Sense) -> u8 {
                Sense::to_bits(val)
            }
        }
    }
}
pub mod gpiote {
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsPort {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsPort {}
    unsafe impl Sync for EventsPort {}
    impl EventsPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Non-secure port event from owner n"]
        #[inline(always)]
        pub const fn nonsecure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Secure port event from owner n"]
        #[inline(always)]
        pub const fn secure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "GPIO Tasks and Events 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is configured in CONFIG\\[n\\].POLARITY."]
        #[inline(always)]
        pub const fn tasks_out(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it high."]
        #[inline(always)]
        pub const fn tasks_set(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it low."]
        #[inline(always)]
        pub const fn tasks_clr(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task OUT\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task SET\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_set(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CLR\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_clr(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Event from pin specified in CONFIG\\[n\\].PSEL"]
        #[inline(always)]
        pub const fn events_in(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_port(self, n: usize) -> EventsPort {
            assert!(n < 1usize);
            unsafe { EventsPort::from_ptr(self.ptr.add(0x0140usize + n * 8usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event IN\\[n\\]"]
        #[inline(always)]
        pub const fn publish_in(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_port(self, n: usize) -> PublishPort {
            assert!(n < 1usize);
            unsafe { PublishPort::from_ptr(self.ptr.add(0x01c0usize + n * 8usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize + n * 16usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize + n * 16usize) as _) }
        }
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[inline(always)]
        pub const fn config(self, n: usize) -> crate::common::Reg<regs::Config, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishPort {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishPort {}
    unsafe impl Sync for PublishPort {}
    impl PublishPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].NONSECURE"]
        #[inline(always)]
        pub const fn nonsecure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].SECURE"]
        #[inline(always)]
        pub const fn secure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[must_use]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[inline(always)]
            pub const fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 4usize)) | (((val as u32) & 0x1f) << 4usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x0f;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val as u32) & 0x0f) << 9usize);
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[must_use]
            #[inline(always)]
            pub const fn polarity(&self) -> super::vals::Polarity {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Polarity::from_bits(val as u8)
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[inline(always)]
            pub const fn set_polarity(&mut self, val: super::vals::Polarity) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[must_use]
            #[inline(always)]
            pub const fn outinit(&self) -> super::vals::Outinit {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Outinit::from_bits(val as u8)
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[inline(always)]
            pub const fn set_outinit(&mut self, val: super::vals::Outinit) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("mode", &self.mode())
                    .field("psel", &self.psel())
                    .field("port", &self.port())
                    .field("polarity", &self.polarity())
                    .field("outinit", &self.outinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ mode: {:?}, psel: {=u8:?}, port: {=u8:?}, polarity: {:?}, outinit: {:?} }}" , self . mode () , self . psel () , self . port () , self . polarity () , self . outinit ())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn in_(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[inline(always)]
            pub const fn set_in_(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[must_use]
            #[inline(always)]
            pub const fn port0nonsecure(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[inline(always)]
            pub const fn set_port0nonsecure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[must_use]
            #[inline(always)]
            pub const fn port0secure(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[inline(always)]
            pub const fn set_port0secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("in_[0]", &self.in_(0usize))
                    .field("in_[1]", &self.in_(1usize))
                    .field("in_[2]", &self.in_(2usize))
                    .field("in_[3]", &self.in_(3usize))
                    .field("in_[4]", &self.in_(4usize))
                    .field("in_[5]", &self.in_(5usize))
                    .field("in_[6]", &self.in_(6usize))
                    .field("in_[7]", &self.in_(7usize))
                    .field("port0nonsecure", &self.port0nonsecure())
                    .field("port0secure", &self.port0secure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ in_[0]: {=bool:?}, in_[1]: {=bool:?}, in_[2]: {=bool:?}, in_[3]: {=bool:?}, in_[4]: {=bool:?}, in_[5]: {=bool:?}, in_[6]: {=bool:?}, in_[7]: {=bool:?}, port0nonsecure: {=bool:?}, port0secure: {=bool:?} }}" , self . in_ (0usize) , self . in_ (1usize) , self . in_ (2usize) , self . in_ (3usize) , self . in_ (4usize) , self . in_ (5usize) , self . in_ (6usize) , self . in_ (7usize) , self . port0nonsecure () , self . port0secure ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module."]
            DISABLED = 0x0,
            #[doc = "Event mode"]
            EVENT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Task mode"]
            TASK = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outinit {
            #[doc = "Task mode: Initial value of pin before task triggering is low"]
            LOW = 0x0,
            #[doc = "Task mode: Initial value of pin before task triggering is high"]
            HIGH = 0x01,
        }
        impl Outinit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outinit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outinit {
            #[inline(always)]
            fn from(val: u8) -> Outinit {
                Outinit::from_bits(val)
            }
        }
        impl From<Outinit> for u8 {
            #[inline(always)]
            fn from(val: Outinit) -> u8 {
                Outinit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Polarity {
            #[doc = "Task mode: No effect on pin from OUT\\[n\\] task. Event mode: no IN\\[n\\] event generated on pin activity."]
            NONE = 0x0,
            #[doc = "Task mode: Set pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when rising edge on pin."]
            LO_TO_HI = 0x01,
            #[doc = "Task mode: Clear pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when falling edge on pin."]
            HI_TO_LO = 0x02,
            #[doc = "Task mode: Toggle pin from OUT\\[n\\]. Event mode: Generate IN\\[n\\] when any change on pin."]
            TOGGLE = 0x03,
        }
        impl Polarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Polarity {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Polarity {
            #[inline(always)]
            fn from(val: u8) -> Polarity {
                Polarity::from_bits(val)
            }
        }
        impl From<Polarity> for u8 {
            #[inline(always)]
            fn from(val: Polarity) -> u8 {
                Polarity::to_bits(val)
            }
        }
    }
}
pub mod grtc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cc {
        ptr: *mut u8,
    }
    unsafe impl Send for Cc {}
    unsafe impl Sync for Cc {}
    impl Cc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn cch(self) -> crate::common::Reg<regs::Cch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[inline(always)]
        pub const fn ccadd(self) -> crate::common::Reg<regs::Ccadd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccen(self) -> crate::common::Reg<regs::Ccen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Global Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Capture the counter value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Start the counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Stop the counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Clear the counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "Start the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "Stop the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "The GRTC low frequency timer is synchronized with the SYSCOUNTER"]
        #[inline(always)]
        pub const fn events_rtcomparesync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0164usize) as _) }
        }
        #[doc = "Event on end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 16usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize + n * 16usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize + n * 16usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize + n * 16usize) as _) }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Counter mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> Cc {
            assert!(n < 12usize);
            unsafe { Cc::from_ptr(self.ptr.add(0x0520usize + n * 16usize) as _) }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[inline(always)]
        pub const fn timeout(self) -> crate::common::Reg<regs::Timeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06a4usize) as _) }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[inline(always)]
        pub const fn interval(self) -> crate::common::Reg<regs::Interval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06a8usize) as _) }
        }
        #[doc = "GRTC wake up time."]
        #[inline(always)]
        pub const fn waketime(self) -> crate::common::Reg<regs::Waketime, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06acusize) as _) }
        }
        #[doc = "PWM configuration."]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0710usize) as _) }
        }
        #[doc = "Configuration of clock output"]
        #[inline(always)]
        pub const fn clkout(self) -> crate::common::Reg<regs::Clkout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0714usize) as _) }
        }
        #[doc = "Clock Configuration"]
        #[inline(always)]
        pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0718usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn syscounter(self, n: usize) -> Syscounter {
            assert!(n < 4usize);
            unsafe { Syscounter::from_ptr(self.ptr.add(0x0720usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Syscounter {
        ptr: *mut u8,
    }
    unsafe impl Send for Syscounter {}
    unsafe impl Sync for Syscounter {}
    impl Syscounter {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterl(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterh(self) -> crate::common::Reg<regs::Syscounterh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[inline(always)]
        pub const fn active(self) -> crate::common::Reg<regs::Active, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Active(pub u32);
        impl Active {
            #[doc = "Keep SYSCOUNTER in active state"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep SYSCOUNTER in active state"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Active {
            #[inline(always)]
            fn default() -> Active {
                Active(0)
            }
        }
        impl core::fmt::Debug for Active {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Active")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Active {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Active {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccadd(pub u32);
        impl Ccadd {
            #[doc = "Count to add to CC\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Count to add to CC\\[n\\]"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
            #[doc = "Configure the Capture/Compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn reference(&self) -> super::vals::Reference {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Reference::from_bits(val as u8)
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn set_reference(&mut self, val: super::vals::Reference) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ccadd {
            #[inline(always)]
            fn default() -> Ccadd {
                Ccadd(0)
            }
        }
        impl core::fmt::Debug for Ccadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccadd")
                    .field("value", &self.value())
                    .field("reference", &self.reference())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccadd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ccadd {{ value: {=u32:?}, reference: {:?} }}",
                    self.value(),
                    self.reference()
                )
            }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccen(pub u32);
        impl Ccen {
            #[doc = "Configure the Capture/Compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ccen {
            #[inline(always)]
            fn default() -> Ccen {
                Ccen(0)
            }
        }
        impl core::fmt::Debug for Ccen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccen")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ccen {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cch(pub u32);
        impl Cch {
            #[doc = "Capture/Compare high value in 1 us"]
            #[must_use]
            #[inline(always)]
            pub const fn cch(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Capture/Compare high value in 1 us"]
            #[inline(always)]
            pub const fn set_cch(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Cch {
            #[inline(always)]
            fn default() -> Cch {
                Cch(0)
            }
        }
        impl core::fmt::Debug for Cch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cch").field("cch", &self.cch()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cch {{ cch: {=u32:?} }}", self.cch())
            }
        }
        #[doc = "Clock Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkcfg(pub u32);
        impl Clkcfg {
            #[doc = "Fast clock divisor value of clock output"]
            #[must_use]
            #[inline(always)]
            pub const fn clkfastdiv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fast clock divisor value of clock output"]
            #[inline(always)]
            pub const fn set_clkfastdiv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[must_use]
            #[inline(always)]
            pub const fn clksel(&self) -> super::vals::Clksel {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Clksel::from_bits(val as u8)
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[inline(always)]
            pub const fn set_clksel(&mut self, val: super::vals::Clksel) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
        }
        impl Default for Clkcfg {
            #[inline(always)]
            fn default() -> Clkcfg {
                Clkcfg(0)
            }
        }
        impl core::fmt::Debug for Clkcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkcfg")
                    .field("clkfastdiv", &self.clkfastdiv())
                    .field("clksel", &self.clksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkcfg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clkcfg {{ clkfastdiv: {=u8:?}, clksel: {:?} }}",
                    self.clkfastdiv(),
                    self.clksel()
                )
            }
        }
        #[doc = "Configuration of clock output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkout(pub u32);
        impl Clkout {
            #[doc = "Enable 32Ki clock output on pin"]
            #[must_use]
            #[inline(always)]
            pub const fn clkout32k(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32Ki clock output on pin"]
            #[inline(always)]
            pub const fn set_clkout32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable fast clock output on pin"]
            #[must_use]
            #[inline(always)]
            pub const fn clkoutfast(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable fast clock output on pin"]
            #[inline(always)]
            pub const fn set_clkoutfast(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Clkout {
            #[inline(always)]
            fn default() -> Clkout {
                Clkout(0)
            }
        }
        impl core::fmt::Debug for Clkout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkout")
                    .field("clkout32k", &self.clkout32k())
                    .field("clkoutfast", &self.clkoutfast())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clkout {{ clkout32k: {=bool:?}, clkoutfast: {=bool:?} }}",
                    self.clkout32k(),
                    self.clkoutfast()
                )
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("pwmperiodend", &self.pwmperiodend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Evt {{ pwmperiodend: {=bool:?} }}", self.pwmperiodend())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[inline(always)]
            pub const fn set_compare1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[inline(always)]
            pub const fn set_compare2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[inline(always)]
            pub const fn set_compare3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[inline(always)]
            pub const fn set_compare4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[inline(always)]
            pub const fn set_compare5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[inline(always)]
            pub const fn set_compare6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[inline(always)]
            pub const fn set_compare7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[inline(always)]
            pub const fn set_compare8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[inline(always)]
            pub const fn set_compare9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[inline(always)]
            pub const fn set_compare10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[inline(always)]
            pub const fn set_compare11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[must_use]
            #[inline(always)]
            pub const fn rtcomparesync(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[inline(always)]
            pub const fn set_rtcomparesync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare0", &self.compare0())
                    .field("compare1", &self.compare1())
                    .field("compare2", &self.compare2())
                    .field("compare3", &self.compare3())
                    .field("compare4", &self.compare4())
                    .field("compare5", &self.compare5())
                    .field("compare6", &self.compare6())
                    .field("compare7", &self.compare7())
                    .field("compare8", &self.compare8())
                    .field("compare9", &self.compare9())
                    .field("compare10", &self.compare10())
                    .field("compare11", &self.compare11())
                    .field("rtcomparesync", &self.rtcomparesync())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ compare0: {=bool:?}, compare1: {=bool:?}, compare2: {=bool:?}, compare3: {=bool:?}, compare4: {=bool:?}, compare5: {=bool:?}, compare6: {=bool:?}, compare7: {=bool:?}, compare8: {=bool:?}, compare9: {=bool:?}, compare10: {=bool:?}, compare11: {=bool:?}, rtcomparesync: {=bool:?}, pwmperiodend: {=bool:?} }}" , self . compare0 () , self . compare1 () , self . compare2 () , self . compare3 () , self . compare4 () , self . compare5 () , self . compare6 () , self . compare7 () , self . compare8 () , self . compare9 () , self . compare10 () , self . compare11 () , self . rtcomparesync () , self . pwmperiodend ())
            }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Interval(pub u32);
        impl Interval {
            #[doc = "Count to add to CC\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Count to add to CC\\[0\\]"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Interval {
            #[inline(always)]
            fn default() -> Interval {
                Interval(0)
            }
        }
        impl core::fmt::Debug for Interval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Interval")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Interval {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Interval {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "Counter mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[must_use]
            #[inline(always)]
            pub const fn autoen(&self) -> super::vals::Autoen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Autoen::from_bits(val as u8)
            }
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[inline(always)]
            pub const fn set_autoen(&mut self, val: super::vals::Autoen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[must_use]
            #[inline(always)]
            pub const fn syscounteren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[inline(always)]
            pub const fn set_syscounteren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("autoen", &self.autoen())
                    .field("syscounteren", &self.syscounteren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ autoen: {:?}, syscounteren: {=bool:?} }}",
                    self.autoen(),
                    self.syscounteren()
                )
            }
        }
        #[doc = "PWM configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "The PWM compare value"]
            #[must_use]
            #[inline(always)]
            pub const fn comparevalue(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The PWM compare value"]
            #[inline(always)]
            pub const fn set_comparevalue(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("comparevalue", &self.comparevalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwmconfig {{ comparevalue: {=u8:?} }}",
                    self.comparevalue()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn rtcompare_clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[inline(always)]
            pub const fn set_rtcompare_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("rtcompare_clear", &self.rtcompare_clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Shorts {{ rtcompare_clear: {=bool:?} }}",
                    self.rtcompare_clear()
                )
            }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounterh(pub u32);
        impl Syscounterh {
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "SYSCOUNTER busy status"]
            #[must_use]
            #[inline(always)]
            pub const fn busy(&self) -> super::vals::Busy {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Busy::from_bits(val as u8)
            }
            #[doc = "SYSCOUNTER busy status"]
            #[inline(always)]
            pub const fn set_busy(&mut self, val: super::vals::Busy) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Syscounterh {
            #[inline(always)]
            fn default() -> Syscounterh {
                Syscounterh(0)
            }
        }
        impl core::fmt::Debug for Syscounterh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounterh")
                    .field("value", &self.value())
                    .field("busy", &self.busy())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounterh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Syscounterh {{ value: {=u32:?}, busy: {:?}, overflow: {=bool:?} }}",
                    self.value(),
                    self.busy(),
                    self.overflow()
                )
            }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timeout(pub u32);
        impl Timeout {
            #[doc = "Number of 32Ki cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of 32Ki cycles"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Timeout {
            #[inline(always)]
            fn default() -> Timeout {
                Timeout(0)
            }
        }
        impl core::fmt::Debug for Timeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timeout")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Timeout {{ value: {=u16:?} }}", self.value())
            }
        }
        #[doc = "GRTC wake up time."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Waketime(pub u32);
        impl Waketime {
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Waketime {
            #[inline(always)]
            fn default() -> Waketime {
                Waketime(0)
            }
        }
        impl core::fmt::Debug for Waketime {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Waketime")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Waketime {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Waketime {{ value: {=u8:?} }}", self.value())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Autoen {
            #[doc = "Default configuration to keep the SYSCOUNTER active."]
            DEFAULT = 0x0,
            #[doc = "In addition to the above mode, any local CPU that is not sleeping keep the SYSCOUNTER active."]
            CPU_ACTIVE = 0x01,
        }
        impl Autoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Autoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Autoen {
            #[inline(always)]
            fn from(val: u8) -> Autoen {
                Autoen::from_bits(val)
            }
        }
        impl From<Autoen> for u8 {
            #[inline(always)]
            fn from(val: Autoen) -> u8 {
                Autoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busy {
            #[doc = "SYSCOUNTER is ready for read"]
            READY = 0x0,
            #[doc = "SYSCOUNTER is busy, so not ready for read (value returned in the VALUE field of this register is not valid)"]
            BUSY = 0x01,
        }
        impl Busy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busy {
            #[inline(always)]
            fn from(val: u8) -> Busy {
                Busy::from_bits(val)
            }
        }
        impl From<Busy> for u8 {
            #[inline(always)]
            fn from(val: Busy) -> u8 {
                Busy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clksel {
            #[doc = "GRTC LFCLK clock source is LFXO"]
            LFXO = 0x0,
            #[doc = "GRTC LFCLK clock source is system LFCLK"]
            SYSTEM_LFCLK = 0x01,
            #[doc = "GRTC LFCLK clock source is LFLPRC"]
            LFLPRC = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Clksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clksel {
            #[inline(always)]
            fn from(val: u8) -> Clksel {
                Clksel::from_bits(val)
            }
        }
        impl From<Clksel> for u8 {
            #[inline(always)]
            fn from(val: Clksel) -> u8 {
                Clksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reference {
            #[doc = "Adds SYSCOUNTER value."]
            SYSCOUNTER = 0x0,
            #[doc = "Adds CC value."]
            CC = 0x01,
        }
        impl Reference {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reference {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reference {
            #[inline(always)]
            fn from(val: u8) -> Reference {
                Reference::from_bits(val)
            }
        }
        impl From<Reference> for u8 {
            #[inline(always)]
            fn from(val: Reference) -> u8 {
                Reference::to_bits(val)
            }
        }
    }
}
pub mod i2s {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Channel {
        ptr: *mut u8,
    }
    unsafe impl Send for Channel {}
    unsafe impl Sync for Channel {}
    impl Channel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2S mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Reception (RX) enable"]
        #[inline(always)]
        pub const fn rxen(self) -> crate::common::Reg<regs::Rxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Transmission (TX) enable"]
        #[inline(always)]
        pub const fn txen(self) -> crate::common::Reg<regs::Txen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Master clock generator enable"]
        #[inline(always)]
        pub const fn mcken(self) -> crate::common::Reg<regs::Mcken, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "I2S clock generator control"]
        #[inline(always)]
        pub const fn mckfreq(self) -> crate::common::Reg<regs::Mckfreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "MCK / LRCK ratio"]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Sample width"]
        #[inline(always)]
        pub const fn swidth(self) -> crate::common::Reg<regs::Swidth, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Alignment of sample within a frame"]
        #[inline(always)]
        pub const fn align(self) -> crate::common::Reg<regs::Align, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Frame format"]
        #[inline(always)]
        pub const fn format(self) -> crate::common::Reg<regs::Format, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Enable channels"]
        #[inline(always)]
        pub const fn channels(self) -> crate::common::Reg<regs::Channels, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Inter-IC Sound 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct I2s {
        ptr: *mut u8,
    }
    unsafe impl Send for I2s {}
    unsafe impl Sync for I2s {}
    impl I2s {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous I2S transfer. Also starts MCK generator when this is enabled"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops I2S transfer and MCK generator. Triggering this task will cause the event STOPPED to be generated."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words received on the SDIN pin."]
        #[inline(always)]
        pub const fn events_rxptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "I2S transfer stopped."]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin."]
        #[inline(always)]
        pub const fn events_txptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Frame start event, generated on the active edge of LRCK"]
        #[inline(always)]
        pub const fn events_framestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Publish configuration for event RXPTRUPD"]
        #[inline(always)]
        pub const fn publish_rxptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXPTRUPD"]
        #[inline(always)]
        pub const fn publish_txptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event FRAMESTART"]
        #[inline(always)]
        pub const fn publish_framestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable I2S module"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxtxd(self) -> Rxtxd {
            unsafe { Rxtxd::from_ptr(self.ptr.add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn channel(self, n: usize) -> Channel {
            assert!(n < 2usize);
            unsafe { Channel::from_ptr(self.ptr.add(0x0580usize + n * 8usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for MCK signal"]
        #[inline(always)]
        pub const fn mck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SCK signal"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for LRCK signal"]
        #[inline(always)]
        pub const fn lrck(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for SDIN signal"]
        #[inline(always)]
        pub const fn sdin(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Pin select for SDOUT signal"]
        #[inline(always)]
        pub const fn sdout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Receive buffer RAM start address."]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxtxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxtxd {}
    unsafe impl Sync for Rxtxd {}
    impl Rxtxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Size of RXD and TXD buffers"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Transmit buffer RAM start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Alignment of sample within a frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Align(pub u32);
        impl Align {
            #[doc = "Alignment of sample within a frame"]
            #[must_use]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Alignment of sample within a frame"]
            #[inline(always)]
            pub const fn set_align(&mut self, val: super::vals::Align) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Align {
            #[inline(always)]
            fn default() -> Align {
                Align(0)
            }
        }
        impl core::fmt::Debug for Align {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Align")
                    .field("align", &self.align())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Align {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Align {{ align: {:?} }}", self.align())
            }
        }
        #[doc = "Enable channels"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Channels(pub u32);
        impl Channels {
            #[doc = "Enable channels"]
            #[must_use]
            #[inline(always)]
            pub const fn channels(&self) -> super::vals::Channels {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Channels::from_bits(val as u8)
            }
            #[doc = "Enable channels"]
            #[inline(always)]
            pub const fn set_channels(&mut self, val: super::vals::Channels) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Channels {
            #[inline(always)]
            fn default() -> Channels {
                Channels(0)
            }
        }
        impl core::fmt::Debug for Channels {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Channels")
                    .field("channels", &self.channels())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Channels {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Channels {{ channels: {:?} }}", self.channels())
            }
        }
        #[doc = "Enable I2S module"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable I2S module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable I2S module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Frame format"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Format(pub u32);
        impl Format {
            #[doc = "Frame format"]
            #[must_use]
            #[inline(always)]
            pub const fn format(&self) -> super::vals::Format {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Format::from_bits(val as u8)
            }
            #[doc = "Frame format"]
            #[inline(always)]
            pub const fn set_format(&mut self, val: super::vals::Format) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Format {
            #[inline(always)]
            fn default() -> Format {
                Format(0)
            }
        }
        impl core::fmt::Debug for Format {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Format")
                    .field("format", &self.format())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Format {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Format {{ format: {:?} }}", self.format())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn rxptrupd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[inline(always)]
            pub const fn set_rxptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[must_use]
            #[inline(always)]
            pub const fn txptrupd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[inline(always)]
            pub const fn set_txptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event FRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn framestart(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub const fn set_framestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxptrupd", &self.rxptrupd())
                    .field("stopped", &self.stopped())
                    .field("txptrupd", &self.txptrupd())
                    .field("framestart", &self.framestart())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ rxptrupd: {=bool:?}, stopped: {=bool:?}, txptrupd: {=bool:?}, framestart: {=bool:?} }}" , self . rxptrupd () , self . stopped () , self . txptrupd () , self . framestart ())
            }
        }
        #[doc = "Size of RXD and TXD buffers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Master clock generator enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mcken(pub u32);
        impl Mcken {
            #[doc = "Master clock generator enable"]
            #[must_use]
            #[inline(always)]
            pub const fn mcken(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master clock generator enable"]
            #[inline(always)]
            pub const fn set_mcken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mcken {
            #[inline(always)]
            fn default() -> Mcken {
                Mcken(0)
            }
        }
        impl core::fmt::Debug for Mcken {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mcken")
                    .field("mcken", &self.mcken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mcken {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mcken {{ mcken: {=bool:?} }}", self.mcken())
            }
        }
        #[doc = "I2S clock generator control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mckfreq(pub u32);
        impl Mckfreq {
            #[doc = "I2S MCK frequency configuration NOTE: Enumerations are deprecated, use MCKFREQ equation. NOTE: The 12 least significant bits of the register are ignored and shall be set to zero."]
            #[must_use]
            #[inline(always)]
            pub const fn mckfreq(&self) -> super::vals::Mckfreq {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Mckfreq::from_bits(val as u32)
            }
            #[doc = "I2S MCK frequency configuration NOTE: Enumerations are deprecated, use MCKFREQ equation. NOTE: The 12 least significant bits of the register are ignored and shall be set to zero."]
            #[inline(always)]
            pub const fn set_mckfreq(&mut self, val: super::vals::Mckfreq) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mckfreq {
            #[inline(always)]
            fn default() -> Mckfreq {
                Mckfreq(0)
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mckfreq")
                    .field("mckfreq", &self.mckfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mckfreq {{ mckfreq: {:?} }}", self.mckfreq())
            }
        }
        #[doc = "I2S mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "I2S mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "I2S mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "MCK / LRCK ratio"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "MCK / LRCK ratio"]
            #[must_use]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "MCK / LRCK ratio"]
            #[inline(always)]
            pub const fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ratio {{ ratio: {:?} }}", self.ratio())
            }
        }
        #[doc = "Reception (RX) enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxen(pub u32);
        impl Rxen {
            #[doc = "Reception (RX) enable"]
            #[must_use]
            #[inline(always)]
            pub const fn rxen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reception (RX) enable"]
            #[inline(always)]
            pub const fn set_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxen {
            #[inline(always)]
            fn default() -> Rxen {
                Rxen(0)
            }
        }
        impl core::fmt::Debug for Rxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxen").field("rxen", &self.rxen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxen {{ rxen: {=bool:?} }}", self.rxen())
            }
        }
        #[doc = "Sample width"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swidth(pub u32);
        impl Swidth {
            #[doc = "Sample and half-frame width"]
            #[must_use]
            #[inline(always)]
            pub const fn swidth(&self) -> super::vals::Swidth {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Swidth::from_bits(val as u8)
            }
            #[doc = "Sample and half-frame width"]
            #[inline(always)]
            pub const fn set_swidth(&mut self, val: super::vals::Swidth) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Swidth {
            #[inline(always)]
            fn default() -> Swidth {
                Swidth(0)
            }
        }
        impl core::fmt::Debug for Swidth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swidth")
                    .field("swidth", &self.swidth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swidth {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Swidth {{ swidth: {:?} }}", self.swidth())
            }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Terminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Transmission (TX) enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txen(pub u32);
        impl Txen {
            #[doc = "Transmission (TX) enable"]
            #[must_use]
            #[inline(always)]
            pub const fn txen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transmission (TX) enable"]
            #[inline(always)]
            pub const fn set_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txen {
            #[inline(always)]
            fn default() -> Txen {
                Txen(0)
            }
        }
        impl core::fmt::Debug for Txen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txen").field("txen", &self.txen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txen {{ txen: {=bool:?} }}", self.txen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            #[doc = "Left-aligned."]
            LEFT = 0x0,
            #[doc = "Right-aligned."]
            RIGHT = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Channels {
            #[doc = "Stereo."]
            STEREO = 0x0,
            #[doc = "Left only."]
            LEFT = 0x01,
            #[doc = "Right only."]
            RIGHT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Channels {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Channels {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Channels {
            #[inline(always)]
            fn from(val: u8) -> Channels {
                Channels::from_bits(val)
            }
        }
        impl From<Channels> for u8 {
            #[inline(always)]
            fn from(val: Channels) -> u8 {
                Channels::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Format {
            #[doc = "Original I2S format."]
            I2S = 0x0,
            #[doc = "Alternate (left- or right-aligned) format."]
            ALIGNED = 0x01,
        }
        impl Format {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Format {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Format {
            #[inline(always)]
            fn from(val: u8) -> Format {
                Format::from_bits(val)
            }
        }
        impl From<Format> for u8 {
            #[inline(always)]
            fn from(val: Format) -> u8 {
                Format::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Mckfreq(u32);
        impl Mckfreq {
            #[doc = "32 MHz / 125 = 0.256 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV125: Self = Self(0x020c_0000);
            #[doc = "32 MHz / 63 = 0.5079365 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV63: Self = Self(0x0410_0000);
            #[doc = "32 MHz / 42 = 0.7619048 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV42: Self = Self(0x0600_0000);
            #[doc = "32 MHz / 32 = 1.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV32: Self = Self(0x0800_0000);
            #[doc = "32 MHz / 31 = 1.0322581 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV31: Self = Self(0x0840_0000);
            #[doc = "32 MHz / 30 = 1.0666667 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV30: Self = Self(0x0880_0000);
            #[doc = "32 MHz / 23 = 1.3913043 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV23: Self = Self(0x0b00_0000);
            #[doc = "32 MHz / 21 = 1.5238095 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV21: Self = Self(0x0c00_0000);
            #[doc = "32 MHz / 16 = 2.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV16: Self = Self(0x1000_0000);
            #[doc = "32 MHz / 15 = 2.1333333 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV15: Self = Self(0x1100_0000);
            #[doc = "32 MHz / 11 = 2.9090909 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV11: Self = Self(0x1600_0000);
            #[doc = "32 MHz / 10 = 3.2 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV10: Self = Self(0x1800_0000);
            #[doc = "32 MHz / 8 = 4.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV8: Self = Self(0x2000_0000);
            #[doc = "32 MHz / 6 = 5.3333333 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV6: Self = Self(0x2800_0000);
            #[doc = "32 MHz / 5 = 6.4 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV5: Self = Self(0x3000_0000);
            #[doc = "32 MHz / 4 = 8.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV4: Self = Self(0x4000_0000);
            #[doc = "32 MHz / 3 = 10.6666667 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV3: Self = Self(0x5000_0000);
            #[doc = "32 MHz / 2 = 16.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV2: Self = Self(0x8000_0000);
        }
        impl Mckfreq {
            pub const fn from_bits(val: u32) -> Mckfreq {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x020c_0000 => f.write_str("_32MDIV125"),
                    0x0410_0000 => f.write_str("_32MDIV63"),
                    0x0600_0000 => f.write_str("_32MDIV42"),
                    0x0800_0000 => f.write_str("_32MDIV32"),
                    0x0840_0000 => f.write_str("_32MDIV31"),
                    0x0880_0000 => f.write_str("_32MDIV30"),
                    0x0b00_0000 => f.write_str("_32MDIV23"),
                    0x0c00_0000 => f.write_str("_32MDIV21"),
                    0x1000_0000 => f.write_str("_32MDIV16"),
                    0x1100_0000 => f.write_str("_32MDIV15"),
                    0x1600_0000 => f.write_str("_32MDIV11"),
                    0x1800_0000 => f.write_str("_32MDIV10"),
                    0x2000_0000 => f.write_str("_32MDIV8"),
                    0x2800_0000 => f.write_str("_32MDIV6"),
                    0x3000_0000 => f.write_str("_32MDIV5"),
                    0x4000_0000 => f.write_str("_32MDIV4"),
                    0x5000_0000 => f.write_str("_32MDIV3"),
                    0x8000_0000 => f.write_str("_32MDIV2"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x020c_0000 => defmt::write!(f, "_32MDIV125"),
                    0x0410_0000 => defmt::write!(f, "_32MDIV63"),
                    0x0600_0000 => defmt::write!(f, "_32MDIV42"),
                    0x0800_0000 => defmt::write!(f, "_32MDIV32"),
                    0x0840_0000 => defmt::write!(f, "_32MDIV31"),
                    0x0880_0000 => defmt::write!(f, "_32MDIV30"),
                    0x0b00_0000 => defmt::write!(f, "_32MDIV23"),
                    0x0c00_0000 => defmt::write!(f, "_32MDIV21"),
                    0x1000_0000 => defmt::write!(f, "_32MDIV16"),
                    0x1100_0000 => defmt::write!(f, "_32MDIV15"),
                    0x1600_0000 => defmt::write!(f, "_32MDIV11"),
                    0x1800_0000 => defmt::write!(f, "_32MDIV10"),
                    0x2000_0000 => defmt::write!(f, "_32MDIV8"),
                    0x2800_0000 => defmt::write!(f, "_32MDIV6"),
                    0x3000_0000 => defmt::write!(f, "_32MDIV5"),
                    0x4000_0000 => defmt::write!(f, "_32MDIV4"),
                    0x5000_0000 => defmt::write!(f, "_32MDIV3"),
                    0x8000_0000 => defmt::write!(f, "_32MDIV2"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Mckfreq {
            #[inline(always)]
            fn from(val: u32) -> Mckfreq {
                Mckfreq::from_bits(val)
            }
        }
        impl From<Mckfreq> for u32 {
            #[inline(always)]
            fn from(val: Mckfreq) -> u32 {
                Mckfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx."]
            MASTER = 0x0,
            #[doc = "Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx"]
            SLAVE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "LRCK = MCK / 32"]
            _32X = 0x0,
            #[doc = "LRCK = MCK / 48"]
            _48X = 0x01,
            #[doc = "LRCK = MCK / 64"]
            _64X = 0x02,
            #[doc = "LRCK = MCK / 96"]
            _96X = 0x03,
            #[doc = "LRCK = MCK / 128"]
            _128X = 0x04,
            #[doc = "LRCK = MCK / 192"]
            _192X = 0x05,
            #[doc = "LRCK = MCK / 256"]
            _256X = 0x06,
            #[doc = "LRCK = MCK / 384"]
            _384X = 0x07,
            #[doc = "LRCK = MCK / 512"]
            _512X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swidth {
            #[doc = "8 bit sample."]
            _8BIT = 0x0,
            #[doc = "16 bit sample."]
            _16BIT = 0x01,
            #[doc = "24 bit sample."]
            _24BIT = 0x02,
            #[doc = "32 bit sample."]
            _32BIT = 0x03,
            #[doc = "8 bit sample in a 16-bit half-frame."]
            _8BIT_IN16 = 0x04,
            #[doc = "8 bit sample in a 32-bit half-frame."]
            _8BIT_IN32 = 0x05,
            #[doc = "16 bit sample in a 32-bit half-frame."]
            _16BIT_IN32 = 0x06,
            #[doc = "24 bit sample in a 32-bit half-frame."]
            _24BIT_IN32 = 0x07,
        }
        impl Swidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swidth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swidth {
            #[inline(always)]
            fn from(val: u8) -> Swidth {
                Swidth::from_bits(val)
            }
        }
        impl From<Swidth> for u8 {
            #[inline(always)]
            fn from(val: Swidth) -> u8 {
                Swidth::to_bits(val)
            }
        }
    }
}
pub mod kmu {
    #[doc = "Key management unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kmu {
        ptr: *mut u8,
    }
    unsafe impl Send for Kmu {}
    unsafe impl Sync for Kmu {}
    impl Kmu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Provision key slot"]
        #[inline(always)]
        pub const fn tasks_provision(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Push key slot"]
        #[inline(always)]
        pub const fn tasks_push(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Revoke key slot"]
        #[inline(always)]
        pub const fn tasks_revoke(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read key slot metedata into METADATA register"]
        #[inline(always)]
        pub const fn tasks_readmetadata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Block the PUSH operation of key slot, preventing the key slot being PUSH until next reset"]
        #[inline(always)]
        pub const fn tasks_pushblock(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Key slot successfully provisioned"]
        #[inline(always)]
        pub const fn events_provisioned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Key slot successfully pushed"]
        #[inline(always)]
        pub const fn events_pushed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Key slot has been revoked and can no longer be used"]
        #[inline(always)]
        pub const fn events_revoked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Error during PROVISION, PUSH, or REVOKE operations"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Key slot metedata has been read into METADATA register"]
        #[inline(always)]
        pub const fn events_metadataread(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "The PUSHBLOCK operation was succesful"]
        #[inline(always)]
        pub const fn events_pushblocked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "KMU status register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Select key slot to operate on"]
        #[inline(always)]
        pub const fn keyslot(self) -> crate::common::Reg<regs::Keyslot, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Source address for provisioning"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Key slot metadata as read by TASKS_READMETADATA."]
        #[inline(always)]
        pub const fn metadata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Select key slot to operate on"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Keyslot(pub u32);
        impl Keyslot {
            #[doc = "Select key slot ID to provision, read, or push when TASKS_PROVISION, TASKS_PUSH, TASKS_READMETADATA, or TASKS_REVOKE, is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select key slot ID to provision, read, or push when TASKS_PROVISION, TASKS_PUSH, TASKS_READMETADATA, or TASKS_REVOKE, is triggered."]
            #[inline(always)]
            pub const fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Keyslot {
            #[inline(always)]
            fn default() -> Keyslot {
                Keyslot(0)
            }
        }
        impl core::fmt::Debug for Keyslot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Keyslot").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Keyslot {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Keyslot {{ id: {=u8:?} }}", self.id())
            }
        }
        #[doc = "KMU status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "KMU status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "KMU status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "KMU is ready for new operation"]
            READY = 0x0,
            #[doc = "KMU is busy, an operation is in progress"]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
    }
}
pub mod lpcomp {
    #[doc = "Low-power comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lpcomp {
        ptr: *mut u8,
    }
    unsafe impl Send for Lpcomp {}
    unsafe impl Sync for Lpcomp {}
    impl Lpcomp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that LPCOMP has been started by the START task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "LPCOMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable LPCOMP"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Input pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Reference select"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Analog detect configuration"]
        #[inline(always)]
        pub const fn anadetect(self) -> crate::common::Reg<regs::Anadetect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Analog detect configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Anadetect(pub u32);
        impl Anadetect {
            #[doc = "Analog detect configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn anadetect(&self) -> super::vals::Anadetect {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Anadetect::from_bits(val as u8)
            }
            #[doc = "Analog detect configuration"]
            #[inline(always)]
            pub const fn set_anadetect(&mut self, val: super::vals::Anadetect) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Anadetect {
            #[inline(always)]
            fn default() -> Anadetect {
                Anadetect(0)
            }
        }
        impl core::fmt::Debug for Anadetect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Anadetect")
                    .field("anadetect", &self.anadetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Anadetect {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Anadetect {{ anadetect: {:?} }}", self.anadetect())
            }
        }
        #[doc = "Enable LPCOMP"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable LPCOMP"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable LPCOMP"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Extrefsel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis enable"]
            #[must_use]
            #[inline(always)]
            pub const fn hyst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator hysteresis enable"]
            #[inline(always)]
            pub const fn set_hyst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Hyst {{ hyst: {=bool:?} }}", self.hyst())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[must_use]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[must_use]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[must_use]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ ready: {=bool:?}, down: {=bool:?}, up: {=bool:?}, cross: {=bool:?} }}",
                    self.ready(),
                    self.down(),
                    self.up(),
                    self.cross()
                )
            }
        }
        #[doc = "Input pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?} }}",
                    self.pin(),
                    self.port()
                )
            }
        }
        #[doc = "Reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refsel {{ refsel: {:?} }}", self.refsel())
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[must_use]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Result {{ result: {:?} }}", self.result())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_sample: {=bool:?}, ready_stop: {=bool:?}, down_stop: {=bool:?}, up_stop: {=bool:?}, cross_stop: {=bool:?} }}" , self . ready_sample () , self . ready_stop () , self . down_stop () , self . up_stop () , self . cross_stop ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Anadetect {
            #[doc = "Generate ANADETECT on crossing, both upward crossing and downward crossing"]
            CROSS = 0x0,
            #[doc = "Generate ANADETECT on upward crossing only"]
            UP = 0x01,
            #[doc = "Generate ANADETECT on downward crossing only"]
            DOWN = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Anadetect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Anadetect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Anadetect {
            #[inline(always)]
            fn from(val: u8) -> Anadetect {
                Anadetect::from_bits(val)
            }
        }
        impl From<Anadetect> for u8 {
            #[inline(always)]
            fn from(val: Anadetect) -> u8 {
                Anadetect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            #[doc = "Enable"]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VDD * 1/8 selected as reference"]
            REF1_8VDD = 0x0,
            #[doc = "VDD * 2/8 selected as reference"]
            REF2_8VDD = 0x01,
            #[doc = "VDD * 3/8 selected as reference"]
            REF3_8VDD = 0x02,
            #[doc = "VDD * 4/8 selected as reference"]
            REF4_8VDD = 0x03,
            #[doc = "VDD * 5/8 selected as reference"]
            REF5_8VDD = 0x04,
            #[doc = "VDD * 6/8 selected as reference"]
            REF6_8VDD = 0x05,
            #[doc = "VDD * 7/8 selected as reference"]
            REF7_8VDD = 0x06,
            #[doc = "External analog reference selected"]
            AREF = 0x07,
            #[doc = "VDD * 1/16 selected as reference"]
            REF1_16VDD = 0x08,
            #[doc = "VDD * 3/16 selected as reference"]
            REF3_16VDD = 0x09,
            #[doc = "VDD * 5/16 selected as reference"]
            REF5_16VDD = 0x0a,
            #[doc = "VDD * 7/16 selected as reference"]
            REF7_16VDD = 0x0b,
            #[doc = "VDD * 9/16 selected as reference"]
            REF9_16VDD = 0x0c,
            #[doc = "VDD * 11/16 selected as reference"]
            REF11_16VDD = 0x0d,
            #[doc = "VDD * 13/16 selected as reference"]
            REF13_16VDD = 0x0e,
            #[doc = "VDD * 15/16 selected as reference"]
            REF15_16VDD = 0x0f,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the reference threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the reference threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
    }
}
pub mod memconf {
    #[doc = "Memory configuration 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memconf {
        ptr: *mut u8,
    }
    unsafe impl Send for Memconf {}
    unsafe impl Sync for Memconf {}
    impl Memconf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self, n: usize) -> Power {
            assert!(n < 2usize);
            unsafe { Power::from_ptr(self.ptr.add(0x0500usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control memory block power."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::Control, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[inline(always)]
        pub const fn ret(self) -> crate::common::Reg<regs::Ret, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: RAM retention for the second bank in the RAM block"]
        #[inline(always)]
        pub const fn ret2(self) -> crate::common::Reg<regs::Ret2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Control memory block power."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Control(pub u32);
        impl Control {
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Control {
            #[inline(always)]
            fn default() -> Control {
                Control(0)
            }
        }
        impl core::fmt::Debug for Control {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Control")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Control {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Control {{ mem0: {=bool:?}, mem1: {=bool:?}, mem2: {=bool:?}, mem3: {=bool:?}, mem4: {=bool:?}, mem5: {=bool:?}, mem6: {=bool:?}, mem7: {=bool:?}, mem8: {=bool:?}, mem9: {=bool:?}, mem10: {=bool:?}, mem11: {=bool:?}, mem12: {=bool:?}, mem13: {=bool:?}, mem14: {=bool:?}, mem15: {=bool:?}, mem16: {=bool:?}, mem17: {=bool:?}, mem18: {=bool:?}, mem19: {=bool:?}, mem20: {=bool:?}, mem21: {=bool:?}, mem22: {=bool:?}, mem23: {=bool:?}, mem24: {=bool:?}, mem25: {=bool:?}, mem26: {=bool:?}, mem27: {=bool:?}, mem28: {=bool:?}, mem29: {=bool:?}, mem30: {=bool:?}, mem31: {=bool:?} }}" , self . mem0 () , self . mem1 () , self . mem2 () , self . mem3 () , self . mem4 () , self . mem5 () , self . mem6 () , self . mem7 () , self . mem8 () , self . mem9 () , self . mem10 () , self . mem11 () , self . mem12 () , self . mem13 () , self . mem14 () , self . mem15 () , self . mem16 () , self . mem17 () , self . mem18 () , self . mem19 () , self . mem20 () , self . mem21 () , self . mem22 () , self . mem23 () , self . mem24 () , self . mem25 () , self . mem26 () , self . mem27 () , self . mem28 () , self . mem29 () , self . mem30 () , self . mem31 ())
            }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ret(pub u32);
        impl Ret {
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ret {
            #[inline(always)]
            fn default() -> Ret {
                Ret(0)
            }
        }
        impl core::fmt::Debug for Ret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ret")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ret {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ret {{ mem0: {=bool:?}, mem1: {=bool:?}, mem2: {=bool:?}, mem3: {=bool:?}, mem4: {=bool:?}, mem5: {=bool:?}, mem6: {=bool:?}, mem7: {=bool:?}, mem8: {=bool:?}, mem9: {=bool:?}, mem10: {=bool:?}, mem11: {=bool:?}, mem12: {=bool:?}, mem13: {=bool:?}, mem14: {=bool:?}, mem15: {=bool:?}, mem16: {=bool:?}, mem17: {=bool:?}, mem18: {=bool:?}, mem19: {=bool:?}, mem20: {=bool:?}, mem21: {=bool:?}, mem22: {=bool:?}, mem23: {=bool:?}, mem24: {=bool:?}, mem25: {=bool:?}, mem26: {=bool:?}, mem27: {=bool:?}, mem28: {=bool:?}, mem29: {=bool:?}, mem30: {=bool:?}, mem31: {=bool:?} }}" , self . mem0 () , self . mem1 () , self . mem2 () , self . mem3 () , self . mem4 () , self . mem5 () , self . mem6 () , self . mem7 () , self . mem8 () , self . mem9 () , self . mem10 () , self . mem11 () , self . mem12 () , self . mem13 () , self . mem14 () , self . mem15 () , self . mem16 () , self . mem17 () , self . mem18 () , self . mem19 () , self . mem20 () , self . mem21 () , self . mem22 () , self . mem23 () , self . mem24 () , self . mem25 () , self . mem26 () , self . mem27 () , self . mem28 () , self . mem29 () , self . mem30 () , self . mem31 ())
            }
        }
        #[doc = "Description cluster: RAM retention for the second bank in the RAM block"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ret2(pub u32);
        impl Ret2 {
            #[doc = "Keep the second bank in RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[must_use]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ret2 {
            #[inline(always)]
            fn default() -> Ret2 {
                Ret2(0)
            }
        }
        impl core::fmt::Debug for Ret2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ret2")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ret2 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ret2 {{ mem0: {=bool:?}, mem1: {=bool:?}, mem2: {=bool:?}, mem3: {=bool:?}, mem4: {=bool:?}, mem5: {=bool:?}, mem6: {=bool:?}, mem7: {=bool:?}, mem8: {=bool:?}, mem9: {=bool:?}, mem10: {=bool:?}, mem11: {=bool:?}, mem12: {=bool:?}, mem13: {=bool:?}, mem14: {=bool:?}, mem15: {=bool:?}, mem16: {=bool:?}, mem17: {=bool:?}, mem18: {=bool:?}, mem19: {=bool:?}, mem20: {=bool:?}, mem21: {=bool:?}, mem22: {=bool:?}, mem23: {=bool:?}, mem24: {=bool:?}, mem25: {=bool:?}, mem26: {=bool:?}, mem27: {=bool:?}, mem28: {=bool:?}, mem29: {=bool:?}, mem30: {=bool:?}, mem31: {=bool:?} }}" , self . mem0 () , self . mem1 () , self . mem2 () , self . mem3 () , self . mem4 () , self . mem5 () , self . mem6 () , self . mem7 () , self . mem8 () , self . mem9 () , self . mem10 () , self . mem11 () , self . mem12 () , self . mem13 () , self . mem14 () , self . mem15 () , self . mem16 () , self . mem17 () , self . mem18 () , self . mem19 () , self . mem20 () , self . mem21 () , self . mem22 () , self . mem23 () , self . mem24 () , self . mem25 () , self . mem26 () , self . mem27 () , self . mem28 () , self . mem29 () , self . mem30 () , self . mem31 ())
            }
        }
    }
}
pub mod mpc {
    #[doc = "Global slave master port connection information"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Globalslave {
        ptr: *mut u8,
    }
    unsafe impl Send for Globalslave {}
    unsafe impl Sync for Globalslave {}
    impl Globalslave {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Global slave connection information for master port"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::GlobalslaveMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Lock global slave registers"]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Memory Access Error status registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Memaccerr {}
    unsafe impl Sync for Memaccerr {}
    impl Memaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Target Address of Memory Access Error. Register content won't be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content won't be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn info(self) -> crate::common::Reg<regs::Info, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Memory Privilege Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mpc {
        ptr: *mut u8,
    }
    unsafe impl Send for Mpc {}
    unsafe impl Sync for Mpc {}
    impl Mpc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Memory Access Error event"]
        #[inline(always)]
        pub const fn events_memaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Memory Access Error status registers"]
        #[inline(always)]
        pub const fn memaccerr(self) -> Memaccerr {
            unsafe { Memaccerr::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Global slave master port connection information"]
        #[inline(always)]
        pub const fn globalslave(self) -> Globalslave {
            unsafe { Globalslave::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Memory region to slave decoding table"]
        #[inline(always)]
        pub const fn region(self, n: usize) -> Region {
            assert!(n < 8usize);
            unsafe { Region::from_ptr(self.ptr.add(0x0600usize + n * 16usize) as _) }
        }
        #[doc = "Special privilege tables"]
        #[inline(always)]
        pub const fn override_(self, n: usize) -> Override {
            assert!(n < 7usize);
            unsafe { Override::from_ptr(self.ptr.add(0x0800usize + n * 32usize) as _) }
        }
    }
    #[doc = "Special privilege tables"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Override {
        ptr: *mut u8,
    }
    unsafe impl Send for Override {}
    unsafe impl Sync for Override {}
    impl Override {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Override region n Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::OverrideConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Override region n Start Address"]
        #[inline(always)]
        pub const fn startaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Override region n End Address"]
        #[inline(always)]
        pub const fn endaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[inline(always)]
        pub const fn permmask(self) -> crate::common::Reg<regs::Permmask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Description cluster: Owner for override region"]
        #[inline(always)]
        pub const fn owner(self) -> crate::common::Reg<regs::Owner, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Description cluster: Override region n local master enable"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::OverrideMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Memory region to slave decoding table"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Region {
        ptr: *mut u8,
    }
    unsafe impl Send for Region {}
    unsafe impl Sync for Region {}
    impl Region {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Slave region n Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RegionConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Region n start address"]
        #[inline(always)]
        pub const fn startaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Select which bits of the incoming address are compared against the STARTADDR"]
        #[inline(always)]
        pub const fn addrmask(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Region n local master enable"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::RegionMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Global slave connection information for master port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlobalslaveMasterport(pub u32);
        impl GlobalslaveMasterport {
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[must_use]
            #[inline(always)]
            pub const fn connection_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn set_connection_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for GlobalslaveMasterport {
            #[inline(always)]
            fn default() -> GlobalslaveMasterport {
                GlobalslaveMasterport(0)
            }
        }
        impl core::fmt::Debug for GlobalslaveMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlobalslaveMasterport")
                    .field("connection_0", &self.connection_0())
                    .field("connection_1", &self.connection_1())
                    .field("connection_2", &self.connection_2())
                    .field("connection_3", &self.connection_3())
                    .field("connection_4", &self.connection_4())
                    .field("connection_5", &self.connection_5())
                    .field("connection_6", &self.connection_6())
                    .field("connection_7", &self.connection_7())
                    .field("connection_8", &self.connection_8())
                    .field("connection_9", &self.connection_9())
                    .field("connection_10", &self.connection_10())
                    .field("connection_11", &self.connection_11())
                    .field("connection_12", &self.connection_12())
                    .field("connection_13", &self.connection_13())
                    .field("connection_14", &self.connection_14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlobalslaveMasterport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GlobalslaveMasterport {{ connection_0: {=bool:?}, connection_1: {=bool:?}, connection_2: {=bool:?}, connection_3: {=bool:?}, connection_4: {=bool:?}, connection_5: {=bool:?}, connection_6: {=bool:?}, connection_7: {=bool:?}, connection_8: {=bool:?}, connection_9: {=bool:?}, connection_10: {=bool:?}, connection_11: {=bool:?}, connection_12: {=bool:?}, connection_13: {=bool:?}, connection_14: {=bool:?} }}" , self . connection_0 () , self . connection_1 () , self . connection_2 () , self . connection_3 () , self . connection_4 () , self . connection_5 () , self . connection_6 () , self . connection_7 () , self . connection_8 () , self . connection_9 () , self . connection_10 () , self . connection_11 () , self . connection_12 () , self . connection_13 () , self . connection_14 ())
            }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content won't be changed as long as MEMACCERR event is active."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Info(pub u32);
        impl Info {
            #[doc = "Owner identifier of the erroneous access"]
            #[must_use]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Owner identifier of the erroneous access"]
            #[inline(always)]
            pub const fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Master port where erroneous access is detected"]
            #[must_use]
            #[inline(always)]
            pub const fn masterport(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x1f;
                val as u8
            }
            #[doc = "Master port where erroneous access is detected"]
            #[inline(always)]
            pub const fn set_masterport(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 4usize)) | (((val as u32) & 0x1f) << 4usize);
            }
            #[doc = "Read bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Read bit of bus access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Write bit of bus access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Execute bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Execute bit of bus access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Secure bit of bus access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Secure bit of bus access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Source of memory access error"]
            #[must_use]
            #[inline(always)]
            pub const fn errorsource(&self) -> super::vals::Errorsource {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Errorsource::from_bits(val as u8)
            }
            #[doc = "Source of memory access error"]
            #[inline(always)]
            pub const fn set_errorsource(&mut self, val: super::vals::Errorsource) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Info {
            #[inline(always)]
            fn default() -> Info {
                Info(0)
            }
        }
        impl core::fmt::Debug for Info {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Info")
                    .field("ownerid", &self.ownerid())
                    .field("masterport", &self.masterport())
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("errorsource", &self.errorsource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Info {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Info {{ ownerid: {=u8:?}, masterport: {=u8:?}, read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, errorsource: {:?} }}" , self . ownerid () , self . masterport () , self . read () , self . write () , self . execute () , self . secure () , self . errorsource ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn memaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[inline(always)]
            pub const fn set_memaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("memaccerr", &self.memaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ memaccerr: {=bool:?} }}", self.memaccerr())
            }
        }
        #[doc = "Lock global slave registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Enable lock"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lock {{ lock: {=bool:?} }}", self.lock())
            }
        }
        #[doc = "Description cluster: Override region n Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OverrideConfig(pub u32);
        impl OverrideConfig {
            #[doc = "Target slave number for override region n accesses. Slave number 0 is reserved for default slave"]
            #[must_use]
            #[inline(always)]
            pub const fn slavenumber(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Target slave number for override region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub const fn set_slavenumber(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Lock Override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Override region n"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Override region n"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Secure mask enable for Override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn securemask(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Secure mask enable for Override region n"]
            #[inline(always)]
            pub const fn set_securemask(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for OverrideConfig {
            #[inline(always)]
            fn default() -> OverrideConfig {
                OverrideConfig(0)
            }
        }
        impl core::fmt::Debug for OverrideConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OverrideConfig")
                    .field("slavenumber", &self.slavenumber())
                    .field("lock", &self.lock())
                    .field("enable", &self.enable())
                    .field("securemask", &self.securemask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OverrideConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OverrideConfig {{ slavenumber: {=u8:?}, lock: {=bool:?}, enable: {=bool:?}, securemask: {=bool:?} }}" , self . slavenumber () , self . lock () , self . enable () , self . securemask ())
            }
        }
        #[doc = "Description cluster: Override region n local master enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OverrideMasterport(pub u32);
        impl OverrideMasterport {
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable override"]
            #[must_use]
            #[inline(always)]
            pub const fn enable14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn set_enable14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for OverrideMasterport {
            #[inline(always)]
            fn default() -> OverrideMasterport {
                OverrideMasterport(0)
            }
        }
        impl core::fmt::Debug for OverrideMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OverrideMasterport")
                    .field("enable0", &self.enable0())
                    .field("enable1", &self.enable1())
                    .field("enable2", &self.enable2())
                    .field("enable3", &self.enable3())
                    .field("enable4", &self.enable4())
                    .field("enable5", &self.enable5())
                    .field("enable6", &self.enable6())
                    .field("enable7", &self.enable7())
                    .field("enable8", &self.enable8())
                    .field("enable9", &self.enable9())
                    .field("enable10", &self.enable10())
                    .field("enable11", &self.enable11())
                    .field("enable12", &self.enable12())
                    .field("enable13", &self.enable13())
                    .field("enable14", &self.enable14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OverrideMasterport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "OverrideMasterport {{ enable0: {=bool:?}, enable1: {=bool:?}, enable2: {=bool:?}, enable3: {=bool:?}, enable4: {=bool:?}, enable5: {=bool:?}, enable6: {=bool:?}, enable7: {=bool:?}, enable8: {=bool:?}, enable9: {=bool:?}, enable10: {=bool:?}, enable11: {=bool:?}, enable12: {=bool:?}, enable13: {=bool:?}, enable14: {=bool:?} }}" , self . enable0 () , self . enable1 () , self . enable2 () , self . enable3 () , self . enable4 () , self . enable5 () , self . enable6 () , self . enable7 () , self . enable8 () , self . enable9 () , self . enable10 () , self . enable11 () , self . enable12 () , self . enable13 () , self . enable14 ())
            }
        }
        #[doc = "Description cluster: Owner for override region"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Owner(pub u32);
        impl Owner {
            #[doc = "owner identifier for override region n"]
            #[must_use]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "owner identifier for override region n"]
            #[inline(always)]
            pub const fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Owner {
            #[inline(always)]
            fn default() -> Owner {
                Owner(0)
            }
        }
        impl core::fmt::Debug for Owner {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Owner")
                    .field("ownerid", &self.ownerid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Owner {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Owner {{ ownerid: {=u8:?} }}", self.ownerid())
            }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software execute"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Perm {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secattr: {=bool:?} }}" , self . read () , self . write () , self . execute () , self . secattr ())
            }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Permmask(pub u32);
        impl Permmask {
            #[doc = "Read mask"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> super::vals::PermmaskRead {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PermmaskRead::from_bits(val as u8)
            }
            #[doc = "Read mask"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: super::vals::PermmaskRead) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Write mask"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> super::vals::PermmaskWrite {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PermmaskWrite::from_bits(val as u8)
            }
            #[doc = "Write mask"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: super::vals::PermmaskWrite) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute mask"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> super::vals::PermmaskExecute {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PermmaskExecute::from_bits(val as u8)
            }
            #[doc = "Execute mask"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: super::vals::PermmaskExecute) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping mask"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> super::vals::PermmaskSecattr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PermmaskSecattr::from_bits(val as u8)
            }
            #[doc = "Security mapping mask"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: super::vals::PermmaskSecattr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Permmask {
            #[inline(always)]
            fn default() -> Permmask {
                Permmask(0)
            }
        }
        impl core::fmt::Debug for Permmask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Permmask")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Permmask {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Permmask {{ read: {:?}, write: {:?}, execute: {:?}, secattr: {:?} }}",
                    self.read(),
                    self.write(),
                    self.execute(),
                    self.secattr()
                )
            }
        }
        #[doc = "Description cluster: Slave region n Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionConfig(pub u32);
        impl RegionConfig {
            #[doc = "Target slave number for region n accesses. Slave number 0 is reserved for default slave"]
            #[must_use]
            #[inline(always)]
            pub const fn slavenumber(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Target slave number for region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub const fn set_slavenumber(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Locks the region n setting"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the region n setting"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Region n enable"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Region n enable"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Software execute"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Memory security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Memory security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Region owner identifier."]
            #[must_use]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Region owner identifier."]
            #[inline(always)]
            pub const fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
        }
        impl Default for RegionConfig {
            #[inline(always)]
            fn default() -> RegionConfig {
                RegionConfig(0)
            }
        }
        impl core::fmt::Debug for RegionConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionConfig")
                    .field("slavenumber", &self.slavenumber())
                    .field("lock", &self.lock())
                    .field("enable", &self.enable())
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .field("ownerid", &self.ownerid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RegionConfig {{ slavenumber: {=u8:?}, lock: {=bool:?}, enable: {=bool:?}, read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secattr: {=bool:?}, ownerid: {=u8:?} }}" , self . slavenumber () , self . lock () , self . enable () , self . read () , self . write () , self . execute () , self . secattr () , self . ownerid ())
            }
        }
        #[doc = "Description cluster: Region n local master enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionMasterport(pub u32);
        impl RegionMasterport {
            #[doc = "Enable region n for master port 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 0"]
            #[inline(always)]
            pub const fn set_enable0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable region n for master port 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 1"]
            #[inline(always)]
            pub const fn set_enable1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable region n for master port 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 2"]
            #[inline(always)]
            pub const fn set_enable2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable region n for master port 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 3"]
            #[inline(always)]
            pub const fn set_enable3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable region n for master port 4"]
            #[must_use]
            #[inline(always)]
            pub const fn enable4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 4"]
            #[inline(always)]
            pub const fn set_enable4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable region n for master port 5"]
            #[must_use]
            #[inline(always)]
            pub const fn enable5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 5"]
            #[inline(always)]
            pub const fn set_enable5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable region n for master port 6"]
            #[must_use]
            #[inline(always)]
            pub const fn enable6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 6"]
            #[inline(always)]
            pub const fn set_enable6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable region n for master port 7"]
            #[must_use]
            #[inline(always)]
            pub const fn enable7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 7"]
            #[inline(always)]
            pub const fn set_enable7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable region n for master port 8"]
            #[must_use]
            #[inline(always)]
            pub const fn enable8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 8"]
            #[inline(always)]
            pub const fn set_enable8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable region n for master port 9"]
            #[must_use]
            #[inline(always)]
            pub const fn enable9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 9"]
            #[inline(always)]
            pub const fn set_enable9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable region n for master port 10"]
            #[must_use]
            #[inline(always)]
            pub const fn enable10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 10"]
            #[inline(always)]
            pub const fn set_enable10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable region n for master port 11"]
            #[must_use]
            #[inline(always)]
            pub const fn enable11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 11"]
            #[inline(always)]
            pub const fn set_enable11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable region n for master port 12"]
            #[must_use]
            #[inline(always)]
            pub const fn enable12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 12"]
            #[inline(always)]
            pub const fn set_enable12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable region n for master port 13"]
            #[must_use]
            #[inline(always)]
            pub const fn enable13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 13"]
            #[inline(always)]
            pub const fn set_enable13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable region n for master port 14"]
            #[must_use]
            #[inline(always)]
            pub const fn enable14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 14"]
            #[inline(always)]
            pub const fn set_enable14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for RegionMasterport {
            #[inline(always)]
            fn default() -> RegionMasterport {
                RegionMasterport(0)
            }
        }
        impl core::fmt::Debug for RegionMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionMasterport")
                    .field("enable0", &self.enable0())
                    .field("enable1", &self.enable1())
                    .field("enable2", &self.enable2())
                    .field("enable3", &self.enable3())
                    .field("enable4", &self.enable4())
                    .field("enable5", &self.enable5())
                    .field("enable6", &self.enable6())
                    .field("enable7", &self.enable7())
                    .field("enable8", &self.enable8())
                    .field("enable9", &self.enable9())
                    .field("enable10", &self.enable10())
                    .field("enable11", &self.enable11())
                    .field("enable12", &self.enable12())
                    .field("enable13", &self.enable13())
                    .field("enable14", &self.enable14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionMasterport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RegionMasterport {{ enable0: {=bool:?}, enable1: {=bool:?}, enable2: {=bool:?}, enable3: {=bool:?}, enable4: {=bool:?}, enable5: {=bool:?}, enable6: {=bool:?}, enable7: {=bool:?}, enable8: {=bool:?}, enable9: {=bool:?}, enable10: {=bool:?}, enable11: {=bool:?}, enable12: {=bool:?}, enable13: {=bool:?}, enable14: {=bool:?} }}" , self . enable0 () , self . enable1 () , self . enable2 () , self . enable3 () , self . enable4 () , self . enable5 () , self . enable6 () , self . enable7 () , self . enable8 () , self . enable9 () , self . enable10 () , self . enable11 () , self . enable12 () , self . enable13 () , self . enable14 ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorsource {
            #[doc = "Error was triggered by an AXI slave"]
            SLAVE = 0x0,
            #[doc = "Error was triggered by MPC module"]
            MPC = 0x01,
        }
        impl Errorsource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorsource {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorsource {
            #[inline(always)]
            fn from(val: u8) -> Errorsource {
                Errorsource::from_bits(val)
            }
        }
        impl From<Errorsource> for u8 {
            #[inline(always)]
            fn from(val: Errorsource) -> u8 {
                Errorsource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskExecute {
            #[doc = "Permission setting EXECUTE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting EXECUTE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskExecute {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskExecute {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskExecute {
            #[inline(always)]
            fn from(val: u8) -> PermmaskExecute {
                PermmaskExecute::from_bits(val)
            }
        }
        impl From<PermmaskExecute> for u8 {
            #[inline(always)]
            fn from(val: PermmaskExecute) -> u8 {
                PermmaskExecute::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskRead {
            #[doc = "Permission setting READ in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting READ in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskRead {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskRead {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskRead {
            #[inline(always)]
            fn from(val: u8) -> PermmaskRead {
                PermmaskRead::from_bits(val)
            }
        }
        impl From<PermmaskRead> for u8 {
            #[inline(always)]
            fn from(val: PermmaskRead) -> u8 {
                PermmaskRead::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskSecattr {
            #[doc = "Permission setting SECATTR in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting SECATTR in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskSecattr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskSecattr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskSecattr {
            #[inline(always)]
            fn from(val: u8) -> PermmaskSecattr {
                PermmaskSecattr::from_bits(val)
            }
        }
        impl From<PermmaskSecattr> for u8 {
            #[inline(always)]
            fn from(val: PermmaskSecattr) -> u8 {
                PermmaskSecattr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskWrite {
            #[doc = "Permission setting WRITE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting WRITE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskWrite {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskWrite {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskWrite {
            #[inline(always)]
            fn from(val: u8) -> PermmaskWrite {
                PermmaskWrite::from_bits(val)
            }
        }
        impl From<PermmaskWrite> for u8 {
            #[inline(always)]
            fn from(val: PermmaskWrite) -> u8 {
                PermmaskWrite::to_bits(val)
            }
        }
    }
}
pub mod nfct {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Framestatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Framestatus {}
    unsafe impl Sync for Framestatus {}
    impl Framestatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Result of last incoming frame"]
        #[inline(always)]
        pub const fn rx(self) -> crate::common::Reg<regs::Rx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfcid1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfcid1 {}
    unsafe impl Sync for Nfcid1 {}
    impl Nfcid1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn last(self) -> crate::common::Reg<regs::Last, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn secondlast(self) -> crate::common::Reg<regs::Secondlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[inline(always)]
        pub const fn thirdlast(self) -> crate::common::Reg<regs::Thirdlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfct {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfct {}
    unsafe impl Sync for Nfct {}
    impl Nfct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Activate NFCT peripheral for incoming and outgoing frames, change state to activated"]
        #[inline(always)]
        pub const fn tasks_activate(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Disable NFCT peripheral"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Enable NFC sense field mode, change state to sense mode"]
        #[inline(always)]
        pub const fn tasks_sense(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Start transmission of an outgoing frame, change state to transmit"]
        #[inline(always)]
        pub const fn tasks_starttx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Stops an issued transmission of a frame"]
        #[inline(always)]
        pub const fn tasks_stoptx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Initializes the EasyDMA for receive."]
        #[inline(always)]
        pub const fn tasks_enablerxdata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Force state machine to IDLE state"]
        #[inline(always)]
        pub const fn tasks_goidle(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Force state machine to SLEEP_A state"]
        #[inline(always)]
        pub const fn tasks_gosleep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACTIVATE"]
        #[inline(always)]
        pub const fn subscribe_activate(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SENSE"]
        #[inline(always)]
        pub const fn subscribe_sense(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTTX"]
        #[inline(always)]
        pub const fn subscribe_starttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task STOPTX"]
        #[inline(always)]
        pub const fn subscribe_stoptx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task ENABLERXDATA"]
        #[inline(always)]
        pub const fn subscribe_enablerxdata(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task GOIDLE"]
        #[inline(always)]
        pub const fn subscribe_goidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task GOSLEEP"]
        #[inline(always)]
        pub const fn subscribe_gosleep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "The NFCT peripheral is ready to receive and send frames"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Remote NFC field detected"]
        #[inline(always)]
        pub const fn events_fielddetected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Remote NFC field lost"]
        #[inline(always)]
        pub const fn events_fieldlost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Marks the start of the first symbol of a transmitted frame"]
        #[inline(always)]
        pub const fn events_txframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Marks the end of the last transmitted on-air symbol of a frame"]
        #[inline(always)]
        pub const fn events_txframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Marks the end of the first symbol of a received frame"]
        #[inline(always)]
        pub const fn events_rxframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer"]
        #[inline(always)]
        pub const fn events_rxframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "NFC error reported. The ERRORSTATUS register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_rxerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full."]
        #[inline(always)]
        pub const fn events_endrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer"]
        #[inline(always)]
        pub const fn events_endtx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Auto collision resolution process has started"]
        #[inline(always)]
        pub const fn events_autocolresstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "NFC auto collision resolution error reported."]
        #[inline(always)]
        pub const fn events_collision(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
        }
        #[doc = "NFC auto collision resolution successfully completed"]
        #[inline(always)]
        pub const fn events_selected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "EasyDMA is ready to receive or send frames."]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDDETECTED"]
        #[inline(always)]
        pub const fn publish_fielddetected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDLOST"]
        #[inline(always)]
        pub const fn publish_fieldlost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_txframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_txframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_rxframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_rxframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RXERROR"]
        #[inline(always)]
        pub const fn publish_rxerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01acusize) as _) }
        }
        #[doc = "Publish configuration for event ENDTX"]
        #[inline(always)]
        pub const fn publish_endtx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event AUTOCOLRESSTARTED"]
        #[inline(always)]
        pub const fn publish_autocolresstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for event COLLISION"]
        #[inline(always)]
        pub const fn publish_collision(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Publish configuration for event SELECTED"]
        #[inline(always)]
        pub const fn publish_selected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "NFC Error Status register"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn framestatus(self) -> Framestatus {
            unsafe { Framestatus::from_ptr(self.ptr.add(0x040cusize) as _) }
        }
        #[doc = "Current operating state of NFC tag"]
        #[inline(always)]
        pub const fn nfctagstate(self) -> crate::common::Reg<regs::Nfctagstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[inline(always)]
        pub const fn sleepstate(self) -> crate::common::Reg<regs::Sleepstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[inline(always)]
        pub const fn fieldpresent(
            self,
        ) -> crate::common::Reg<regs::Fieldpresent, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x043cusize) as _) }
        }
        #[doc = "Minimum frame delay"]
        #[inline(always)]
        pub const fn framedelaymin(
            self,
        ) -> crate::common::Reg<regs::Framedelaymin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Maximum frame delay"]
        #[inline(always)]
        pub const fn framedelaymax(
            self,
        ) -> crate::common::Reg<regs::Framedelaymax, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[inline(always)]
        pub const fn framedelaymode(
            self,
        ) -> crate::common::Reg<regs::Framedelaymode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Packet pointer for TXD and RXD data storage in Data RAM"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[inline(always)]
        pub const fn maxlen(self) -> crate::common::Reg<regs::Maxlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[inline(always)]
        pub const fn modulationctrl(
            self,
        ) -> crate::common::Reg<regs::Modulationctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x052cusize) as _) }
        }
        #[doc = "Pin select for Modulation control"]
        #[inline(always)]
        pub const fn modulationpsel(
            self,
        ) -> crate::common::Reg<regs::Modulationpsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Configure EasyDMA mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfcid1(self) -> Nfcid1 {
            unsafe { Nfcid1::from_ptr(self.ptr.add(0x0590usize) as _) }
        }
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[inline(always)]
        pub const fn autocolresconfig(
            self,
        ) -> crate::common::Reg<regs::Autocolresconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x059cusize) as _) }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[inline(always)]
        pub const fn sensres(self) -> crate::common::Reg<regs::Sensres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a0usize) as _) }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[inline(always)]
        pub const fn selres(self) -> crate::common::Reg<regs::Selres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a4usize) as _) }
        }
        #[doc = "NFC pad configuration"]
        #[inline(always)]
        pub const fn padconfig(self) -> crate::common::Reg<regs::Padconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06d4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of incoming frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::RxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Size of last incoming frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of outgoing frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::TxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Size of outgoing frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Autocolresconfig(pub u32);
        impl Autocolresconfig {
            #[doc = "Enables/disables auto collision resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Enables/disables auto collision resolution"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Autocolresconfig {
            #[inline(always)]
            fn default() -> Autocolresconfig {
                Autocolresconfig(0)
            }
        }
        impl core::fmt::Debug for Autocolresconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Autocolresconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Autocolresconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Autocolresconfig {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "NFC Error Status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaytimeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[inline(always)]
            pub const fn set_framedelaytimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("framedelaytimeout", &self.framedelaytimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorstatus {{ framedelaytimeout: {=bool:?} }}",
                    self.framedelaytimeout()
                )
            }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fieldpresent(pub u32);
        impl Fieldpresent {
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[must_use]
            #[inline(always)]
            pub const fn fieldpresent(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[inline(always)]
            pub const fn set_fieldpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[must_use]
            #[inline(always)]
            pub const fn lockdetect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[inline(always)]
            pub const fn set_lockdetect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Fieldpresent {
            #[inline(always)]
            fn default() -> Fieldpresent {
                Fieldpresent(0)
            }
        }
        impl core::fmt::Debug for Fieldpresent {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fieldpresent")
                    .field("fieldpresent", &self.fieldpresent())
                    .field("lockdetect", &self.lockdetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fieldpresent {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Fieldpresent {{ fieldpresent: {=bool:?}, lockdetect: {=bool:?} }}",
                    self.fieldpresent(),
                    self.lockdetect()
                )
            }
        }
        #[doc = "Maximum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymax(pub u32);
        impl Framedelaymax {
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymax(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn set_framedelaymax(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Framedelaymax {
            #[inline(always)]
            fn default() -> Framedelaymax {
                Framedelaymax(0)
            }
        }
        impl core::fmt::Debug for Framedelaymax {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymax")
                    .field("framedelaymax", &self.framedelaymax())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymax {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymax {{ framedelaymax: {=u32:?} }}",
                    self.framedelaymax()
                )
            }
        }
        #[doc = "Minimum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymin(pub u32);
        impl Framedelaymin {
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn set_framedelaymin(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Framedelaymin {
            #[inline(always)]
            fn default() -> Framedelaymin {
                Framedelaymin(0)
            }
        }
        impl core::fmt::Debug for Framedelaymin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymin")
                    .field("framedelaymin", &self.framedelaymin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymin {{ framedelaymin: {=u16:?} }}",
                    self.framedelaymin()
                )
            }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymode(pub u32);
        impl Framedelaymode {
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[must_use]
            #[inline(always)]
            pub const fn framedelaymode(&self) -> super::vals::Framedelaymode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Framedelaymode::from_bits(val as u8)
            }
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[inline(always)]
            pub const fn set_framedelaymode(&mut self, val: super::vals::Framedelaymode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Framedelaymode {
            #[inline(always)]
            fn default() -> Framedelaymode {
                Framedelaymode(0)
            }
        }
        impl core::fmt::Debug for Framedelaymode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymode")
                    .field("framedelaymode", &self.framedelaymode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Framedelaymode {{ framedelaymode: {:?} }}",
                    self.framedelaymode()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[must_use]
            #[inline(always)]
            pub const fn fielddetected(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[inline(always)]
            pub const fn set_fielddetected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldlost(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[inline(always)]
            pub const fn set_fieldlost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn txframestart(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[inline(always)]
            pub const fn set_txframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[must_use]
            #[inline(always)]
            pub const fn txframeend(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[inline(always)]
            pub const fn set_txframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn rxframestart(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[inline(always)]
            pub const fn set_rxframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[must_use]
            #[inline(always)]
            pub const fn rxframeend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[inline(always)]
            pub const fn set_rxframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn rxerror(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[inline(always)]
            pub const fn set_rxerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[must_use]
            #[inline(always)]
            pub const fn endrx(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn set_endrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[must_use]
            #[inline(always)]
            pub const fn endtx(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[inline(always)]
            pub const fn set_endtx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn autocolresstarted(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[inline(always)]
            pub const fn set_autocolresstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[must_use]
            #[inline(always)]
            pub const fn collision(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[inline(always)]
            pub const fn set_collision(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[must_use]
            #[inline(always)]
            pub const fn selected(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[inline(always)]
            pub const fn set_selected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("fielddetected", &self.fielddetected())
                    .field("fieldlost", &self.fieldlost())
                    .field("txframestart", &self.txframestart())
                    .field("txframeend", &self.txframeend())
                    .field("rxframestart", &self.rxframestart())
                    .field("rxframeend", &self.rxframeend())
                    .field("error", &self.error())
                    .field("rxerror", &self.rxerror())
                    .field("endrx", &self.endrx())
                    .field("endtx", &self.endtx())
                    .field("autocolresstarted", &self.autocolresstarted())
                    .field("collision", &self.collision())
                    .field("selected", &self.selected())
                    .field("started", &self.started())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ ready: {=bool:?}, fielddetected: {=bool:?}, fieldlost: {=bool:?}, txframestart: {=bool:?}, txframeend: {=bool:?}, rxframestart: {=bool:?}, rxframeend: {=bool:?}, error: {=bool:?}, rxerror: {=bool:?}, endrx: {=bool:?}, endtx: {=bool:?}, autocolresstarted: {=bool:?}, collision: {=bool:?}, selected: {=bool:?}, started: {=bool:?} }}" , self . ready () , self . fielddetected () , self . fieldlost () , self . txframestart () , self . txframeend () , self . rxframestart () , self . rxframeend () , self . error () , self . rxerror () , self . endrx () , self . endtx () , self . autocolresstarted () , self . collision () , self . selected () , self . started ())
            }
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Last(pub u32);
        impl Last {
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[must_use]
            #[inline(always)]
            pub const fn z(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[inline(always)]
            pub const fn set_z(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte Y"]
            #[must_use]
            #[inline(always)]
            pub const fn y(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Y"]
            #[inline(always)]
            pub const fn set_y(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte X"]
            #[must_use]
            #[inline(always)]
            pub const fn x(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte X"]
            #[inline(always)]
            pub const fn set_x(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "NFCID1 byte W"]
            #[must_use]
            #[inline(always)]
            pub const fn w(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte W"]
            #[inline(always)]
            pub const fn set_w(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Last {
            #[inline(always)]
            fn default() -> Last {
                Last(0)
            }
        }
        impl core::fmt::Debug for Last {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Last")
                    .field("z", &self.z())
                    .field("y", &self.y())
                    .field("x", &self.x())
                    .field("w", &self.w())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Last {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Last {{ z: {=u8:?}, y: {=u8:?}, x: {=u8:?}, w: {=u8:?} }}",
                    self.z(),
                    self.y(),
                    self.x(),
                    self.w()
                )
            }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxlen(pub u32);
        impl Maxlen {
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[must_use]
            #[inline(always)]
            pub const fn maxlen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[inline(always)]
            pub const fn set_maxlen(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Maxlen {
            #[inline(always)]
            fn default() -> Maxlen {
                Maxlen(0)
            }
        }
        impl core::fmt::Debug for Maxlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxlen")
                    .field("maxlen", &self.maxlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxlen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxlen {{ maxlen: {=u16:?} }}", self.maxlen())
            }
        }
        #[doc = "Configure EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Enable low-power operation, or use low-latency"]
            #[must_use]
            #[inline(always)]
            pub const fn lpop(&self) -> super::vals::Lpop {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lpop::from_bits(val as u8)
            }
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub const fn set_lpop(&mut self, val: super::vals::Lpop) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("lpop", &self.lpop()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ lpop: {:?} }}", self.lpop())
            }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationctrl(pub u32);
        impl Modulationctrl {
            #[doc = "Configuration of modulation control."]
            #[must_use]
            #[inline(always)]
            pub const fn modulationctrl(&self) -> super::vals::Modulationctrl {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Modulationctrl::from_bits(val as u8)
            }
            #[doc = "Configuration of modulation control."]
            #[inline(always)]
            pub const fn set_modulationctrl(&mut self, val: super::vals::Modulationctrl) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Modulationctrl {
            #[inline(always)]
            fn default() -> Modulationctrl {
                Modulationctrl(0)
            }
        }
        impl core::fmt::Debug for Modulationctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationctrl")
                    .field("modulationctrl", &self.modulationctrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Modulationctrl {{ modulationctrl: {:?} }}",
                    self.modulationctrl()
                )
            }
        }
        #[doc = "Pin select for Modulation control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationpsel(pub u32);
        impl Modulationpsel {
            #[doc = "Pin number"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::super::shared::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::super::shared::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::super::shared::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Modulationpsel {
            #[inline(always)]
            fn default() -> Modulationpsel {
                Modulationpsel(0)
            }
        }
        impl core::fmt::Debug for Modulationpsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationpsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationpsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Modulationpsel {{ pin: {=u8:?}, port: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.connect()
                )
            }
        }
        #[doc = "Current operating state of NFC tag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nfctagstate(pub u32);
        impl Nfctagstate {
            #[doc = "NfcTag state"]
            #[must_use]
            #[inline(always)]
            pub const fn nfctagstate(&self) -> super::vals::Nfctagstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfctagstate::from_bits(val as u8)
            }
            #[doc = "NfcTag state"]
            #[inline(always)]
            pub const fn set_nfctagstate(&mut self, val: super::vals::Nfctagstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Nfctagstate {
            #[inline(always)]
            fn default() -> Nfctagstate {
                Nfctagstate(0)
            }
        }
        impl core::fmt::Debug for Nfctagstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nfctagstate")
                    .field("nfctagstate", &self.nfctagstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nfctagstate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Nfctagstate {{ nfctagstate: {:?} }}", self.nfctagstate())
            }
        }
        #[doc = "NFC pad configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Padconfig(pub u32);
        impl Padconfig {
            #[doc = "Enable NFC pads"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable NFC pads"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Padconfig {
            #[inline(always)]
            fn default() -> Padconfig {
                Padconfig(0)
            }
        }
        impl core::fmt::Debug for Padconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Padconfig")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Padconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Padconfig {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Result of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rx(pub u32);
        impl Rx {
            #[doc = "No valid end of frame (EoF) detected"]
            #[must_use]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No valid end of frame (EoF) detected"]
            #[inline(always)]
            pub const fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity status of received frame"]
            #[must_use]
            #[inline(always)]
            pub const fn paritystatus(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Parity status of received frame"]
            #[inline(always)]
            pub const fn set_paritystatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Overrun detected"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun detected"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Rx {
            #[inline(always)]
            fn default() -> Rx {
                Rx(0)
            }
        }
        impl core::fmt::Debug for Rx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rx")
                    .field("crcerror", &self.crcerror())
                    .field("paritystatus", &self.paritystatus())
                    .field("overrun", &self.overrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rx {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Rx {{ crcerror: {=bool:?}, paritystatus: {=bool:?}, overrun: {=bool:?} }}",
                    self.crcerror(),
                    self.paritystatus(),
                    self.overrun()
                )
            }
        }
        #[doc = "Size of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[must_use]
            #[inline(always)]
            pub const fn rxdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[inline(always)]
            pub const fn set_rxdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[inline(always)]
            pub const fn set_rxdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("rxdatabits", &self.rxdatabits())
                    .field("rxdatabytes", &self.rxdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxdAmount {{ rxdatabits: {=u8:?}, rxdatabytes: {=u16:?} }}",
                    self.rxdatabits(),
                    self.rxdatabytes()
                )
            }
        }
        #[doc = "Configuration of incoming frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdFrameconfig(pub u32);
        impl RxdFrameconfig {
            #[doc = "Indicates if parity expected in RX frame"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity expected in RX frame"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SoF expected or not in RX frames"]
            #[must_use]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SoF expected or not in RX frames"]
            #[inline(always)]
            pub const fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for incoming frames"]
            #[must_use]
            #[inline(always)]
            pub const fn crcmoderx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for incoming frames"]
            #[inline(always)]
            pub const fn set_crcmoderx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for RxdFrameconfig {
            #[inline(always)]
            fn default() -> RxdFrameconfig {
                RxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for RxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("sof", &self.sof())
                    .field("crcmoderx", &self.crcmoderx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxdFrameconfig {{ parity: {=bool:?}, sof: {=bool:?}, crcmoderx: {=bool:?} }}",
                    self.parity(),
                    self.sof(),
                    self.crcmoderx()
                )
            }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Secondlast(pub u32);
        impl Secondlast {
            #[doc = "NFCID1 byte V"]
            #[must_use]
            #[inline(always)]
            pub const fn v(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte V"]
            #[inline(always)]
            pub const fn set_v(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte U"]
            #[must_use]
            #[inline(always)]
            pub const fn u(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte U"]
            #[inline(always)]
            pub const fn set_u(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte T"]
            #[must_use]
            #[inline(always)]
            pub const fn t(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte T"]
            #[inline(always)]
            pub const fn set_t(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Secondlast {
            #[inline(always)]
            fn default() -> Secondlast {
                Secondlast(0)
            }
        }
        impl core::fmt::Debug for Secondlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Secondlast")
                    .field("v", &self.v())
                    .field("u", &self.u())
                    .field("t", &self.t())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Secondlast {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Secondlast {{ v: {=u8:?}, u: {=u8:?}, t: {=u8:?} }}",
                    self.v(),
                    self.u(),
                    self.t()
                )
            }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Selres(pub u32);
        impl Selres {
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu10(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[must_use]
            #[inline(always)]
            pub const fn cascade(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[inline(always)]
            pub const fn set_cascade(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu43(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu43(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u32) & 0x03) << 3usize);
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn protocol(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_protocol(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Selres {
            #[inline(always)]
            fn default() -> Selres {
                Selres(0)
            }
        }
        impl core::fmt::Debug for Selres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Selres")
                    .field("rfu10", &self.rfu10())
                    .field("cascade", &self.cascade())
                    .field("rfu43", &self.rfu43())
                    .field("protocol", &self.protocol())
                    .field("rfu7", &self.rfu7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Selres {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Selres {{ rfu10: {=u8:?}, cascade: {=bool:?}, rfu43: {=u8:?}, protocol: {=u8:?}, rfu7: {=bool:?} }}" , self . rfu10 () , self . cascade () , self . rfu43 () , self . protocol () , self . rfu7 ())
            }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sensres(pub u32);
        impl Sensres {
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn bitframesdd(&self) -> super::vals::Bitframesdd {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Bitframesdd::from_bits(val as u8)
            }
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_bitframesdd(&mut self, val: super::vals::Bitframesdd) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[must_use]
            #[inline(always)]
            pub const fn nfcidsize(&self) -> super::vals::Nfcidsize {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Nfcidsize::from_bits(val as u8)
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[inline(always)]
            pub const fn set_nfcidsize(&mut self, val: super::vals::Nfcidsize) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[must_use]
            #[inline(always)]
            pub const fn platfconfig(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn set_platfconfig(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[must_use]
            #[inline(always)]
            pub const fn rfu74(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn set_rfu74(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Sensres {
            #[inline(always)]
            fn default() -> Sensres {
                Sensres(0)
            }
        }
        impl core::fmt::Debug for Sensres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sensres")
                    .field("bitframesdd", &self.bitframesdd())
                    .field("rfu5", &self.rfu5())
                    .field("nfcidsize", &self.nfcidsize())
                    .field("platfconfig", &self.platfconfig())
                    .field("rfu74", &self.rfu74())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sensres {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sensres {{ bitframesdd: {:?}, rfu5: {=bool:?}, nfcidsize: {:?}, platfconfig: {=u8:?}, rfu74: {=u8:?} }}" , self . bitframesdd () , self . rfu5 () , self . nfcidsize () , self . platfconfig () , self . rfu74 ())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[must_use]
            #[inline(always)]
            pub const fn fielddetected_activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[inline(always)]
            pub const fn set_fielddetected_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[must_use]
            #[inline(always)]
            pub const fn fieldlost_sense(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[inline(always)]
            pub const fn set_fieldlost_sense(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[must_use]
            #[inline(always)]
            pub const fn txframeend_enablerxdata(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[inline(always)]
            pub const fn set_txframeend_enablerxdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("fielddetected_activate", &self.fielddetected_activate())
                    .field("fieldlost_sense", &self.fieldlost_sense())
                    .field("txframeend_enablerxdata", &self.txframeend_enablerxdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ fielddetected_activate: {=bool:?}, fieldlost_sense: {=bool:?}, txframeend_enablerxdata: {=bool:?} }}" , self . fielddetected_activate () , self . fieldlost_sense () , self . txframeend_enablerxdata ())
            }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sleepstate(pub u32);
        impl Sleepstate {
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[must_use]
            #[inline(always)]
            pub const fn sleepstate(&self) -> super::vals::Sleepstate {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleepstate::from_bits(val as u8)
            }
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[inline(always)]
            pub const fn set_sleepstate(&mut self, val: super::vals::Sleepstate) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sleepstate {
            #[inline(always)]
            fn default() -> Sleepstate {
                Sleepstate(0)
            }
        }
        impl core::fmt::Debug for Sleepstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sleepstate")
                    .field("sleepstate", &self.sleepstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sleepstate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sleepstate {{ sleepstate: {:?} }}", self.sleepstate())
            }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Thirdlast(pub u32);
        impl Thirdlast {
            #[doc = "NFCID1 byte S"]
            #[must_use]
            #[inline(always)]
            pub const fn s(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte S"]
            #[inline(always)]
            pub const fn set_s(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte R"]
            #[must_use]
            #[inline(always)]
            pub const fn r(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte R"]
            #[inline(always)]
            pub const fn set_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte Q"]
            #[must_use]
            #[inline(always)]
            pub const fn q(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Q"]
            #[inline(always)]
            pub const fn set_q(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Thirdlast {
            #[inline(always)]
            fn default() -> Thirdlast {
                Thirdlast(0)
            }
        }
        impl core::fmt::Debug for Thirdlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Thirdlast")
                    .field("s", &self.s())
                    .field("r", &self.r())
                    .field("q", &self.q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Thirdlast {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Thirdlast {{ s: {=u8:?}, r: {=u8:?}, q: {=u8:?} }}",
                    self.s(),
                    self.r(),
                    self.q()
                )
            }
        }
        #[doc = "Size of outgoing frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[must_use]
            #[inline(always)]
            pub const fn txdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[inline(always)]
            pub const fn set_txdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[must_use]
            #[inline(always)]
            pub const fn txdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[inline(always)]
            pub const fn set_txdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("txdatabits", &self.txdatabits())
                    .field("txdatabytes", &self.txdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxdAmount {{ txdatabits: {=u8:?}, txdatabytes: {=u16:?} }}",
                    self.txdatabits(),
                    self.txdatabytes()
                )
            }
        }
        #[doc = "Configuration of outgoing frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdFrameconfig(pub u32);
        impl TxdFrameconfig {
            #[doc = "Indicates if parity is added to the frame"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity is added to the frame"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[must_use]
            #[inline(always)]
            pub const fn discardmode(&self) -> super::vals::Discardmode {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Discardmode::from_bits(val as u8)
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[inline(always)]
            pub const fn set_discardmode(&mut self, val: super::vals::Discardmode) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[must_use]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[inline(always)]
            pub const fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for outgoing frames"]
            #[must_use]
            #[inline(always)]
            pub const fn crcmodetx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for outgoing frames"]
            #[inline(always)]
            pub const fn set_crcmodetx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for TxdFrameconfig {
            #[inline(always)]
            fn default() -> TxdFrameconfig {
                TxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for TxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("discardmode", &self.discardmode())
                    .field("sof", &self.sof())
                    .field("crcmodetx", &self.crcmodetx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TxdFrameconfig {{ parity: {=bool:?}, discardmode: {:?}, sof: {=bool:?}, crcmodetx: {=bool:?} }}" , self . parity () , self . discardmode () , self . sof () , self . crcmodetx ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitframesdd {
            #[doc = "SDD pattern 00000"]
            SDD00000 = 0x0,
            #[doc = "SDD pattern 00001"]
            SDD00001 = 0x01,
            #[doc = "SDD pattern 00010"]
            SDD00010 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "SDD pattern 00100"]
            SDD00100 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "SDD pattern 01000"]
            SDD01000 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "SDD pattern 10000"]
            SDD10000 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Bitframesdd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitframesdd {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitframesdd {
            #[inline(always)]
            fn from(val: u8) -> Bitframesdd {
                Bitframesdd::from_bits(val)
            }
        }
        impl From<Bitframesdd> for u8 {
            #[inline(always)]
            fn from(val: Bitframesdd) -> u8 {
                Bitframesdd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Discardmode {
            #[doc = "Unused bits are discarded at end of frame (EoF)"]
            DISCARD_END = 0x0,
            #[doc = "Unused bits are discarded at start of frame (SoF)"]
            DISCARD_START = 0x01,
        }
        impl Discardmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Discardmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Discardmode {
            #[inline(always)]
            fn from(val: u8) -> Discardmode {
                Discardmode::from_bits(val)
            }
        }
        impl From<Discardmode> for u8 {
            #[inline(always)]
            fn from(val: Discardmode) -> u8 {
                Discardmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framedelaymode {
            #[doc = "Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout."]
            FREE_RUN = 0x0,
            #[doc = "Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW = 0x01,
            #[doc = "Frame is transmitted exactly at FRAMEDELAYMAX"]
            EXACT_VAL = 0x02,
            #[doc = "Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW_GRID = 0x03,
        }
        impl Framedelaymode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framedelaymode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framedelaymode {
            #[inline(always)]
            fn from(val: u8) -> Framedelaymode {
                Framedelaymode::from_bits(val)
            }
        }
        impl From<Framedelaymode> for u8 {
            #[inline(always)]
            fn from(val: Framedelaymode) -> u8 {
                Framedelaymode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpop {
            #[doc = "Low-latency operation"]
            LOW_LAT = 0x0,
            #[doc = "Low-power operation"]
            LOW_POWER = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Full Low-power operation"]
            FULL_LOW_POWER = 0x03,
        }
        impl Lpop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpop {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpop {
            #[inline(always)]
            fn from(val: u8) -> Lpop {
                Lpop::from_bits(val)
            }
        }
        impl From<Lpop> for u8 {
            #[inline(always)]
            fn from(val: Lpop) -> u8 {
                Lpop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Auto collision resolution enabled"]
            ENABLED = 0x0,
            #[doc = "Auto collision resolution disabled"]
            DISABLED = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modulationctrl {
            #[doc = "Invalid, defaults to same behaviour as for Internal"]
            INVALID = 0x0,
            #[doc = "Use internal modulator only"]
            INTERNAL = 0x01,
            #[doc = "Output digital modulation signal to a GPIO pin."]
            MOD_TO_GPIO = 0x02,
            #[doc = "Use internal modulator and output digital modulation signal to a GPIO pin."]
            INTERNAL_AND_MOD_TO_GPIO = 0x03,
        }
        impl Modulationctrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modulationctrl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modulationctrl {
            #[inline(always)]
            fn from(val: u8) -> Modulationctrl {
                Modulationctrl::from_bits(val)
            }
        }
        impl From<Modulationctrl> for u8 {
            #[inline(always)]
            fn from(val: Modulationctrl) -> u8 {
                Modulationctrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcidsize {
            #[doc = "NFCID1 size: single (4 bytes)"]
            NFCID1SINGLE = 0x0,
            #[doc = "NFCID1 size: double (7 bytes)"]
            NFCID1DOUBLE = 0x01,
            #[doc = "NFCID1 size: triple (10 bytes)"]
            NFCID1TRIPLE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcidsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcidsize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcidsize {
            #[inline(always)]
            fn from(val: u8) -> Nfcidsize {
                Nfcidsize::from_bits(val)
            }
        }
        impl From<Nfcidsize> for u8 {
            #[inline(always)]
            fn from(val: Nfcidsize) -> u8 {
                Nfcidsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfctagstate {
            #[doc = "Disabled or sense"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "RampUp"]
            RAMP_UP = 0x02,
            #[doc = "Idle"]
            IDLE = 0x03,
            #[doc = "Receive"]
            RECEIVE = 0x04,
            #[doc = "FrameDelay"]
            FRAME_DELAY = 0x05,
            #[doc = "Transmit"]
            TRANSMIT = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfctagstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfctagstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfctagstate {
            #[inline(always)]
            fn from(val: u8) -> Nfctagstate {
                Nfctagstate::from_bits(val)
            }
        }
        impl From<Nfctagstate> for u8 {
            #[inline(always)]
            fn from(val: Nfctagstate) -> u8 {
                Nfctagstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleepstate {
            #[doc = "State is IDLE."]
            IDLE = 0x0,
            #[doc = "State is SLEEP_A."]
            SLEEP_A = 0x01,
        }
        impl Sleepstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleepstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleepstate {
            #[inline(always)]
            fn from(val: u8) -> Sleepstate {
                Sleepstate::from_bits(val)
            }
        }
        impl From<Sleepstate> for u8 {
            #[inline(always)]
            fn from(val: Sleepstate) -> u8 {
                Sleepstate::to_bits(val)
            }
        }
    }
}
pub mod oscillators {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::ConfigIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Oscillator control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Oscillators {
        ptr: *mut u8,
    }
    unsafe impl Send for Oscillators {}
    unsafe impl Sync for Oscillators {}
    impl Oscillators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "32 MHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32m(self) -> Xosc32m {
            unsafe { Xosc32m::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
        #[doc = "Oscillator control"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "32.768 kHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32ki(self) -> Xosc32ki {
            unsafe { Xosc32ki::from_ptr(self.ptr.add(0x0900usize) as _) }
        }
    }
    #[doc = "Oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn freq(self) -> crate::common::Reg<regs::Freq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn currentfreq(self) -> crate::common::Reg<regs::Currentfreq, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "32.768 kHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32ki {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32ki {}
    unsafe impl Sync for Xosc32ki {}
    impl Xosc32ki {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::Xosc32kiIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "32 MHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32m {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32m {}
    unsafe impl Sync for Xosc32m {}
    impl Xosc32m {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConfigIntcap(pub u32);
        impl ConfigIntcap {
            #[doc = "Crystal load capacitor value"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Crystal load capacitor value"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for ConfigIntcap {
            #[inline(always)]
            fn default() -> ConfigIntcap {
                ConfigIntcap(0)
            }
        }
        impl core::fmt::Debug for ConfigIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConfigIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConfigIntcap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ConfigIntcap {{ val: {=u8:?} }}", self.val())
            }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentfreq(pub u32);
        impl Currentfreq {
            #[doc = "Active CPU speed"]
            #[must_use]
            #[inline(always)]
            pub const fn currentfreq(&self) -> super::vals::Currentfreq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Currentfreq::from_bits(val as u8)
            }
            #[doc = "Active CPU speed"]
            #[inline(always)]
            pub const fn set_currentfreq(&mut self, val: super::vals::Currentfreq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Currentfreq {
            #[inline(always)]
            fn default() -> Currentfreq {
                Currentfreq(0)
            }
        }
        impl core::fmt::Debug for Currentfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentfreq")
                    .field("currentfreq", &self.currentfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentfreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentfreq {{ currentfreq: {:?} }}", self.currentfreq())
            }
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freq(pub u32);
        impl Freq {
            #[doc = "Select CPU speed"]
            #[must_use]
            #[inline(always)]
            pub const fn freq(&self) -> super::vals::Freq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Freq::from_bits(val as u8)
            }
            #[doc = "Select CPU speed"]
            #[inline(always)]
            pub const fn set_freq(&mut self, val: super::vals::Freq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Freq {
            #[inline(always)]
            fn default() -> Freq {
                Freq(0)
            }
        }
        impl core::fmt::Debug for Freq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freq").field("freq", &self.freq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Freq {{ freq: {:?} }}", self.freq())
            }
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32kiIntcap(pub u32);
        impl Xosc32kiIntcap {
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Xosc32kiIntcap {
            #[inline(always)]
            fn default() -> Xosc32kiIntcap {
                Xosc32kiIntcap(0)
            }
        }
        impl core::fmt::Debug for Xosc32kiIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32kiIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32kiIntcap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Xosc32kiIntcap {{ val: {=u8:?} }}", self.val())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Currentfreq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Currentfreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Currentfreq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Currentfreq {
            #[inline(always)]
            fn from(val: u8) -> Currentfreq {
                Currentfreq::from_bits(val)
            }
        }
        impl From<Currentfreq> for u8 {
            #[inline(always)]
            fn from(val: Currentfreq) -> u8 {
                Currentfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Freq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freq {
            #[inline(always)]
            fn from(val: u8) -> Freq {
                Freq::from_bits(val)
            }
        }
        impl From<Freq> for u8 {
            #[inline(always)]
            fn from(val: Freq) -> u8 {
                Freq::to_bits(val)
            }
        }
    }
}
pub mod pdm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This event is generated if an error occurs during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pdm {}
    unsafe impl Sync for Pdm {}
    impl Pdm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous PDM transfer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops PDM transfer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "PDM transfer has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "PDM transfer has finished"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "PDM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Left output gain adjustment"]
        #[inline(always)]
        pub const fn gainl(self) -> crate::common::Reg<regs::Gainl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Right output gain adjustment"]
        #[inline(always)]
        pub const fn gainr(self) -> crate::common::Reg<regs::Gainr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x051cusize) as _) }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. Change PRESCALER accordingly."]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn sample(self) -> Sample {
            unsafe { Sample::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "The prescaler is used to set the PDM frequency"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0580usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin number configuration for PDM CLK signal"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin number configuration for PDM DIN signal"]
        #[inline(always)]
        pub const fn din(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event DMA.BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sample {
        ptr: *mut u8,
    }
    unsafe impl Send for Sample {}
    unsafe impl Sync for Sample {}
    impl Sample {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM address pointer to write samples to with EasyDMA"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PDM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PDM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PDM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Left output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainl(pub u32);
        impl Gainl {
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[must_use]
            #[inline(always)]
            pub const fn gainl(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[inline(always)]
            pub const fn set_gainl(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainl {
            #[inline(always)]
            fn default() -> Gainl {
                Gainl(0)
            }
        }
        impl core::fmt::Debug for Gainl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainl")
                    .field("gainl", &self.gainl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainl {{ gainl: {:?} }}", self.gainl())
            }
        }
        #[doc = "Right output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainr(pub u32);
        impl Gainr {
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[must_use]
            #[inline(always)]
            pub const fn gainr(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[inline(always)]
            pub const fn set_gainr(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainr {
            #[inline(always)]
            fn default() -> Gainr {
                Gainr(0)
            }
        }
        impl core::fmt::Debug for Gainr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainr")
                    .field("gainr", &self.gainr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gainr {{ gainr: {:?} }}", self.gainr())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmabuserror(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[inline(always)]
            pub const fn set_dmabuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmabuserror", &self.dmabuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, stopped: {=bool:?}, end: {=bool:?}, dmabuserror: {=bool:?} }}" , self . started () , self . stopped () , self . end () , self . dmabuserror ())
            }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[must_use]
            #[inline(always)]
            pub const fn buffsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[inline(always)]
            pub const fn set_buffsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("buffsize", &self.buffsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ buffsize: {=u16:?} }}", self.buffsize())
            }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Mono or stereo operation"]
            #[must_use]
            #[inline(always)]
            pub const fn operation(&self) -> super::vals::Operation {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Operation::from_bits(val as u8)
            }
            #[doc = "Mono or stereo operation"]
            #[inline(always)]
            pub const fn set_operation(&mut self, val: super::vals::Operation) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[must_use]
            #[inline(always)]
            pub const fn edge(&self) -> super::vals::Edge {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Edge::from_bits(val as u8)
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[inline(always)]
            pub const fn set_edge(&mut self, val: super::vals::Edge) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("operation", &self.operation())
                    .field("edge", &self.edge())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Mode {{ operation: {:?}, edge: {:?} }}",
                    self.operation(),
                    self.edge()
                )
            }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. Change PRESCALER accordingly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[must_use]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[inline(always)]
            pub const fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ratio {{ ratio: {:?} }}", self.ratio())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Terminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edge {
            #[doc = "Left (or mono) is sampled on falling edge of PDM_CLK"]
            LEFT_FALLING = 0x0,
            #[doc = "Left (or mono) is sampled on rising edge of PDM_CLK"]
            LEFT_RISING = 0x01,
        }
        impl Edge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edge {
            #[inline(always)]
            fn from(val: u8) -> Edge {
                Edge::from_bits(val)
            }
        }
        impl From<Edge> for u8 {
            #[inline(always)]
            fn from(val: Edge) -> u8 {
                Edge::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Gain(u8);
        impl Gain {
            #[doc = "-20 dB gain adjustment (minimum)"]
            pub const MIN_GAIN: Self = Self(0x0);
            #[doc = "0 dB gain adjustment"]
            pub const DEFAULT_GAIN: Self = Self(0x28);
            #[doc = "+20 dB gain adjustment (maximum)"]
            pub const MAX_GAIN: Self = Self(0x50);
        }
        impl Gain {
            pub const fn from_bits(val: u8) -> Gain {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_GAIN"),
                    0x28 => f.write_str("DEFAULT_GAIN"),
                    0x50 => f.write_str("MAX_GAIN"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_GAIN"),
                    0x28 => defmt::write!(f, "DEFAULT_GAIN"),
                    0x50 => defmt::write!(f, "MAX_GAIN"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Operation {
            #[doc = "Sample and store one pair (left + right) of 16-bit samples per RAM word R=\\[31:16\\]; L=\\[15:0\\]"]
            STEREO = 0x0,
            #[doc = "Sample and store two successive left samples (16 bits each) per RAM word L1=\\[31:16\\]; L0=\\[15:0\\]"]
            MONO = 0x01,
        }
        impl Operation {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Operation {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Operation {
            #[inline(always)]
            fn from(val: u8) -> Operation {
                Operation::from_bits(val)
            }
        }
        impl From<Operation> for u8 {
            #[inline(always)]
            fn from(val: Operation) -> u8 {
                Operation::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "Ratio of 32"]
            RATIO32 = 0x0,
            #[doc = "Ratio of 48"]
            RATIO48 = 0x01,
            #[doc = "Ratio of 50"]
            RATIO50 = 0x02,
            #[doc = "Ratio of 64"]
            RATIO64 = 0x03,
            #[doc = "Ratio of 80"]
            RATIO80 = 0x04,
            #[doc = "Ratio of 96"]
            RATIO96 = 0x05,
            #[doc = "Ratio of 100"]
            RATIO100 = 0x06,
            #[doc = "Ratio of 128"]
            RATIO128 = 0x07,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
    }
}
pub mod power {
    #[doc = "Power control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable Constant Latency mode"]
        #[inline(always)]
        pub const fn tasks_constlat(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Enable Low-power mode (variable latency)"]
        #[inline(always)]
        pub const fn tasks_lowpwr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Subscribe configuration for task CONSTLAT"]
        #[inline(always)]
        pub const fn subscribe_constlat(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "Subscribe configuration for task LOWPWR"]
        #[inline(always)]
        pub const fn subscribe_lowpwr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize) as _) }
        }
        #[doc = "Power failure warning"]
        #[inline(always)]
        pub const fn events_pofwarn(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "CPU entered WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepenter(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "CPU exited WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepexit(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Publish configuration for event POFWARN"]
        #[inline(always)]
        pub const fn publish_pofwarn(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPENTER"]
        #[inline(always)]
        pub const fn publish_sleepenter(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPEXIT"]
        #[inline(always)]
        pub const fn publish_sleepexit(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[inline(always)]
        pub const fn gpregret(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Gpregret, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
        #[doc = "Status of constant latency"]
        #[inline(always)]
        pub const fn constlatstat(
            self,
        ) -> crate::common::Reg<regs::Constlatstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status of constant latency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Constlatstat(pub u32);
        impl Constlatstat {
            #[doc = "Status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Constlatstat {
            #[inline(always)]
            fn default() -> Constlatstat {
                Constlatstat(0)
            }
        }
        impl core::fmt::Debug for Constlatstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Constlatstat")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Constlatstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Constlatstat {{ status: {=bool:?} }}", self.status())
            }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gpregret(pub u32);
        impl Gpregret {
            #[doc = "General purpose retention register"]
            #[must_use]
            #[inline(always)]
            pub const fn gpregret(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "General purpose retention register"]
            #[inline(always)]
            pub const fn set_gpregret(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Gpregret {
            #[inline(always)]
            fn default() -> Gpregret {
                Gpregret(0)
            }
        }
        impl core::fmt::Debug for Gpregret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gpregret")
                    .field("gpregret", &self.gpregret())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gpregret {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Gpregret {{ gpregret: {=u8:?} }}", self.gpregret())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[must_use]
            #[inline(always)]
            pub const fn pofwarn(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[inline(always)]
            pub const fn set_pofwarn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepenter(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[inline(always)]
            pub const fn set_sleepenter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[must_use]
            #[inline(always)]
            pub const fn sleepexit(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[inline(always)]
            pub const fn set_sleepexit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("pofwarn", &self.pofwarn())
                    .field("sleepenter", &self.sleepenter())
                    .field("sleepexit", &self.sleepexit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ pofwarn: {=bool:?}, sleepenter: {=bool:?}, sleepexit: {=bool:?} }}",
                    self.pofwarn(),
                    self.sleepenter(),
                    self.sleepexit()
                )
            }
        }
    }
}
pub mod ppib {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Overflow {
        ptr: *mut u8,
    }
    unsafe impl Send for Overflow {}
    unsafe impl Sync for Overflow {}
    impl Overflow {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[inline(always)]
        pub const fn send(self) -> crate::common::Reg<regs::Send, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "PPIB APB registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ppib {
        ptr: *mut u8,
    }
    unsafe impl Send for Ppib {}
    unsafe impl Sync for Ppib {}
    impl Ppib {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: This task is unused, but the PPIB provides the SUBSCRIBE task to connect SEND \\[n\\] task."]
        #[inline(always)]
        pub const fn tasks_send(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task SEND\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_send(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: This event is unused, but the PPIB provides the PUBLISH event to connect RECEIVE \\[n\\] event."]
        #[inline(always)]
        pub const fn events_receive(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event RECEIVE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_receive(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn overflow(self) -> Overflow {
            unsafe { Overflow::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Send(pub u32);
        impl Send {
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[inline(always)]
            pub const fn set_send_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[inline(always)]
            pub const fn set_send_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[inline(always)]
            pub const fn set_send_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[inline(always)]
            pub const fn set_send_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[inline(always)]
            pub const fn set_send_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[inline(always)]
            pub const fn set_send_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[inline(always)]
            pub const fn set_send_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[inline(always)]
            pub const fn set_send_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[inline(always)]
            pub const fn set_send_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[inline(always)]
            pub const fn set_send_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[inline(always)]
            pub const fn set_send_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[inline(always)]
            pub const fn set_send_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[inline(always)]
            pub const fn set_send_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[inline(always)]
            pub const fn set_send_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[inline(always)]
            pub const fn set_send_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[inline(always)]
            pub const fn set_send_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[inline(always)]
            pub const fn set_send_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[inline(always)]
            pub const fn set_send_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[inline(always)]
            pub const fn set_send_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[inline(always)]
            pub const fn set_send_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[inline(always)]
            pub const fn set_send_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[inline(always)]
            pub const fn set_send_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[inline(always)]
            pub const fn set_send_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[inline(always)]
            pub const fn set_send_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[inline(always)]
            pub const fn set_send_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[inline(always)]
            pub const fn set_send_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[inline(always)]
            pub const fn set_send_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[inline(always)]
            pub const fn set_send_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[inline(always)]
            pub const fn set_send_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[inline(always)]
            pub const fn set_send_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[inline(always)]
            pub const fn set_send_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[must_use]
            #[inline(always)]
            pub const fn send_31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[inline(always)]
            pub const fn set_send_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Send {
            #[inline(always)]
            fn default() -> Send {
                Send(0)
            }
        }
        impl core::fmt::Debug for Send {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Send")
                    .field("send_0", &self.send_0())
                    .field("send_1", &self.send_1())
                    .field("send_2", &self.send_2())
                    .field("send_3", &self.send_3())
                    .field("send_4", &self.send_4())
                    .field("send_5", &self.send_5())
                    .field("send_6", &self.send_6())
                    .field("send_7", &self.send_7())
                    .field("send_8", &self.send_8())
                    .field("send_9", &self.send_9())
                    .field("send_10", &self.send_10())
                    .field("send_11", &self.send_11())
                    .field("send_12", &self.send_12())
                    .field("send_13", &self.send_13())
                    .field("send_14", &self.send_14())
                    .field("send_15", &self.send_15())
                    .field("send_16", &self.send_16())
                    .field("send_17", &self.send_17())
                    .field("send_18", &self.send_18())
                    .field("send_19", &self.send_19())
                    .field("send_20", &self.send_20())
                    .field("send_21", &self.send_21())
                    .field("send_22", &self.send_22())
                    .field("send_23", &self.send_23())
                    .field("send_24", &self.send_24())
                    .field("send_25", &self.send_25())
                    .field("send_26", &self.send_26())
                    .field("send_27", &self.send_27())
                    .field("send_28", &self.send_28())
                    .field("send_29", &self.send_29())
                    .field("send_30", &self.send_30())
                    .field("send_31", &self.send_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Send {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Send {{ send_0: {=bool:?}, send_1: {=bool:?}, send_2: {=bool:?}, send_3: {=bool:?}, send_4: {=bool:?}, send_5: {=bool:?}, send_6: {=bool:?}, send_7: {=bool:?}, send_8: {=bool:?}, send_9: {=bool:?}, send_10: {=bool:?}, send_11: {=bool:?}, send_12: {=bool:?}, send_13: {=bool:?}, send_14: {=bool:?}, send_15: {=bool:?}, send_16: {=bool:?}, send_17: {=bool:?}, send_18: {=bool:?}, send_19: {=bool:?}, send_20: {=bool:?}, send_21: {=bool:?}, send_22: {=bool:?}, send_23: {=bool:?}, send_24: {=bool:?}, send_25: {=bool:?}, send_26: {=bool:?}, send_27: {=bool:?}, send_28: {=bool:?}, send_29: {=bool:?}, send_30: {=bool:?}, send_31: {=bool:?} }}" , self . send_0 () , self . send_1 () , self . send_2 () , self . send_3 () , self . send_4 () , self . send_5 () , self . send_6 () , self . send_7 () , self . send_8 () , self . send_9 () , self . send_10 () , self . send_11 () , self . send_12 () , self . send_13 () , self . send_14 () , self . send_15 () , self . send_16 () , self . send_17 () , self . send_18 () , self . send_19 () , self . send_20 () , self . send_21 () , self . send_22 () , self . send_23 () , self . send_24 () , self . send_25 () , self . send_26 () , self . send_27 () , self . send_28 () , self . send_29 () , self . send_30 () , self . send_31 ())
            }
        }
    }
}
pub mod pwm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> DmaSeq {
            assert!(n < 2usize);
            unsafe { DmaSeq::from_ptr(self.ptr.add(0x0usize + n * 36usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaSeq {}
    unsafe impl Sync for DmaSeq {}
    impl DmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Description cluster: Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> EventsDmaSeq {
            assert!(n < 2usize);
            unsafe { EventsDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaSeq {}
    unsafe impl Sync for EventsDmaSeq {}
    impl EventsDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Output pin select for PWM channel n"]
        #[inline(always)]
        pub const fn out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PublishDmaSeq {
            assert!(n < 2usize);
            unsafe { PublishDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaSeq {}
    unsafe impl Sync for PublishDmaSeq {}
    impl PublishDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Pulse width modulation unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm {}
    unsafe impl Sync for Pwm {}
    impl Pwm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running."]
        #[inline(always)]
        pub const fn tasks_nextstep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task NEXTSTEP"]
        #[inline(always)]
        pub const fn subscribe_nextstep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Response to STOP task, emitted when PWM pulses are no longer generated"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Description collection: First PWM period started on sequence n"]
        #[inline(always)]
        pub const fn events_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter"]
        #[inline(always)]
        pub const fn events_seqend(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize + n * 4usize) as _) }
        }
        #[doc = "Emitted at the end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"]
        #[inline(always)]
        pub const fn events_loopsdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Emitted when retrieving from RAM does not complete in time for the PWM module"]
        #[inline(always)]
        pub const fn events_ramunderflow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Description collection: This event is generated when the compare matches for the compare channel \\[n\\]."]
        #[inline(always)]
        pub const fn events_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQSTARTED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQEND\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqend(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event PWMPERIODEND"]
        #[inline(always)]
        pub const fn publish_pwmperiodend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event LOOPSDONE"]
        #[inline(always)]
        pub const fn publish_loopsdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RAMUNDERFLOW"]
        #[inline(always)]
        pub const fn publish_ramunderflow(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPAREMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn publish_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bcusize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "PWM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[inline(always)]
        pub const fn countertop(self) -> crate::common::Reg<regs::Countertop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Configuration of the decoder"]
        #[inline(always)]
        pub const fn decoder(self) -> crate::common::Reg<regs::Decoder, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Number of playbacks of a loop"]
        #[inline(always)]
        pub const fn loop_(self) -> crate::common::Reg<regs::Loop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[inline(always)]
        pub const fn idleout(self) -> crate::common::Reg<regs::Idleout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PwmSeq {
            assert!(n < 2usize);
            unsafe { PwmSeq::from_ptr(self.ptr.add(0x0520usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PwmSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PwmSeq {}
    unsafe impl Sync for PwmSeq {}
    impl PwmSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[inline(always)]
        pub const fn refresh(self) -> crate::common::Reg<regs::Refresh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[inline(always)]
        pub const fn enddelay(self) -> crate::common::Reg<regs::Enddelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> SubscribeDmaSeq {
            assert!(n < 2usize);
            unsafe { SubscribeDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaSeq {}
    unsafe impl Sync for SubscribeDmaSeq {}
    impl SubscribeDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> TasksDmaSeq {
            assert!(n < 2usize);
            unsafe { TasksDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaSeq {}
    unsafe impl Sync for TasksDmaSeq {}
    impl TasksDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Countertop(pub u32);
        impl Countertop {
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[must_use]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[inline(always)]
            pub const fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Countertop {
            #[inline(always)]
            fn default() -> Countertop {
                Countertop(0)
            }
        }
        impl core::fmt::Debug for Countertop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Countertop")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Countertop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Countertop {{ countertop: {=u16:?} }}",
                    self.countertop()
                )
            }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Configuration of the decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Decoder(pub u32);
        impl Decoder {
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[must_use]
            #[inline(always)]
            pub const fn load(&self) -> super::vals::Load {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Load::from_bits(val as u8)
            }
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[inline(always)]
            pub const fn set_load(&mut self, val: super::vals::Load) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Decoder {
            #[inline(always)]
            fn default() -> Decoder {
                Decoder(0)
            }
        }
        impl core::fmt::Debug for Decoder {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Decoder")
                    .field("load", &self.load())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Decoder {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Decoder {{ load: {:?}, mode: {:?} }}",
                    self.load(),
                    self.mode()
                )
            }
        }
        #[doc = "PWM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PWM module"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PWM module"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enddelay(pub u32);
        impl Enddelay {
            #[doc = "Time added after the sequence in PWM periods"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Time added after the sequence in PWM periods"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Enddelay {
            #[inline(always)]
            fn default() -> Enddelay {
                Enddelay(0)
            }
        }
        impl core::fmt::Debug for Enddelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enddelay")
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enddelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enddelay {{ cnt: {=u32:?} }}", self.cnt())
            }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idleout(pub u32);
        impl Idleout {
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[inline(always)]
            pub const fn set_val_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[inline(always)]
            pub const fn set_val_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[inline(always)]
            pub const fn set_val_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn val_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[inline(always)]
            pub const fn set_val_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Idleout {
            #[inline(always)]
            fn default() -> Idleout {
                Idleout(0)
            }
        }
        impl core::fmt::Debug for Idleout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idleout")
                    .field("val_0", &self.val_0())
                    .field("val_1", &self.val_1())
                    .field("val_2", &self.val_2())
                    .field("val_3", &self.val_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idleout {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Idleout {{ val_0: {=bool:?}, val_1: {=bool:?}, val_2: {=bool:?}, val_3: {=bool:?} }}" , self . val_0 () , self . val_1 () , self . val_2 () , self . val_3 ())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqstarted0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqstarted1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqstarted1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[inline(always)]
            pub const fn set_seqend0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[inline(always)]
            pub const fn set_seqend1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[must_use]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[inline(always)]
            pub const fn set_loopsdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[must_use]
            #[inline(always)]
            pub const fn ramunderflow(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[inline(always)]
            pub const fn set_ramunderflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0end(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[inline(always)]
            pub const fn set_dmaseq0end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0ready(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[inline(always)]
            pub const fn set_dmaseq0ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq0buserror(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[inline(always)]
            pub const fn set_dmaseq0buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1end(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[inline(always)]
            pub const fn set_dmaseq1end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1ready(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[inline(always)]
            pub const fn set_dmaseq1ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmaseq1buserror(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[inline(always)]
            pub const fn set_dmaseq1buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn comparematch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_comparematch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("seqstarted0", &self.seqstarted0())
                    .field("seqstarted1", &self.seqstarted1())
                    .field("seqend0", &self.seqend0())
                    .field("seqend1", &self.seqend1())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .field("loopsdone", &self.loopsdone())
                    .field("ramunderflow", &self.ramunderflow())
                    .field("dmaseq0end", &self.dmaseq0end())
                    .field("dmaseq0ready", &self.dmaseq0ready())
                    .field("dmaseq0buserror", &self.dmaseq0buserror())
                    .field("dmaseq1end", &self.dmaseq1end())
                    .field("dmaseq1ready", &self.dmaseq1ready())
                    .field("dmaseq1buserror", &self.dmaseq1buserror())
                    .field("comparematch[0]", &self.comparematch(0usize))
                    .field("comparematch[1]", &self.comparematch(1usize))
                    .field("comparematch[2]", &self.comparematch(2usize))
                    .field("comparematch[3]", &self.comparematch(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, seqstarted0: {=bool:?}, seqstarted1: {=bool:?}, seqend0: {=bool:?}, seqend1: {=bool:?}, pwmperiodend: {=bool:?}, loopsdone: {=bool:?}, ramunderflow: {=bool:?}, dmaseq0end: {=bool:?}, dmaseq0ready: {=bool:?}, dmaseq0buserror: {=bool:?}, dmaseq1end: {=bool:?}, dmaseq1ready: {=bool:?}, dmaseq1buserror: {=bool:?}, comparematch[0]: {=bool:?}, comparematch[1]: {=bool:?}, comparematch[2]: {=bool:?}, comparematch[3]: {=bool:?} }}" , self . stopped () , self . seqstarted0 () , self . seqstarted1 () , self . seqend0 () , self . seqend1 () , self . pwmperiodend () , self . loopsdone () , self . ramunderflow () , self . dmaseq0end () , self . dmaseq0ready () , self . dmaseq0buserror () , self . dmaseq1end () , self . dmaseq1ready () , self . dmaseq1buserror () , self . comparematch (0usize) , self . comparematch (1usize) , self . comparematch (2usize) , self . comparematch (3usize))
            }
        }
        #[doc = "Number of playbacks of a loop"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Loop(pub u32);
        impl Loop {
            #[doc = "Number of playbacks of pattern cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::LoopCnt {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::LoopCnt::from_bits(val as u16)
            }
            #[doc = "Number of playbacks of pattern cycles"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::LoopCnt) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Loop {
            #[inline(always)]
            fn default() -> Loop {
                Loop(0)
            }
        }
        impl core::fmt::Debug for Loop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Loop").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Loop {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Loop {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[must_use]
            #[inline(always)]
            pub const fn updown(&self) -> super::vals::Updown {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Updown::from_bits(val as u8)
            }
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[inline(always)]
            pub const fn set_updown(&mut self, val: super::vals::Updown) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("updown", &self.updown())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ updown: {:?} }}", self.updown())
            }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler of PWM_CLK"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> super::vals::Prescaler {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Prescaler::from_bits(val as u8)
            }
            #[doc = "Prescaler of PWM_CLK"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: super::vals::Prescaler) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {:?} }}", self.prescaler())
            }
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refresh(pub u32);
        impl Refresh {
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[must_use]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::RefreshCnt {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                super::vals::RefreshCnt::from_bits(val as u32)
            }
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[inline(always)]
            pub const fn set_cnt(&mut self, val: super::vals::RefreshCnt) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Refresh {
            #[inline(always)]
            fn default() -> Refresh {
                Refresh(0)
            }
        }
        impl core::fmt::Debug for Refresh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refresh").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refresh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Refresh {{ cnt: {:?} }}", self.cnt())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend0_stop(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend0_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn seqend1_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn set_seqend1_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_dma_seq0_start(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn set_loopsdone_dma_seq0_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_dma_seq1_start(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn set_loopsdone_dma_seq1_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn loopsdone_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[inline(always)]
            pub const fn set_loopsdone_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ramunderflow_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[inline(always)]
            pub const fn set_ramunderflow_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_seq0_buserror_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn set_dma_seq0_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_seq1_buserror_stop(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn set_dma_seq1_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("seqend0_stop", &self.seqend0_stop())
                    .field("seqend1_stop", &self.seqend1_stop())
                    .field("loopsdone_dma_seq0_start", &self.loopsdone_dma_seq0_start())
                    .field("loopsdone_dma_seq1_start", &self.loopsdone_dma_seq1_start())
                    .field("loopsdone_stop", &self.loopsdone_stop())
                    .field("ramunderflow_stop", &self.ramunderflow_stop())
                    .field("dma_seq0_buserror_stop", &self.dma_seq0_buserror_stop())
                    .field("dma_seq1_buserror_stop", &self.dma_seq1_buserror_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ seqend0_stop: {=bool:?}, seqend1_stop: {=bool:?}, loopsdone_dma_seq0_start: {=bool:?}, loopsdone_dma_seq1_start: {=bool:?}, loopsdone_stop: {=bool:?}, ramunderflow_stop: {=bool:?}, dma_seq0_buserror_stop: {=bool:?}, dma_seq1_buserror_stop: {=bool:?} }}" , self . seqend0_stop () , self . seqend1_stop () , self . loopsdone_dma_seq0_start () , self . loopsdone_dma_seq1_start () , self . loopsdone_stop () , self . ramunderflow_stop () , self . dma_seq0_buserror_stop () , self . dma_seq1_buserror_stop ())
            }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Terminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Load {
            #[doc = "1st half word (16-bit) used in all PWM channels 0..3"]
            COMMON = 0x0,
            #[doc = "1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3"]
            GROUPED = 0x01,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3"]
            INDIVIDUAL = 0x02,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP"]
            WAVE_FORM = 0x03,
        }
        impl Load {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Load {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Load {
            #[inline(always)]
            fn from(val: u8) -> Load {
                Load::from_bits(val)
            }
        }
        impl From<Load> for u8 {
            #[inline(always)]
            fn from(val: Load) -> u8 {
                Load::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct LoopCnt(u16);
        impl LoopCnt {
            #[doc = "Looping disabled (stop at the end of the sequence)"]
            pub const DISABLED: Self = Self(0x0);
        }
        impl LoopCnt {
            pub const fn from_bits(val: u16) -> LoopCnt {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for LoopCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LoopCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for LoopCnt {
            #[inline(always)]
            fn from(val: u16) -> LoopCnt {
                LoopCnt::from_bits(val)
            }
        }
        impl From<LoopCnt> for u16 {
            #[inline(always)]
            fn from(val: LoopCnt) -> u16 {
                LoopCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "SEQ\\[n\\].REFRESH is used to determine loading internal compare registers"]
            REFRESH_COUNT = 0x0,
            #[doc = "NEXTSTEP task causes a new value to be loaded to internal compare registers"]
            NEXT_STEP = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prescaler {
            #[doc = "Divide by 1 (16 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (8 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (4 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (2 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (1 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (500 kHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (250 kHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (125 kHz)"]
            DIV_128 = 0x07,
        }
        impl Prescaler {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prescaler {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prescaler {
            #[inline(always)]
            fn from(val: u8) -> Prescaler {
                Prescaler::from_bits(val)
            }
        }
        impl From<Prescaler> for u8 {
            #[inline(always)]
            fn from(val: Prescaler) -> u8 {
                Prescaler::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct RefreshCnt(u32);
        impl RefreshCnt {
            #[doc = "Update every PWM period"]
            pub const CONTINUOUS: Self = Self(0x0);
        }
        impl RefreshCnt {
            pub const fn from_bits(val: u32) -> RefreshCnt {
                Self(val & 0x00ff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for RefreshCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("CONTINUOUS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RefreshCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "CONTINUOUS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for RefreshCnt {
            #[inline(always)]
            fn from(val: u32) -> RefreshCnt {
                RefreshCnt::from_bits(val)
            }
        }
        impl From<RefreshCnt> for u32 {
            #[inline(always)]
            fn from(val: RefreshCnt) -> u32 {
                RefreshCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Updown {
            #[doc = "Up counter, edge-aligned PWM duty cycle"]
            UP = 0x0,
            #[doc = "Up and down counter, center-aligned PWM duty cycle"]
            UP_AND_DOWN = 0x01,
        }
        impl Updown {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Updown {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Updown {
            #[inline(always)]
            fn from(val: u8) -> Updown {
                Updown::from_bits(val)
            }
        }
        impl From<Updown> for u8 {
            #[inline(always)]
            fn from(val: Updown) -> u8 {
                Updown::to_bits(val)
            }
        }
    }
}
pub mod qdec {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for LED signal"]
        #[inline(always)]
        pub const fn led(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for A signal"]
        #[inline(always)]
        pub const fn a(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for B signal"]
        #[inline(always)]
        pub const fn b(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Quadrature Decoder 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qdec {
        ptr: *mut u8,
    }
    unsafe impl Send for Qdec {}
    unsafe impl Sync for Qdec {}
    impl Qdec {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Task starting the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Task stopping the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Read and clear ACC and ACCDBL"]
        #[inline(always)]
        pub const fn tasks_readclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read and clear ACC"]
        #[inline(always)]
        pub const fn tasks_rdclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Read and clear ACCDBL"]
        #[inline(always)]
        pub const fn tasks_rdclrdbl(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task READCLRACC"]
        #[inline(always)]
        pub const fn subscribe_readclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRACC"]
        #[inline(always)]
        pub const fn subscribe_rdclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRDBL"]
        #[inline(always)]
        pub const fn subscribe_rdclrdbl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Event being generated for every new sample value written to the SAMPLE register"]
        #[inline(always)]
        pub const fn events_samplerdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non-null report ready"]
        #[inline(always)]
        pub const fn events_reportrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "ACC or ACCDBL register overflow"]
        #[inline(always)]
        pub const fn events_accof(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Double displacement(s) detected"]
        #[inline(always)]
        pub const fn events_dblrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "QDEC has been stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event SAMPLERDY"]
        #[inline(always)]
        pub const fn publish_samplerdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event REPORTRDY"]
        #[inline(always)]
        pub const fn publish_reportrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACCOF"]
        #[inline(always)]
        pub const fn publish_accof(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DBLRDY"]
        #[inline(always)]
        pub const fn publish_dblrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable the quadrature decoder"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "LED output pin polarity"]
        #[inline(always)]
        pub const fn ledpol(self) -> crate::common::Reg<regs::Ledpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Sample period"]
        #[inline(always)]
        pub const fn sampleper(self) -> crate::common::Reg<regs::Sampleper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Motion sample value"]
        #[inline(always)]
        pub const fn sample(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[inline(always)]
        pub const fn reportper(self) -> crate::common::Reg<regs::Reportper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Register accumulating the valid transitions"]
        #[inline(always)]
        pub const fn acc(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task"]
        #[inline(always)]
        pub const fn accread(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x051cusize) as _) }
        }
        #[doc = "Enable input debounce filters"]
        #[inline(always)]
        pub const fn dbfen(self) -> crate::common::Reg<regs::Dbfen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0528usize) as _) }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[inline(always)]
        pub const fn ledpre(self) -> crate::common::Reg<regs::Ledpre, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Register accumulating the number of detected double transitions"]
        #[inline(always)]
        pub const fn accdbl(self) -> crate::common::Reg<regs::Accdbl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0544usize) as _) }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[inline(always)]
        pub const fn accdblread(self) -> crate::common::Reg<regs::Accdblread, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0548usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Register accumulating the number of detected double transitions"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdbl(pub u32);
        impl Accdbl {
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[must_use]
            #[inline(always)]
            pub const fn accdbl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[inline(always)]
            pub const fn set_accdbl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdbl {
            #[inline(always)]
            fn default() -> Accdbl {
                Accdbl(0)
            }
        }
        impl core::fmt::Debug for Accdbl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdbl")
                    .field("accdbl", &self.accdbl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdbl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Accdbl {{ accdbl: {=u8:?} }}", self.accdbl())
            }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdblread(pub u32);
        impl Accdblread {
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[must_use]
            #[inline(always)]
            pub const fn accdblread(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[inline(always)]
            pub const fn set_accdblread(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdblread {
            #[inline(always)]
            fn default() -> Accdblread {
                Accdblread(0)
            }
        }
        impl core::fmt::Debug for Accdblread {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdblread")
                    .field("accdblread", &self.accdblread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdblread {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Accdblread {{ accdblread: {=u8:?} }}", self.accdblread())
            }
        }
        #[doc = "Enable input debounce filters"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbfen(pub u32);
        impl Dbfen {
            #[doc = "Enable input debounce filters"]
            #[must_use]
            #[inline(always)]
            pub const fn dbfen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable input debounce filters"]
            #[inline(always)]
            pub const fn set_dbfen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbfen {
            #[inline(always)]
            fn default() -> Dbfen {
                Dbfen(0)
            }
        }
        impl core::fmt::Debug for Dbfen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbfen")
                    .field("dbfen", &self.dbfen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbfen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dbfen {{ dbfen: {=bool:?} }}", self.dbfen())
            }
        }
        #[doc = "Enable the quadrature decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable the quadrature decoder"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable the quadrature decoder"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[inline(always)]
            pub const fn set_samplerdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[inline(always)]
            pub const fn set_reportrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[must_use]
            #[inline(always)]
            pub const fn accof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[inline(always)]
            pub const fn set_accof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[inline(always)]
            pub const fn set_dblrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("samplerdy", &self.samplerdy())
                    .field("reportrdy", &self.reportrdy())
                    .field("accof", &self.accof())
                    .field("dblrdy", &self.dblrdy())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ samplerdy: {=bool:?}, reportrdy: {=bool:?}, accof: {=bool:?}, dblrdy: {=bool:?}, stopped: {=bool:?} }}" , self . samplerdy () , self . reportrdy () , self . accof () , self . dblrdy () , self . stopped ())
            }
        }
        #[doc = "LED output pin polarity"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpol(pub u32);
        impl Ledpol {
            #[doc = "LED output pin polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn ledpol(&self) -> super::vals::Ledpol {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ledpol::from_bits(val as u8)
            }
            #[doc = "LED output pin polarity"]
            #[inline(always)]
            pub const fn set_ledpol(&mut self, val: super::vals::Ledpol) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ledpol {
            #[inline(always)]
            fn default() -> Ledpol {
                Ledpol(0)
            }
        }
        impl core::fmt::Debug for Ledpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpol")
                    .field("ledpol", &self.ledpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ledpol {{ ledpol: {:?} }}", self.ledpol())
            }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpre(pub u32);
        impl Ledpre {
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[must_use]
            #[inline(always)]
            pub const fn ledpre(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[inline(always)]
            pub const fn set_ledpre(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ledpre {
            #[inline(always)]
            fn default() -> Ledpre {
                Ledpre(0)
            }
        }
        impl core::fmt::Debug for Ledpre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpre")
                    .field("ledpre", &self.ledpre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpre {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ledpre {{ ledpre: {=u16:?} }}", self.ledpre())
            }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reportper(pub u32);
        impl Reportper {
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[must_use]
            #[inline(always)]
            pub const fn reportper(&self) -> super::vals::Reportper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Reportper::from_bits(val as u8)
            }
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[inline(always)]
            pub const fn set_reportper(&mut self, val: super::vals::Reportper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Reportper {
            #[inline(always)]
            fn default() -> Reportper {
                Reportper(0)
            }
        }
        impl core::fmt::Debug for Reportper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reportper")
                    .field("reportper", &self.reportper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reportper {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Reportper {{ reportper: {:?} }}", self.reportper())
            }
        }
        #[doc = "Sample period"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sampleper(pub u32);
        impl Sampleper {
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[must_use]
            #[inline(always)]
            pub const fn sampleper(&self) -> super::vals::Sampleper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Sampleper::from_bits(val as u8)
            }
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[inline(always)]
            pub const fn set_sampleper(&mut self, val: super::vals::Sampleper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Sampleper {
            #[inline(always)]
            fn default() -> Sampleper {
                Sampleper(0)
            }
        }
        impl core::fmt::Debug for Sampleper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sampleper")
                    .field("sampleper", &self.sampleper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sampleper {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sampleper {{ sampleper: {:?} }}", self.sampleper())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_readclracc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[inline(always)]
            pub const fn set_reportrdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[inline(always)]
            pub const fn set_samplerdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_rdclracc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[inline(always)]
            pub const fn set_reportrdy_rdclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn reportrdy_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[inline(always)]
            pub const fn set_reportrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy_rdclrdbl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[inline(always)]
            pub const fn set_dblrdy_rdclrdbl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dblrdy_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[inline(always)]
            pub const fn set_dblrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[must_use]
            #[inline(always)]
            pub const fn samplerdy_readclracc(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[inline(always)]
            pub const fn set_samplerdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("reportrdy_readclracc", &self.reportrdy_readclracc())
                    .field("samplerdy_stop", &self.samplerdy_stop())
                    .field("reportrdy_rdclracc", &self.reportrdy_rdclracc())
                    .field("reportrdy_stop", &self.reportrdy_stop())
                    .field("dblrdy_rdclrdbl", &self.dblrdy_rdclrdbl())
                    .field("dblrdy_stop", &self.dblrdy_stop())
                    .field("samplerdy_readclracc", &self.samplerdy_readclracc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ reportrdy_readclracc: {=bool:?}, samplerdy_stop: {=bool:?}, reportrdy_rdclracc: {=bool:?}, reportrdy_stop: {=bool:?}, dblrdy_rdclrdbl: {=bool:?}, dblrdy_stop: {=bool:?}, samplerdy_readclracc: {=bool:?} }}" , self . reportrdy_readclracc () , self . samplerdy_stop () , self . reportrdy_rdclracc () , self . reportrdy_stop () , self . dblrdy_rdclrdbl () , self . dblrdy_stop () , self . samplerdy_readclracc ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ledpol {
            #[doc = "Led active on output pin low"]
            ACTIVE_LOW = 0x0,
            #[doc = "Led active on output pin high"]
            ACTIVE_HIGH = 0x01,
        }
        impl Ledpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ledpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ledpol {
            #[inline(always)]
            fn from(val: u8) -> Ledpol {
                Ledpol::from_bits(val)
            }
        }
        impl From<Ledpol> for u8 {
            #[inline(always)]
            fn from(val: Ledpol) -> u8 {
                Ledpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reportper {
            #[doc = "10 samples/report"]
            _10SMPL = 0x0,
            #[doc = "40 samples/report"]
            _40SMPL = 0x01,
            #[doc = "80 samples/report"]
            _80SMPL = 0x02,
            #[doc = "120 samples/report"]
            _120SMPL = 0x03,
            #[doc = "160 samples/report"]
            _160SMPL = 0x04,
            #[doc = "200 samples/report"]
            _200SMPL = 0x05,
            #[doc = "240 samples/report"]
            _240SMPL = 0x06,
            #[doc = "280 samples/report"]
            _280SMPL = 0x07,
            #[doc = "1 sample/report"]
            _1SMPL = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Reportper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reportper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reportper {
            #[inline(always)]
            fn from(val: u8) -> Reportper {
                Reportper::from_bits(val)
            }
        }
        impl From<Reportper> for u8 {
            #[inline(always)]
            fn from(val: Reportper) -> u8 {
                Reportper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampleper {
            #[doc = "128 us"]
            _128US = 0x0,
            #[doc = "256 us"]
            _256US = 0x01,
            #[doc = "512 us"]
            _512US = 0x02,
            #[doc = "1024 us"]
            _1024US = 0x03,
            #[doc = "2048 us"]
            _2048US = 0x04,
            #[doc = "4096 us"]
            _4096US = 0x05,
            #[doc = "8192 us"]
            _8192US = 0x06,
            #[doc = "16384 us"]
            _16384US = 0x07,
            #[doc = "32768 us"]
            _32MS = 0x08,
            #[doc = "65536 us"]
            _65MS = 0x09,
            #[doc = "131072 us"]
            _131MS = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sampleper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampleper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampleper {
            #[inline(always)]
            fn from(val: u8) -> Sampleper {
                Sampleper::from_bits(val)
            }
        }
        impl From<Sampleper> for u8 {
            #[inline(always)]
            fn from(val: Sampleper) -> u8 {
                Sampleper::to_bits(val)
            }
        }
    }
}
pub mod radio {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cstones {
        ptr: *mut u8,
    }
    unsafe impl Send for Cstones {}
    unsafe impl Sync for Cstones {}
    impl Cstones {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::CstonesMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[inline(always)]
        pub const fn numsamples(self) -> crate::common::Reg<regs::Numsamples, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[inline(always)]
        pub const fn nextfrequency(
            self,
        ) -> crate::common::Reg<regs::Nextfrequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Override value of FFO (Fractional Frequency Offset) if not to be based on the frequency estimate derived from CnAcc (autocorrelation of the scaled input signal) value"]
        #[inline(always)]
        pub const fn ffoin(self) -> crate::common::Reg<regs::Ffoin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Source of FFO"]
        #[inline(always)]
        pub const fn ffosource(self) -> crate::common::Reg<regs::Ffosource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[inline(always)]
        pub const fn faepeer(self) -> crate::common::Reg<regs::Faepeer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn phaseshift(self) -> crate::common::Reg<regs::Phaseshift, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn numsamplescoeff(
            self,
        ) -> crate::common::Reg<regs::Numsamplescoeff, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[inline(always)]
        pub const fn pct16(self) -> crate::common::Reg<regs::Pct16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[inline(always)]
        pub const fn magphasemean(
            self,
        ) -> crate::common::Reg<regs::Magphasemean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Mean of IQ values"]
        #[inline(always)]
        pub const fn iqrawmean(self) -> crate::common::Reg<regs::Iqrawmean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[inline(always)]
        pub const fn magstd(self) -> crate::common::Reg<regs::Magstd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Output of the autocorrelation of the accumulated IQ signal"]
        #[inline(always)]
        pub const fn cnacc(self) -> crate::common::Reg<regs::Cnacc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "FFO estimate"]
        #[inline(always)]
        pub const fn ffoest(self) -> crate::common::Reg<regs::Ffoest, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[inline(always)]
        pub const fn downsample(self) -> crate::common::Reg<regs::Downsample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Number of full ADPLL finetune steps"]
        #[inline(always)]
        pub const fn finetunenext(
            self,
        ) -> crate::common::Reg<regs::Finetunenext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Cordic output of CnAcc"]
        #[inline(always)]
        pub const fn cfophase(self) -> crate::common::Reg<regs::Cfophase, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Frequency offset estimate"]
        #[inline(always)]
        pub const fn freqoffset(self) -> crate::common::Reg<regs::Freqoffset, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ. IQ values limited to \\[-1024,1023\\]."]
        #[inline(always)]
        pub const fn pct11(self) -> crate::common::Reg<regs::Pct11, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Quantization error between ADPLL frequency and the desired value of FFO * RF Frequency. Values limited to \\[-64,63\\] with units 7.6294 Hz."]
        #[inline(always)]
        pub const fn lfaenext(self) -> crate::common::Reg<regs::Lfaenext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
    }
    #[doc = "DFE packet EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dfepacket {
        ptr: *mut u8,
    }
    unsafe impl Send for Dfepacket {}
    unsafe impl Sync for Dfepacket {}
    impl Dfepacket {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Pin select for DFE pin n"]
        #[inline(always)]
        pub const fn dfegpio(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "2.4 GHz radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Radio {
        ptr: *mut u8,
    }
    unsafe impl Send for Radio {}
    unsafe impl Sync for Radio {}
    impl Radio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable RADIO in TX mode"]
        #[inline(always)]
        pub const fn tasks_txen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Enable RADIO in RX mode"]
        #[inline(always)]
        pub const fn tasks_rxen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Start RADIO"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Stop RADIO"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Disable RADIO"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
        #[inline(always)]
        pub const fn tasks_rssistart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Start the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Stop the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_edstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Stop the energy detect measurement"]
        #[inline(always)]
        pub const fn tasks_edstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_ccastart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Stop the clear channel assessment"]
        #[inline(always)]
        pub const fn tasks_ccastop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Reset all public registers, but with these exceptions: DMA registers and EVENT/INTEN/SUBSCRIBE/PUBLISH registers. Only to be used in DISABLED state."]
        #[inline(always)]
        pub const fn tasks_softreset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task TXEN"]
        #[inline(always)]
        pub const fn subscribe_txen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Subscribe configuration for task RXEN"]
        #[inline(always)]
        pub const fn subscribe_rxen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Subscribe configuration for task RSSISTART"]
        #[inline(always)]
        pub const fn subscribe_rssistart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTART"]
        #[inline(always)]
        pub const fn subscribe_bcstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTOP"]
        #[inline(always)]
        pub const fn subscribe_bcstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTART"]
        #[inline(always)]
        pub const fn subscribe_edstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTOP"]
        #[inline(always)]
        pub const fn subscribe_edstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTART"]
        #[inline(always)]
        pub const fn subscribe_ccastart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTOP"]
        #[inline(always)]
        pub const fn subscribe_ccastop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Subscribe configuration for task SOFTRESET"]
        #[inline(always)]
        pub const fn subscribe_softreset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started TX path"]
        #[inline(always)]
        pub const fn events_txready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started RX path"]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "Address sent or received"]
        #[inline(always)]
        pub const fn events_address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020cusize) as _) }
        }
        #[doc = "IEEE 802.15.4 length field received"]
        #[inline(always)]
        pub const fn events_framestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
        }
        #[doc = "Packet payload sent or received"]
        #[inline(always)]
        pub const fn events_payload(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0214usize) as _) }
        }
        #[doc = "Memory access for packet data has been completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0218usize) as _) }
        }
        #[doc = "The last bit is sent on air or last bit is received"]
        #[inline(always)]
        pub const fn events_phyend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x021cusize) as _) }
        }
        #[doc = "RADIO has been disabled"]
        #[inline(always)]
        pub const fn events_disabled(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0220usize) as _) }
        }
        #[doc = "A device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize) as _) }
        }
        #[doc = "No device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmiss(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Packet received with CRC ok"]
        #[inline(always)]
        pub const fn events_crcok(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x022cusize) as _) }
        }
        #[doc = "Packet received with CRC error"]
        #[inline(always)]
        pub const fn events_crcerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0230usize) as _) }
        }
        #[doc = "Bit counter reached bit count value"]
        #[inline(always)]
        pub const fn events_bcmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0238usize) as _) }
        }
        #[doc = "Sampling of energy detection complete (a new ED sample is ready for readout from the RADIO.EDSAMPLE register)"]
        #[inline(always)]
        pub const fn events_edend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x023cusize) as _) }
        }
        #[doc = "The sampling of energy detection has stopped"]
        #[inline(always)]
        pub const fn events_edstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[doc = "Wireless medium in idle - clear to send"]
        #[inline(always)]
        pub const fn events_ccaidle(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0244usize) as _) }
        }
        #[doc = "Wireless medium busy - do not send"]
        #[inline(always)]
        pub const fn events_ccabusy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0248usize) as _) }
        }
        #[doc = "The CCA has stopped"]
        #[inline(always)]
        pub const fn events_ccastopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x024cusize) as _) }
        }
        #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit"]
        #[inline(always)]
        pub const fn events_rateboost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0250usize) as _) }
        }
        #[doc = "MAC header match found"]
        #[inline(always)]
        pub const fn events_mhrmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0254usize) as _) }
        }
        #[doc = "Initial sync detected"]
        #[inline(always)]
        pub const fn events_sync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0258usize) as _) }
        }
        #[doc = "CTEInfo byte is received"]
        #[inline(always)]
        pub const fn events_ctepresent(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x025cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Publish configuration for event TXREADY"]
        #[inline(always)]
        pub const fn publish_txready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Publish configuration for event RXREADY"]
        #[inline(always)]
        pub const fn publish_rxready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Publish configuration for event ADDRESS"]
        #[inline(always)]
        pub const fn publish_address(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMESTART"]
        #[inline(always)]
        pub const fn publish_framestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0310usize) as _) }
        }
        #[doc = "Publish configuration for event PAYLOAD"]
        #[inline(always)]
        pub const fn publish_payload(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0318usize) as _) }
        }
        #[doc = "Publish configuration for event PHYEND"]
        #[inline(always)]
        pub const fn publish_phyend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x031cusize) as _) }
        }
        #[doc = "Publish configuration for event DISABLED"]
        #[inline(always)]
        pub const fn publish_disabled(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0320usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMATCH"]
        #[inline(always)]
        pub const fn publish_devmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMISS"]
        #[inline(always)]
        pub const fn publish_devmiss(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0328usize) as _) }
        }
        #[doc = "Publish configuration for event CRCOK"]
        #[inline(always)]
        pub const fn publish_crcok(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x032cusize) as _) }
        }
        #[doc = "Publish configuration for event CRCERROR"]
        #[inline(always)]
        pub const fn publish_crcerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "Publish configuration for event BCMATCH"]
        #[inline(always)]
        pub const fn publish_bcmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0338usize) as _) }
        }
        #[doc = "Publish configuration for event EDEND"]
        #[inline(always)]
        pub const fn publish_edend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033cusize) as _) }
        }
        #[doc = "Publish configuration for event EDSTOPPED"]
        #[inline(always)]
        pub const fn publish_edstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "Publish configuration for event CCAIDLE"]
        #[inline(always)]
        pub const fn publish_ccaidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "Publish configuration for event CCABUSY"]
        #[inline(always)]
        pub const fn publish_ccabusy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "Publish configuration for event CCASTOPPED"]
        #[inline(always)]
        pub const fn publish_ccastopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034cusize) as _) }
        }
        #[doc = "Publish configuration for event RATEBOOST"]
        #[inline(always)]
        pub const fn publish_rateboost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0350usize) as _) }
        }
        #[doc = "Publish configuration for event MHRMATCH"]
        #[inline(always)]
        pub const fn publish_mhrmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0354usize) as _) }
        }
        #[doc = "Publish configuration for event SYNC"]
        #[inline(always)]
        pub const fn publish_sync(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0358usize) as _) }
        }
        #[doc = "Publish configuration for event CTEPRESENT"]
        #[inline(always)]
        pub const fn publish_ctepresent(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0488usize + n * 32usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0490usize + n * 32usize) as _) }
        }
        #[doc = "Data rate and modulation"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::RadioMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Current radio state"]
        #[inline(always)]
        pub const fn state(self) -> crate::common::Reg<regs::State, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[inline(always)]
        pub const fn edctrl(self) -> crate::common::Reg<regs::Edctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[inline(always)]
        pub const fn edsample(self) -> crate::common::Reg<regs::Edsample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[inline(always)]
        pub const fn ccactrl(self) -> crate::common::Reg<regs::Ccactrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Data whitening configuration"]
        #[inline(always)]
        pub const fn datawhite(self) -> crate::common::Reg<regs::Datawhite, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Timing"]
        #[inline(always)]
        pub const fn timing(self) -> crate::common::Reg<regs::Timing, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0704usize) as _) }
        }
        #[doc = "Frequency"]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0708usize) as _) }
        }
        #[doc = "Output power"]
        #[inline(always)]
        pub const fn txpower(self) -> crate::common::Reg<regs::Txpower, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0710usize) as _) }
        }
        #[doc = "Interframe spacing in us"]
        #[inline(always)]
        pub const fn tifs(self) -> crate::common::Reg<regs::Tifs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0714usize) as _) }
        }
        #[doc = "RSSI sample"]
        #[inline(always)]
        pub const fn rssisample(self) -> crate::common::Reg<regs::Rssisample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0718usize) as _) }
        }
        #[doc = "Config register"]
        #[inline(always)]
        pub const fn feconfig(self) -> crate::common::Reg<regs::Feconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0908usize) as _) }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[inline(always)]
        pub const fn dfemode(self) -> crate::common::Reg<regs::Dfemode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d00usize) as _) }
        }
        #[doc = "DFE status information"]
        #[inline(always)]
        pub const fn dfestatus(self) -> crate::common::Reg<regs::Dfestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d04usize) as _) }
        }
        #[doc = "Various configuration for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl1(self) -> crate::common::Reg<regs::Dfectrl1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d10usize) as _) }
        }
        #[doc = "Start offset for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl2(self) -> crate::common::Reg<regs::Dfectrl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d14usize) as _) }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[inline(always)]
        pub const fn switchpattern(
            self,
        ) -> crate::common::Reg<regs::Switchpattern, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d28usize) as _) }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[inline(always)]
        pub const fn clearpattern(
            self,
        ) -> crate::common::Reg<regs::Clearpattern, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d2cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0d30usize) as _) }
        }
        #[doc = "DFE packet EasyDMA channel"]
        #[inline(always)]
        pub const fn dfepacket(self) -> Dfepacket {
            unsafe { Dfepacket::from_ptr(self.ptr.add(0x0d50usize) as _) }
        }
        #[doc = "CRC status"]
        #[inline(always)]
        pub const fn crcstatus(self) -> crate::common::Reg<regs::Crcstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e0cusize) as _) }
        }
        #[doc = "Received address"]
        #[inline(always)]
        pub const fn rxmatch(self) -> crate::common::Reg<regs::Rxmatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e10usize) as _) }
        }
        #[doc = "CRC field of previously received packet"]
        #[inline(always)]
        pub const fn rxcrc(self) -> crate::common::Reg<regs::Rxcrc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e14usize) as _) }
        }
        #[doc = "Device address match index"]
        #[inline(always)]
        pub const fn dai(self) -> crate::common::Reg<regs::Dai, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e18usize) as _) }
        }
        #[doc = "Payload status"]
        #[inline(always)]
        pub const fn pdustat(self) -> crate::common::Reg<regs::Pdustat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e1cusize) as _) }
        }
        #[doc = "Packet configuration register 0"]
        #[inline(always)]
        pub const fn pcnf0(self) -> crate::common::Reg<regs::Pcnf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e20usize) as _) }
        }
        #[doc = "Packet configuration register 1"]
        #[inline(always)]
        pub const fn pcnf1(self) -> crate::common::Reg<regs::Pcnf1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e28usize) as _) }
        }
        #[doc = "Base address 0"]
        #[inline(always)]
        pub const fn base0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e2cusize) as _) }
        }
        #[doc = "Base address 1"]
        #[inline(always)]
        pub const fn base1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e30usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[inline(always)]
        pub const fn prefix0(self) -> crate::common::Reg<regs::Prefix0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e34usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[inline(always)]
        pub const fn prefix1(self) -> crate::common::Reg<regs::Prefix1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e38usize) as _) }
        }
        #[doc = "Transmit address select"]
        #[inline(always)]
        pub const fn txaddress(self) -> crate::common::Reg<regs::Txaddress, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e3cusize) as _) }
        }
        #[doc = "Receive address select"]
        #[inline(always)]
        pub const fn rxaddresses(self) -> crate::common::Reg<regs::Rxaddresses, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e40usize) as _) }
        }
        #[doc = "CRC configuration"]
        #[inline(always)]
        pub const fn crccnf(self) -> crate::common::Reg<regs::Crccnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e44usize) as _) }
        }
        #[doc = "CRC polynomial"]
        #[inline(always)]
        pub const fn crcpoly(self) -> crate::common::Reg<regs::Crcpoly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e48usize) as _) }
        }
        #[doc = "CRC initial value"]
        #[inline(always)]
        pub const fn crcinit(self) -> crate::common::Reg<regs::Crcinit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e4cusize) as _) }
        }
        #[doc = "Description collection: Device address base segment n"]
        #[inline(always)]
        pub const fn dab(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e50usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[inline(always)]
        pub const fn dap(self, n: usize) -> crate::common::Reg<regs::Dap, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e70usize + n * 4usize) as _) }
        }
        #[doc = "Device address match configuration"]
        #[inline(always)]
        pub const fn dacnf(self) -> crate::common::Reg<regs::Dacnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e90usize) as _) }
        }
        #[doc = "Bit counter compare"]
        #[inline(always)]
        pub const fn bcc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e94usize) as _) }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[inline(always)]
        pub const fn ctestatus(self) -> crate::common::Reg<regs::Ctestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ea4usize) as _) }
        }
        #[doc = "Search pattern configuration"]
        #[inline(always)]
        pub const fn mhrmatchconf(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eb4usize) as _) }
        }
        #[doc = "Pattern mask"]
        #[inline(always)]
        pub const fn mhrmatchmask(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eb8usize) as _) }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[inline(always)]
        pub const fn sfd(self) -> crate::common::Reg<regs::Sfd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ebcusize) as _) }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[inline(always)]
        pub const fn cteinlineconf(
            self,
        ) -> crate::common::Reg<regs::Cteinlineconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ec0usize) as _) }
        }
        #[doc = "Packet pointer"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ed0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cstones(self) -> Cstones {
            unsafe { Cstones::from_ptr(self.ptr.add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rtt(self) -> Rtt {
            unsafe { Rtt::from_ptr(self.ptr.add(0x1050usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtt {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtt {}
    unsafe impl Sync for Rtt {}
    impl Rtt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTT Config."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "RTT segments 0 and 1"]
        #[inline(always)]
        pub const fn segment01(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "RTT segments 2 and 3"]
        #[inline(always)]
        pub const fn segment23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "RTT segments 4 and 5"]
        #[inline(always)]
        pub const fn segment45(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "RTT segments 6 and 7"]
        #[inline(always)]
        pub const fn segment67(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccactrl(pub u32);
        impl Ccactrl {
            #[doc = "CCA mode of operation"]
            #[must_use]
            #[inline(always)]
            pub const fn ccamode(&self) -> super::vals::Ccamode {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ccamode::from_bits(val as u8)
            }
            #[doc = "CCA mode of operation"]
            #[inline(always)]
            pub const fn set_ccamode(&mut self, val: super::vals::Ccamode) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[must_use]
            #[inline(always)]
            pub const fn ccaedthres(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[inline(always)]
            pub const fn set_ccaedthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[must_use]
            #[inline(always)]
            pub const fn ccacorrthres(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[inline(always)]
            pub const fn set_ccacorrthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[must_use]
            #[inline(always)]
            pub const fn ccacorrcnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[inline(always)]
            pub const fn set_ccacorrcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Ccactrl {
            #[inline(always)]
            fn default() -> Ccactrl {
                Ccactrl(0)
            }
        }
        impl core::fmt::Debug for Ccactrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccactrl")
                    .field("ccamode", &self.ccamode())
                    .field("ccaedthres", &self.ccaedthres())
                    .field("ccacorrthres", &self.ccacorrthres())
                    .field("ccacorrcnt", &self.ccacorrcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccactrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ccactrl {{ ccamode: {:?}, ccaedthres: {=u8:?}, ccacorrthres: {=u8:?}, ccacorrcnt: {=u8:?} }}" , self . ccamode () , self . ccaedthres () , self . ccacorrthres () , self . ccacorrcnt ())
            }
        }
        #[doc = "Cordic output of CnAcc"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfophase(pub u32);
        impl Cfophase {
            #[must_use]
            #[inline(always)]
            pub const fn cfophase(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_cfophase(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Cfophase {
            #[inline(always)]
            fn default() -> Cfophase {
                Cfophase(0)
            }
        }
        impl core::fmt::Debug for Cfophase {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfophase")
                    .field("cfophase", &self.cfophase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfophase {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cfophase {{ cfophase: {=u16:?} }}", self.cfophase())
            }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clearpattern(pub u32);
        impl Clearpattern {
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[must_use]
            #[inline(always)]
            pub const fn clearpattern(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[inline(always)]
            pub const fn set_clearpattern(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clearpattern {
            #[inline(always)]
            fn default() -> Clearpattern {
                Clearpattern(0)
            }
        }
        impl core::fmt::Debug for Clearpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clearpattern")
                    .field("clearpattern", &self.clearpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clearpattern {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clearpattern {{ clearpattern: {=bool:?} }}",
                    self.clearpattern()
                )
            }
        }
        #[doc = "Output of the autocorrelation of the accumulated IQ signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnacc(pub u32);
        impl Cnacc {
            #[must_use]
            #[inline(always)]
            pub const fn cnacci(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_cnacci(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn cnaccq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_cnaccq(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Cnacc {
            #[inline(always)]
            fn default() -> Cnacc {
                Cnacc(0)
            }
        }
        impl core::fmt::Debug for Cnacc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnacc")
                    .field("cnacci", &self.cnacci())
                    .field("cnaccq", &self.cnaccq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnacc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cnacc {{ cnacci: {=u16:?}, cnaccq: {=u16:?} }}",
                    self.cnacci(),
                    self.cnaccq()
                )
            }
        }
        #[doc = "RTT Config."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[must_use]
            #[inline(always)]
            pub const fn enfullaa(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[inline(always)]
            pub const fn set_enfullaa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[must_use]
            #[inline(always)]
            pub const fn role(&self) -> super::vals::Role {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Role::from_bits(val as u8)
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[inline(always)]
            pub const fn set_role(&mut self, val: super::vals::Role) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[must_use]
            #[inline(always)]
            pub const fn numsegments(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[inline(always)]
            pub const fn set_numsegments(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[must_use]
            #[inline(always)]
            pub const fn efsdelay(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x01ff;
                val as u16
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[inline(always)]
            pub const fn set_efsdelay(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 8usize)) | (((val as u32) & 0x01ff) << 8usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("en", &self.en())
                    .field("enfullaa", &self.enfullaa())
                    .field("role", &self.role())
                    .field("numsegments", &self.numsegments())
                    .field("efsdelay", &self.efsdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ en: {=bool:?}, enfullaa: {=bool:?}, role: {:?}, numsegments: {=u8:?}, efsdelay: {=u16:?} }}" , self . en () , self . enfullaa () , self . role () , self . numsegments () , self . efsdelay ())
            }
        }
        #[doc = "CRC configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccnf(pub u32);
        impl Crccnf {
            #[doc = "CRC length in number of bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn len(&self) -> super::vals::Len {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Len::from_bits(val as u8)
            }
            #[doc = "CRC length in number of bytes."]
            #[inline(always)]
            pub const fn set_len(&mut self, val: super::vals::Len) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[must_use]
            #[inline(always)]
            pub const fn skipaddr(&self) -> super::vals::Skipaddr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Skipaddr::from_bits(val as u8)
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[inline(always)]
            pub const fn set_skipaddr(&mut self, val: super::vals::Skipaddr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
        }
        impl Default for Crccnf {
            #[inline(always)]
            fn default() -> Crccnf {
                Crccnf(0)
            }
        }
        impl core::fmt::Debug for Crccnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccnf")
                    .field("len", &self.len())
                    .field("skipaddr", &self.skipaddr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccnf {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Crccnf {{ len: {:?}, skipaddr: {:?} }}",
                    self.len(),
                    self.skipaddr()
                )
            }
        }
        #[doc = "CRC initial value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcinit(pub u32);
        impl Crcinit {
            #[doc = "CRC initial value"]
            #[must_use]
            #[inline(always)]
            pub const fn crcinit(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC initial value"]
            #[inline(always)]
            pub const fn set_crcinit(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcinit {
            #[inline(always)]
            fn default() -> Crcinit {
                Crcinit(0)
            }
        }
        impl core::fmt::Debug for Crcinit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcinit")
                    .field("crcinit", &self.crcinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcinit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcinit {{ crcinit: {=u32:?} }}", self.crcinit())
            }
        }
        #[doc = "CRC polynomial"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcpoly(pub u32);
        impl Crcpoly {
            #[doc = "CRC polynomial"]
            #[must_use]
            #[inline(always)]
            pub const fn crcpoly(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC polynomial"]
            #[inline(always)]
            pub const fn set_crcpoly(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcpoly {
            #[inline(always)]
            fn default() -> Crcpoly {
                Crcpoly(0)
            }
        }
        impl core::fmt::Debug for Crcpoly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcpoly")
                    .field("crcpoly", &self.crcpoly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcpoly {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcpoly {{ crcpoly: {=u32:?} }}", self.crcpoly())
            }
        }
        #[doc = "CRC status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcstatus(pub u32);
        impl Crcstatus {
            #[doc = "CRC status of packet received"]
            #[must_use]
            #[inline(always)]
            pub const fn crcstatus(&self) -> super::vals::Crcstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Crcstatus::from_bits(val as u8)
            }
            #[doc = "CRC status of packet received"]
            #[inline(always)]
            pub const fn set_crcstatus(&mut self, val: super::vals::Crcstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Crcstatus {
            #[inline(always)]
            fn default() -> Crcstatus {
                Crcstatus(0)
            }
        }
        impl core::fmt::Debug for Crcstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcstatus")
                    .field("crcstatus", &self.crcstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Crcstatus {{ crcstatus: {:?} }}", self.crcstatus())
            }
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CstonesMode(pub u32);
        impl CstonesMode {
            #[doc = "Enable or disable TPM"]
            #[must_use]
            #[inline(always)]
            pub const fn tpm(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TPM"]
            #[inline(always)]
            pub const fn set_tpm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable TFM"]
            #[must_use]
            #[inline(always)]
            pub const fn tfm(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TFM"]
            #[inline(always)]
            pub const fn set_tfm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CstonesMode {
            #[inline(always)]
            fn default() -> CstonesMode {
                CstonesMode(0)
            }
        }
        impl core::fmt::Debug for CstonesMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CstonesMode")
                    .field("tpm", &self.tpm())
                    .field("tfm", &self.tfm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CstonesMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "CstonesMode {{ tpm: {=bool:?}, tfm: {=bool:?} }}",
                    self.tpm(),
                    self.tfm()
                )
            }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cteinlineconf(pub u32);
        impl Cteinlineconf {
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinectrlen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[inline(always)]
            pub const fn set_cteinlinectrlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinfoins1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[inline(always)]
            pub const fn set_cteinfoins1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[must_use]
            #[inline(always)]
            pub const fn cteerrorhandling(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[inline(always)]
            pub const fn set_cteerrorhandling(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Max range of CTETime"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetimevalidrange(&self) -> super::vals::Ctetimevalidrange {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Ctetimevalidrange::from_bits(val as u8)
            }
            #[doc = "Max range of CTETime"]
            #[inline(always)]
            pub const fn set_ctetimevalidrange(&mut self, val: super::vals::Ctetimevalidrange) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinerxmode1us(&self) -> super::vals::Cteinlinerxmode1us {
                let val = (self.0 >> 10usize) & 0x07;
                super::vals::Cteinlinerxmode1us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn set_cteinlinerxmode1us(&mut self, val: super::vals::Cteinlinerxmode1us) {
                self.0 =
                    (self.0 & !(0x07 << 10usize)) | (((val.to_bits() as u32) & 0x07) << 10usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[must_use]
            #[inline(always)]
            pub const fn cteinlinerxmode2us(&self) -> super::vals::Cteinlinerxmode2us {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Cteinlinerxmode2us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn set_cteinlinerxmode2us(&mut self, val: super::vals::Cteinlinerxmode2us) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "S0 bit pattern to match"]
            #[must_use]
            #[inline(always)]
            pub const fn s0conf(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit pattern to match"]
            #[inline(always)]
            pub const fn set_s0conf(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[must_use]
            #[inline(always)]
            pub const fn s0mask(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[inline(always)]
            pub const fn set_s0mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cteinlineconf {
            #[inline(always)]
            fn default() -> Cteinlineconf {
                Cteinlineconf(0)
            }
        }
        impl core::fmt::Debug for Cteinlineconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cteinlineconf")
                    .field("cteinlinectrlen", &self.cteinlinectrlen())
                    .field("cteinfoins1", &self.cteinfoins1())
                    .field("cteerrorhandling", &self.cteerrorhandling())
                    .field("ctetimevalidrange", &self.ctetimevalidrange())
                    .field("cteinlinerxmode1us", &self.cteinlinerxmode1us())
                    .field("cteinlinerxmode2us", &self.cteinlinerxmode2us())
                    .field("s0conf", &self.s0conf())
                    .field("s0mask", &self.s0mask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cteinlineconf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Cteinlineconf {{ cteinlinectrlen: {=bool:?}, cteinfoins1: {=bool:?}, cteerrorhandling: {=bool:?}, ctetimevalidrange: {:?}, cteinlinerxmode1us: {:?}, cteinlinerxmode2us: {:?}, s0conf: {=u8:?}, s0mask: {=u8:?} }}" , self . cteinlinectrlen () , self . cteinfoins1 () , self . cteerrorhandling () , self . ctetimevalidrange () , self . cteinlinerxmode1us () , self . cteinlinerxmode2us () , self . s0conf () , self . s0mask ())
            }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctestatus(pub u32);
        impl Ctestatus {
            #[doc = "CTETime parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetime(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "CTETime parsed from packet"]
            #[inline(always)]
            pub const fn set_ctetime(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "RFU parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn rfu(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "RFU parsed from packet"]
            #[inline(always)]
            pub const fn set_rfu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "CTEType parsed from packet"]
            #[must_use]
            #[inline(always)]
            pub const fn ctetype(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "CTEType parsed from packet"]
            #[inline(always)]
            pub const fn set_ctetype(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Ctestatus {
            #[inline(always)]
            fn default() -> Ctestatus {
                Ctestatus(0)
            }
        }
        impl core::fmt::Debug for Ctestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctestatus")
                    .field("ctetime", &self.ctetime())
                    .field("rfu", &self.rfu())
                    .field("ctetype", &self.ctetype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ctestatus {{ ctetime: {=u8:?}, rfu: {=bool:?}, ctetype: {=u8:?} }}",
                    self.ctetime(),
                    self.rfu(),
                    self.ctetype()
                )
            }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Device address match configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacnf(pub u32);
        impl Dacnf {
            #[doc = "Enable or disable device address matching using device address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ena0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 0"]
            #[inline(always)]
            pub const fn set_ena0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ena1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[inline(always)]
            pub const fn set_ena1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ena2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[inline(always)]
            pub const fn set_ena2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ena3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[inline(always)]
            pub const fn set_ena3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ena4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[inline(always)]
            pub const fn set_ena4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ena5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[inline(always)]
            pub const fn set_ena5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ena6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[inline(always)]
            pub const fn set_ena6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ena7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[inline(always)]
            pub const fn set_ena7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "TxAdd for device address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 0"]
            #[inline(always)]
            pub const fn set_txadd0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "TxAdd for device address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 1"]
            #[inline(always)]
            pub const fn set_txadd1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "TxAdd for device address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 2"]
            #[inline(always)]
            pub const fn set_txadd2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TxAdd for device address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 3"]
            #[inline(always)]
            pub const fn set_txadd3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TxAdd for device address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 4"]
            #[inline(always)]
            pub const fn set_txadd4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TxAdd for device address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 5"]
            #[inline(always)]
            pub const fn set_txadd5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "TxAdd for device address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 6"]
            #[inline(always)]
            pub const fn set_txadd6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "TxAdd for device address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn txadd7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 7"]
            #[inline(always)]
            pub const fn set_txadd7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Dacnf {
            #[inline(always)]
            fn default() -> Dacnf {
                Dacnf(0)
            }
        }
        impl core::fmt::Debug for Dacnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacnf")
                    .field("ena0", &self.ena0())
                    .field("ena1", &self.ena1())
                    .field("ena2", &self.ena2())
                    .field("ena3", &self.ena3())
                    .field("ena4", &self.ena4())
                    .field("ena5", &self.ena5())
                    .field("ena6", &self.ena6())
                    .field("ena7", &self.ena7())
                    .field("txadd0", &self.txadd0())
                    .field("txadd1", &self.txadd1())
                    .field("txadd2", &self.txadd2())
                    .field("txadd3", &self.txadd3())
                    .field("txadd4", &self.txadd4())
                    .field("txadd5", &self.txadd5())
                    .field("txadd6", &self.txadd6())
                    .field("txadd7", &self.txadd7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacnf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dacnf {{ ena0: {=bool:?}, ena1: {=bool:?}, ena2: {=bool:?}, ena3: {=bool:?}, ena4: {=bool:?}, ena5: {=bool:?}, ena6: {=bool:?}, ena7: {=bool:?}, txadd0: {=bool:?}, txadd1: {=bool:?}, txadd2: {=bool:?}, txadd3: {=bool:?}, txadd4: {=bool:?}, txadd5: {=bool:?}, txadd6: {=bool:?}, txadd7: {=bool:?} }}" , self . ena0 () , self . ena1 () , self . ena2 () , self . ena3 () , self . ena4 () , self . ena5 () , self . ena6 () , self . ena7 () , self . txadd0 () , self . txadd1 () , self . txadd2 () , self . txadd3 () , self . txadd4 () , self . txadd5 () , self . txadd6 () , self . txadd7 ())
            }
        }
        #[doc = "Device address match index"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dai(pub u32);
        impl Dai {
            #[doc = "Device address match index"]
            #[must_use]
            #[inline(always)]
            pub const fn dai(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Device address match index"]
            #[inline(always)]
            pub const fn set_dai(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Dai {
            #[inline(always)]
            fn default() -> Dai {
                Dai(0)
            }
        }
        impl core::fmt::Debug for Dai {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dai").field("dai", &self.dai()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dai {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dai {{ dai: {=u8:?} }}", self.dai())
            }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dap(pub u32);
        impl Dap {
            #[doc = "Device address prefix n"]
            #[must_use]
            #[inline(always)]
            pub const fn dap(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Device address prefix n"]
            #[inline(always)]
            pub const fn set_dap(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dap {
            #[inline(always)]
            fn default() -> Dap {
                Dap(0)
            }
        }
        impl core::fmt::Debug for Dap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dap").field("dap", &self.dap()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dap {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dap {{ dap: {=u16:?} }}", self.dap())
            }
        }
        #[doc = "Data whitening configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datawhite(pub u32);
        impl Datawhite {
            #[doc = "Whitening initial value"]
            #[must_use]
            #[inline(always)]
            pub const fn iv(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Whitening initial value"]
            #[inline(always)]
            pub const fn set_iv(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Whitening polynomial"]
            #[must_use]
            #[inline(always)]
            pub const fn poly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Whitening polynomial"]
            #[inline(always)]
            pub const fn set_poly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Datawhite {
            #[inline(always)]
            fn default() -> Datawhite {
                Datawhite(0)
            }
        }
        impl core::fmt::Debug for Datawhite {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datawhite")
                    .field("iv", &self.iv())
                    .field("poly", &self.poly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datawhite {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Datawhite {{ iv: {=u16:?}, poly: {=u16:?} }}",
                    self.iv(),
                    self.poly()
                )
            }
        }
        #[doc = "Various configuration for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl1(pub u32);
        impl Dfectrl1 {
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[must_use]
            #[inline(always)]
            pub const fn numberof8us(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[inline(always)]
            pub const fn set_numberof8us(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[must_use]
            #[inline(always)]
            pub const fn dfeinextension(&self) -> super::vals::Dfeinextension {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dfeinextension::from_bits(val as u8)
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[inline(always)]
            pub const fn set_dfeinextension(&mut self, val: super::vals::Dfeinextension) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[must_use]
            #[inline(always)]
            pub const fn tswitchspacing(&self) -> super::vals::Tswitchspacing {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tswitchspacing::from_bits(val as u8)
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[inline(always)]
            pub const fn set_tswitchspacing(&mut self, val: super::vals::Tswitchspacing) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[must_use]
            #[inline(always)]
            pub const fn tsamplespacingref(&self) -> super::vals::Tsamplespacingref {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Tsamplespacingref::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[inline(always)]
            pub const fn set_tsamplespacingref(&mut self, val: super::vals::Tsamplespacingref) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[must_use]
            #[inline(always)]
            pub const fn sampletype(&self) -> super::vals::Sampletype {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sampletype::from_bits(val as u8)
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[inline(always)]
            pub const fn set_sampletype(&mut self, val: super::vals::Sampletype) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[must_use]
            #[inline(always)]
            pub const fn tsamplespacing(&self) -> super::vals::Tsamplespacing {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Tsamplespacing::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[inline(always)]
            pub const fn set_tsamplespacing(&mut self, val: super::vals::Tsamplespacing) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[must_use]
            #[inline(always)]
            pub const fn repeatpattern(&self) -> super::vals::Repeatpattern {
                let val = (self.0 >> 20usize) & 0x0f;
                super::vals::Repeatpattern::from_bits(val as u8)
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[inline(always)]
            pub const fn set_repeatpattern(&mut self, val: super::vals::Repeatpattern) {
                self.0 =
                    (self.0 & !(0x0f << 20usize)) | (((val.to_bits() as u32) & 0x0f) << 20usize);
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[must_use]
            #[inline(always)]
            pub const fn agcbackoffgain(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[inline(always)]
            pub const fn set_agcbackoffgain(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Dfectrl1 {
            #[inline(always)]
            fn default() -> Dfectrl1 {
                Dfectrl1(0)
            }
        }
        impl core::fmt::Debug for Dfectrl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl1")
                    .field("numberof8us", &self.numberof8us())
                    .field("dfeinextension", &self.dfeinextension())
                    .field("tswitchspacing", &self.tswitchspacing())
                    .field("tsamplespacingref", &self.tsamplespacingref())
                    .field("sampletype", &self.sampletype())
                    .field("tsamplespacing", &self.tsamplespacing())
                    .field("repeatpattern", &self.repeatpattern())
                    .field("agcbackoffgain", &self.agcbackoffgain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dfectrl1 {{ numberof8us: {=u8:?}, dfeinextension: {:?}, tswitchspacing: {:?}, tsamplespacingref: {:?}, sampletype: {:?}, tsamplespacing: {:?}, repeatpattern: {:?}, agcbackoffgain: {=u8:?} }}" , self . numberof8us () , self . dfeinextension () , self . tswitchspacing () , self . tsamplespacingref () , self . sampletype () , self . tsamplespacing () , self . repeatpattern () , self . agcbackoffgain ())
            }
        }
        #[doc = "Start offset for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl2(pub u32);
        impl Dfectrl2 {
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[must_use]
            #[inline(always)]
            pub const fn tswitchoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[inline(always)]
            pub const fn set_tswitchoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[must_use]
            #[inline(always)]
            pub const fn tsampleoffset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[inline(always)]
            pub const fn set_tsampleoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Dfectrl2 {
            #[inline(always)]
            fn default() -> Dfectrl2 {
                Dfectrl2(0)
            }
        }
        impl core::fmt::Debug for Dfectrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl2")
                    .field("tswitchoffset", &self.tswitchoffset())
                    .field("tsampleoffset", &self.tsampleoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dfectrl2 {{ tswitchoffset: {=u16:?}, tsampleoffset: {=u16:?} }}",
                    self.tswitchoffset(),
                    self.tsampleoffset()
                )
            }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfemode(pub u32);
        impl Dfemode {
            #[doc = "Direction finding operation mode"]
            #[must_use]
            #[inline(always)]
            pub const fn dfeopmode(&self) -> super::vals::Dfeopmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Dfeopmode::from_bits(val as u8)
            }
            #[doc = "Direction finding operation mode"]
            #[inline(always)]
            pub const fn set_dfeopmode(&mut self, val: super::vals::Dfeopmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Dfemode {
            #[inline(always)]
            fn default() -> Dfemode {
                Dfemode(0)
            }
        }
        impl core::fmt::Debug for Dfemode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfemode")
                    .field("dfeopmode", &self.dfeopmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfemode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dfemode {{ dfeopmode: {:?} }}", self.dfeopmode())
            }
        }
        #[doc = "DFE status information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfestatus(pub u32);
        impl Dfestatus {
            #[doc = "Internal state of switching state machine"]
            #[must_use]
            #[inline(always)]
            pub const fn switchingstate(&self) -> super::vals::Switchingstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Switchingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of switching state machine"]
            #[inline(always)]
            pub const fn set_switchingstate(&mut self, val: super::vals::Switchingstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Internal state of sampling state machine"]
            #[must_use]
            #[inline(always)]
            pub const fn samplingstate(&self) -> super::vals::Samplingstate {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Samplingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of sampling state machine"]
            #[inline(always)]
            pub const fn set_samplingstate(&mut self, val: super::vals::Samplingstate) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Dfestatus {
            #[inline(always)]
            fn default() -> Dfestatus {
                Dfestatus(0)
            }
        }
        impl core::fmt::Debug for Dfestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfestatus")
                    .field("switchingstate", &self.switchingstate())
                    .field("samplingstate", &self.samplingstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfestatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Dfestatus {{ switchingstate: {:?}, samplingstate: {:?} }}",
                    self.switchingstate(),
                    self.samplingstate()
                )
            }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Downsample(pub u32);
        impl Downsample {
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[must_use]
            #[inline(always)]
            pub const fn enablefilter(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[inline(always)]
            pub const fn set_enablefilter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[must_use]
            #[inline(always)]
            pub const fn rate(&self) -> super::vals::Rate {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rate::from_bits(val as u8)
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[inline(always)]
            pub const fn set_rate(&mut self, val: super::vals::Rate) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Downsample {
            #[inline(always)]
            fn default() -> Downsample {
                Downsample(0)
            }
        }
        impl core::fmt::Debug for Downsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Downsample")
                    .field("enablefilter", &self.enablefilter())
                    .field("rate", &self.rate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Downsample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Downsample {{ enablefilter: {=bool:?}, rate: {:?} }}",
                    self.enablefilter(),
                    self.rate()
                )
            }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edctrl(pub u32);
        impl Edctrl {
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[must_use]
            #[inline(always)]
            pub const fn edcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x001f_ffff;
                val as u32
            }
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[inline(always)]
            pub const fn set_edcnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x001f_ffff << 0usize)) | (((val as u32) & 0x001f_ffff) << 0usize);
            }
        }
        impl Default for Edctrl {
            #[inline(always)]
            fn default() -> Edctrl {
                Edctrl(0)
            }
        }
        impl core::fmt::Debug for Edctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edctrl")
                    .field("edcnt", &self.edcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Edctrl {{ edcnt: {=u32:?} }}", self.edcnt())
            }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edsample(pub u32);
        impl Edsample {
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[must_use]
            #[inline(always)]
            pub const fn edlvl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[inline(always)]
            pub const fn set_edlvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Edsample {
            #[inline(always)]
            fn default() -> Edsample {
                Edsample(0)
            }
        }
        impl core::fmt::Debug for Edsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edsample")
                    .field("edlvl", &self.edlvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edsample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Edsample {{ edlvl: {=u8:?} }}", self.edlvl())
            }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Faepeer(pub u32);
        impl Faepeer {
            #[doc = "Units 31.25 ppb."]
            #[must_use]
            #[inline(always)]
            pub const fn faepeer(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Units 31.25 ppb."]
            #[inline(always)]
            pub const fn set_faepeer(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Faepeer {
            #[inline(always)]
            fn default() -> Faepeer {
                Faepeer(0)
            }
        }
        impl core::fmt::Debug for Faepeer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Faepeer")
                    .field("faepeer", &self.faepeer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Faepeer {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Faepeer {{ faepeer: {=u8:?} }}", self.faepeer())
            }
        }
        #[doc = "Config register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feconfig(pub u32);
        impl Feconfig {
            #[doc = "Mode for narrow scaling output."]
            #[must_use]
            #[inline(always)]
            pub const fn scalermode(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Mode for narrow scaling output."]
            #[inline(always)]
            pub const fn set_scalermode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Feconfig {
            #[inline(always)]
            fn default() -> Feconfig {
                Feconfig(0)
            }
        }
        impl core::fmt::Debug for Feconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feconfig")
                    .field("scalermode", &self.scalermode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Feconfig {{ scalermode: {=bool:?} }}", self.scalermode())
            }
        }
        #[doc = "FFO estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffoest(pub u32);
        impl Ffoest {
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[must_use]
            #[inline(always)]
            pub const fn ffoest(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub const fn set_ffoest(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Ffoest {
            #[inline(always)]
            fn default() -> Ffoest {
                Ffoest(0)
            }
        }
        impl core::fmt::Debug for Ffoest {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffoest")
                    .field("ffoest", &self.ffoest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffoest {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ffoest {{ ffoest: {=u16:?} }}", self.ffoest())
            }
        }
        #[doc = "Override value of FFO (Fractional Frequency Offset) if not to be based on the frequency estimate derived from CnAcc (autocorrelation of the scaled input signal) value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffoin(pub u32);
        impl Ffoin {
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[must_use]
            #[inline(always)]
            pub const fn fffin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub const fn set_fffin(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Ffoin {
            #[inline(always)]
            fn default() -> Ffoin {
                Ffoin(0)
            }
        }
        impl core::fmt::Debug for Ffoin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffoin")
                    .field("fffin", &self.fffin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffoin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ffoin {{ fffin: {=u16:?} }}", self.fffin())
            }
        }
        #[doc = "Source of FFO"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffosource(pub u32);
        impl Ffosource {
            #[doc = "Use external or internal FFOSOURCE"]
            #[must_use]
            #[inline(always)]
            pub const fn ffosource(&self) -> super::vals::Ffosource {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ffosource::from_bits(val as u8)
            }
            #[doc = "Use external or internal FFOSOURCE"]
            #[inline(always)]
            pub const fn set_ffosource(&mut self, val: super::vals::Ffosource) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ffosource {
            #[inline(always)]
            fn default() -> Ffosource {
                Ffosource(0)
            }
        }
        impl core::fmt::Debug for Ffosource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffosource")
                    .field("ffosource", &self.ffosource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffosource {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ffosource {{ ffosource: {:?} }}", self.ffosource())
            }
        }
        #[doc = "Number of full ADPLL finetune steps"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Finetunenext(pub u32);
        impl Finetunenext {
            #[doc = "Units of 488.28125 Hz"]
            #[must_use]
            #[inline(always)]
            pub const fn finetunenext(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Units of 488.28125 Hz"]
            #[inline(always)]
            pub const fn set_finetunenext(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Finetunenext {
            #[inline(always)]
            fn default() -> Finetunenext {
                Finetunenext(0)
            }
        }
        impl core::fmt::Debug for Finetunenext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Finetunenext")
                    .field("finetunenext", &self.finetunenext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Finetunenext {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Finetunenext {{ finetunenext: {=u16:?} }}",
                    self.finetunenext()
                )
            }
        }
        #[doc = "Frequency offset estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freqoffset(pub u32);
        impl Freqoffset {
            #[must_use]
            #[inline(always)]
            pub const fn freqoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[inline(always)]
            pub const fn set_freqoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Freqoffset {
            #[inline(always)]
            fn default() -> Freqoffset {
                Freqoffset(0)
            }
        }
        impl core::fmt::Debug for Freqoffset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freqoffset")
                    .field("freqoffset", &self.freqoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freqoffset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Freqoffset {{ freqoffset: {=u16:?} }}",
                    self.freqoffset()
                )
            }
        }
        #[doc = "Frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[must_use]
            #[inline(always)]
            pub const fn map(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn set_map(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .field("map", &self.map())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Frequency {{ frequency: {=u8:?}, map: {=bool:?} }}",
                    self.frequency(),
                    self.map()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn txready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[inline(always)]
            pub const fn set_txready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[must_use]
            #[inline(always)]
            pub const fn framestart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub const fn set_framestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[must_use]
            #[inline(always)]
            pub const fn payload(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[inline(always)]
            pub const fn set_payload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[inline(always)]
            pub const fn set_phyend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[inline(always)]
            pub const fn set_disabled(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn devmatch(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[inline(always)]
            pub const fn set_devmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[must_use]
            #[inline(always)]
            pub const fn devmiss(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[inline(always)]
            pub const fn set_devmiss(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[must_use]
            #[inline(always)]
            pub const fn crcok(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[inline(always)]
            pub const fn set_crcok(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[inline(always)]
            pub const fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn bcmatch(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[inline(always)]
            pub const fn set_bcmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[must_use]
            #[inline(always)]
            pub const fn edend(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[inline(always)]
            pub const fn set_edend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn edstopped(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[inline(always)]
            pub const fn set_edstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[inline(always)]
            pub const fn set_ccaidle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[must_use]
            #[inline(always)]
            pub const fn ccabusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[inline(always)]
            pub const fn set_ccabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn ccastopped(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[inline(always)]
            pub const fn set_ccastopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[must_use]
            #[inline(always)]
            pub const fn rateboost(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[inline(always)]
            pub const fn set_rateboost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[must_use]
            #[inline(always)]
            pub const fn mhrmatch(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[inline(always)]
            pub const fn set_mhrmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[must_use]
            #[inline(always)]
            pub const fn sync(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[inline(always)]
            pub const fn set_sync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[must_use]
            #[inline(always)]
            pub const fn ctepresent(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[inline(always)]
            pub const fn set_ctepresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("txready", &self.txready())
                    .field("rxready", &self.rxready())
                    .field("address", &self.address())
                    .field("framestart", &self.framestart())
                    .field("payload", &self.payload())
                    .field("end", &self.end())
                    .field("phyend", &self.phyend())
                    .field("disabled", &self.disabled())
                    .field("devmatch", &self.devmatch())
                    .field("devmiss", &self.devmiss())
                    .field("crcok", &self.crcok())
                    .field("crcerror", &self.crcerror())
                    .field("bcmatch", &self.bcmatch())
                    .field("edend", &self.edend())
                    .field("edstopped", &self.edstopped())
                    .field("ccaidle", &self.ccaidle())
                    .field("ccabusy", &self.ccabusy())
                    .field("ccastopped", &self.ccastopped())
                    .field("rateboost", &self.rateboost())
                    .field("mhrmatch", &self.mhrmatch())
                    .field("sync", &self.sync())
                    .field("ctepresent", &self.ctepresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ ready: {=bool:?}, txready: {=bool:?}, rxready: {=bool:?}, address: {=bool:?}, framestart: {=bool:?}, payload: {=bool:?}, end: {=bool:?}, phyend: {=bool:?}, disabled: {=bool:?}, devmatch: {=bool:?}, devmiss: {=bool:?}, crcok: {=bool:?}, crcerror: {=bool:?}, bcmatch: {=bool:?}, edend: {=bool:?}, edstopped: {=bool:?}, ccaidle: {=bool:?}, ccabusy: {=bool:?}, ccastopped: {=bool:?}, rateboost: {=bool:?}, mhrmatch: {=bool:?}, sync: {=bool:?}, ctepresent: {=bool:?} }}" , self . ready () , self . txready () , self . rxready () , self . address () , self . framestart () , self . payload () , self . end () , self . phyend () , self . disabled () , self . devmatch () , self . devmiss () , self . crcok () , self . crcerror () , self . bcmatch () , self . edend () , self . edstopped () , self . ccaidle () , self . ccabusy () , self . ccastopped () , self . rateboost () , self . mhrmatch () , self . sync () , self . ctepresent ())
            }
        }
        #[doc = "Mean of IQ values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iqrawmean(pub u32);
        impl Iqrawmean {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn iqrawmeani(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_iqrawmeani(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[must_use]
            #[inline(always)]
            pub const fn iqrawmeanq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn set_iqrawmeanq(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Iqrawmean {
            #[inline(always)]
            fn default() -> Iqrawmean {
                Iqrawmean(0)
            }
        }
        impl core::fmt::Debug for Iqrawmean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iqrawmean")
                    .field("iqrawmeani", &self.iqrawmeani())
                    .field("iqrawmeanq", &self.iqrawmeanq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iqrawmean {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Iqrawmean {{ iqrawmeani: {=u16:?}, iqrawmeanq: {=u16:?} }}",
                    self.iqrawmeani(),
                    self.iqrawmeanq()
                )
            }
        }
        #[doc = "Quantization error between ADPLL frequency and the desired value of FFO * RF Frequency. Values limited to \\[-64,63\\] with units 7.6294 Hz."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfaenext(pub u32);
        impl Lfaenext {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn lfaenext(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_lfaenext(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Lfaenext {
            #[inline(always)]
            fn default() -> Lfaenext {
                Lfaenext(0)
            }
        }
        impl core::fmt::Debug for Lfaenext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfaenext")
                    .field("lfaenext", &self.lfaenext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfaenext {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lfaenext {{ lfaenext: {=u8:?} }}", self.lfaenext())
            }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magphasemean(pub u32);
        impl Magphasemean {
            #[doc = "Mean phase"]
            #[must_use]
            #[inline(always)]
            pub const fn phase(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean phase"]
            #[inline(always)]
            pub const fn set_phase(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Mean magnitude"]
            #[must_use]
            #[inline(always)]
            pub const fn mag(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean magnitude"]
            #[inline(always)]
            pub const fn set_mag(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Magphasemean {
            #[inline(always)]
            fn default() -> Magphasemean {
                Magphasemean(0)
            }
        }
        impl core::fmt::Debug for Magphasemean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magphasemean")
                    .field("phase", &self.phase())
                    .field("mag", &self.mag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magphasemean {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Magphasemean {{ phase: {=u16:?}, mag: {=u16:?} }}",
                    self.phase(),
                    self.mag()
                )
            }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magstd(pub u32);
        impl Magstd {
            #[doc = "Magnitude standard deviation approximation"]
            #[must_use]
            #[inline(always)]
            pub const fn magstd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Magnitude standard deviation approximation"]
            #[inline(always)]
            pub const fn set_magstd(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Magstd {
            #[inline(always)]
            fn default() -> Magstd {
                Magstd(0)
            }
        }
        impl core::fmt::Debug for Magstd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magstd")
                    .field("magstd", &self.magstd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magstd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Magstd {{ magstd: {=u16:?} }}", self.magstd())
            }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of bytes to transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes to transfer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nextfrequency(pub u32);
        impl Nextfrequency {
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[must_use]
            #[inline(always)]
            pub const fn nextfrequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[inline(always)]
            pub const fn set_nextfrequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Nextfrequency {
            #[inline(always)]
            fn default() -> Nextfrequency {
                Nextfrequency(0)
            }
        }
        impl core::fmt::Debug for Nextfrequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nextfrequency")
                    .field("nextfrequency", &self.nextfrequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nextfrequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nextfrequency {{ nextfrequency: {=u8:?} }}",
                    self.nextfrequency()
                )
            }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamples(pub u32);
        impl Numsamples {
            #[doc = "Maximum value supported is 160"]
            #[must_use]
            #[inline(always)]
            pub const fn numsamples(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum value supported is 160"]
            #[inline(always)]
            pub const fn set_numsamples(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Numsamples {
            #[inline(always)]
            fn default() -> Numsamples {
                Numsamples(0)
            }
        }
        impl core::fmt::Debug for Numsamples {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamples")
                    .field("numsamples", &self.numsamples())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamples {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Numsamples {{ numsamples: {=u8:?} }}", self.numsamples())
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamplescoeff(pub u32);
        impl Numsamplescoeff {
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[must_use]
            #[inline(always)]
            pub const fn numsamplescoeff(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[inline(always)]
            pub const fn set_numsamplescoeff(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Numsamplescoeff {
            #[inline(always)]
            fn default() -> Numsamplescoeff {
                Numsamplescoeff(0)
            }
        }
        impl core::fmt::Debug for Numsamplescoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamplescoeff")
                    .field("numsamplescoeff", &self.numsamplescoeff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamplescoeff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Numsamplescoeff {{ numsamplescoeff: {=u16:?} }}",
                    self.numsamplescoeff()
                )
            }
        }
        #[doc = "Packet configuration register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf0(pub u32);
        impl Pcnf0 {
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[must_use]
            #[inline(always)]
            pub const fn lflen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[inline(always)]
            pub const fn set_lflen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn s0len(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[inline(always)]
            pub const fn set_s0len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[must_use]
            #[inline(always)]
            pub const fn s1len(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[inline(always)]
            pub const fn set_s1len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[must_use]
            #[inline(always)]
            pub const fn s1incl(&self) -> super::vals::S1incl {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::S1incl::from_bits(val as u8)
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[inline(always)]
            pub const fn set_s1incl(&mut self, val: super::vals::S1incl) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "Length of code indicator - long range"]
            #[must_use]
            #[inline(always)]
            pub const fn cilen(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "Length of code indicator - long range"]
            #[inline(always)]
            pub const fn set_cilen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[must_use]
            #[inline(always)]
            pub const fn plen(&self) -> super::vals::Plen {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Plen::from_bits(val as u8)
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[inline(always)]
            pub const fn set_plen(&mut self, val: super::vals::Plen) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[must_use]
            #[inline(always)]
            pub const fn crcinc(&self) -> super::vals::Crcinc {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Crcinc::from_bits(val as u8)
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[inline(always)]
            pub const fn set_crcinc(&mut self, val: super::vals::Crcinc) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[must_use]
            #[inline(always)]
            pub const fn termlen(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[inline(always)]
            pub const fn set_termlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Pcnf0 {
            #[inline(always)]
            fn default() -> Pcnf0 {
                Pcnf0(0)
            }
        }
        impl core::fmt::Debug for Pcnf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf0")
                    .field("lflen", &self.lflen())
                    .field("s0len", &self.s0len())
                    .field("s1len", &self.s1len())
                    .field("s1incl", &self.s1incl())
                    .field("cilen", &self.cilen())
                    .field("plen", &self.plen())
                    .field("crcinc", &self.crcinc())
                    .field("termlen", &self.termlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcnf0 {{ lflen: {=u8:?}, s0len: {=bool:?}, s1len: {=u8:?}, s1incl: {:?}, cilen: {=u8:?}, plen: {:?}, crcinc: {:?}, termlen: {=u8:?} }}" , self . lflen () , self . s0len () , self . s1len () , self . s1incl () , self . cilen () , self . plen () , self . crcinc () , self . termlen ())
            }
        }
        #[doc = "Packet configuration register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf1(pub u32);
        impl Pcnf1 {
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[must_use]
            #[inline(always)]
            pub const fn maxlen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[inline(always)]
            pub const fn set_maxlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Static length in number of bytes"]
            #[must_use]
            #[inline(always)]
            pub const fn statlen(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Static length in number of bytes"]
            #[inline(always)]
            pub const fn set_statlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Base address length in number of bytes"]
            #[must_use]
            #[inline(always)]
            pub const fn balen(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "Base address length in number of bytes"]
            #[inline(always)]
            pub const fn set_balen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable packet whitening"]
            #[must_use]
            #[inline(always)]
            pub const fn whiteen(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable packet whitening"]
            #[inline(always)]
            pub const fn set_whiteen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[must_use]
            #[inline(always)]
            pub const fn whiteoffset(&self) -> super::vals::Whiteoffset {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Whiteoffset::from_bits(val as u8)
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[inline(always)]
            pub const fn set_whiteoffset(&mut self, val: super::vals::Whiteoffset) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Pcnf1 {
            #[inline(always)]
            fn default() -> Pcnf1 {
                Pcnf1(0)
            }
        }
        impl core::fmt::Debug for Pcnf1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf1")
                    .field("maxlen", &self.maxlen())
                    .field("statlen", &self.statlen())
                    .field("balen", &self.balen())
                    .field("endian", &self.endian())
                    .field("whiteen", &self.whiteen())
                    .field("whiteoffset", &self.whiteoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf1 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Pcnf1 {{ maxlen: {=u8:?}, statlen: {=u8:?}, balen: {=u8:?}, endian: {:?}, whiteen: {=bool:?}, whiteoffset: {:?} }}" , self . maxlen () , self . statlen () , self . balen () , self . endian () , self . whiteen () , self . whiteoffset ())
            }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ. IQ values limited to \\[-1024,1023\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pct11(pub u32);
        impl Pct11 {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn pct11i(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_pct11i(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[must_use]
            #[inline(always)]
            pub const fn pct11q(&self) -> u16 {
                let val = (self.0 >> 11usize) & 0x07ff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn set_pct11q(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 11usize)) | (((val as u32) & 0x07ff) << 11usize);
            }
        }
        impl Default for Pct11 {
            #[inline(always)]
            fn default() -> Pct11 {
                Pct11(0)
            }
        }
        impl core::fmt::Debug for Pct11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pct11")
                    .field("pct11i", &self.pct11i())
                    .field("pct11q", &self.pct11q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pct11 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pct11 {{ pct11i: {=u16:?}, pct11q: {=u16:?} }}",
                    self.pct11i(),
                    self.pct11q()
                )
            }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pct16(pub u32);
        impl Pct16 {
            #[doc = "Inphase"]
            #[must_use]
            #[inline(always)]
            pub const fn pct16i(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn set_pct16i(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[must_use]
            #[inline(always)]
            pub const fn pct16q(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn set_pct16q(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Pct16 {
            #[inline(always)]
            fn default() -> Pct16 {
                Pct16(0)
            }
        }
        impl core::fmt::Debug for Pct16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pct16")
                    .field("pct16i", &self.pct16i())
                    .field("pct16q", &self.pct16q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pct16 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pct16 {{ pct16i: {=u16:?}, pct16q: {=u16:?} }}",
                    self.pct16i(),
                    self.pct16q()
                )
            }
        }
        #[doc = "Payload status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdustat(pub u32);
        impl Pdustat {
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[must_use]
            #[inline(always)]
            pub const fn pdustat(&self) -> super::vals::Pdustat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pdustat::from_bits(val as u8)
            }
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[inline(always)]
            pub const fn set_pdustat(&mut self, val: super::vals::Pdustat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[must_use]
            #[inline(always)]
            pub const fn cistat(&self) -> super::vals::Cistat {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Cistat::from_bits(val as u8)
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[inline(always)]
            pub const fn set_cistat(&mut self, val: super::vals::Cistat) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
        }
        impl Default for Pdustat {
            #[inline(always)]
            fn default() -> Pdustat {
                Pdustat(0)
            }
        }
        impl core::fmt::Debug for Pdustat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdustat")
                    .field("pdustat", &self.pdustat())
                    .field("cistat", &self.cistat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdustat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pdustat {{ pdustat: {:?}, cistat: {:?} }}",
                    self.pdustat(),
                    self.cistat()
                )
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Phaseshift(pub u32);
        impl Phaseshift {
            #[doc = "Phase shift used in TPM calculation"]
            #[must_use]
            #[inline(always)]
            pub const fn phaseshift(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Phase shift used in TPM calculation"]
            #[inline(always)]
            pub const fn set_phaseshift(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Phaseshift {
            #[inline(always)]
            fn default() -> Phaseshift {
                Phaseshift(0)
            }
        }
        impl core::fmt::Debug for Phaseshift {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Phaseshift")
                    .field("phaseshift", &self.phaseshift())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Phaseshift {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Phaseshift {{ phaseshift: {=u16:?} }}",
                    self.phaseshift()
                )
            }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix0(pub u32);
        impl Prefix0 {
            #[doc = "Address prefix 0"]
            #[must_use]
            #[inline(always)]
            pub const fn ap0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 0"]
            #[inline(always)]
            pub const fn set_ap0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 1"]
            #[must_use]
            #[inline(always)]
            pub const fn ap1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 1"]
            #[inline(always)]
            pub const fn set_ap1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 2"]
            #[must_use]
            #[inline(always)]
            pub const fn ap2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 2"]
            #[inline(always)]
            pub const fn set_ap2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 3"]
            #[must_use]
            #[inline(always)]
            pub const fn ap3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 3"]
            #[inline(always)]
            pub const fn set_ap3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix0 {
            #[inline(always)]
            fn default() -> Prefix0 {
                Prefix0(0)
            }
        }
        impl core::fmt::Debug for Prefix0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix0")
                    .field("ap0", &self.ap0())
                    .field("ap1", &self.ap1())
                    .field("ap2", &self.ap2())
                    .field("ap3", &self.ap3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prefix0 {{ ap0: {=u8:?}, ap1: {=u8:?}, ap2: {=u8:?}, ap3: {=u8:?} }}",
                    self.ap0(),
                    self.ap1(),
                    self.ap2(),
                    self.ap3()
                )
            }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix1(pub u32);
        impl Prefix1 {
            #[doc = "Address prefix 4"]
            #[must_use]
            #[inline(always)]
            pub const fn ap4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 4"]
            #[inline(always)]
            pub const fn set_ap4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 5"]
            #[must_use]
            #[inline(always)]
            pub const fn ap5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 5"]
            #[inline(always)]
            pub const fn set_ap5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 6"]
            #[must_use]
            #[inline(always)]
            pub const fn ap6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 6"]
            #[inline(always)]
            pub const fn set_ap6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 7"]
            #[must_use]
            #[inline(always)]
            pub const fn ap7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 7"]
            #[inline(always)]
            pub const fn set_ap7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix1 {
            #[inline(always)]
            fn default() -> Prefix1 {
                Prefix1(0)
            }
        }
        impl core::fmt::Debug for Prefix1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix1")
                    .field("ap4", &self.ap4())
                    .field("ap5", &self.ap5())
                    .field("ap6", &self.ap6())
                    .field("ap7", &self.ap7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Prefix1 {{ ap4: {=u8:?}, ap5: {=u8:?}, ap6: {=u8:?}, ap7: {=u8:?} }}",
                    self.ap4(),
                    self.ap5(),
                    self.ap6(),
                    self.ap7()
                )
            }
        }
        #[doc = "Data rate and modulation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RadioMode(pub u32);
        impl RadioMode {
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for RadioMode {
            #[inline(always)]
            fn default() -> RadioMode {
                RadioMode(0)
            }
        }
        impl core::fmt::Debug for RadioMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RadioMode")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RadioMode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RadioMode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "RSSI sample"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rssisample(pub u32);
        impl Rssisample {
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[must_use]
            #[inline(always)]
            pub const fn rssisample(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[inline(always)]
            pub const fn set_rssisample(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Rssisample {
            #[inline(always)]
            fn default() -> Rssisample {
                Rssisample(0)
            }
        }
        impl core::fmt::Debug for Rssisample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rssisample")
                    .field("rssisample", &self.rssisample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rssisample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rssisample {{ rssisample: {=u8:?} }}", self.rssisample())
            }
        }
        #[doc = "Receive address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxaddresses(pub u32);
        impl Rxaddresses {
            #[doc = "Enable or disable reception on logical address 0"]
            #[must_use]
            #[inline(always)]
            pub const fn addr0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 0"]
            #[inline(always)]
            pub const fn set_addr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[must_use]
            #[inline(always)]
            pub const fn addr1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[inline(always)]
            pub const fn set_addr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[must_use]
            #[inline(always)]
            pub const fn addr2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[inline(always)]
            pub const fn set_addr2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[must_use]
            #[inline(always)]
            pub const fn addr3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[inline(always)]
            pub const fn set_addr3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[must_use]
            #[inline(always)]
            pub const fn addr4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[inline(always)]
            pub const fn set_addr4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[must_use]
            #[inline(always)]
            pub const fn addr5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[inline(always)]
            pub const fn set_addr5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[must_use]
            #[inline(always)]
            pub const fn addr6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[inline(always)]
            pub const fn set_addr6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[must_use]
            #[inline(always)]
            pub const fn addr7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[inline(always)]
            pub const fn set_addr7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rxaddresses {
            #[inline(always)]
            fn default() -> Rxaddresses {
                Rxaddresses(0)
            }
        }
        impl core::fmt::Debug for Rxaddresses {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxaddresses")
                    .field("addr0", &self.addr0())
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .field("addr3", &self.addr3())
                    .field("addr4", &self.addr4())
                    .field("addr5", &self.addr5())
                    .field("addr6", &self.addr6())
                    .field("addr7", &self.addr7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxaddresses {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rxaddresses {{ addr0: {=bool:?}, addr1: {=bool:?}, addr2: {=bool:?}, addr3: {=bool:?}, addr4: {=bool:?}, addr5: {=bool:?}, addr6: {=bool:?}, addr7: {=bool:?} }}" , self . addr0 () , self . addr1 () , self . addr2 () , self . addr3 () , self . addr4 () , self . addr5 () , self . addr6 () , self . addr7 ())
            }
        }
        #[doc = "CRC field of previously received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxcrc(pub u32);
        impl Rxcrc {
            #[doc = "CRC field of previously received packet"]
            #[must_use]
            #[inline(always)]
            pub const fn rxcrc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC field of previously received packet"]
            #[inline(always)]
            pub const fn set_rxcrc(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Rxcrc {
            #[inline(always)]
            fn default() -> Rxcrc {
                Rxcrc(0)
            }
        }
        impl core::fmt::Debug for Rxcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxcrc")
                    .field("rxcrc", &self.rxcrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxcrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxcrc {{ rxcrc: {=u32:?} }}", self.rxcrc())
            }
        }
        #[doc = "Received address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxmatch(pub u32);
        impl Rxmatch {
            #[doc = "Received address"]
            #[must_use]
            #[inline(always)]
            pub const fn rxmatch(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Received address"]
            #[inline(always)]
            pub const fn set_rxmatch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxmatch {
            #[inline(always)]
            fn default() -> Rxmatch {
                Rxmatch(0)
            }
        }
        impl core::fmt::Debug for Rxmatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxmatch")
                    .field("rxmatch", &self.rxmatch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxmatch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxmatch {{ rxmatch: {=u8:?} }}", self.rxmatch())
            }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sfd(pub u32);
        impl Sfd {
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[must_use]
            #[inline(always)]
            pub const fn sfd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[inline(always)]
            pub const fn set_sfd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Sfd {
            #[inline(always)]
            fn default() -> Sfd {
                Sfd(0)
            }
        }
        impl core::fmt::Debug for Sfd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sfd").field("sfd", &self.sfd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sfd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Sfd {{ sfd: {=u8:?} }}", self.sfd())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task START"]
            #[inline(always)]
            pub const fn set_ready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled_txen(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[inline(always)]
            pub const fn set_disabled_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn disabled_rxen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[inline(always)]
            pub const fn set_disabled_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[must_use]
            #[inline(always)]
            pub const fn address_rssistart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[inline(always)]
            pub const fn set_address_rssistart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn address_bcstart(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[inline(always)]
            pub const fn set_address_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready_ccastart(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[inline(always)]
            pub const fn set_rxready_ccastart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle_txen(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[inline(always)]
            pub const fn set_ccaidle_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn ccabusy_disable(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[inline(always)]
            pub const fn set_ccabusy_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn framestart_bcstart(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[inline(always)]
            pub const fn set_framestart_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[must_use]
            #[inline(always)]
            pub const fn ready_edstart(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[inline(always)]
            pub const fn set_ready_edstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn edend_disable(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[inline(always)]
            pub const fn set_edend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn ccaidle_stop(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[inline(always)]
            pub const fn set_ccaidle_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn txready_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[inline(always)]
            pub const fn set_txready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn rxready_start(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[inline(always)]
            pub const fn set_rxready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend_disable(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[inline(always)]
            pub const fn set_phyend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn phyend_start(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[inline(always)]
            pub const fn set_phyend_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_start", &self.ready_start())
                    .field("disabled_txen", &self.disabled_txen())
                    .field("disabled_rxen", &self.disabled_rxen())
                    .field("address_rssistart", &self.address_rssistart())
                    .field("end_start", &self.end_start())
                    .field("address_bcstart", &self.address_bcstart())
                    .field("rxready_ccastart", &self.rxready_ccastart())
                    .field("ccaidle_txen", &self.ccaidle_txen())
                    .field("ccabusy_disable", &self.ccabusy_disable())
                    .field("framestart_bcstart", &self.framestart_bcstart())
                    .field("ready_edstart", &self.ready_edstart())
                    .field("edend_disable", &self.edend_disable())
                    .field("ccaidle_stop", &self.ccaidle_stop())
                    .field("txready_start", &self.txready_start())
                    .field("rxready_start", &self.rxready_start())
                    .field("phyend_disable", &self.phyend_disable())
                    .field("phyend_start", &self.phyend_start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ ready_start: {=bool:?}, disabled_txen: {=bool:?}, disabled_rxen: {=bool:?}, address_rssistart: {=bool:?}, end_start: {=bool:?}, address_bcstart: {=bool:?}, rxready_ccastart: {=bool:?}, ccaidle_txen: {=bool:?}, ccabusy_disable: {=bool:?}, framestart_bcstart: {=bool:?}, ready_edstart: {=bool:?}, edend_disable: {=bool:?}, ccaidle_stop: {=bool:?}, txready_start: {=bool:?}, rxready_start: {=bool:?}, phyend_disable: {=bool:?}, phyend_start: {=bool:?} }}" , self . ready_start () , self . disabled_txen () , self . disabled_rxen () , self . address_rssistart () , self . end_start () , self . address_bcstart () , self . rxready_ccastart () , self . ccaidle_txen () , self . ccabusy_disable () , self . framestart_bcstart () , self . ready_edstart () , self . edend_disable () , self . ccaidle_stop () , self . txready_start () , self . rxready_start () , self . phyend_disable () , self . phyend_start ())
            }
        }
        #[doc = "Current radio state"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct State(pub u32);
        impl State {
            #[doc = "Current radio state"]
            #[must_use]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Current radio state"]
            #[inline(always)]
            pub const fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for State {
            #[inline(always)]
            fn default() -> State {
                State(0)
            }
        }
        impl core::fmt::Debug for State {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("State")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for State {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "State {{ state: {:?} }}", self.state())
            }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Switchpattern(pub u32);
        impl Switchpattern {
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[must_use]
            #[inline(always)]
            pub const fn switchpattern(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[inline(always)]
            pub const fn set_switchpattern(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Switchpattern {
            #[inline(always)]
            fn default() -> Switchpattern {
                Switchpattern(0)
            }
        }
        impl core::fmt::Debug for Switchpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Switchpattern")
                    .field("switchpattern", &self.switchpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Switchpattern {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Switchpattern {{ switchpattern: {=u8:?} }}",
                    self.switchpattern()
                )
            }
        }
        #[doc = "Interframe spacing in us"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tifs(pub u32);
        impl Tifs {
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[must_use]
            #[inline(always)]
            pub const fn tifs(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[inline(always)]
            pub const fn set_tifs(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Tifs {
            #[inline(always)]
            fn default() -> Tifs {
                Tifs(0)
            }
        }
        impl core::fmt::Debug for Tifs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tifs").field("tifs", &self.tifs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tifs {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tifs {{ tifs: {=u16:?} }}", self.tifs())
            }
        }
        #[doc = "Timing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timing(pub u32);
        impl Timing {
            #[doc = "Ramp-up time"]
            #[must_use]
            #[inline(always)]
            pub const fn ru(&self) -> super::vals::Ru {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ru::from_bits(val as u8)
            }
            #[doc = "Ramp-up time"]
            #[inline(always)]
            pub const fn set_ru(&mut self, val: super::vals::Ru) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Timing {
            #[inline(always)]
            fn default() -> Timing {
                Timing(0)
            }
        }
        impl core::fmt::Debug for Timing {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timing").field("ru", &self.ru()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timing {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Timing {{ ru: {:?} }}", self.ru())
            }
        }
        #[doc = "Transmit address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txaddress(pub u32);
        impl Txaddress {
            #[doc = "Transmit address select"]
            #[must_use]
            #[inline(always)]
            pub const fn txaddress(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Transmit address select"]
            #[inline(always)]
            pub const fn set_txaddress(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Txaddress {
            #[inline(always)]
            fn default() -> Txaddress {
                Txaddress(0)
            }
        }
        impl core::fmt::Debug for Txaddress {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txaddress")
                    .field("txaddress", &self.txaddress())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txaddress {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txaddress {{ txaddress: {=u8:?} }}", self.txaddress())
            }
        }
        #[doc = "Output power"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txpower(pub u32);
        impl Txpower {
            #[doc = "RADIO output power"]
            #[must_use]
            #[inline(always)]
            pub const fn txpower(&self) -> super::vals::Txpower {
                let val = (self.0 >> 0usize) & 0x07ff;
                super::vals::Txpower::from_bits(val as u16)
            }
            #[doc = "RADIO output power"]
            #[inline(always)]
            pub const fn set_txpower(&mut self, val: super::vals::Txpower) {
                self.0 =
                    (self.0 & !(0x07ff << 0usize)) | (((val.to_bits() as u32) & 0x07ff) << 0usize);
            }
        }
        impl Default for Txpower {
            #[inline(always)]
            fn default() -> Txpower {
                Txpower(0)
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txpower")
                    .field("txpower", &self.txpower())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Txpower {{ txpower: {:?} }}", self.txpower())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccamode {
            #[doc = "Energy above threshold"]
            ED_MODE = 0x0,
            #[doc = "Carrier seen"]
            CARRIER_MODE = 0x01,
            #[doc = "Energy above threshold AND carrier seen"]
            CARRIER_AND_ED_MODE = 0x02,
            #[doc = "Energy above threshold OR carrier seen"]
            CARRIER_OR_ED_MODE = 0x03,
            #[doc = "Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging."]
            ED_MODE_TEST1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ccamode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccamode {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccamode {
            #[inline(always)]
            fn from(val: u8) -> Ccamode {
                Ccamode::from_bits(val)
            }
        }
        impl From<Ccamode> for u8 {
            #[inline(always)]
            fn from(val: Ccamode) -> u8 {
                Ccamode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cistat {
            #[doc = "Frame is received at 125 kbps"]
            LR125KBIT = 0x0,
            #[doc = "Frame is received at 500 kbps"]
            LR500KBIT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cistat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cistat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cistat {
            #[inline(always)]
            fn from(val: u8) -> Cistat {
                Cistat::from_bits(val)
            }
        }
        impl From<Cistat> for u8 {
            #[inline(always)]
            fn from(val: Cistat) -> u8 {
                Cistat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcinc {
            #[doc = "LENGTH does not contain CRC"]
            EXCLUDE = 0x0,
            #[doc = "LENGTH includes CRC"]
            INCLUDE = 0x01,
        }
        impl Crcinc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcinc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcinc {
            #[inline(always)]
            fn from(val: u8) -> Crcinc {
                Crcinc::from_bits(val)
            }
        }
        impl From<Crcinc> for u8 {
            #[inline(always)]
            fn from(val: Crcinc) -> u8 {
                Crcinc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcstatus {
            #[doc = "Packet received with CRC error"]
            CRCERROR = 0x0,
            #[doc = "Packet received with CRC ok"]
            CRCOK = 0x01,
        }
        impl Crcstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcstatus {
            #[inline(always)]
            fn from(val: u8) -> Crcstatus {
                Crcstatus::from_bits(val)
            }
        }
        impl From<Crcstatus> for u8 {
            #[inline(always)]
            fn from(val: Crcstatus) -> u8 {
                Crcstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode1us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode1us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode1us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode1us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode1us {
                Cteinlinerxmode1us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode1us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode1us) -> u8 {
                Cteinlinerxmode1us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode2us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode2us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode2us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode2us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode2us {
                Cteinlinerxmode2us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode2us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode2us) -> u8 {
                Cteinlinerxmode2us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctetimevalidrange {
            #[doc = "20 in 8us unit (default) Set to 20 if parsed CTETime is larger han 20"]
            _20 = 0x0,
            #[doc = "31 in 8us unit"]
            _31 = 0x01,
            #[doc = "63 in 8us unit"]
            _63 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctetimevalidrange {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctetimevalidrange {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctetimevalidrange {
            #[inline(always)]
            fn from(val: u8) -> Ctetimevalidrange {
                Ctetimevalidrange::from_bits(val)
            }
        }
        impl From<Ctetimevalidrange> for u8 {
            #[inline(always)]
            fn from(val: Ctetimevalidrange) -> u8 {
                Ctetimevalidrange::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeinextension {
            #[doc = "Antenna switching/sampling is done in the packet payload"]
            PAYLOAD = 0x0,
            #[doc = "AoA/AoD procedure triggered at end of CRC"]
            CRC = 0x01,
        }
        impl Dfeinextension {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeinextension {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeinextension {
            #[inline(always)]
            fn from(val: u8) -> Dfeinextension {
                Dfeinextension::from_bits(val)
            }
        }
        impl From<Dfeinextension> for u8 {
            #[inline(always)]
            fn from(val: Dfeinextension) -> u8 {
                Dfeinextension::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeopmode {
            #[doc = "Direction finding mode disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Direction finding mode set to AoD"]
            AO_D = 0x02,
            #[doc = "Direction finding mode set to AoA"]
            AO_A = 0x03,
        }
        impl Dfeopmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeopmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeopmode {
            #[inline(always)]
            fn from(val: u8) -> Dfeopmode {
                Dfeopmode::from_bits(val)
            }
        }
        impl From<Dfeopmode> for u8 {
            #[inline(always)]
            fn from(val: Dfeopmode) -> u8 {
                Dfeopmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Least significant bit on air first"]
            LITTLE = 0x0,
            #[doc = "Most significant bit on air first"]
            BIG = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ffosource {
            #[doc = "Use FFOIN"]
            EXTERNAL = 0x0,
            #[doc = "Calc FFO from CnAcc"]
            INTERNAL = 0x01,
        }
        impl Ffosource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ffosource {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ffosource {
            #[inline(always)]
            fn from(val: u8) -> Ffosource {
                Ffosource::from_bits(val)
            }
        }
        impl From<Ffosource> for u8 {
            #[inline(always)]
            fn from(val: Ffosource) -> u8 {
                Ffosource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Len {
            #[doc = "CRC length is zero and CRC calculation is disabled"]
            DISABLED = 0x0,
            #[doc = "CRC length is one byte and CRC calculation is enabled"]
            ONE = 0x01,
            #[doc = "CRC length is two bytes and CRC calculation is enabled"]
            TWO = 0x02,
            #[doc = "CRC length is three bytes and CRC calculation is enabled"]
            THREE = 0x03,
        }
        impl Len {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Len {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Len {
            #[inline(always)]
            fn from(val: u8) -> Len {
                Len::from_bits(val)
            }
        }
        impl From<Len> for u8 {
            #[inline(always)]
            fn from(val: Len) -> u8 {
                Len::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "1 Mbps Nordic proprietary radio mode"]
            NRF_1MBIT = 0x0,
            #[doc = "2 Mbps Nordic proprietary radio mode"]
            NRF_2MBIT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "1 Mbps BLE"]
            BLE_1MBIT = 0x03,
            #[doc = "2 Mbps BLE"]
            BLE_2MBIT = 0x04,
            #[doc = "Long range 125 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR125KBIT = 0x05,
            #[doc = "Long range 500 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR500KBIT = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.6/h=0.5)"]
            NRF_4MBIT_0BT6 = 0x09,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.4/h=0.5)"]
            NRF_4MBIT_0BT4 = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "IEEE 802.15.4-2006 250 kbps"]
            IEEE802154_250KBIT = 0x0f,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdustat {
            #[doc = "Payload less than PCNF1.MAXLEN"]
            LESS_THAN = 0x0,
            #[doc = "Payload greater than PCNF1.MAXLEN"]
            GREATER_THAN = 0x01,
        }
        impl Pdustat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdustat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdustat {
            #[inline(always)]
            fn from(val: u8) -> Pdustat {
                Pdustat::from_bits(val)
            }
        }
        impl From<Pdustat> for u8 {
            #[inline(always)]
            fn from(val: Pdustat) -> u8 {
                Pdustat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Plen {
            #[doc = "8-bit preamble"]
            _8BIT = 0x0,
            #[doc = "16-bit preamble"]
            _16BIT = 0x01,
            #[doc = "32-bit zero preamble - used for IEEE 802.15.4"]
            _32BIT_ZERO = 0x02,
            #[doc = "Preamble - used for BLE long range"]
            LONG_RANGE = 0x03,
        }
        impl Plen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Plen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Plen {
            #[inline(always)]
            fn from(val: u8) -> Plen {
                Plen::from_bits(val)
            }
        }
        impl From<Plen> for u8 {
            #[inline(always)]
            fn from(val: Plen) -> u8 {
                Plen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rate {
            #[doc = "Radio mode BLE1M is used"]
            BLE1M = 0x0,
            #[doc = "Radio mode BLE2M is used"]
            BLE2M = 0x01,
        }
        impl Rate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rate {
            #[inline(always)]
            fn from(val: u8) -> Rate {
                Rate::from_bits(val)
            }
        }
        impl From<Rate> for u8 {
            #[inline(always)]
            fn from(val: Rate) -> u8 {
                Rate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Repeatpattern {
            #[doc = "Do not repeat (1 time in total)"]
            NO_REPEAT = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Repeatpattern {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Repeatpattern {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Repeatpattern {
            #[inline(always)]
            fn from(val: u8) -> Repeatpattern {
                Repeatpattern::from_bits(val)
            }
        }
        impl From<Repeatpattern> for u8 {
            #[inline(always)]
            fn from(val: Repeatpattern) -> u8 {
                Repeatpattern::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Role {
            #[doc = "Initiator"]
            INITIATOR = 0x0,
            #[doc = "Reflector"]
            REFLECTOR = 0x01,
        }
        impl Role {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Role {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Role {
            #[inline(always)]
            fn from(val: u8) -> Role {
                Role::from_bits(val)
            }
        }
        impl From<Role> for u8 {
            #[inline(always)]
            fn from(val: Role) -> u8 {
                Role::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ru {
            #[doc = "Legacy ramp-up time"]
            LEGACY = 0x0,
            #[doc = "Fast ramp-up (default)"]
            FAST = 0x01,
        }
        impl Ru {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ru {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ru {
            #[inline(always)]
            fn from(val: u8) -> Ru {
                Ru::from_bits(val)
            }
        }
        impl From<Ru> for u8 {
            #[inline(always)]
            fn from(val: Ru) -> u8 {
                Ru::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum S1incl {
            #[doc = "Include S1 field in RAM only if S1LEN &gt; 0"]
            AUTOMATIC = 0x0,
            #[doc = "Always include S1 field in RAM independent of S1LEN"]
            INCLUDE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl S1incl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> S1incl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for S1incl {
            #[inline(always)]
            fn from(val: u8) -> S1incl {
                S1incl::from_bits(val)
            }
        }
        impl From<S1incl> for u8 {
            #[inline(always)]
            fn from(val: S1incl) -> u8 {
                S1incl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampletype {
            #[doc = "Complex samples in I and Q"]
            IQ = 0x0,
            #[doc = "Complex samples as magnitude and phase"]
            MAG_PHASE = 0x01,
        }
        impl Sampletype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampletype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampletype {
            #[inline(always)]
            fn from(val: u8) -> Sampletype {
                Sampletype::from_bits(val)
            }
        }
        impl From<Sampletype> for u8 {
            #[inline(always)]
            fn from(val: Sampletype) -> u8 {
                Sampletype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Samplingstate {
            #[doc = "Sampling state Idle"]
            IDLE = 0x0,
            #[doc = "Sampling state Sampling"]
            SAMPLING = 0x01,
        }
        impl Samplingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Samplingstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Samplingstate {
            #[inline(always)]
            fn from(val: u8) -> Samplingstate {
                Samplingstate::from_bits(val)
            }
        }
        impl From<Samplingstate> for u8 {
            #[inline(always)]
            fn from(val: Samplingstate) -> u8 {
                Samplingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Skipaddr {
            #[doc = "CRC calculation includes address field"]
            INCLUDE = 0x0,
            #[doc = "CRC calculation starting at first byte after address field."]
            SKIP = 0x01,
            #[doc = "CRC calculation starting at first byte after length field (as per 802.15.4 standard)."]
            IEEE802154 = 0x02,
            #[doc = "CRC calculation starting at first byte after S0 field."]
            SKIP_S0 = 0x03,
            #[doc = "CRC calculation starting at first byte after S1 field."]
            SKIP_S1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Skipaddr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Skipaddr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Skipaddr {
            #[inline(always)]
            fn from(val: u8) -> Skipaddr {
                Skipaddr::from_bits(val)
            }
        }
        impl From<Skipaddr> for u8 {
            #[inline(always)]
            fn from(val: Skipaddr) -> u8 {
                Skipaddr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "RADIO is in the DISABLED state"]
            DISABLED = 0x0,
            #[doc = "RADIO is in the RXRU state"]
            RX_RU = 0x01,
            #[doc = "RADIO is in the RXIDLE state"]
            RX_IDLE = 0x02,
            #[doc = "RADIO is in the RX state"]
            RX = 0x03,
            #[doc = "RADIO is in the RXDISABLE state"]
            RX_DISABLE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "RADIO is in the TXRU state"]
            TX_RU = 0x09,
            #[doc = "RADIO is in the TXIDLE state"]
            TX_IDLE = 0x0a,
            #[doc = "RADIO is in the TX state"]
            TX = 0x0b,
            #[doc = "RADIO is in the TXDISABLE state"]
            TX_DISABLE = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Switchingstate {
            #[doc = "Switching state Idle"]
            IDLE = 0x0,
            #[doc = "Switching state Offset"]
            OFFSET = 0x01,
            #[doc = "Switching state Guard"]
            GUARD = 0x02,
            #[doc = "Switching state Ref"]
            REF = 0x03,
            #[doc = "Switching state Switching"]
            SWITCHING = 0x04,
            #[doc = "Switching state Ending"]
            ENDING = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Switchingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Switchingstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Switchingstate {
            #[inline(always)]
            fn from(val: u8) -> Switchingstate {
                Switchingstate::from_bits(val)
            }
        }
        impl From<Switchingstate> for u8 {
            #[inline(always)]
            fn from(val: Switchingstate) -> u8 {
                Switchingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacing {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacing {
                Tsamplespacing::from_bits(val)
            }
        }
        impl From<Tsamplespacing> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacing) -> u8 {
                Tsamplespacing::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacingref {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacingref {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacingref {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacingref {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacingref {
                Tsamplespacingref::from_bits(val)
            }
        }
        impl From<Tsamplespacingref> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacingref) -> u8 {
                Tsamplespacingref::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tswitchspacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tswitchspacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tswitchspacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tswitchspacing {
            #[inline(always)]
            fn from(val: u8) -> Tswitchspacing {
                Tswitchspacing::from_bits(val)
            }
        }
        impl From<Tswitchspacing> for u8 {
            #[inline(always)]
            fn from(val: Tswitchspacing) -> u8 {
                Tswitchspacing::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Txpower(u16);
        impl Txpower {
            #[doc = "-28 dBm"]
            pub const NEG28_DBM: Self = Self(0x01);
            #[doc = "-20 dBm"]
            pub const NEG20_DBM: Self = Self(0x02);
            #[doc = "-22 dBm"]
            pub const NEG22_DBM: Self = Self(0x02);
            #[doc = "-18 dBm"]
            pub const NEG18_DBM: Self = Self(0x03);
            #[doc = "-16 dBm"]
            pub const NEG16_DBM: Self = Self(0x04);
            #[doc = "-14 dBm"]
            pub const NEG14_DBM: Self = Self(0x05);
            #[doc = "-12 dBm"]
            pub const NEG12_DBM: Self = Self(0x06);
            #[doc = "-10 dBm"]
            pub const NEG10_DBM: Self = Self(0x07);
            #[doc = "-9 dBm"]
            pub const NEG9_DBM: Self = Self(0x08);
            #[doc = "-8 dBm"]
            pub const NEG8_DBM: Self = Self(0x09);
            #[doc = "-7 dBm"]
            pub const NEG7_DBM: Self = Self(0x0a);
            #[doc = "-6 dBm"]
            pub const NEG6_DBM: Self = Self(0x0b);
            #[doc = "-5 dBm"]
            pub const NEG5_DBM: Self = Self(0x0d);
            #[doc = "-4 dBm"]
            pub const NEG4_DBM: Self = Self(0x0f);
            #[doc = "-3 dBm"]
            pub const NEG3_DBM: Self = Self(0x11);
            #[doc = "-2 dBm"]
            pub const NEG2_DBM: Self = Self(0x13);
            #[doc = "-1 dBm"]
            pub const NEG1_DBM: Self = Self(0x15);
            #[doc = "0 dBm"]
            pub const _0_DBM: Self = Self(0x18);
            #[doc = "+1 dBm"]
            pub const POS1_DBM: Self = Self(0x1b);
            #[doc = "+2 dBm"]
            pub const POS2_DBM: Self = Self(0x1f);
            #[doc = "+3 dBm"]
            pub const POS3_DBM: Self = Self(0x23);
            #[doc = "+4 dBm"]
            pub const POS4_DBM: Self = Self(0x28);
            #[doc = "+5 dBm"]
            pub const POS5_DBM: Self = Self(0x2d);
            #[doc = "+6 dBm"]
            pub const POS6_DBM: Self = Self(0x33);
            #[doc = "+7 dBm"]
            pub const POS7_DBM: Self = Self(0x39);
            #[doc = "+8 dBm"]
            pub const POS8_DBM: Self = Self(0x3f);
            #[doc = "-46 dBm"]
            pub const NEG46_DBM: Self = Self(0x0110);
            #[doc = "-40 dBm"]
            pub const NEG40_DBM: Self = Self(0x0130);
        }
        impl Txpower {
            pub const fn from_bits(val: u16) -> Txpower {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("NEG28_DBM"),
                    0x02 => f.write_str("NEG20_DBM"),
                    0x02 => f.write_str("NEG22_DBM"),
                    0x03 => f.write_str("NEG18_DBM"),
                    0x04 => f.write_str("NEG16_DBM"),
                    0x05 => f.write_str("NEG14_DBM"),
                    0x06 => f.write_str("NEG12_DBM"),
                    0x07 => f.write_str("NEG10_DBM"),
                    0x08 => f.write_str("NEG9_DBM"),
                    0x09 => f.write_str("NEG8_DBM"),
                    0x0a => f.write_str("NEG7_DBM"),
                    0x0b => f.write_str("NEG6_DBM"),
                    0x0d => f.write_str("NEG5_DBM"),
                    0x0f => f.write_str("NEG4_DBM"),
                    0x11 => f.write_str("NEG3_DBM"),
                    0x13 => f.write_str("NEG2_DBM"),
                    0x15 => f.write_str("NEG1_DBM"),
                    0x18 => f.write_str("_0_DBM"),
                    0x1b => f.write_str("POS1_DBM"),
                    0x1f => f.write_str("POS2_DBM"),
                    0x23 => f.write_str("POS3_DBM"),
                    0x28 => f.write_str("POS4_DBM"),
                    0x2d => f.write_str("POS5_DBM"),
                    0x33 => f.write_str("POS6_DBM"),
                    0x39 => f.write_str("POS7_DBM"),
                    0x3f => f.write_str("POS8_DBM"),
                    0x0110 => f.write_str("NEG46_DBM"),
                    0x0130 => f.write_str("NEG40_DBM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "NEG28_DBM"),
                    0x02 => defmt::write!(f, "NEG20_DBM"),
                    0x02 => defmt::write!(f, "NEG22_DBM"),
                    0x03 => defmt::write!(f, "NEG18_DBM"),
                    0x04 => defmt::write!(f, "NEG16_DBM"),
                    0x05 => defmt::write!(f, "NEG14_DBM"),
                    0x06 => defmt::write!(f, "NEG12_DBM"),
                    0x07 => defmt::write!(f, "NEG10_DBM"),
                    0x08 => defmt::write!(f, "NEG9_DBM"),
                    0x09 => defmt::write!(f, "NEG8_DBM"),
                    0x0a => defmt::write!(f, "NEG7_DBM"),
                    0x0b => defmt::write!(f, "NEG6_DBM"),
                    0x0d => defmt::write!(f, "NEG5_DBM"),
                    0x0f => defmt::write!(f, "NEG4_DBM"),
                    0x11 => defmt::write!(f, "NEG3_DBM"),
                    0x13 => defmt::write!(f, "NEG2_DBM"),
                    0x15 => defmt::write!(f, "NEG1_DBM"),
                    0x18 => defmt::write!(f, "_0_DBM"),
                    0x1b => defmt::write!(f, "POS1_DBM"),
                    0x1f => defmt::write!(f, "POS2_DBM"),
                    0x23 => defmt::write!(f, "POS3_DBM"),
                    0x28 => defmt::write!(f, "POS4_DBM"),
                    0x2d => defmt::write!(f, "POS5_DBM"),
                    0x33 => defmt::write!(f, "POS6_DBM"),
                    0x39 => defmt::write!(f, "POS7_DBM"),
                    0x3f => defmt::write!(f, "POS8_DBM"),
                    0x0110 => defmt::write!(f, "NEG46_DBM"),
                    0x0130 => defmt::write!(f, "NEG40_DBM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Txpower {
            #[inline(always)]
            fn from(val: u16) -> Txpower {
                Txpower::from_bits(val)
            }
        }
        impl From<Txpower> for u16 {
            #[inline(always)]
            fn from(val: Txpower) -> u16 {
                Txpower::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Whiteoffset {
            #[doc = "S0 included in whitening"]
            INCLUDE = 0x0,
            #[doc = "S0 excluded from whitening"]
            EXCLUDE = 0x01,
        }
        impl Whiteoffset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Whiteoffset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Whiteoffset {
            #[inline(always)]
            fn from(val: u8) -> Whiteoffset {
                Whiteoffset::from_bits(val)
            }
        }
        impl From<Whiteoffset> for u8 {
            #[inline(always)]
            fn from(val: Whiteoffset) -> u8 {
                Whiteoffset::to_bits(val)
            }
        }
    }
}
pub mod regulators {
    #[doc = "Voltage regulators 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Regulators {
        ptr: *mut u8,
    }
    unsafe impl Send for Regulators {}
    unsafe impl Sync for Regulators {}
    impl Regulators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Register interface for the medium voltage regulator"]
        #[inline(always)]
        pub const fn vregm(self) -> Vregm {
            unsafe { Vregm::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "System OFF register"]
        #[inline(always)]
        pub const fn systemoff(self) -> crate::common::Reg<regs::Systemoff, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Power-fail comparator configuration"]
        #[inline(always)]
        pub const fn pofcon(self) -> crate::common::Reg<regs::Pofcon, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "Power-fail comparator status register"]
        #[inline(always)]
        pub const fn pofstat(self) -> crate::common::Reg<regs::Pofstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "Register interface for main voltage regulator."]
        #[inline(always)]
        pub const fn vregmain(self) -> Vregmain {
            unsafe { Vregmain::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    #[doc = "Register interface for the medium voltage regulator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregm {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregm {}
    unsafe impl Sync for Vregm {}
    impl Vregm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable register for VREGM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Register interface for main voltage regulator."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregmain {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregmain {}
    unsafe impl Sync for Vregmain {}
    impl Vregmain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable DC/DC converter for better power efficiency"]
        #[inline(always)]
        pub const fn dcdcen(self) -> crate::common::Reg<regs::Dcdcen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[inline(always)]
        pub const fn inductordet(self) -> crate::common::Reg<regs::Inductordet, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable DC/DC converter for better power efficiency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcdcen(pub u32);
        impl Dcdcen {
            #[doc = "Enable DC/DC buck converter"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable DC/DC buck converter"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dcdcen {
            #[inline(always)]
            fn default() -> Dcdcen {
                Dcdcen(0)
            }
        }
        impl core::fmt::Debug for Dcdcen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcdcen").field("val", &self.val()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcdcen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dcdcen {{ val: {=bool:?} }}", self.val())
            }
        }
        #[doc = "Enable register for VREGM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable the regulator"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the regulator"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inductordet(pub u32);
        impl Inductordet {
            #[must_use]
            #[inline(always)]
            pub const fn detected(&self) -> super::vals::Detected {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detected::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_detected(&mut self, val: super::vals::Detected) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Inductordet {
            #[inline(always)]
            fn default() -> Inductordet {
                Inductordet(0)
            }
        }
        impl core::fmt::Debug for Inductordet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inductordet")
                    .field("detected", &self.detected())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inductordet {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Inductordet {{ detected: {:?} }}", self.detected())
            }
        }
        #[doc = "Power-fail comparator configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofcon(pub u32);
        impl Pofcon {
            #[doc = "Enable or disable power-fail comparator"]
            #[must_use]
            #[inline(always)]
            pub const fn pof(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable power-fail comparator"]
            #[inline(always)]
            pub const fn set_pof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[must_use]
            #[inline(always)]
            pub const fn threshold(&self) -> super::vals::Threshold {
                let val = (self.0 >> 1usize) & 0x0f;
                super::vals::Threshold::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[inline(always)]
            pub const fn set_threshold(&mut self, val: super::vals::Threshold) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val.to_bits() as u32) & 0x0f) << 1usize);
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[must_use]
            #[inline(always)]
            pub const fn eventdisable(&self) -> super::vals::Eventdisable {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Eventdisable::from_bits(val as u8)
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[inline(always)]
            pub const fn set_eventdisable(&mut self, val: super::vals::Eventdisable) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Pofcon {
            #[inline(always)]
            fn default() -> Pofcon {
                Pofcon(0)
            }
        }
        impl core::fmt::Debug for Pofcon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofcon")
                    .field("pof", &self.pof())
                    .field("threshold", &self.threshold())
                    .field("eventdisable", &self.eventdisable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofcon {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pofcon {{ pof: {=bool:?}, threshold: {:?}, eventdisable: {:?} }}",
                    self.pof(),
                    self.threshold(),
                    self.eventdisable()
                )
            }
        }
        #[doc = "Power-fail comparator status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofstat(pub u32);
        impl Pofstat {
            #[doc = "Power-fail comparator status"]
            #[must_use]
            #[inline(always)]
            pub const fn comparator(&self) -> super::vals::Comparator {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Comparator::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator status"]
            #[inline(always)]
            pub const fn set_comparator(&mut self, val: super::vals::Comparator) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Pofstat {
            #[inline(always)]
            fn default() -> Pofstat {
                Pofstat(0)
            }
        }
        impl core::fmt::Debug for Pofstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofstat")
                    .field("comparator", &self.comparator())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Pofstat {{ comparator: {:?} }}", self.comparator())
            }
        }
        #[doc = "System OFF register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Systemoff(pub u32);
        impl Systemoff {
            #[doc = "Enable System OFF mode"]
            #[must_use]
            #[inline(always)]
            pub const fn systemoff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable System OFF mode"]
            #[inline(always)]
            pub const fn set_systemoff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Systemoff {
            #[inline(always)]
            fn default() -> Systemoff {
                Systemoff(0)
            }
        }
        impl core::fmt::Debug for Systemoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Systemoff")
                    .field("systemoff", &self.systemoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Systemoff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Systemoff {{ systemoff: {=bool:?} }}", self.systemoff())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Comparator {
            #[doc = "Voltage detected above VPOF threshold"]
            ABOVE = 0x0,
            #[doc = "Voltage detected below VPOF threshold"]
            BELOW = 0x01,
        }
        impl Comparator {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Comparator {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Comparator {
            #[inline(always)]
            fn from(val: u8) -> Comparator {
                Comparator::from_bits(val)
            }
        }
        impl From<Comparator> for u8 {
            #[inline(always)]
            fn from(val: Comparator) -> u8 {
                Comparator::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detected {
            #[doc = "VREGMAIN inductor not detected"]
            INDUCTOR_NOT_DETECTED = 0x0,
            #[doc = "VREGMAIN inductor detected"]
            INDUCTOR_DETECTED = 0x01,
        }
        impl Detected {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detected {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detected {
            #[inline(always)]
            fn from(val: u8) -> Detected {
                Detected::from_bits(val)
            }
        }
        impl From<Detected> for u8 {
            #[inline(always)]
            fn from(val: Detected) -> u8 {
                Detected::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eventdisable {
            #[doc = "POFWARN event is generated"]
            ENABLED = 0x0,
            #[doc = "POFWARN event is not generated"]
            DISABLED = 0x01,
        }
        impl Eventdisable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eventdisable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eventdisable {
            #[inline(always)]
            fn from(val: u8) -> Eventdisable {
                Eventdisable::from_bits(val)
            }
        }
        impl From<Eventdisable> for u8 {
            #[inline(always)]
            fn from(val: Eventdisable) -> u8 {
                Eventdisable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Threshold {
            #[doc = "Set threshold to 1.7 V"]
            V17 = 0x0,
            #[doc = "Set threshold to 1.8 V"]
            V18 = 0x01,
            #[doc = "Set threshold to 1.9 V"]
            V19 = 0x02,
            #[doc = "Set threshold to 2.0 V"]
            V20 = 0x03,
            #[doc = "Set threshold to 2.1 V"]
            V21 = 0x04,
            #[doc = "Set threshold to 2.2 V"]
            V22 = 0x05,
            #[doc = "Set threshold to 2.3 V"]
            V23 = 0x06,
            #[doc = "Set threshold to 2.4 V"]
            V24 = 0x07,
            #[doc = "Set threshold to 2.5 V"]
            V25 = 0x08,
            #[doc = "Set threshold to 2.6 V"]
            V26 = 0x09,
            #[doc = "Set threshold to 2.7 V"]
            V27 = 0x0a,
            #[doc = "Set threshold to 2.8 V"]
            V28 = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Threshold {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Threshold {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Threshold {
            #[inline(always)]
            fn from(val: u8) -> Threshold {
                Threshold::from_bits(val)
            }
        }
        impl From<Threshold> for u8 {
            #[inline(always)]
            fn from(val: Threshold) -> u8 {
                Threshold::to_bits(val)
            }
        }
    }
}
pub mod reset {
    #[doc = "Reset control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Reset {
        ptr: *mut u8,
    }
    unsafe impl Send for Reset {}
    unsafe impl Sync for Reset {}
    impl Reset {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Reset reason"]
        #[inline(always)]
        pub const fn resetreas(self) -> crate::common::Reg<regs::Resetreas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Reset reason"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resetreas(pub u32);
        impl Resetreas {
            #[doc = "Reset from pin reset detected"]
            #[must_use]
            #[inline(always)]
            pub const fn resetpin(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from pin reset detected"]
            #[inline(always)]
            pub const fn set_resetpin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[must_use]
            #[inline(always)]
            pub const fn dog0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[inline(always)]
            pub const fn set_dog0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[must_use]
            #[inline(always)]
            pub const fn dog1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[inline(always)]
            pub const fn set_dog1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlapsoft(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[inline(always)]
            pub const fn set_ctrlapsoft(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlaphard(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[inline(always)]
            pub const fn set_ctrlaphard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[must_use]
            #[inline(always)]
            pub const fn ctrlappin(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[inline(always)]
            pub const fn set_ctrlappin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Reset from soft reset detected"]
            #[must_use]
            #[inline(always)]
            pub const fn sreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from soft reset detected"]
            #[inline(always)]
            pub const fn set_sreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Reset from CPU lockup detected"]
            #[must_use]
            #[inline(always)]
            pub const fn lockup(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from CPU lockup detected"]
            #[inline(always)]
            pub const fn set_lockup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[must_use]
            #[inline(always)]
            pub const fn off(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[inline(always)]
            pub const fn set_off(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[must_use]
            #[inline(always)]
            pub const fn lpcomp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[inline(always)]
            pub const fn set_lpcomp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[must_use]
            #[inline(always)]
            pub const fn dif(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[inline(always)]
            pub const fn set_dif(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[must_use]
            #[inline(always)]
            pub const fn grtc(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[inline(always)]
            pub const fn set_grtc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[must_use]
            #[inline(always)]
            pub const fn nfc(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[inline(always)]
            pub const fn set_nfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[must_use]
            #[inline(always)]
            pub const fn sectamper(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[inline(always)]
            pub const fn set_sectamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Resetreas {
            #[inline(always)]
            fn default() -> Resetreas {
                Resetreas(0)
            }
        }
        impl core::fmt::Debug for Resetreas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resetreas")
                    .field("resetpin", &self.resetpin())
                    .field("dog0", &self.dog0())
                    .field("dog1", &self.dog1())
                    .field("ctrlapsoft", &self.ctrlapsoft())
                    .field("ctrlaphard", &self.ctrlaphard())
                    .field("ctrlappin", &self.ctrlappin())
                    .field("sreq", &self.sreq())
                    .field("lockup", &self.lockup())
                    .field("off", &self.off())
                    .field("lpcomp", &self.lpcomp())
                    .field("dif", &self.dif())
                    .field("grtc", &self.grtc())
                    .field("nfc", &self.nfc())
                    .field("sectamper", &self.sectamper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resetreas {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Resetreas {{ resetpin: {=bool:?}, dog0: {=bool:?}, dog1: {=bool:?}, ctrlapsoft: {=bool:?}, ctrlaphard: {=bool:?}, ctrlappin: {=bool:?}, sreq: {=bool:?}, lockup: {=bool:?}, off: {=bool:?}, lpcomp: {=bool:?}, dif: {=bool:?}, grtc: {=bool:?}, nfc: {=bool:?}, sectamper: {=bool:?} }}" , self . resetpin () , self . dog0 () , self . dog1 () , self . ctrlapsoft () , self . ctrlaphard () , self . ctrlappin () , self . sreq () , self . lockup () , self . off () , self . lpcomp () , self . dif () , self . grtc () , self . nfc () , self . sectamper ())
            }
        }
    }
}
pub mod rramc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bufstatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bufstatus {}
    unsafe impl Sync for Bufstatus {}
    impl Bufstatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Internal write-buffer is empty"]
        #[inline(always)]
        pub const fn writebufempty(
            self,
        ) -> crate::common::Reg<regs::Writebufempty, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecc {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecc {}
    unsafe impl Sync for Ecc {}
    impl Ecc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the first ECC error that could not be corrected"]
        #[inline(always)]
        pub const fn erroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Erase {
        ptr: *mut u8,
    }
    unsafe impl Send for Erase {}
    unsafe impl Sync for Erase {}
    impl Erase {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Register for erasing whole RRAM main block, that includes the SICR and the UICR"]
        #[inline(always)]
        pub const fn eraseall(self) -> crate::common::Reg<regs::Eraseall, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Power configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::PowerConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Low power mode configuration"]
        #[inline(always)]
        pub const fn lowpowerconfig(
            self,
        ) -> crate::common::Reg<regs::Lowpowerconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Region {
        ptr: *mut u8,
    }
    unsafe impl Send for Region {}
    unsafe impl Sync for Region {}
    impl Region {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Region address"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Region configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RegionConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "RRAM controller GLITCH detector"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rramc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rramc {}
    unsafe impl Sync for Rramc {}
    impl Rramc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Wakeup the RRAM from low power mode"]
        #[inline(always)]
        pub const fn tasks_wakeup(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Commits the data stored in internal write-buffer to RRAM"]
        #[inline(always)]
        pub const fn tasks_commitwritebuf(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task WAKEUP"]
        #[inline(always)]
        pub const fn subscribe_wakeup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task COMMITWRITEBUF"]
        #[inline(always)]
        pub const fn subscribe_commitwritebuf(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "RRAMC is woken up from low power mode"]
        #[inline(always)]
        pub const fn events_wokenup(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "RRAMC is ready"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Ready to accept a new write operation"]
        #[inline(always)]
        pub const fn events_readynext(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "RRAM access error"]
        #[inline(always)]
        pub const fn events_accesserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Uncorrectable ECC error detected"]
        #[inline(always)]
        pub const fn events_eccerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event WOKENUP"]
        #[inline(always)]
        pub const fn publish_wokenup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "RRAMC ready status"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<regs::Ready, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Ready next flag"]
        #[inline(always)]
        pub const fn readynext(self) -> crate::common::Reg<regs::Readynext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Address of the first access error"]
        #[inline(always)]
        pub const fn accesserroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn bufstatus(self) -> Bufstatus {
            unsafe { Bufstatus::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ecc(self) -> Ecc {
            unsafe { Ecc::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RramcConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[inline(always)]
        pub const fn readynexttimeout(
            self,
        ) -> crate::common::Reg<regs::Readynexttimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self) -> Power {
            unsafe { Power::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn erase(self) -> Erase {
            unsafe { Erase::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn region(self, n: usize) -> Region {
            assert!(n < 5usize);
            unsafe { Region::from_ptr(self.ptr.add(0x0550usize + n * 8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Register for erasing whole RRAM main block, that includes the SICR and the UICR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eraseall(pub u32);
        impl Eraseall {
            #[doc = "Erase whole RRAM main block"]
            #[must_use]
            #[inline(always)]
            pub const fn erase(&self) -> super::vals::Erase {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Erase::from_bits(val as u8)
            }
            #[doc = "Erase whole RRAM main block"]
            #[inline(always)]
            pub const fn set_erase(&mut self, val: super::vals::Erase) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Eraseall {
            #[inline(always)]
            fn default() -> Eraseall {
                Eraseall(0)
            }
        }
        impl core::fmt::Debug for Eraseall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eraseall")
                    .field("erase", &self.erase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eraseall {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Eraseall {{ erase: {:?} }}", self.erase())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[must_use]
            #[inline(always)]
            pub const fn wokenup(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[inline(always)]
            pub const fn set_wokenup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[must_use]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[inline(always)]
            pub const fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn accesserror(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[inline(always)]
            pub const fn set_accesserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event ECCERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn eccerror(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ECCERROR"]
            #[inline(always)]
            pub const fn set_eccerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("wokenup", &self.wokenup())
                    .field("ready", &self.ready())
                    .field("readynext", &self.readynext())
                    .field("accesserror", &self.accesserror())
                    .field("eccerror", &self.eccerror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ wokenup: {=bool:?}, ready: {=bool:?}, readynext: {=bool:?}, accesserror: {=bool:?}, eccerror: {=bool:?} }}" , self . wokenup () , self . ready () , self . readynext () , self . accesserror () , self . eccerror ())
            }
        }
        #[doc = "Low power mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lowpowerconfig(pub u32);
        impl Lowpowerconfig {
            #[doc = "RRAM low power mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "RRAM low power mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Lowpowerconfig {
            #[inline(always)]
            fn default() -> Lowpowerconfig {
                Lowpowerconfig(0)
            }
        }
        impl core::fmt::Debug for Lowpowerconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lowpowerconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lowpowerconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lowpowerconfig {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Power configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PowerConfig(pub u32);
        impl PowerConfig {
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[must_use]
            #[inline(always)]
            pub const fn accesstimeout(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[inline(always)]
            pub const fn set_accesstimeout(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Power on failure warning handling configuration"]
            #[must_use]
            #[inline(always)]
            pub const fn pof(&self) -> super::vals::Pof {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pof::from_bits(val as u8)
            }
            #[doc = "Power on failure warning handling configuration"]
            #[inline(always)]
            pub const fn set_pof(&mut self, val: super::vals::Pof) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PowerConfig {
            #[inline(always)]
            fn default() -> PowerConfig {
                PowerConfig(0)
            }
        }
        impl core::fmt::Debug for PowerConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PowerConfig")
                    .field("accesstimeout", &self.accesstimeout())
                    .field("pof", &self.pof())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PowerConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "PowerConfig {{ accesstimeout: {=u16:?}, pof: {:?} }}",
                    self.accesstimeout(),
                    self.pof()
                )
            }
        }
        #[doc = "RRAMC ready status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ready(pub u32);
        impl Ready {
            #[doc = "RRAMC is ready or busy"]
            #[must_use]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC is ready or busy"]
            #[inline(always)]
            pub const fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ready {
            #[inline(always)]
            fn default() -> Ready {
                Ready(0)
            }
        }
        impl core::fmt::Debug for Ready {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ready")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ready {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Ready {{ ready: {=bool:?} }}", self.ready())
            }
        }
        #[doc = "Ready next flag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynext(pub u32);
        impl Readynext {
            #[doc = "RRAMC can accept a new write operation"]
            #[must_use]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC can accept a new write operation"]
            #[inline(always)]
            pub const fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Readynext {
            #[inline(always)]
            fn default() -> Readynext {
                Readynext(0)
            }
        }
        impl core::fmt::Debug for Readynext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynext")
                    .field("readynext", &self.readynext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynext {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Readynext {{ readynext: {=bool:?} }}", self.readynext())
            }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynexttimeout(pub u32);
        impl Readynexttimeout {
            #[doc = "Preload value for waiting for a next write"]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Preload value for waiting for a next write"]
            #[inline(always)]
            pub const fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Enable ready next timeout"]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Enable ready next timeout"]
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Readynexttimeout {
            #[inline(always)]
            fn default() -> Readynexttimeout {
                Readynexttimeout(0)
            }
        }
        impl core::fmt::Debug for Readynexttimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynexttimeout")
                    .field("value", &self.value())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynexttimeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Readynexttimeout {{ value: {=u16:?}, en: {=bool:?} }}",
                    self.value(),
                    self.en()
                )
            }
        }
        #[doc = "Description cluster: Region configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionConfig(pub u32);
        impl RegionConfig {
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Owner ID"]
            #[must_use]
            #[inline(always)]
            pub const fn owner(&self) -> super::vals::Owner {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Owner::from_bits(val as u8)
            }
            #[doc = "Owner ID"]
            #[inline(always)]
            pub const fn set_owner(&mut self, val: super::vals::Owner) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Write-once"]
            #[must_use]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
        }
        impl Default for RegionConfig {
            #[inline(always)]
            fn default() -> RegionConfig {
                RegionConfig(0)
            }
        }
        impl core::fmt::Debug for RegionConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionConfig")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("owner", &self.owner())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "RegionConfig {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, owner: {:?}, writeonce: {=bool:?}, lock: {=bool:?}, size: {=u8:?} }}" , self . read () , self . write () , self . execute () , self . secure () , self . owner () , self . writeonce () , self . lock () , self . size ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RramcConfig(pub u32);
        impl RramcConfig {
            #[doc = "Write enable"]
            #[must_use]
            #[inline(always)]
            pub const fn wen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write enable"]
            #[inline(always)]
            pub const fn set_wen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[must_use]
            #[inline(always)]
            pub const fn writebufsize(&self) -> super::vals::Writebufsize {
                let val = (self.0 >> 8usize) & 0x3f;
                super::vals::Writebufsize::from_bits(val as u8)
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[inline(always)]
            pub const fn set_writebufsize(&mut self, val: super::vals::Writebufsize) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val.to_bits() as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for RramcConfig {
            #[inline(always)]
            fn default() -> RramcConfig {
                RramcConfig(0)
            }
        }
        impl core::fmt::Debug for RramcConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RramcConfig")
                    .field("wen", &self.wen())
                    .field("writebufsize", &self.writebufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RramcConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RramcConfig {{ wen: {=bool:?}, writebufsize: {:?} }}",
                    self.wen(),
                    self.writebufsize()
                )
            }
        }
        #[doc = "Internal write-buffer is empty"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writebufempty(pub u32);
        impl Writebufempty {
            #[must_use]
            #[inline(always)]
            pub const fn empty(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Writebufempty {
            #[inline(always)]
            fn default() -> Writebufempty {
                Writebufempty(0)
            }
        }
        impl core::fmt::Debug for Writebufempty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writebufempty")
                    .field("empty", &self.empty())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writebufempty {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Writebufempty {{ empty: {=bool:?} }}", self.empty())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Erase {
            #[doc = "No operation"]
            NO_OPERATION = 0x0,
            #[doc = "Start erase of chip"]
            ERASE = 0x01,
        }
        impl Erase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Erase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Erase {
            #[inline(always)]
            fn from(val: u8) -> Erase {
                Erase::from_bits(val)
            }
        }
        impl From<Erase> for u8 {
            #[inline(always)]
            fn from(val: Erase) -> u8 {
                Erase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "The RRAM goes into power down mode"]
            POWER_DOWN = 0x0,
            #[doc = "The RRAM automatically goes into standby mode while the RRAM is not being accessed"]
            STANDBY = 0x01,
            #[doc = "The RRAM goes into NAP mode"]
            NAP = 0x02,
            #[doc = "The RRAM is powered Off"]
            POWER_OFF = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Owner {
            #[doc = "Owner ID protection is not enforced"]
            NOT_ENFORCED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Owner {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Owner {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Owner {
            #[inline(always)]
            fn from(val: u8) -> Owner {
                Owner::from_bits(val)
            }
        }
        impl From<Owner> for u8 {
            #[inline(always)]
            fn from(val: Owner) -> u8 {
                Owner::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pof {
            #[doc = "Wait until the current RRAM write finishes"]
            WAIT = 0x0,
            #[doc = "Abort the current RRAM write"]
            ABORT = 0x01,
        }
        impl Pof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pof {
            #[inline(always)]
            fn from(val: u8) -> Pof {
                Pof::from_bits(val)
            }
        }
        impl From<Pof> for u8 {
            #[inline(always)]
            fn from(val: Pof) -> u8 {
                Pof::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Writebufsize {
            #[doc = "Disable buffering"]
            UNBUFFERED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            _RESERVED_10 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
            _RESERVED_20 = 0x20,
            _RESERVED_21 = 0x21,
            _RESERVED_22 = 0x22,
            _RESERVED_23 = 0x23,
            _RESERVED_24 = 0x24,
            _RESERVED_25 = 0x25,
            _RESERVED_26 = 0x26,
            _RESERVED_27 = 0x27,
            _RESERVED_28 = 0x28,
            _RESERVED_29 = 0x29,
            _RESERVED_2a = 0x2a,
            _RESERVED_2b = 0x2b,
            _RESERVED_2c = 0x2c,
            _RESERVED_2d = 0x2d,
            _RESERVED_2e = 0x2e,
            _RESERVED_2f = 0x2f,
            _RESERVED_30 = 0x30,
            _RESERVED_31 = 0x31,
            _RESERVED_32 = 0x32,
            _RESERVED_33 = 0x33,
            _RESERVED_34 = 0x34,
            _RESERVED_35 = 0x35,
            _RESERVED_36 = 0x36,
            _RESERVED_37 = 0x37,
            _RESERVED_38 = 0x38,
            _RESERVED_39 = 0x39,
            _RESERVED_3a = 0x3a,
            _RESERVED_3b = 0x3b,
            _RESERVED_3c = 0x3c,
            _RESERVED_3d = 0x3d,
            _RESERVED_3e = 0x3e,
            _RESERVED_3f = 0x3f,
        }
        impl Writebufsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Writebufsize {
                unsafe { core::mem::transmute(val & 0x3f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Writebufsize {
            #[inline(always)]
            fn from(val: u8) -> Writebufsize {
                Writebufsize::from_bits(val)
            }
        }
        impl From<Writebufsize> for u8 {
            #[inline(always)]
            fn from(val: Writebufsize) -> u8 {
                Writebufsize::to_bits(val)
            }
        }
    }
}
pub mod rtc {
    #[doc = "Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start RTC counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop RTC counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Clear RTC counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Set counter to 0xFFFFF0"]
        #[inline(always)]
        pub const fn tasks_trigovrflw(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Capture RTC counter to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task TRIGOVRFLW"]
        #[inline(always)]
        pub const fn subscribe_trigovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Event on counter increment"]
        #[inline(always)]
        pub const fn events_tick(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Event on counter overflow"]
        #[inline(always)]
        pub const fn events_ovrflw(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event TICK"]
        #[inline(always)]
        pub const fn publish_tick(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event OVRFLW"]
        #[inline(always)]
        pub const fn publish_ovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "Current counter value"]
        #[inline(always)]
        pub const fn counter(self) -> crate::common::Reg<regs::Counter, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "12-bit prescaler for counter frequency (32768 / (PRESCALER + 1)). Must be written when RTC is stopped."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Compare register n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "Compare value"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Compare value"]
            #[inline(always)]
            pub const fn set_compare(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("compare", &self.compare())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cc {{ compare: {=u32:?} }}", self.compare())
            }
        }
        #[doc = "Current counter value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Counter(pub u32);
        impl Counter {
            #[doc = "Counter value"]
            #[must_use]
            #[inline(always)]
            pub const fn counter(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Counter value"]
            #[inline(always)]
            pub const fn set_counter(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Counter {
            #[inline(always)]
            fn default() -> Counter {
                Counter(0)
            }
        }
        impl core::fmt::Debug for Counter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Counter")
                    .field("counter", &self.counter())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Counter {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Counter {{ counter: {=u32:?} }}", self.counter())
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event TICK"]
            #[must_use]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event TICK"]
            #[inline(always)]
            pub const fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[must_use]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[inline(always)]
            pub const fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Evt {{ tick: {=bool:?}, ovrflw: {=bool:?}, compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?} }}" , self . tick () , self . ovrflw () , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize))
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[must_use]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[inline(always)]
            pub const fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[must_use]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[inline(always)]
            pub const fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ tick: {=bool:?}, ovrflw: {=bool:?}, compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?} }}" , self . tick () , self . ovrflw () , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize))
            }
        }
        #[doc = "12-bit prescaler for counter frequency (32768 / (PRESCALER + 1)). Must be written when RTC is stopped."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {=u16:?} }}", self.prescaler())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn comparen_clear(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn set_comparen_clear(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("comparen_clear[0]", &self.comparen_clear(0usize))
                    .field("comparen_clear[1]", &self.comparen_clear(1usize))
                    .field("comparen_clear[2]", &self.comparen_clear(2usize))
                    .field("comparen_clear[3]", &self.comparen_clear(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ comparen_clear[0]: {=bool:?}, comparen_clear[1]: {=bool:?}, comparen_clear[2]: {=bool:?}, comparen_clear[3]: {=bool:?} }}" , self . comparen_clear (0usize) , self . comparen_clear (1usize) , self . comparen_clear (2usize) , self . comparen_clear (3usize))
            }
        }
    }
}
pub mod saadc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ch {
        ptr: *mut u8,
    }
    unsafe impl Send for Ch {}
    unsafe impl Sync for Ch {}
    impl Ch {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pselp(self) -> crate::common::Reg<regs::Pselp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pseln(self) -> crate::common::Reg<regs::Pseln, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsCh {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsCh {}
    unsafe impl Sync for EventsCh {}
    impl EventsCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Last results is equal or above CH\\[n\\].LIMIT.HIGH"]
        #[inline(always)]
        pub const fn limith(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Last results is equal or below CH\\[n\\].LIMIT.LOW"]
        #[inline(always)]
        pub const fn limitl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishCh {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishCh {}
    unsafe impl Sync for PublishCh {}
    impl PublishCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITH"]
        #[inline(always)]
        pub const fn limith(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITL"]
        #[inline(always)]
        pub const fn limitl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "RESULT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Result {
        ptr: *mut u8,
    }
    unsafe impl Send for Result {}
    unsafe impl Sync for Result {}
    impl Result {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of buffer bytes to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Analog to Digital Converter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Saadc {
        ptr: *mut u8,
    }
    unsafe impl Send for Saadc {}
    unsafe impl Sync for Saadc {}
    impl Saadc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the ADC and prepare the result buffer in RAM"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Take one ADC sample, if scan is enabled all channels are sampled. This task requires that SAADC has started, i.e. EVENTS_STARTED was set and EVENTS_STOPPED was not."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Stop the ADC and terminate any on-going conversion"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Starts offset auto-calibration"]
        #[inline(always)]
        pub const fn tasks_calibrateoffset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CALIBRATEOFFSET"]
        #[inline(always)]
        pub const fn subscribe_calibrateoffset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "The ADC has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "The ADC has filled up the Result buffer"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM."]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "A result is ready to get transferred to RAM."]
        #[inline(always)]
        pub const fn events_resultdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Calibration is complete"]
        #[inline(always)]
        pub const fn events_calibratedone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "The ADC has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_ch(self, n: usize) -> EventsCh {
            assert!(n < 8usize);
            unsafe { EventsCh::from_ptr(self.ptr.add(0x0118usize + n * 8usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event RESULTDONE"]
        #[inline(always)]
        pub const fn publish_resultdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event CALIBRATEDONE"]
        #[inline(always)]
        pub const fn publish_calibratedone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_ch(self, n: usize) -> PublishCh {
            assert!(n < 8usize);
            unsafe { PublishCh::from_ptr(self.ptr.add(0x0198usize + n * 8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trim(self) -> Trim {
            unsafe { Trim::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable or disable ADC"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> Ch {
            assert!(n < 8usize);
            unsafe { Ch::from_ptr(self.ptr.add(0x0510usize + n * 16usize) as _) }
        }
        #[doc = "Resolution configuration"]
        #[inline(always)]
        pub const fn resolution(self) -> crate::common::Reg<regs::Resolution, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f0usize) as _) }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[inline(always)]
        pub const fn oversample(self) -> crate::common::Reg<regs::Oversample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f4usize) as _) }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[inline(always)]
        pub const fn samplerate(self) -> crate::common::Reg<regs::Samplerate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f8usize) as _) }
        }
        #[doc = "RESULT EasyDMA channel"]
        #[inline(always)]
        pub const fn result(self) -> Result {
            unsafe { Result::from_ptr(self.ptr.add(0x0628usize) as _) }
        }
        #[doc = "Enable noise shaping"]
        #[inline(always)]
        pub const fn noiseshape(self) -> crate::common::Reg<regs::Noiseshape, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0654usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trim {
        ptr: *mut u8,
    }
    unsafe impl Send for Trim {}
    unsafe impl Sync for Trim {}
    impl Trim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[inline(always)]
        pub const fn lincalcoeff(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Lincalcoeff, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Amount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Gain control"]
            #[must_use]
            #[inline(always)]
            pub const fn gain(&self) -> super::vals::Gain {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Gain control"]
            #[inline(always)]
            pub const fn set_gain(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Enable burst mode"]
            #[must_use]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable burst mode"]
            #[inline(always)]
            pub const fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Reference control"]
            #[must_use]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference control"]
            #[inline(always)]
            pub const fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable differential mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::ConfigMode {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::ConfigMode::from_bits(val as u8)
            }
            #[doc = "Enable differential mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::ConfigMode) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[must_use]
            #[inline(always)]
            pub const fn tacq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[inline(always)]
            pub const fn set_tacq(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[must_use]
            #[inline(always)]
            pub const fn tconv(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x07;
                val as u8
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[inline(always)]
            pub const fn set_tconv(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("gain", &self.gain())
                    .field("burst", &self.burst())
                    .field("refsel", &self.refsel())
                    .field("mode", &self.mode())
                    .field("tacq", &self.tacq())
                    .field("tconv", &self.tconv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ gain: {:?}, burst: {=bool:?}, refsel: {:?}, mode: {:?}, tacq: {=u16:?}, tconv: {=u8:?} }}" , self . gain () , self . burst () , self . refsel () , self . mode () , self . tacq () , self . tconv ())
            }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Currentamount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Enable or disable ADC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable ADC"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable ADC"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[must_use]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn resultdone(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[inline(always)]
            pub const fn set_resultdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[must_use]
            #[inline(always)]
            pub const fn calibratedone(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[inline(always)]
            pub const fn set_calibratedone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimith(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[inline(always)]
            pub const fn set_chlimith(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[must_use]
            #[inline(always)]
            pub const fn chlimitl(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[inline(always)]
            pub const fn set_chlimitl(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("end", &self.end())
                    .field("done", &self.done())
                    .field("resultdone", &self.resultdone())
                    .field("calibratedone", &self.calibratedone())
                    .field("stopped", &self.stopped())
                    .field("chlimith[0]", &self.chlimith(0usize))
                    .field("chlimith[1]", &self.chlimith(1usize))
                    .field("chlimith[2]", &self.chlimith(2usize))
                    .field("chlimith[3]", &self.chlimith(3usize))
                    .field("chlimith[4]", &self.chlimith(4usize))
                    .field("chlimith[5]", &self.chlimith(5usize))
                    .field("chlimith[6]", &self.chlimith(6usize))
                    .field("chlimith[7]", &self.chlimith(7usize))
                    .field("chlimitl[0]", &self.chlimitl(0usize))
                    .field("chlimitl[1]", &self.chlimitl(1usize))
                    .field("chlimitl[2]", &self.chlimitl(2usize))
                    .field("chlimitl[3]", &self.chlimitl(3usize))
                    .field("chlimitl[4]", &self.chlimitl(4usize))
                    .field("chlimitl[5]", &self.chlimitl(5usize))
                    .field("chlimitl[6]", &self.chlimitl(6usize))
                    .field("chlimitl[7]", &self.chlimitl(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, end: {=bool:?}, done: {=bool:?}, resultdone: {=bool:?}, calibratedone: {=bool:?}, stopped: {=bool:?}, chlimith[0]: {=bool:?}, chlimith[1]: {=bool:?}, chlimith[2]: {=bool:?}, chlimith[3]: {=bool:?}, chlimith[4]: {=bool:?}, chlimith[5]: {=bool:?}, chlimith[6]: {=bool:?}, chlimith[7]: {=bool:?}, chlimitl[0]: {=bool:?}, chlimitl[1]: {=bool:?}, chlimitl[2]: {=bool:?}, chlimitl[3]: {=bool:?}, chlimitl[4]: {=bool:?}, chlimitl[5]: {=bool:?}, chlimitl[6]: {=bool:?}, chlimitl[7]: {=bool:?} }}" , self . started () , self . end () , self . done () , self . resultdone () , self . calibratedone () , self . stopped () , self . chlimith (0usize) , self . chlimith (1usize) , self . chlimith (2usize) , self . chlimith (3usize) , self . chlimith (4usize) , self . chlimith (5usize) , self . chlimith (6usize) , self . chlimith (7usize) , self . chlimitl (0usize) , self . chlimitl (1usize) , self . chlimitl (2usize) , self . chlimitl (3usize) , self . chlimitl (4usize) , self . chlimitl (5usize) , self . chlimitl (6usize) , self . chlimitl (7usize))
            }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "Low level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Low level limit"]
            #[inline(always)]
            pub const fn set_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "High level limit"]
            #[must_use]
            #[inline(always)]
            pub const fn high(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "High level limit"]
            #[inline(always)]
            pub const fn set_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("low", &self.low())
                    .field("high", &self.high())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Limit {{ low: {=u16:?}, high: {=u16:?} }}",
                    self.low(),
                    self.high()
                )
            }
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lincalcoeff(pub u32);
        impl Lincalcoeff {
            #[doc = "value"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "value"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Lincalcoeff {
            #[inline(always)]
            fn default() -> Lincalcoeff {
                Lincalcoeff(0)
            }
        }
        impl core::fmt::Debug for Lincalcoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lincalcoeff")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lincalcoeff {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lincalcoeff {{ val: {=u16:?} }}", self.val())
            }
        }
        #[doc = "Maximum number of buffer bytes to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of buffer bytes to transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum number of buffer bytes to transfer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Maxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Enable noise shaping"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Noiseshape(pub u32);
        impl Noiseshape {
            #[doc = "Enable noise shaping"]
            #[must_use]
            #[inline(always)]
            pub const fn noiseshape(&self) -> super::vals::Noiseshape {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Noiseshape::from_bits(val as u8)
            }
            #[doc = "Enable noise shaping"]
            #[inline(always)]
            pub const fn set_noiseshape(&mut self, val: super::vals::Noiseshape) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Noiseshape {
            #[inline(always)]
            fn default() -> Noiseshape {
                Noiseshape(0)
            }
        }
        impl core::fmt::Debug for Noiseshape {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Noiseshape")
                    .field("noiseshape", &self.noiseshape())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Noiseshape {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Noiseshape {{ noiseshape: {:?} }}", self.noiseshape())
            }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oversample(pub u32);
        impl Oversample {
            #[doc = "Oversample control"]
            #[must_use]
            #[inline(always)]
            pub const fn oversample(&self) -> super::vals::Oversample {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Oversample::from_bits(val as u8)
            }
            #[doc = "Oversample control"]
            #[inline(always)]
            pub const fn set_oversample(&mut self, val: super::vals::Oversample) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Oversample {
            #[inline(always)]
            fn default() -> Oversample {
                Oversample(0)
            }
        }
        impl core::fmt::Debug for Oversample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oversample")
                    .field("oversample", &self.oversample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oversample {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oversample {{ oversample: {:?} }}", self.oversample())
            }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pseln(pub u32);
        impl Pseln {
            #[doc = "GPIO pin selection."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselnConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselnConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::PselnConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pseln {
            #[inline(always)]
            fn default() -> Pseln {
                Pseln(0)
            }
        }
        impl core::fmt::Debug for Pseln {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pseln")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pseln {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pseln {{ pin: {=u8:?}, port: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.connect()
                )
            }
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pselp(pub u32);
        impl Pselp {
            #[doc = "GPIO pin selection."]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO port selection"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO port selection"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[must_use]
            #[inline(always)]
            pub const fn internal(&self) -> super::vals::Internal {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Internal::from_bits(val as u8)
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[inline(always)]
            pub const fn set_internal(&mut self, val: super::vals::Internal) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselpConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselpConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::PselpConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pselp {
            #[inline(always)]
            fn default() -> Pselp {
                Pselp(0)
            }
        }
        impl core::fmt::Debug for Pselp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pselp")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("internal", &self.internal())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pselp {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pselp {{ pin: {=u8:?}, port: {=u8:?}, internal: {:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.internal(),
                    self.connect()
                )
            }
        }
        #[doc = "Resolution configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resolution(pub u32);
        impl Resolution {
            #[doc = "Set the resolution"]
            #[must_use]
            #[inline(always)]
            pub const fn val(&self) -> super::vals::Val {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Val::from_bits(val as u8)
            }
            #[doc = "Set the resolution"]
            #[inline(always)]
            pub const fn set_val(&mut self, val: super::vals::Val) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Resolution {
            #[inline(always)]
            fn default() -> Resolution {
                Resolution(0)
            }
        }
        impl core::fmt::Debug for Resolution {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resolution")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resolution {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Resolution {{ val: {:?} }}", self.val())
            }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Samplerate(pub u32);
        impl Samplerate {
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[must_use]
            #[inline(always)]
            pub const fn cc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[inline(always)]
            pub const fn set_cc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Select mode for sample rate control"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::SamplerateMode {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::SamplerateMode::from_bits(val as u8)
            }
            #[doc = "Select mode for sample rate control"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::SamplerateMode) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Samplerate {
            #[inline(always)]
            fn default() -> Samplerate {
                Samplerate(0)
            }
        }
        impl core::fmt::Debug for Samplerate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Samplerate")
                    .field("cc", &self.cc())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Samplerate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Samplerate {{ cc: {=u16:?}, mode: {:?} }}",
                    self.cc(),
                    self.mode()
                )
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Status"]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "Status"]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Status {{ status: {:?} }}", self.status())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigMode {
            #[doc = "Single ended, PSELN will be ignored, negative input to ADC shorted to GND"]
            SE = 0x0,
            #[doc = "Differential"]
            DIFF = 0x01,
        }
        impl ConfigMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigMode {
            #[inline(always)]
            fn from(val: u8) -> ConfigMode {
                ConfigMode::from_bits(val)
            }
        }
        impl From<ConfigMode> for u8 {
            #[inline(always)]
            fn from(val: ConfigMode) -> u8 {
                ConfigMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain {
            #[doc = "2"]
            GAIN2 = 0x0,
            #[doc = "1"]
            GAIN1 = 0x01,
            #[doc = "2/3"]
            GAIN2_3 = 0x02,
            #[doc = "2/4"]
            GAIN2_4 = 0x03,
            #[doc = "2/5"]
            GAIN2_5 = 0x04,
            #[doc = "2/6"]
            GAIN2_6 = 0x05,
            #[doc = "2/7"]
            GAIN2_7 = 0x06,
            #[doc = "2/8"]
            GAIN2_8 = 0x07,
        }
        impl Gain {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Internal {
            #[doc = "Connected to the internal 0.9V analog supply rail"]
            AVDD = 0x0,
            #[doc = "Connected to the internal 0.9V digital supply rail"]
            DVDD = 0x01,
            #[doc = "Connected to VDD"]
            VDD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Internal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Internal {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Internal {
            #[inline(always)]
            fn from(val: u8) -> Internal {
                Internal::from_bits(val)
            }
        }
        impl From<Internal> for u8 {
            #[inline(always)]
            fn from(val: Internal) -> u8 {
                Internal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Noiseshape {
            #[doc = "Disable noiseshaping. Oversampling based on accumulate and average."]
            DISABLE = 0x0,
            #[doc = "Noiseshaping and decimating. Larger passband. Provides a 50kS/s cut off frequency, 8x the oversampling ratio. See design description for more information"]
            AUDIO = 0x01,
            #[doc = "Noiseshaping and decimating. Smaller passband. Recommended resolution setting is 14 bits. Provides a 5kS/s cut off frequency, 32x the oversampling ratio. See design description for more information"]
            ACCURACY = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Noiseshape {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Noiseshape {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Noiseshape {
            #[inline(always)]
            fn from(val: u8) -> Noiseshape {
                Noiseshape::from_bits(val)
            }
        }
        impl From<Noiseshape> for u8 {
            #[inline(always)]
            fn from(val: Noiseshape) -> u8 {
                Noiseshape::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oversample {
            #[doc = "Bypass oversampling"]
            BYPASS = 0x0,
            #[doc = "Oversample 2x"]
            OVER2X = 0x01,
            #[doc = "Oversample 4x"]
            OVER4X = 0x02,
            #[doc = "Oversample 8x"]
            OVER8X = 0x03,
            #[doc = "Oversample 16x"]
            OVER16X = 0x04,
            #[doc = "Oversample 32x"]
            OVER32X = 0x05,
            #[doc = "Oversample 64x"]
            OVER64X = 0x06,
            #[doc = "Oversample 128x"]
            OVER128X = 0x07,
            #[doc = "Oversample 256x"]
            OVER256X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Oversample {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oversample {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oversample {
            #[inline(always)]
            fn from(val: u8) -> Oversample {
                Oversample::from_bits(val)
            }
        }
        impl From<Oversample> for u8 {
            #[inline(always)]
            fn from(val: Oversample) -> u8 {
                Oversample::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselnConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselnConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselnConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselnConnect {
            #[inline(always)]
            fn from(val: u8) -> PselnConnect {
                PselnConnect::from_bits(val)
            }
        }
        impl From<PselnConnect> for u8 {
            #[inline(always)]
            fn from(val: PselnConnect) -> u8 {
                PselnConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselpConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            #[doc = "Selects internal inputs."]
            INTERNAL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselpConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselpConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselpConnect {
            #[inline(always)]
            fn from(val: u8) -> PselpConnect {
                PselpConnect::from_bits(val)
            }
        }
        impl From<PselpConnect> for u8 {
            #[inline(always)]
            fn from(val: PselpConnect) -> u8 {
                PselpConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "Internal reference (1.024 V)"]
            INTERNAL = 0x0,
            #[doc = "External reference given at PADC_EXT_REF_1V2"]
            EXTERNAL = 0x01,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SamplerateMode {
            #[doc = "Rate is controlled from SAMPLE task"]
            TASK = 0x0,
            #[doc = "Rate is controlled from local timer (use CC to control the rate)"]
            TIMERS = 0x01,
        }
        impl SamplerateMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SamplerateMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SamplerateMode {
            #[inline(always)]
            fn from(val: u8) -> SamplerateMode {
                SamplerateMode::from_bits(val)
            }
        }
        impl From<SamplerateMode> for u8 {
            #[inline(always)]
            fn from(val: SamplerateMode) -> u8 {
                SamplerateMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "ADC is ready. No on-going conversion."]
            READY = 0x0,
            #[doc = "ADC is busy. Single conversion in progress."]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Val {
            #[doc = "8 bit"]
            _8BIT = 0x0,
            #[doc = "10 bit"]
            _10BIT = 0x01,
            #[doc = "12 bit"]
            _12BIT = 0x02,
            #[doc = "14 bit"]
            _14BIT = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Val {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Val {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Val {
            #[inline(always)]
            fn from(val: u8) -> Val {
                Val::from_bits(val)
            }
        }
        impl From<Val> for u8 {
            #[inline(always)]
            fn from(val: Val) -> u8 {
                Val::to_bits(val)
            }
        }
    }
}
pub mod shared {
    pub mod regs {
        #[doc = "Pin select for LRCK signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Pin number"]
            #[must_use]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[must_use]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "Connection"]
            #[must_use]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn set_connect(&mut self, val: super::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Psel {{ pin: {=u8:?}, port: {=u8:?}, connect: {:?} }}",
                    self.pin(),
                    self.port(),
                    self.connect()
                )
            }
        }
        #[doc = "Publish configuration for event END"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Publish(pub u32);
        impl Publish {
            #[doc = "DPPI channel that event END will publish to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that event END will publish to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Publish {
            #[inline(always)]
            fn default() -> Publish {
                Publish(0)
            }
        }
        impl core::fmt::Debug for Publish {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Publish")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Publish {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Publish {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
        #[doc = "Subscribe configuration for task START"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Subscribe(pub u32);
        impl Subscribe {
            #[doc = "DPPI channel that task START will subscribe to"]
            #[must_use]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that task START will subscribe to"]
            #[inline(always)]
            pub const fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Subscribe {
            #[inline(always)]
            fn default() -> Subscribe {
                Subscribe(0)
            }
        }
        impl core::fmt::Debug for Subscribe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Subscribe")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Subscribe {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Subscribe {{ chidx: {=u8:?}, en: {=bool:?} }}",
                    self.chidx(),
                    self.en()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Connect {
            #[doc = "Connect"]
            CONNECTED = 0x0,
            #[doc = "Disconnect"]
            DISCONNECTED = 0x01,
        }
        impl Connect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Connect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Connect {
            #[inline(always)]
            fn from(val: u8) -> Connect {
                Connect::from_bits(val)
            }
        }
        impl From<Connect> for u8 {
            #[inline(always)]
            fn from(val: Connect) -> u8 {
                Connect::to_bits(val)
            }
        }
    }
}
pub mod sicr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Sicr {}
    unsafe impl Sync for Sicr {}
    impl Sicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
}
pub mod spim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iftiming {
        ptr: *mut u8,
    }
    unsafe impl Send for Iftiming {}
    unsafe impl Sync for Iftiming {}
    impl Iftiming {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Sample delay for input serial data on MISO"]
        #[inline(always)]
        pub const fn rxdelay(self) -> crate::common::Reg<regs::Rxdelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[inline(always)]
        pub const fn csndur(self) -> crate::common::Reg<regs::Csndur, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for DCX signal"]
        #[inline(always)]
        pub const fn dcx(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Pin select for CSN"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spim {
        ptr: *mut u8,
    }
    unsafe impl Send for Spim {}
    unsafe impl Sync for Spim {}
    impl Spim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start SPI transaction"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop SPI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend SPI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume SPI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "SPI transaction has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "SPI transaction has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "End of RXD buffer and TXD buffer reached"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable SPIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x052cusize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpimConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0554usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn iftiming(self) -> Iftiming {
            unsafe { Iftiming::from_ptr(self.ptr.add(0x05acusize) as _) }
        }
        #[doc = "DCX configuration"]
        #[inline(always)]
        pub const fn dcxcnt(self) -> crate::common::Reg<regs::Dcxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05b4usize) as _) }
        }
        #[doc = "Polarity of CSN output"]
        #[inline(always)]
        pub const fn csnpol(self) -> crate::common::Reg<regs::Csnpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05b8usize) as _) }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csndur(pub u32);
        impl Csndur {
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[must_use]
            #[inline(always)]
            pub const fn csndur(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[inline(always)]
            pub const fn set_csndur(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Csndur {
            #[inline(always)]
            fn default() -> Csndur {
                Csndur(0)
            }
        }
        impl core::fmt::Debug for Csndur {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csndur")
                    .field("csndur", &self.csndur())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csndur {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Csndur {{ csndur: {=u8:?} }}", self.csndur())
            }
        }
        #[doc = "Polarity of CSN output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csnpol(pub u32);
        impl Csnpol {
            #[doc = "Polarity of CSN output"]
            #[must_use]
            #[inline(always)]
            pub const fn csnpol_0(&self) -> super::vals::Csnpol0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csnpol0::from_bits(val as u8)
            }
            #[doc = "Polarity of CSN output"]
            #[inline(always)]
            pub const fn set_csnpol_0(&mut self, val: super::vals::Csnpol0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Csnpol {
            #[inline(always)]
            fn default() -> Csnpol {
                Csnpol(0)
            }
        }
        impl core::fmt::Debug for Csnpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csnpol")
                    .field("csnpol_0", &self.csnpol_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csnpol {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Csnpol {{ csnpol_0: {:?} }}", self.csnpol_0())
            }
        }
        #[doc = "DCX configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcxcnt(pub u32);
        impl Dcxcnt {
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[must_use]
            #[inline(always)]
            pub const fn dcxcnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[inline(always)]
            pub const fn set_dcxcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Dcxcnt {
            #[inline(always)]
            fn default() -> Dcxcnt {
                Dcxcnt(0)
            }
        }
        impl core::fmt::Debug for Dcxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcxcnt")
                    .field("dcxcnt", &self.dcxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dcxcnt {{ dcxcnt: {=u8:?} }}", self.dcxcnt())
            }
        }
        #[doc = "Enable SPIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[must_use]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch[0]", &self.dmarxmatch(0usize))
                    .field("dmarxmatch[1]", &self.dmarxmatch(1usize))
                    .field("dmarxmatch[2]", &self.dmarxmatch(2usize))
                    .field("dmarxmatch[3]", &self.dmarxmatch(3usize))
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ started: {=bool:?}, stopped: {=bool:?}, end: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch[0]: {=bool:?}, dmarxmatch[1]: {=bool:?}, dmarxmatch[2]: {=bool:?}, dmarxmatch[3]: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . started () , self . stopped () , self . end () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch (0usize) , self . dmarxmatch (1usize) , self . dmarxmatch (2usize) , self . dmarxmatch (3usize) , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Core clock to SCK divisor"]
            #[must_use]
            #[inline(always)]
            pub const fn divisor(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Core clock to SCK divisor"]
            #[inline(always)]
            pub const fn set_divisor(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("divisor", &self.divisor())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ divisor: {=u8:?} }}", self.divisor())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxList(pub u32);
        impl RxList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::RxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::RxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for RxList {
            #[inline(always)]
            fn default() -> RxList {
                RxList(0)
            }
        }
        impl core::fmt::Debug for RxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxList {{ type_: {:?} }}", self.type_())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Sample delay for input serial data on MISO"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxdelay(pub u32);
        impl Rxdelay {
            #[doc = "Sample delay for input serial data on MISO. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[must_use]
            #[inline(always)]
            pub const fn rxdelay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Sample delay for input serial data on MISO. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[inline(always)]
            pub const fn set_rxdelay(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxdelay {
            #[inline(always)]
            fn default() -> Rxdelay {
                Rxdelay(0)
            }
        }
        impl core::fmt::Debug for Rxdelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxdelay")
                    .field("rxdelay", &self.rxdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxdelay {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rxdelay {{ rxdelay: {=u8:?} }}", self.rxdelay())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task START"]
            #[must_use]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_start", &self.end_start())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ end_start: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . end_start () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpimConfig(pub u32);
        impl SpimConfig {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpimConfig {
            #[inline(always)]
            fn default() -> SpimConfig {
                SpimConfig(0)
            }
        }
        impl core::fmt::Debug for SpimConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpimConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpimConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpimConfig {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxList(pub u32);
        impl TxList {
            #[doc = "List type"]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::TxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::TxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::TxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for TxList {
            #[inline(always)]
            fn default() -> TxList {
                TxList(0)
            }
        }
        impl core::fmt::Debug for TxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxList {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxList {{ type_: {:?} }}", self.type_())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csnpol0 {
            #[doc = "Active low (idle state high)"]
            LOW = 0x0,
            #[doc = "Active high (idle state low)"]
            HIGH = 0x01,
        }
        impl Csnpol0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csnpol0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csnpol0 {
            #[inline(always)]
            fn from(val: u8) -> Csnpol0 {
                Csnpol0::from_bits(val)
            }
        }
        impl From<Csnpol0> for u8 {
            #[inline(always)]
            fn from(val: Csnpol0) -> u8 {
                Csnpol0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Enable SPIM"]
            ENABLED = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxListType {
            #[inline(always)]
            fn from(val: u8) -> RxListType {
                RxListType::from_bits(val)
            }
        }
        impl From<RxListType> for u8 {
            #[inline(always)]
            fn from(val: RxListType) -> u8 {
                RxListType::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl TxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxListType {
            #[inline(always)]
            fn from(val: u8) -> TxListType {
                TxListType::from_bits(val)
            }
        }
        impl From<TxListType> for u8 {
            #[inline(always)]
            fn from(val: TxListType) -> u8 {
                TxListType::to_bits(val)
            }
        }
    }
}
pub mod spis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for CSN signal"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "SPI Slave 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spis {
        ptr: *mut u8,
    }
    unsafe impl Send for Spis {}
    unsafe impl Sync for Spis {}
    impl Spis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Acquire SPI semaphore"]
        #[inline(always)]
        pub const fn tasks_acquire(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Release SPI semaphore, enabling the SPI slave to acquire it"]
        #[inline(always)]
        pub const fn tasks_release(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACQUIRE"]
        #[inline(always)]
        pub const fn subscribe_acquire(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task RELEASE"]
        #[inline(always)]
        pub const fn subscribe_release(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "Granted transaction completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Semaphore acquired"]
        #[inline(always)]
        pub const fn events_acquired(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACQUIRED"]
        #[inline(always)]
        pub const fn publish_acquired(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Semaphore status register"]
        #[inline(always)]
        pub const fn semstat(self) -> crate::common::Reg<regs::Semstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Status from last transaction"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable SPI slave"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0554usize) as _) }
        }
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[inline(always)]
        pub const fn def(self) -> crate::common::Reg<regs::Def, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x055cusize) as _) }
        }
        #[doc = "Over-read character"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Def(pub u32);
        impl Def {
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[must_use]
            #[inline(always)]
            pub const fn def(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[inline(always)]
            pub const fn set_def(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Def {
            #[inline(always)]
            fn default() -> Def {
                Def(0)
            }
        }
        impl core::fmt::Debug for Def {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Def").field("def", &self.def()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Def {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Def {{ def: {=u8:?} }}", self.def())
            }
        }
        #[doc = "Enable SPI slave"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPI slave"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPI slave"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[must_use]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[must_use]
            #[inline(always)]
            pub const fn acquired(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[inline(always)]
            pub const fn set_acquired(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("acquired", &self.acquired())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch[0]", &self.dmarxmatch(0usize))
                    .field("dmarxmatch[1]", &self.dmarxmatch(1usize))
                    .field("dmarxmatch[2]", &self.dmarxmatch(2usize))
                    .field("dmarxmatch[3]", &self.dmarxmatch(3usize))
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ end: {=bool:?}, acquired: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch[0]: {=bool:?}, dmarxmatch[1]: {=bool:?}, dmarxmatch[2]: {=bool:?}, dmarxmatch[3]: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . end () , self . acquired () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch (0usize) , self . dmarxmatch (1usize) , self . dmarxmatch (2usize) , self . dmarxmatch (3usize) , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Over-read character"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Semaphore status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semstat(pub u32);
        impl Semstat {
            #[doc = "Semaphore status"]
            #[must_use]
            #[inline(always)]
            pub const fn semstat(&self) -> super::vals::Semstat {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Semstat::from_bits(val as u8)
            }
            #[doc = "Semaphore status"]
            #[inline(always)]
            pub const fn set_semstat(&mut self, val: super::vals::Semstat) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Semstat {
            #[inline(always)]
            fn default() -> Semstat {
                Semstat(0)
            }
        }
        impl core::fmt::Debug for Semstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semstat")
                    .field("semstat", &self.semstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semstat {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Semstat {{ semstat: {:?} }}", self.semstat())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[must_use]
            #[inline(always)]
            pub const fn end_acquire(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[inline(always)]
            pub const fn set_end_acquire(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_acquire", &self.end_acquire())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ end_acquire: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . end_acquire () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpisConfig(pub u32);
        impl SpisConfig {
            #[doc = "Bit order"]
            #[must_use]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[must_use]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[must_use]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpisConfig {
            #[inline(always)]
            fn default() -> SpisConfig {
                SpisConfig(0)
            }
        }
        impl core::fmt::Debug for SpisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpisConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpisConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "SpisConfig {{ order: {:?}, cpha: {:?}, cpol: {:?} }}",
                    self.order(),
                    self.cpha(),
                    self.cpol()
                )
            }
        }
        #[doc = "Status from last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("overread", &self.overread())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Status {{ overread: {=bool:?}, overflow: {=bool:?} }}",
                    self.overread(),
                    self.overflow()
                )
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPI slave"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable SPI slave"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Semstat {
            #[doc = "Semaphore is free"]
            FREE = 0x0,
            #[doc = "Semaphore is assigned to CPU"]
            CPU = 0x01,
            #[doc = "Semaphore is assigned to SPI slave"]
            SPIS = 0x02,
            #[doc = "Semaphore is assigned to SPI but a handover to the CPU is pending"]
            CPUPENDING = 0x03,
        }
        impl Semstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Semstat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Semstat {
            #[inline(always)]
            fn from(val: u8) -> Semstat {
                Semstat::from_bits(val)
            }
        }
        impl From<Semstat> for u8 {
            #[inline(always)]
            fn from(val: Semstat) -> u8 {
                Semstat::to_bits(val)
            }
        }
    }
}
pub mod spu {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracen {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracen {}
    unsafe impl Sync for Cracen {}
    impl Cracen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration for CRACEN SEED"]
        #[inline(always)]
        pub const fn seed(self) -> crate::common::Reg<regs::Seed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for channel n of DPPIC"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::DppicCh, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Configuration of features for channel group n of DPPIC"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Feature {
        ptr: *mut u8,
    }
    unsafe impl Send for Feature {}
    unsafe impl Sync for Feature {}
    impl Feature {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dppic(self) -> Dppic {
            unsafe { Dppic::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpiote(self, n: usize) -> Gpiote {
            assert!(n < 2usize);
            unsafe { Gpiote::from_ptr(self.ptr.add(0x0100usize + n * 64usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cracen(self) -> Cracen {
            unsafe { Cracen::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpio(self, n: usize) -> Gpio {
            assert!(n < 3usize);
            unsafe { Gpio::from_ptr(self.ptr.add(0x0200usize + n * 128usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn grtc(self) -> Grtc {
            unsafe { Grtc::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for GPIO\\[n\\] PIN\\[o\\]"]
        #[inline(always)]
        pub const fn pin(self, n: usize) -> crate::common::Reg<regs::Pin, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for channel o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::GpioteCh, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Configuration of features for interrupt o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GpioteInterrupt, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for CC n of GRTC"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Configuration of feature for PWMCONFIG of GRTC"]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Configuration of features for CLKOUT/CLKCFG of GRTC"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<regs::Clk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Configuration of features for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[inline(always)]
        pub const fn syscounter(self) -> crate::common::Reg<regs::Syscounter, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Description collection: Configuration of features for interrupt n of GRTC"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GrtcInterrupt, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periph {
        ptr: *mut u8,
    }
    unsafe impl Send for Periph {}
    unsafe impl Sync for Periph {}
    impl Periph {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periphaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Periphaccerr {}
    unsafe impl Sync for Periphaccerr {}
    impl Periphaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the transaction that caused first error."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "System protection unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spu {
        ptr: *mut u8,
    }
    unsafe impl Send for Spu {}
    unsafe impl Sync for Spu {}
    impl Spu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A security violation has been detected on one or several peripherals"]
        #[inline(always)]
        pub const fn events_periphaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periphaccerr(self) -> Periphaccerr {
            unsafe { Periphaccerr::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periph(self, n: usize) -> Periph {
            assert!(n < 64usize);
            unsafe { Periph::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn feature(self) -> Feature {
            unsafe { Feature::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address of the transaction that caused first error."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u16:?} }}", self.address())
            }
        }
        #[doc = "Description collection: Configuration of features for CC n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Cc {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Configuration of features for channel group n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Chg {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Configuration of features for CLKOUT/CLKCFG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clk(pub u32);
        impl Clk {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Clk {
            #[inline(always)]
            fn default() -> Clk {
                Clk(0)
            }
        }
        impl core::fmt::Debug for Clk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clk")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clk {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Clk {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Configuration of features for channel n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DppicCh(pub u32);
        impl DppicCh {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for DppicCh {
            #[inline(always)]
            fn default() -> DppicCh {
                DppicCh(0)
            }
        }
        impl core::fmt::Debug for DppicCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DppicCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DppicCh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "DppicCh {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Configuration of features for channel o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteCh(pub u32);
        impl GpioteCh {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteCh {
            #[inline(always)]
            fn default() -> GpioteCh {
                GpioteCh(0)
            }
        }
        impl core::fmt::Debug for GpioteCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteCh {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioteCh {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Configuration of features for interrupt o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteInterrupt(pub u32);
        impl GpioteInterrupt {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteInterrupt {
            #[inline(always)]
            fn default() -> GpioteInterrupt {
                GpioteInterrupt(0)
            }
        }
        impl core::fmt::Debug for GpioteInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteInterrupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GpioteInterrupt {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Description collection: Configuration of features for interrupt n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GrtcInterrupt(pub u32);
        impl GrtcInterrupt {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GrtcInterrupt {
            #[inline(always)]
            fn default() -> GrtcInterrupt {
                GrtcInterrupt(0)
            }
        }
        impl core::fmt::Debug for GrtcInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GrtcInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GrtcInterrupt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GrtcInterrupt {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[must_use]
            #[inline(always)]
            pub const fn periphaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[inline(always)]
            pub const fn set_periphaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("periphaccerr", &self.periphaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ periphaccerr: {=bool:?} }}", self.periphaccerr())
            }
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[must_use]
            #[inline(always)]
            pub const fn securemapping(&self) -> super::vals::Securemapping {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Securemapping::from_bits(val as u8)
            }
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub const fn set_securemapping(&mut self, val: super::vals::Securemapping) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[must_use]
            #[inline(always)]
            pub const fn dma(&self) -> super::vals::Dma {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Dma::from_bits(val as u8)
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[inline(always)]
            pub const fn set_dma(&mut self, val: super::vals::Dma) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Peripheral security mapping"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn dmasec(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[inline(always)]
            pub const fn set_dmasec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Register lock"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Register lock"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[inline(always)]
            pub const fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("securemapping", &self.securemapping())
                    .field("dma", &self.dma())
                    .field("secattr", &self.secattr())
                    .field("dmasec", &self.dmasec())
                    .field("lock", &self.lock())
                    .field("present", &self.present())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Perm {{ securemapping: {:?}, dma: {:?}, secattr: {=bool:?}, dmasec: {=bool:?}, lock: {=bool:?}, present: {:?} }}" , self . securemapping () , self . dma () , self . secattr () , self . dmasec () , self . lock () , self . present ())
            }
        }
        #[doc = "Description collection: Configuration of features for GPIO\\[n\\] PIN\\[o\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pin(pub u32);
        impl Pin {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pin {
            #[inline(always)]
            fn default() -> Pin {
                Pin(0)
            }
        }
        impl core::fmt::Debug for Pin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pin")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pin {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Configuration of feature for PWMCONFIG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Pwmconfig {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Configuration for CRACEN SEED"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seed(pub u32);
        impl Seed {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Seed {
            #[inline(always)]
            fn default() -> Seed {
                Seed(0)
            }
        }
        impl core::fmt::Debug for Seed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seed")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seed {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Seed {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
        #[doc = "Configuration of features for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounter(pub u32);
        impl Syscounter {
            #[doc = "SECATTR feature"]
            #[must_use]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Syscounter {
            #[inline(always)]
            fn default() -> Syscounter {
                Syscounter(0)
            }
        }
        impl core::fmt::Debug for Syscounter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounter")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounter {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Syscounter {{ secattr: {=bool:?}, lock: {=bool:?} }}",
                    self.secattr(),
                    self.lock()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dma {
            #[doc = "Peripheral has no DMA capability"]
            NO_DMA = 0x0,
            #[doc = "Peripheral has DMA and DMA transfers always have the same security attribute as assigned to the peripheral"]
            NO_SEPARATE_ATTRIBUTE = 0x01,
            #[doc = "Peripheral has DMA and DMA transfers can have a different security attribute than the one assigned to the peripheral"]
            SEPARATE_ATTRIBUTE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dma {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dma {
            #[inline(always)]
            fn from(val: u8) -> Dma {
                Dma::from_bits(val)
            }
        }
        impl From<Dma> for u8 {
            #[inline(always)]
            fn from(val: Dma) -> u8 {
                Dma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "Peripheral is not present"]
            NOT_PRESENT = 0x0,
            #[doc = "Peripheral is present"]
            IS_PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Securemapping {
            #[doc = "This peripheral is always accessible as a non-secure peripheral"]
            NON_SECURE = 0x0,
            #[doc = "This peripheral is always accessible as a secure peripheral"]
            SECURE = 0x01,
            #[doc = "Non-secure or secure attribute for this peripheral is defined by the PERIPH\\[n\\].PERM register"]
            USER_SELECTABLE = 0x02,
            #[doc = "This peripheral implements the split security mechanism."]
            SPLIT = 0x03,
        }
        impl Securemapping {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Securemapping {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Securemapping {
            #[inline(always)]
            fn from(val: u8) -> Securemapping {
                Securemapping::from_bits(val)
            }
        }
        impl From<Securemapping> for u8 {
            #[inline(always)]
            fn from(val: Securemapping) -> u8 {
                Securemapping::to_bits(val)
            }
        }
    }
}
pub mod swi {
    #[doc = "Software interrupt 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Swi {
        ptr: *mut u8,
    }
    unsafe impl Send for Swi {}
    unsafe impl Sync for Swi {}
    impl Swi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
}
pub mod tad {
    #[doc = "Trace and debug control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tad {
        ptr: *mut u8,
    }
    unsafe impl Send for Tad {}
    unsafe impl Sync for Tad {}
    impl Tad {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System power-up request"]
        #[inline(always)]
        pub const fn syspwrupreq(self) -> crate::common::Reg<regs::Syspwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Debug power-up request"]
        #[inline(always)]
        pub const fn dbgpwrupreq(self) -> crate::common::Reg<regs::Dbgpwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Trace port speed"]
        #[inline(always)]
        pub const fn traceportspeed(
            self,
        ) -> crate::common::Reg<regs::Traceportspeed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "SW-DP Target instance"]
        #[inline(always)]
        pub const fn tinstance(self) -> crate::common::Reg<regs::Tinstance, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgpwrupreq(pub u32);
        impl Dbgpwrupreq {
            #[doc = "Activate power-up request"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbgpwrupreq {
            #[inline(always)]
            fn default() -> Dbgpwrupreq {
                Dbgpwrupreq(0)
            }
        }
        impl core::fmt::Debug for Dbgpwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgpwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgpwrupreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Dbgpwrupreq {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {=bool:?} }}", self.enable())
            }
        }
        #[doc = "System power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syspwrupreq(pub u32);
        impl Syspwrupreq {
            #[doc = "Activate power-up request"]
            #[must_use]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Syspwrupreq {
            #[inline(always)]
            fn default() -> Syspwrupreq {
                Syspwrupreq(0)
            }
        }
        impl core::fmt::Debug for Syspwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syspwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syspwrupreq {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Syspwrupreq {{ active: {=bool:?} }}", self.active())
            }
        }
        #[doc = "SW-DP Target instance"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tinstance(pub u32);
        impl Tinstance {
            #[doc = "TINSTANCE bits are used in the SW-DP DLPIDR.TINSTANCE field."]
            #[must_use]
            #[inline(always)]
            pub const fn tinstance(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "TINSTANCE bits are used in the SW-DP DLPIDR.TINSTANCE field."]
            #[inline(always)]
            pub const fn set_tinstance(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Tinstance {
            #[inline(always)]
            fn default() -> Tinstance {
                Tinstance(0)
            }
        }
        impl core::fmt::Debug for Tinstance {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tinstance")
                    .field("tinstance", &self.tinstance())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tinstance {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tinstance {{ tinstance: {=u8:?} }}", self.tinstance())
            }
        }
        #[doc = "Trace port speed"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Traceportspeed(pub u32);
        impl Traceportspeed {
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[must_use]
            #[inline(always)]
            pub const fn traceportspeed(&self) -> super::vals::Traceportspeed {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Traceportspeed::from_bits(val as u8)
            }
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[inline(always)]
            pub const fn set_traceportspeed(&mut self, val: super::vals::Traceportspeed) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Traceportspeed {
            #[inline(always)]
            fn default() -> Traceportspeed {
                Traceportspeed(0)
            }
        }
        impl core::fmt::Debug for Traceportspeed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Traceportspeed")
                    .field("traceportspeed", &self.traceportspeed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Traceportspeed {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Traceportspeed {{ traceportspeed: {:?} }}",
                    self.traceportspeed()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Traceportspeed {
            #[doc = "Trace port speed equals CPU clock"]
            DIV1 = 0x0,
            #[doc = "Trace port speed equals CPU clock divided by 2"]
            DIV2 = 0x01,
            #[doc = "Trace port speed equals CPU clock divided by 4"]
            DIV4 = 0x02,
            #[doc = "Trace port speed equals CPU clock divided by 32"]
            DIV32 = 0x03,
        }
        impl Traceportspeed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Traceportspeed {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Traceportspeed {
            #[inline(always)]
            fn from(val: u8) -> Traceportspeed {
                Traceportspeed::from_bits(val)
            }
        }
        impl From<Traceportspeed> for u8 {
            #[inline(always)]
            fn from(val: Traceportspeed) -> u8 {
                Traceportspeed::to_bits(val)
            }
        }
    }
}
pub mod tampc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ap {
        ptr: *mut u8,
    }
    unsafe impl Send for Ap {}
    unsafe impl Sync for Ap {}
    impl Ap {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> ApDbgen {
            unsafe { ApDbgen::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ApDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for ApDbgen {}
    unsafe impl Sync for ApDbgen {}
    impl ApDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain n's access port."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ApDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n's access port."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ApDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable tamper detector from CRACEN."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracentamp {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracentamp {}
    unsafe impl Sync for Cracentamp {}
    impl Cracentamp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::CracentampCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::CracentampStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Domain {
        ptr: *mut u8,
    }
    unsafe impl Send for Domain {}
    unsafe impl Sync for Domain {}
    impl Domain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> DomainDbgen {
            unsafe { DomainDbgen::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn niden(self) -> Niden {
            unsafe { Niden::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spiden(self) -> Spiden {
            unsafe { Spiden::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spniden(self) -> Spniden {
            unsafe { Spniden::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DomainDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for DomainDbgen {}
    unsafe impl Sync for DomainDbgen {}
    impl DomainDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::DomainDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::DomainDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Device erase protection."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for erase protection."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::EraseprotectCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for eraseprotect."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::EraseprotectStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Extreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Extreseten {}
    unsafe impl Sync for Extreseten {}
    impl Extreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ExtresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ExtresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable fast domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchfastdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchfastdomain {}
    unsafe impl Sync for Glitchfastdomain {}
    impl Glitchfastdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable slow domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchslowdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchslowdomain {}
    unsafe impl Sync for Glitchslowdomain {}
    impl Glitchslowdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Intreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Intreseten {}
    unsafe impl Sync for Intreseten {}
    impl Intreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::IntresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IntresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Niden {
        ptr: *mut u8,
    }
    unsafe impl Send for Niden {}
    unsafe impl Sync for Niden {}
    impl Niden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::NidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::NidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Protect {
        ptr: *mut u8,
    }
    unsafe impl Send for Protect {}
    unsafe impl Sync for Protect {}
    impl Protect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn domain(self, n: usize) -> Domain {
            assert!(n < 1usize);
            unsafe { Domain::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ap(self, n: usize) -> Ap {
            assert!(n < 1usize);
            unsafe { Ap::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Enable active shield detector."]
        #[inline(always)]
        pub const fn activeshield(self) -> ProtectActiveshield {
            unsafe { ProtectActiveshield::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable tamper detector from CRACEN."]
        #[inline(always)]
        pub const fn cracentamp(self) -> Cracentamp {
            unsafe { Cracentamp::from_ptr(self.ptr.add(0x0438usize) as _) }
        }
        #[doc = "Enable slow domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchslowdomain(self) -> Glitchslowdomain {
            unsafe { Glitchslowdomain::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable fast domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchfastdomain(self) -> Glitchfastdomain {
            unsafe { Glitchfastdomain::from_ptr(self.ptr.add(0x0448usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
        #[inline(always)]
        pub const fn extreseten(self) -> Extreseten {
            unsafe { Extreseten::from_ptr(self.ptr.add(0x0470usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
        #[inline(always)]
        pub const fn intreseten(self) -> Intreseten {
            unsafe { Intreseten::from_ptr(self.ptr.add(0x0478usize) as _) }
        }
        #[doc = "Device erase protection."]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
    }
    #[doc = "Enable active shield detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ProtectActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for ProtectActiveshield {}
    unsafe impl Sync for ProtectActiveshield {}
    impl ProtectActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ActiveshieldCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::ActiveshieldStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spiden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spiden {}
    unsafe impl Sync for Spiden {}
    impl Spiden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spniden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spniden {}
    unsafe impl Sync for Spniden {}
    impl Spniden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpnidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpnidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Tamper controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tampc {
        ptr: *mut u8,
    }
    unsafe impl Send for Tampc {}
    unsafe impl Sync for Tampc {}
    impl Tampc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Tamper controller detected an error."]
        #[inline(always)]
        pub const fn events_tamper(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Attempt to write a VALUE in PROTECT registers without clearing the WRITEPROTECT."]
        #[inline(always)]
        pub const fn events_writeerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "The tamper controller status."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::TampcStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn activeshield(self) -> TampcActiveshield {
            unsafe { TampcActiveshield::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn protect(self) -> Protect {
            unsafe { Protect::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TampcActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for TampcActiveshield {}
    unsafe impl Sync for TampcActiveshield {}
    impl TampcActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Active shield detector channel enable register."]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldCtrl(pub u32);
        impl ActiveshieldCtrl {
            #[doc = "Set value of active shield enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ActiveshieldCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ActiveshieldCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of active shield enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ActiveshieldCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ActiveshieldCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ActiveshieldCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ActiveshieldCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ActiveshieldCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ActiveshieldCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ActiveshieldCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ActiveshieldCtrl {
            #[inline(always)]
            fn default() -> ActiveshieldCtrl {
                ActiveshieldCtrl(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ActiveshieldCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldStatus(pub u32);
        impl ActiveshieldStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ActiveshieldStatus {
            #[inline(always)]
            fn default() -> ActiveshieldStatus {
                ActiveshieldStatus(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ActiveshieldStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain n's access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenCtrl(pub u32);
        impl ApDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ApDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ApDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ApDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ApDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ApDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ApDbgenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ApDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ApDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ApDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ApDbgenCtrl {
            #[inline(always)]
            fn default() -> ApDbgenCtrl {
                ApDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for ApDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ApDbgenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n's access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenStatus(pub u32);
        impl ApDbgenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ApDbgenStatus {
            #[inline(always)]
            fn default() -> ApDbgenStatus {
                ApDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for ApDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApDbgenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Active shield detector channel enable register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable active shield channel 0."]
            #[must_use]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable active shield channel 0."]
            #[inline(always)]
            pub const fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field("ch[0]", &self.ch(0usize))
                    .field("ch[1]", &self.ch(1usize))
                    .field("ch[2]", &self.ch(2usize))
                    .field("ch[3]", &self.ch(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Chen {{ ch[0]: {=bool:?}, ch[1]: {=bool:?}, ch[2]: {=bool:?}, ch[3]: {=bool:?} }}" , self . ch (0usize) , self . ch (1usize) , self . ch (2usize) , self . ch (3usize))
            }
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampCtrl(pub u32);
        impl CracentampCtrl {
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::CracentampCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CracentampCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::CracentampCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::CracentampCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::CracentampCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::CracentampCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::CracentampCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::CracentampCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::CracentampCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CracentampCtrl {
            #[inline(always)]
            fn default() -> CracentampCtrl {
                CracentampCtrl(0)
            }
        }
        impl core::fmt::Debug for CracentampCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "CracentampCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampStatus(pub u32);
        impl CracentampStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CracentampStatus {
            #[inline(always)]
            fn default() -> CracentampStatus {
                CracentampStatus(0)
            }
        }
        impl core::fmt::Debug for CracentampStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "CracentampStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenCtrl(pub u32);
        impl DomainDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::DomainDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DomainDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::DomainDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::DomainDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::DomainDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::DomainDbgenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::DomainDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::DomainDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::DomainDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for DomainDbgenCtrl {
            #[inline(always)]
            fn default() -> DomainDbgenCtrl {
                DomainDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "DomainDbgenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenStatus(pub u32);
        impl DomainDbgenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DomainDbgenStatus {
            #[inline(always)]
            fn default() -> DomainDbgenStatus {
                DomainDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "DomainDbgenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for erase protection."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectCtrl(pub u32);
        impl EraseprotectCtrl {
            #[doc = "Set value of eraseprotect signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::EraseprotectCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EraseprotectCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of eraseprotect signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::EraseprotectCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::EraseprotectCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::EraseprotectCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::EraseprotectCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::EraseprotectCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::EraseprotectCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::EraseprotectCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for EraseprotectCtrl {
            #[inline(always)]
            fn default() -> EraseprotectCtrl {
                EraseprotectCtrl(0)
            }
        }
        impl core::fmt::Debug for EraseprotectCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "EraseprotectCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for eraseprotect."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectStatus(pub u32);
        impl EraseprotectStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EraseprotectStatus {
            #[inline(always)]
            fn default() -> EraseprotectStatus {
                EraseprotectStatus(0)
            }
        }
        impl core::fmt::Debug for EraseprotectStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenCtrl(pub u32);
        impl ExtresetenCtrl {
            #[doc = "Set value of external tamper reset enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ExtresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ExtresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of external tamper reset enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::ExtresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ExtresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ExtresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::ExtresetenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ExtresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ExtresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::ExtresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ExtresetenCtrl {
            #[inline(always)]
            fn default() -> ExtresetenCtrl {
                ExtresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for ExtresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "ExtresetenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenStatus(pub u32);
        impl ExtresetenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ExtresetenStatus {
            #[inline(always)]
            fn default() -> ExtresetenStatus {
                ExtresetenStatus(0)
            }
        }
        impl core::fmt::Debug for ExtresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ExtresetenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainCtrl(pub u32);
        impl GlitchfastdomainCtrl {
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchfastdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchfastdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::GlitchfastdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchfastdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchfastdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchfastdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchfastdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchfastdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::GlitchfastdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchfastdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchfastdomainCtrl {
                GlitchfastdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GlitchfastdomainCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainStatus(pub u32);
        impl GlitchfastdomainStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchfastdomainStatus {
            #[inline(always)]
            fn default() -> GlitchfastdomainStatus {
                GlitchfastdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlitchfastdomainStatus {{ error: {=bool:?} }}",
                    self.error()
                )
            }
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainCtrl(pub u32);
        impl GlitchslowdomainCtrl {
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchslowdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchslowdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::GlitchslowdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchslowdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchslowdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchslowdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchslowdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchslowdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::GlitchslowdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchslowdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchslowdomainCtrl {
                GlitchslowdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "GlitchslowdomainCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainStatus(pub u32);
        impl GlitchslowdomainStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchslowdomainStatus {
            #[inline(always)]
            fn default() -> GlitchslowdomainStatus {
                GlitchslowdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "GlitchslowdomainStatus {{ error: {=bool:?} }}",
                    self.error()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[must_use]
            #[inline(always)]
            pub const fn tamper(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[inline(always)]
            pub const fn set_tamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn writeerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[inline(always)]
            pub const fn set_writeerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tamper", &self.tamper())
                    .field("writeerror", &self.writeerror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ tamper: {=bool:?}, writeerror: {=bool:?} }}",
                    self.tamper(),
                    self.writeerror()
                )
            }
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenCtrl(pub u32);
        impl IntresetenCtrl {
            #[doc = "Set value of internal tamper reset enable signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::IntresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IntresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of internal tamper reset enable signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::IntresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::IntresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::IntresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::IntresetenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::IntresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::IntresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::IntresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for IntresetenCtrl {
            #[inline(always)]
            fn default() -> IntresetenCtrl {
                IntresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for IntresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "IntresetenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenStatus(pub u32);
        impl IntresetenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IntresetenStatus {
            #[inline(always)]
            fn default() -> IntresetenStatus {
                IntresetenStatus(0)
            }
        }
        impl core::fmt::Debug for IntresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "IntresetenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenCtrl(pub u32);
        impl NidenCtrl {
            #[doc = "Set value of niden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::NidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::NidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of niden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::NidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::NidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::NidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::NidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::NidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::NidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::NidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for NidenCtrl {
            #[inline(always)]
            fn default() -> NidenCtrl {
                NidenCtrl(0)
            }
        }
        impl core::fmt::Debug for NidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "NidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenStatus(pub u32);
        impl NidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for NidenStatus {
            #[inline(always)]
            fn default() -> NidenStatus {
                NidenStatus(0)
            }
        }
        impl core::fmt::Debug for NidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "NidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenCtrl(pub u32);
        impl SpidenCtrl {
            #[doc = "Set value of spiden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spiden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::SpidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::SpidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::SpidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpidenCtrl {
            #[inline(always)]
            fn default() -> SpidenCtrl {
                SpidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenStatus(pub u32);
        impl SpidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpidenStatus {
            #[inline(always)]
            fn default() -> SpidenStatus {
                SpidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenCtrl(pub u32);
        impl SpnidenCtrl {
            #[doc = "Set value of spniden signal."]
            #[must_use]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpnidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpnidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spniden signal."]
            #[inline(always)]
            pub const fn set_value(&mut self, val: super::vals::SpnidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[must_use]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpnidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpnidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn set_writeprotection(
                &mut self,
                val: super::vals::SpnidenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[must_use]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpnidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpnidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn set_key(&mut self, val: super::vals::SpnidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpnidenCtrl {
            #[inline(always)]
            fn default() -> SpnidenCtrl {
                SpnidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpnidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "SpnidenCtrl {{ value: {:?}, lock: {=bool:?}, writeprotection: {:?}, key: {:?} }}" , self . value () , self . lock () , self . writeprotection () , self . key ())
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenStatus(pub u32);
        impl SpnidenStatus {
            #[doc = "Error detection status."]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpnidenStatus {
            #[inline(always)]
            fn default() -> SpnidenStatus {
                SpnidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpnidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SpnidenStatus {{ error: {=bool:?} }}", self.error())
            }
        }
        #[doc = "The tamper controller status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TampcStatus(pub u32);
        impl TampcStatus {
            #[doc = "Active shield detector detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn activeshield(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Active shield detector detected an error."]
            #[inline(always)]
            pub const fn set_activeshield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error detected for the protected signals."]
            #[must_use]
            #[inline(always)]
            pub const fn protect(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Error detected for the protected signals."]
            #[inline(always)]
            pub const fn set_protect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CRACEN detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn cracentamp(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CRACEN detected an error."]
            #[inline(always)]
            pub const fn set_cracentamp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn glitchslowdomain(&self, n: usize) -> bool {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn set_glitchslowdomain(&mut self, n: usize, val: bool) {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[must_use]
            #[inline(always)]
            pub const fn glitchfastdomain(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn set_glitchfastdomain(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for TampcStatus {
            #[inline(always)]
            fn default() -> TampcStatus {
                TampcStatus(0)
            }
        }
        impl core::fmt::Debug for TampcStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TampcStatus")
                    .field("activeshield", &self.activeshield())
                    .field("protect", &self.protect())
                    .field("cracentamp", &self.cracentamp())
                    .field("glitchslowdomain[0]", &self.glitchslowdomain(0usize))
                    .field("glitchfastdomain[0]", &self.glitchfastdomain(0usize))
                    .field("glitchfastdomain[1]", &self.glitchfastdomain(1usize))
                    .field("glitchfastdomain[2]", &self.glitchfastdomain(2usize))
                    .field("glitchfastdomain[3]", &self.glitchfastdomain(3usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TampcStatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "TampcStatus {{ activeshield: {=bool:?}, protect: {=bool:?}, cracentamp: {=bool:?}, glitchslowdomain[0]: {=bool:?}, glitchfastdomain[0]: {=bool:?}, glitchfastdomain[1]: {=bool:?}, glitchfastdomain[2]: {=bool:?}, glitchfastdomain[3]: {=bool:?} }}" , self . activeshield () , self . protect () , self . cracentamp () , self . glitchslowdomain (0usize) , self . glitchfastdomain (0usize) , self . glitchfastdomain (1usize) , self . glitchfastdomain (2usize) , self . glitchfastdomain (3usize))
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ActiveshieldCtrlKey(u16);
        impl ActiveshieldCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ActiveshieldCtrlKey {
            pub const fn from_bits(val: u16) -> ActiveshieldCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ActiveshieldCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ActiveshieldCtrlKey {
                ActiveshieldCtrlKey::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlKey) -> u16 {
                ActiveshieldCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ActiveshieldCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlValue {
                ActiveshieldCtrlValue::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlValue) -> u8 {
                ActiveshieldCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlWriteprotection {
                ActiveshieldCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlWriteprotection) -> u8 {
                ActiveshieldCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApDbgenCtrlKey(u16);
        impl ApDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ApDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> ApDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ApDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ApDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ApDbgenCtrlKey {
                ApDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlKey) -> u16 {
                ApDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ApDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlValue {
                ApDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlValue) -> u8 {
                ApDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ApDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlWriteprotection {
                ApDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlWriteprotection) -> u8 {
                ApDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct CracentampCtrlKey(u16);
        impl CracentampCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl CracentampCtrlKey {
            pub const fn from_bits(val: u16) -> CracentampCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for CracentampCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for CracentampCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> CracentampCtrlKey {
                CracentampCtrlKey::from_bits(val)
            }
        }
        impl From<CracentampCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: CracentampCtrlKey) -> u16 {
                CracentampCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl CracentampCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlValue {
                CracentampCtrlValue::from_bits(val)
            }
        }
        impl From<CracentampCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlValue) -> u8 {
                CracentampCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl CracentampCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlWriteprotection {
                CracentampCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<CracentampCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlWriteprotection) -> u8 {
                CracentampCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct DomainDbgenCtrlKey(u16);
        impl DomainDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl DomainDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> DomainDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for DomainDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> DomainDbgenCtrlKey {
                DomainDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlKey) -> u16 {
                DomainDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl DomainDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlValue {
                DomainDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlValue) -> u8 {
                DomainDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlWriteprotection {
                DomainDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlWriteprotection) -> u8 {
                DomainDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectCtrlKey(u16);
        impl EraseprotectCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl EraseprotectCtrlKey {
            pub const fn from_bits(val: u16) -> EraseprotectCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for EraseprotectCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> EraseprotectCtrlKey {
                EraseprotectCtrlKey::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlKey) -> u16 {
                EraseprotectCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl EraseprotectCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlValue {
                EraseprotectCtrlValue::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlValue) -> u8 {
                EraseprotectCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl EraseprotectCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlWriteprotection {
                EraseprotectCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlWriteprotection) -> u8 {
                EraseprotectCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ExtresetenCtrlKey(u16);
        impl ExtresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ExtresetenCtrlKey {
            pub const fn from_bits(val: u16) -> ExtresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ExtresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ExtresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ExtresetenCtrlKey {
                ExtresetenCtrlKey::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlKey) -> u16 {
                ExtresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ExtresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlValue {
                ExtresetenCtrlValue::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlValue) -> u8 {
                ExtresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ExtresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlWriteprotection {
                ExtresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlWriteprotection) -> u8 {
                ExtresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchfastdomainCtrlKey(u16);
        impl GlitchfastdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchfastdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchfastdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchfastdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchfastdomainCtrlKey {
                GlitchfastdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlKey) -> u16 {
                GlitchfastdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchfastdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlValue {
                GlitchfastdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlValue) -> u8 {
                GlitchfastdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                GlitchfastdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlWriteprotection) -> u8 {
                GlitchfastdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchslowdomainCtrlKey(u16);
        impl GlitchslowdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchslowdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchslowdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchslowdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchslowdomainCtrlKey {
                GlitchslowdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlKey) -> u16 {
                GlitchslowdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchslowdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlValue {
                GlitchslowdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlValue) -> u8 {
                GlitchslowdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                GlitchslowdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlWriteprotection) -> u8 {
                GlitchslowdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct IntresetenCtrlKey(u16);
        impl IntresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl IntresetenCtrlKey {
            pub const fn from_bits(val: u16) -> IntresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for IntresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for IntresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> IntresetenCtrlKey {
                IntresetenCtrlKey::from_bits(val)
            }
        }
        impl From<IntresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: IntresetenCtrlKey) -> u16 {
                IntresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl IntresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlValue {
                IntresetenCtrlValue::from_bits(val)
            }
        }
        impl From<IntresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlValue) -> u8 {
                IntresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl IntresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlWriteprotection {
                IntresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<IntresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlWriteprotection) -> u8 {
                IntresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct NidenCtrlKey(u16);
        impl NidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl NidenCtrlKey {
            pub const fn from_bits(val: u16) -> NidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for NidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for NidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> NidenCtrlKey {
                NidenCtrlKey::from_bits(val)
            }
        }
        impl From<NidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: NidenCtrlKey) -> u16 {
                NidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl NidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlValue {
                NidenCtrlValue::from_bits(val)
            }
        }
        impl From<NidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlValue) -> u8 {
                NidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl NidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlWriteprotection {
                NidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<NidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlWriteprotection) -> u8 {
                NidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpidenCtrlKey(u16);
        impl SpidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpidenCtrlKey {
                SpidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpidenCtrlKey) -> u16 {
                SpidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl SpidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlValue {
                SpidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlValue) -> u8 {
                SpidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlWriteprotection {
                SpidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlWriteprotection) -> u8 {
                SpidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpnidenCtrlKey(u16);
        impl SpnidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpnidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpnidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpnidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpnidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpnidenCtrlKey {
                SpnidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpnidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpnidenCtrlKey) -> u16 {
                SpnidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl SpnidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlValue {
                SpnidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpnidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlValue) -> u8 {
                SpnidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpnidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlWriteprotection {
                SpnidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpnidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlWriteprotection) -> u8 {
                SpnidenCtrlWriteprotection::to_bits(val)
            }
        }
    }
}
pub mod temp {
    #[doc = "Temperature Sensor 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Temp {
        ptr: *mut u8,
    }
    unsafe impl Send for Temp {}
    unsafe impl Sync for Temp {}
    impl Temp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start temperature measurement"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop temperature measurement"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Temperature measurement complete, data ready"]
        #[inline(always)]
        pub const fn events_datardy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Publish configuration for event DATARDY"]
        #[inline(always)]
        pub const fn publish_datardy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Temperature in degC (0.25deg steps)"]
        #[inline(always)]
        pub const fn temp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Slope of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn a(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize + n * 4usize) as _) }
        }
        #[doc = "y-intercept of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn b(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
        #[doc = "End point of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn t(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0560usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[must_use]
            #[inline(always)]
            pub const fn datardy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[inline(always)]
            pub const fn set_datardy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("datardy", &self.datardy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Int {{ datardy: {=bool:?} }}", self.datardy())
            }
        }
    }
}
pub mod timer {
    #[doc = "Timer/Counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer {}
    unsafe impl Sync for Timer {}
    impl Timer {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start Timer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop Timer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Increment Timer (Counter mode only)"]
        #[inline(always)]
        pub const fn tasks_count(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Clear time"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Deprecated register - Shut down timer"]
        #[inline(always)]
        pub const fn tasks_shutdown(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description collection: Capture Timer value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task COUNT"]
        #[inline(always)]
        pub const fn subscribe_count(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Deprecated register - Subscribe configuration for task SHUTDOWN"]
        #[inline(always)]
        pub const fn subscribe_shutdown(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Timer mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Configure the number of bits used by the TIMER"]
        #[inline(always)]
        pub const fn bitmode(self) -> crate::common::Reg<regs::Bitmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Timer prescaler register"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Description collection: Capture/Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[inline(always)]
        pub const fn oneshoten(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Oneshoten, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0580usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configure the number of bits used by the TIMER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bitmode(pub u32);
        impl Bitmode {
            #[doc = "Timer bit width"]
            #[must_use]
            #[inline(always)]
            pub const fn bitmode(&self) -> super::vals::Bitmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bitmode::from_bits(val as u8)
            }
            #[doc = "Timer bit width"]
            #[inline(always)]
            pub const fn set_bitmode(&mut self, val: super::vals::Bitmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Bitmode {
            #[inline(always)]
            fn default() -> Bitmode {
                Bitmode(0)
            }
        }
        impl core::fmt::Debug for Bitmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bitmode")
                    .field("bitmode", &self.bitmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bitmode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Bitmode {{ bitmode: {:?} }}", self.bitmode())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare[0]", &self.compare(0usize))
                    .field("compare[1]", &self.compare(1usize))
                    .field("compare[2]", &self.compare(2usize))
                    .field("compare[3]", &self.compare(3usize))
                    .field("compare[4]", &self.compare(4usize))
                    .field("compare[5]", &self.compare(5usize))
                    .field("compare[6]", &self.compare(6usize))
                    .field("compare[7]", &self.compare(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ compare[0]: {=bool:?}, compare[1]: {=bool:?}, compare[2]: {=bool:?}, compare[3]: {=bool:?}, compare[4]: {=bool:?}, compare[5]: {=bool:?}, compare[6]: {=bool:?}, compare[7]: {=bool:?} }}" , self . compare (0usize) , self . compare (1usize) , self . compare (2usize) , self . compare (3usize) , self . compare (4usize) , self . compare (5usize) , self . compare (6usize) , self . compare (7usize))
            }
        }
        #[doc = "Timer mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Timer mode"]
            #[must_use]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Timer mode"]
            #[inline(always)]
            pub const fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Mode {{ mode: {:?} }}", self.mode())
            }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oneshoten(pub u32);
        impl Oneshoten {
            #[doc = "Enable one-shot operation"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshoten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable one-shot operation"]
            #[inline(always)]
            pub const fn set_oneshoten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Oneshoten {
            #[inline(always)]
            fn default() -> Oneshoten {
                Oneshoten(0)
            }
        }
        impl core::fmt::Debug for Oneshoten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oneshoten")
                    .field("oneshoten", &self.oneshoten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oneshoten {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Oneshoten {{ oneshoten: {=bool:?} }}", self.oneshoten())
            }
        }
        #[doc = "Timer prescaler register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[must_use]
            #[inline(always)]
            pub const fn prescaler(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn set_prescaler(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Prescaler {{ prescaler: {=u8:?} }}", self.prescaler())
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_clear(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn set_compare_clear(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn compare_stop(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[inline(always)]
            pub const fn set_compare_stop(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("compare_clear[0]", &self.compare_clear(0usize))
                    .field("compare_clear[1]", &self.compare_clear(1usize))
                    .field("compare_clear[2]", &self.compare_clear(2usize))
                    .field("compare_clear[3]", &self.compare_clear(3usize))
                    .field("compare_clear[4]", &self.compare_clear(4usize))
                    .field("compare_clear[5]", &self.compare_clear(5usize))
                    .field("compare_clear[6]", &self.compare_clear(6usize))
                    .field("compare_clear[7]", &self.compare_clear(7usize))
                    .field("compare_stop[0]", &self.compare_stop(0usize))
                    .field("compare_stop[1]", &self.compare_stop(1usize))
                    .field("compare_stop[2]", &self.compare_stop(2usize))
                    .field("compare_stop[3]", &self.compare_stop(3usize))
                    .field("compare_stop[4]", &self.compare_stop(4usize))
                    .field("compare_stop[5]", &self.compare_stop(5usize))
                    .field("compare_stop[6]", &self.compare_stop(6usize))
                    .field("compare_stop[7]", &self.compare_stop(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ compare_clear[0]: {=bool:?}, compare_clear[1]: {=bool:?}, compare_clear[2]: {=bool:?}, compare_clear[3]: {=bool:?}, compare_clear[4]: {=bool:?}, compare_clear[5]: {=bool:?}, compare_clear[6]: {=bool:?}, compare_clear[7]: {=bool:?}, compare_stop[0]: {=bool:?}, compare_stop[1]: {=bool:?}, compare_stop[2]: {=bool:?}, compare_stop[3]: {=bool:?}, compare_stop[4]: {=bool:?}, compare_stop[5]: {=bool:?}, compare_stop[6]: {=bool:?}, compare_stop[7]: {=bool:?} }}" , self . compare_clear (0usize) , self . compare_clear (1usize) , self . compare_clear (2usize) , self . compare_clear (3usize) , self . compare_clear (4usize) , self . compare_clear (5usize) , self . compare_clear (6usize) , self . compare_clear (7usize) , self . compare_stop (0usize) , self . compare_stop (1usize) , self . compare_stop (2usize) , self . compare_stop (3usize) , self . compare_stop (4usize) , self . compare_stop (5usize) , self . compare_stop (6usize) , self . compare_stop (7usize))
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitmode {
            #[doc = "16 bit timer bit width"]
            _16BIT = 0x0,
            #[doc = "8 bit timer bit width"]
            _08BIT = 0x01,
            #[doc = "24 bit timer bit width"]
            _24BIT = 0x02,
            #[doc = "32 bit timer bit width"]
            _32BIT = 0x03,
        }
        impl Bitmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitmode {
            #[inline(always)]
            fn from(val: u8) -> Bitmode {
                Bitmode::from_bits(val)
            }
        }
        impl From<Bitmode> for u8 {
            #[inline(always)]
            fn from(val: Bitmode) -> u8 {
                Bitmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Select Timer mode"]
            TIMER = 0x0,
            #[doc = "Deprecated enumerator - Select Counter mode"]
            COUNTER = 0x01,
            #[doc = "Select Low Power Counter mode"]
            LOW_POWER_COUNTER = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod tpiu {
    #[doc = "Trace Port Interface Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tpiu {
        ptr: *mut u8,
    }
    unsafe impl Send for Tpiu {}
    unsafe impl Sync for Tpiu {}
    impl Tpiu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[inline(always)]
        pub const fn supportedportsizes(
            self,
        ) -> crate::common::Reg<regs::Supportedportsizes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[inline(always)]
        pub const fn currentportsize(
            self,
        ) -> crate::common::Reg<regs::Currentportsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[inline(always)]
        pub const fn supportedtriggermodes(
            self,
        ) -> crate::common::Reg<regs::Supportedtriggermodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[inline(always)]
        pub const fn triggercountervalue(
            self,
        ) -> crate::common::Reg<regs::Triggercountervalue, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[inline(always)]
        pub const fn triggermultiplier(
            self,
        ) -> crate::common::Reg<regs::Triggermultiplier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[inline(always)]
        pub const fn suppportedtestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Suppportedtestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[inline(always)]
        pub const fn currenttestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Currenttestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[inline(always)]
        pub const fn tprcr(self) -> crate::common::Reg<regs::Tprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[inline(always)]
        pub const fn ffsr(self) -> crate::common::Reg<regs::Ffsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[inline(always)]
        pub const fn ffcr(self) -> crate::common::Reg<regs::Ffcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[inline(always)]
        pub const fn fscr(self) -> crate::common::Reg<regs::Fscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[inline(always)]
        pub const fn extctlinport(
            self,
        ) -> crate::common::Reg<regs::Extctlinport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[inline(always)]
        pub const fn extctloutport(
            self,
        ) -> crate::common::Reg<regs::Extctloutport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[inline(always)]
        pub const fn ittrflinack(self) -> crate::common::Reg<regs::Ittrflinack, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee4usize) as _) }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[inline(always)]
        pub const fn ittrflin(self) -> crate::common::Reg<regs::Ittrflin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee8usize) as _) }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbdata0(self) -> crate::common::Reg<regs::Itatbdata0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eecusize) as _) }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[inline(always)]
        pub const fn itatbctr2(self) -> crate::common::Reg<regs::Itatbctr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef0usize) as _) }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef4usize) as _) }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef8usize) as _) }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f00usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa0usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa4usize) as _) }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<regs::Lar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb0usize) as _) }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb8usize) as _) }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fc8usize) as _) }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fccusize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fd0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe4usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe8usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fecusize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff0usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff4usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff8usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[must_use]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Authstatus {{ nsid: {:?}, nsnid: {:?}, sid: {:?}, snid: {:?} }}",
                    self.nsid(),
                    self.nsnid(),
                    self.sid(),
                    self.snid()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "Read or clear claim bit 0."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimclrBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimclrBit0::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimclrBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Read or clear claim bit 1."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimclrBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimclrBit1::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimclrBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Read or clear claim bit 2."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimclrBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimclrBit2::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimclrBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Read or clear claim bit 3."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimclrBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimclrBit3::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimclrBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimclr {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimsetBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimsetBit0::from_bits(val as u8)
            }
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_0(&mut self, val: super::vals::ClaimsetBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimsetBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimsetBit1::from_bits(val as u8)
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_1(&mut self, val: super::vals::ClaimsetBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimsetBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimsetBit2::from_bits(val as u8)
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_2(&mut self, val: super::vals::ClaimsetBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[must_use]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimsetBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimsetBit3::from_bits(val as u8)
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn set_bit_3(&mut self, val: super::vals::ClaimsetBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Claimset {{ bit_0: {:?}, bit_1: {:?}, bit_2: {:?}, bit_3: {:?} }}",
                    self.bit_0(),
                    self.bit_1(),
                    self.bit_2(),
                    self.bit_3()
                )
            }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentportsize(pub u32);
        impl Currentportsize {
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Currentportsize {
            #[inline(always)]
            fn default() -> Currentportsize {
                Currentportsize(0)
            }
        }
        impl core::fmt::Debug for Currentportsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentportsize")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentportsize {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Currentportsize {{ port_size_1: {=bool:?}, port_size_2: {=bool:?}, port_size_3: {=bool:?}, port_size_4: {=bool:?}, port_size_5: {=bool:?}, port_size_6: {=bool:?}, port_size_7: {=bool:?}, port_size_8: {=bool:?}, port_size_9: {=bool:?}, port_size_10: {=bool:?}, port_size_11: {=bool:?}, port_size_12: {=bool:?}, port_size_13: {=bool:?}, port_size_14: {=bool:?}, port_size_15: {=bool:?}, port_size_16: {=bool:?}, port_size_17: {=bool:?}, port_size_18: {=bool:?}, port_size_19: {=bool:?}, port_size_20: {=bool:?}, port_size_21: {=bool:?}, port_size_22: {=bool:?}, port_size_23: {=bool:?}, port_size_24: {=bool:?}, port_size_25: {=bool:?}, port_size_26: {=bool:?}, port_size_27: {=bool:?}, port_size_28: {=bool:?}, port_size_29: {=bool:?}, port_size_30: {=bool:?}, port_size_31: {=bool:?}, port_size_32: {=bool:?} }}" , self . port_size_1 () , self . port_size_2 () , self . port_size_3 () , self . port_size_4 () , self . port_size_5 () , self . port_size_6 () , self . port_size_7 () , self . port_size_8 () , self . port_size_9 () , self . port_size_10 () , self . port_size_11 () , self . port_size_12 () , self . port_size_13 () , self . port_size_14 () , self . port_size_15 () , self . port_size_16 () , self . port_size_17 () , self . port_size_18 () , self . port_size_19 () , self . port_size_20 () , self . port_size_21 () , self . port_size_22 () , self . port_size_23 () , self . port_size_24 () , self . port_size_25 () , self . port_size_26 () , self . port_size_27 () , self . port_size_28 () , self . port_size_29 () , self . port_size_30 () , self . port_size_31 () , self . port_size_32 ())
            }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currenttestpatternmodes(pub u32);
        impl Currenttestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Currenttestpatternmodes {
            #[inline(always)]
            fn default() -> Currenttestpatternmodes {
                Currenttestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Currenttestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currenttestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currenttestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Currenttestpatternmodes {{ patw1: {=bool:?}, patw0: {=bool:?}, pata5: {=bool:?}, patf0: {=bool:?}, ptimeen: {=bool:?}, pconten: {=bool:?} }}" , self . patw1 () , self . patw0 () , self . pata5 () , self . patf0 () , self . ptimeen () , self . pconten ())
            }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[must_use]
            #[inline(always)]
            pub const fn muxnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[inline(always)]
            pub const fn set_muxnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[must_use]
            #[inline(always)]
            pub const fn clkrelat(&self) -> super::vals::Clkrelat {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clkrelat::from_bits(val as u8)
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[inline(always)]
            pub const fn set_clkrelat(&mut self, val: super::vals::Clkrelat) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "FIFO size in powers of 2."]
            #[must_use]
            #[inline(always)]
            pub const fn fifosize(&self) -> super::vals::Fifosize {
                let val = (self.0 >> 6usize) & 0x07;
                super::vals::Fifosize::from_bits(val as u8)
            }
            #[doc = "FIFO size in powers of 2."]
            #[inline(always)]
            pub const fn set_fifosize(&mut self, val: super::vals::Fifosize) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val.to_bits() as u32) & 0x07) << 6usize);
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn tclkdata(&self) -> super::vals::Tclkdata {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tclkdata::from_bits(val as u8)
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[inline(always)]
            pub const fn set_tclkdata(&mut self, val: super::vals::Tclkdata) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn swoman(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[inline(always)]
            pub const fn set_swoman(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn swouartnrz(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[inline(always)]
            pub const fn set_swouartnrz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("muxnum", &self.muxnum())
                    .field("clkrelat", &self.clkrelat())
                    .field("fifosize", &self.fifosize())
                    .field("tclkdata", &self.tclkdata())
                    .field("swoman", &self.swoman())
                    .field("swouartnrz", &self.swouartnrz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Devid {{ muxnum: {=u8:?}, clkrelat: {:?}, fifosize: {:?}, tclkdata: {:?}, swoman: {=bool:?}, swouartnrz: {=bool:?} }}" , self . muxnum () , self . clkrelat () , self . fifosize () , self . tclkdata () , self . swoman () , self . swouartnrz ())
            }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "The main type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[must_use]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Devtype {{ major: {:?}, sub: {:?} }}",
                    self.major(),
                    self.sub()
                )
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctlinport(pub u32);
        impl Extctlinport {
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_0(&self) -> super::vals::Extctlin0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlin0::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_0(&mut self, val: super::vals::Extctlin0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_1(&self) -> super::vals::Extctlin1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlin1::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_1(&mut self, val: super::vals::Extctlin1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_2(&self) -> super::vals::Extctlin2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlin2::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_2(&mut self, val: super::vals::Extctlin2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_3(&self) -> super::vals::Extctlin3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlin3::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_3(&mut self, val: super::vals::Extctlin3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_4(&self) -> super::vals::Extctlin4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlin4::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_4(&mut self, val: super::vals::Extctlin4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_5(&self) -> super::vals::Extctlin5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlin5::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_5(&mut self, val: super::vals::Extctlin5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_6(&self) -> super::vals::Extctlin6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlin6::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_6(&mut self, val: super::vals::Extctlin6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL inputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlin_7(&self) -> super::vals::Extctlin7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlin7::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn set_extctlin_7(&mut self, val: super::vals::Extctlin7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctlinport {
            #[inline(always)]
            fn default() -> Extctlinport {
                Extctlinport(0)
            }
        }
        impl core::fmt::Debug for Extctlinport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctlinport")
                    .field("extctlin_0", &self.extctlin_0())
                    .field("extctlin_1", &self.extctlin_1())
                    .field("extctlin_2", &self.extctlin_2())
                    .field("extctlin_3", &self.extctlin_3())
                    .field("extctlin_4", &self.extctlin_4())
                    .field("extctlin_5", &self.extctlin_5())
                    .field("extctlin_6", &self.extctlin_6())
                    .field("extctlin_7", &self.extctlin_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctlinport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Extctlinport {{ extctlin_0: {:?}, extctlin_1: {:?}, extctlin_2: {:?}, extctlin_3: {:?}, extctlin_4: {:?}, extctlin_5: {:?}, extctlin_6: {:?}, extctlin_7: {:?} }}" , self . extctlin_0 () , self . extctlin_1 () , self . extctlin_2 () , self . extctlin_3 () , self . extctlin_4 () , self . extctlin_5 () , self . extctlin_6 () , self . extctlin_7 ())
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctloutport(pub u32);
        impl Extctloutport {
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_0(&self) -> super::vals::Extctlout0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlout0::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_0(&mut self, val: super::vals::Extctlout0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_1(&self) -> super::vals::Extctlout1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlout1::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_1(&mut self, val: super::vals::Extctlout1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_2(&self) -> super::vals::Extctlout2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlout2::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_2(&mut self, val: super::vals::Extctlout2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_3(&self) -> super::vals::Extctlout3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlout3::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_3(&mut self, val: super::vals::Extctlout3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_4(&self) -> super::vals::Extctlout4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlout4::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_4(&mut self, val: super::vals::Extctlout4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_5(&self) -> super::vals::Extctlout5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlout5::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_5(&mut self, val: super::vals::Extctlout5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_6(&self) -> super::vals::Extctlout6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlout6::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_6(&mut self, val: super::vals::Extctlout6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL outputs."]
            #[must_use]
            #[inline(always)]
            pub const fn extctlout_7(&self) -> super::vals::Extctlout7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlout7::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn set_extctlout_7(&mut self, val: super::vals::Extctlout7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctloutport {
            #[inline(always)]
            fn default() -> Extctloutport {
                Extctloutport(0)
            }
        }
        impl core::fmt::Debug for Extctloutport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctloutport")
                    .field("extctlout_0", &self.extctlout_0())
                    .field("extctlout_1", &self.extctlout_1())
                    .field("extctlout_2", &self.extctlout_2())
                    .field("extctlout_3", &self.extctlout_3())
                    .field("extctlout_4", &self.extctlout_4())
                    .field("extctlout_5", &self.extctlout_5())
                    .field("extctlout_6", &self.extctlout_6())
                    .field("extctlout_7", &self.extctlout_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctloutport {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Extctloutport {{ extctlout_0: {:?}, extctlout_1: {:?}, extctlout_2: {:?}, extctlout_3: {:?}, extctlout_4: {:?}, extctlout_5: {:?}, extctlout_6: {:?}, extctlout_7: {:?} }}" , self . extctlout_0 () , self . extctlout_1 () , self . extctlout_2 () , self . extctlout_3 () , self . extctlout_4 () , self . extctlout_5 () , self . extctlout_6 () , self . extctlout_7 ())
            }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffcr(pub u32);
        impl Ffcr {
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[must_use]
            #[inline(always)]
            pub const fn enftc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[inline(always)]
            pub const fn set_enftc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[must_use]
            #[inline(always)]
            pub const fn enfcont(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[inline(always)]
            pub const fn set_enfcont(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enables the use of the flushin connection."]
            #[must_use]
            #[inline(always)]
            pub const fn fonflin(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the use of the flushin connection."]
            #[inline(always)]
            pub const fn set_fonflin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[must_use]
            #[inline(always)]
            pub const fn fontrig(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[inline(always)]
            pub const fn set_fontrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[must_use]
            #[inline(always)]
            pub const fn fonmanr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[inline(always)]
            pub const fn set_fonmanr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[must_use]
            #[inline(always)]
            pub const fn fonmanw(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[inline(always)]
            pub const fn set_fonmanw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[must_use]
            #[inline(always)]
            pub const fn trigevt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[inline(always)]
            pub const fn set_trigevt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[must_use]
            #[inline(always)]
            pub const fn trigfl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[inline(always)]
            pub const fn set_trigfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[must_use]
            #[inline(always)]
            pub const fn stopfl(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[inline(always)]
            pub const fn set_stopfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[must_use]
            #[inline(always)]
            pub const fn stoptrig(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[inline(always)]
            pub const fn set_stoptrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Ffcr {
            #[inline(always)]
            fn default() -> Ffcr {
                Ffcr(0)
            }
        }
        impl core::fmt::Debug for Ffcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffcr")
                    .field("enftc", &self.enftc())
                    .field("enfcont", &self.enfcont())
                    .field("fonflin", &self.fonflin())
                    .field("fontrig", &self.fontrig())
                    .field("fonmanr", &self.fonmanr())
                    .field("fonmanw", &self.fonmanw())
                    .field("trigin", &self.trigin())
                    .field("trigevt", &self.trigevt())
                    .field("trigfl", &self.trigfl())
                    .field("stopfl", &self.stopfl())
                    .field("stoptrig", &self.stoptrig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffcr {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Ffcr {{ enftc: {=bool:?}, enfcont: {=bool:?}, fonflin: {=bool:?}, fontrig: {=bool:?}, fonmanr: {=bool:?}, fonmanw: {=bool:?}, trigin: {=bool:?}, trigevt: {=bool:?}, trigfl: {=bool:?}, stopfl: {=bool:?}, stoptrig: {=bool:?} }}" , self . enftc () , self . enfcont () , self . fonflin () , self . fontrig () , self . fonmanr () , self . fonmanw () , self . trigin () , self . trigevt () , self . trigfl () , self . stopfl () , self . stoptrig ())
            }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffsr(pub u32);
        impl Ffsr {
            #[doc = "Flush in progress."]
            #[must_use]
            #[inline(always)]
            pub const fn flinprog(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flush in progress."]
            #[inline(always)]
            pub const fn set_flinprog(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[must_use]
            #[inline(always)]
            pub const fn ftstopped(&self) -> super::vals::Ftstopped {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ftstopped::from_bits(val as u8)
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[inline(always)]
            pub const fn set_ftstopped(&mut self, val: super::vals::Ftstopped) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[must_use]
            #[inline(always)]
            pub const fn tcpresent(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[inline(always)]
            pub const fn set_tcpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Ffsr {
            #[inline(always)]
            fn default() -> Ffsr {
                Ffsr(0)
            }
        }
        impl core::fmt::Debug for Ffsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffsr")
                    .field("flinprog", &self.flinprog())
                    .field("ftstopped", &self.ftstopped())
                    .field("tcpresent", &self.tcpresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ffsr {{ flinprog: {=bool:?}, ftstopped: {:?}, tcpresent: {=bool:?} }}",
                    self.flinprog(),
                    self.ftstopped(),
                    self.tcpresent()
                )
            }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscr(pub u32);
        impl Fscr {
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[must_use]
            #[inline(always)]
            pub const fn cyccount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[inline(always)]
            pub const fn set_cyccount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Fscr {
            #[inline(always)]
            fn default() -> Fscr {
                Fscr(0)
            }
        }
        impl core::fmt::Debug for Fscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscr")
                    .field("cyccount", &self.cyccount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Fscr {{ cyccount: {=u16:?} }}", self.cyccount())
            }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "Reads the value of atvalids."]
            #[must_use]
            #[inline(always)]
            pub const fn atvalid(&self) -> super::vals::Atvalid {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atvalid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atvalids."]
            #[inline(always)]
            pub const fn set_atvalid(&mut self, val: super::vals::Atvalid) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of afreadys."]
            #[must_use]
            #[inline(always)]
            pub const fn afready(&self) -> super::vals::Afready {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Afready::from_bits(val as u8)
            }
            #[doc = "Reads the value of afreadys."]
            #[inline(always)]
            pub const fn set_afready(&mut self, val: super::vals::Afready) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Reads the value of atbytess."]
            #[must_use]
            #[inline(always)]
            pub const fn atbytes(&self) -> super::vals::Atbytes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Atbytes::from_bits(val as u8)
            }
            #[doc = "Reads the value of atbytess."]
            #[inline(always)]
            pub const fn set_atbytes(&mut self, val: super::vals::Atbytes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .field("atbytes", &self.atbytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr0 {{ atvalid: {:?}, afready: {:?}, atbytes: {:?} }}",
                    self.atvalid(),
                    self.afready(),
                    self.atbytes()
                )
            }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "Reads the value of atids."]
            #[must_use]
            #[inline(always)]
            pub const fn atid(&self) -> super::vals::Atid {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Atid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atids."]
            #[inline(always)]
            pub const fn set_atid(&mut self, val: super::vals::Atid) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atid", &self.atid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Itatbctr1 {{ atid: {:?} }}", self.atid())
            }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr2(pub u32);
        impl Itatbctr2 {
            #[doc = "Sets the value of afvalid."]
            #[must_use]
            #[inline(always)]
            pub const fn atready(&self) -> super::vals::Atready {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atready::from_bits(val as u8)
            }
            #[doc = "Sets the value of afvalid."]
            #[inline(always)]
            pub const fn set_atready(&mut self, val: super::vals::Atready) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of atready."]
            #[must_use]
            #[inline(always)]
            pub const fn afvalid(&self) -> super::vals::Afvalid {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Afvalid::from_bits(val as u8)
            }
            #[doc = "Sets the value of atready."]
            #[inline(always)]
            pub const fn set_afvalid(&mut self, val: super::vals::Afvalid) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itatbctr2 {
            #[inline(always)]
            fn default() -> Itatbctr2 {
                Itatbctr2(0)
            }
        }
        impl core::fmt::Debug for Itatbctr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr2")
                    .field("atready", &self.atready())
                    .field("afvalid", &self.afvalid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr2 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itatbctr2 {{ atready: {:?}, afvalid: {:?} }}",
                    self.atready(),
                    self.afvalid()
                )
            }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbdata0(pub u32);
        impl Itatbdata0 {
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_0(&self) -> super::vals::Atdata0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atdata0::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_0(&mut self, val: super::vals::Atdata0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_1(&self) -> super::vals::Atdata1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Atdata1::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_1(&mut self, val: super::vals::Atdata1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_2(&self) -> super::vals::Atdata2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Atdata2::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_2(&mut self, val: super::vals::Atdata2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_3(&self) -> super::vals::Atdata3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atdata3::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_3(&mut self, val: super::vals::Atdata3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[must_use]
            #[inline(always)]
            pub const fn atdata_4(&self) -> super::vals::Atdata4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Atdata4::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn set_atdata_4(&mut self, val: super::vals::Atdata4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Itatbdata0 {
            #[inline(always)]
            fn default() -> Itatbdata0 {
                Itatbdata0(0)
            }
        }
        impl core::fmt::Debug for Itatbdata0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbdata0")
                    .field("atdata_0", &self.atdata_0())
                    .field("atdata_1", &self.atdata_1())
                    .field("atdata_2", &self.atdata_2())
                    .field("atdata_3", &self.atdata_3())
                    .field("atdata_4", &self.atdata_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbdata0 {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Itatbdata0 {{ atdata_0: {:?}, atdata_1: {:?}, atdata_2: {:?}, atdata_3: {:?}, atdata_4: {:?} }}" , self . atdata_0 () , self . atdata_1 () , self . atdata_2 () , self . atdata_3 () , self . atdata_4 ())
            }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[must_use]
            #[inline(always)]
            pub const fn integrationmode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[inline(always)]
            pub const fn set_integrationmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl")
                    .field("integrationmode", &self.integrationmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Itctrl {{ integrationmode: {=bool:?} }}",
                    self.integrationmode()
                )
            }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflin(pub u32);
        impl Ittrflin {
            #[doc = "Reads the value of trigin."]
            #[must_use]
            #[inline(always)]
            pub const fn trigin(&self) -> super::vals::IttrflinTrigin {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IttrflinTrigin::from_bits(val as u8)
            }
            #[doc = "Reads the value of trigin."]
            #[inline(always)]
            pub const fn set_trigin(&mut self, val: super::vals::IttrflinTrigin) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of flushin."]
            #[must_use]
            #[inline(always)]
            pub const fn flushin(&self) -> super::vals::Flushin {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushin::from_bits(val as u8)
            }
            #[doc = "Reads the value of flushin."]
            #[inline(always)]
            pub const fn set_flushin(&mut self, val: super::vals::Flushin) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflin {
            #[inline(always)]
            fn default() -> Ittrflin {
                Ittrflin(0)
            }
        }
        impl core::fmt::Debug for Ittrflin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflin")
                    .field("trigin", &self.trigin())
                    .field("flushin", &self.flushin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflin {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflin {{ trigin: {:?}, flushin: {:?} }}",
                    self.trigin(),
                    self.flushin()
                )
            }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflinack(pub u32);
        impl Ittrflinack {
            #[doc = "Sets the value of triginack."]
            #[must_use]
            #[inline(always)]
            pub const fn triginack(&self) -> super::vals::Triginack {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Triginack::from_bits(val as u8)
            }
            #[doc = "Sets the value of triginack."]
            #[inline(always)]
            pub const fn set_triginack(&mut self, val: super::vals::Triginack) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of flushinack."]
            #[must_use]
            #[inline(always)]
            pub const fn flushinack(&self) -> super::vals::Flushinack {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushinack::from_bits(val as u8)
            }
            #[doc = "Sets the value of flushinack."]
            #[inline(always)]
            pub const fn set_flushinack(&mut self, val: super::vals::Flushinack) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflinack {
            #[inline(always)]
            fn default() -> Ittrflinack {
                Ittrflinack(0)
            }
        }
        impl core::fmt::Debug for Ittrflinack {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflinack")
                    .field("triginack", &self.triginack())
                    .field("flushinack", &self.flushinack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflinack {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Ittrflinack {{ triginack: {:?}, flushinack: {:?} }}",
                    self.triginack(),
                    self.flushinack()
                )
            }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lar(pub u32);
        impl Lar {
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[must_use]
            #[inline(always)]
            pub const fn access(&self) -> super::vals::Access {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Access::from_bits(val as u32)
            }
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub const fn set_access(&mut self, val: super::vals::Access) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Lar {
            #[inline(always)]
            fn default() -> Lar {
                Lar(0)
            }
        }
        impl core::fmt::Debug for Lar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lar")
                    .field("access", &self.access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lar {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Lar {{ access: {:?} }}", self.access())
            }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[must_use]
            #[inline(always)]
            pub const fn present(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub const fn set_present(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock."]
            #[must_use]
            #[inline(always)]
            pub const fn locked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub const fn set_locked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub const fn set_type_(&mut self, val: super::vals::Type) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("present", &self.present())
                    .field("locked", &self.locked())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Lsr {{ present: {=bool:?}, locked: {=bool:?}, type_: {:?} }}",
                    self.present(),
                    self.locked(),
                    self.type_()
                )
            }
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedportsizes(pub u32);
        impl Supportedportsizes {
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[inline(always)]
            pub const fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[inline(always)]
            pub const fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[inline(always)]
            pub const fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[inline(always)]
            pub const fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[inline(always)]
            pub const fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[inline(always)]
            pub const fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[inline(always)]
            pub const fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[inline(always)]
            pub const fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[inline(always)]
            pub const fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[inline(always)]
            pub const fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[inline(always)]
            pub const fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[inline(always)]
            pub const fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[inline(always)]
            pub const fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[inline(always)]
            pub const fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[inline(always)]
            pub const fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[inline(always)]
            pub const fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[inline(always)]
            pub const fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[inline(always)]
            pub const fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[inline(always)]
            pub const fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[inline(always)]
            pub const fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[inline(always)]
            pub const fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[inline(always)]
            pub const fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[inline(always)]
            pub const fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[inline(always)]
            pub const fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[inline(always)]
            pub const fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[inline(always)]
            pub const fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[inline(always)]
            pub const fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[inline(always)]
            pub const fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[inline(always)]
            pub const fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[inline(always)]
            pub const fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[inline(always)]
            pub const fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[must_use]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[inline(always)]
            pub const fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Supportedportsizes {
            #[inline(always)]
            fn default() -> Supportedportsizes {
                Supportedportsizes(0)
            }
        }
        impl core::fmt::Debug for Supportedportsizes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedportsizes")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedportsizes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Supportedportsizes {{ port_size_1: {=bool:?}, port_size_2: {=bool:?}, port_size_3: {=bool:?}, port_size_4: {=bool:?}, port_size_5: {=bool:?}, port_size_6: {=bool:?}, port_size_7: {=bool:?}, port_size_8: {=bool:?}, port_size_9: {=bool:?}, port_size_10: {=bool:?}, port_size_11: {=bool:?}, port_size_12: {=bool:?}, port_size_13: {=bool:?}, port_size_14: {=bool:?}, port_size_15: {=bool:?}, port_size_16: {=bool:?}, port_size_17: {=bool:?}, port_size_18: {=bool:?}, port_size_19: {=bool:?}, port_size_20: {=bool:?}, port_size_21: {=bool:?}, port_size_22: {=bool:?}, port_size_23: {=bool:?}, port_size_24: {=bool:?}, port_size_25: {=bool:?}, port_size_26: {=bool:?}, port_size_27: {=bool:?}, port_size_28: {=bool:?}, port_size_29: {=bool:?}, port_size_30: {=bool:?}, port_size_31: {=bool:?}, port_size_32: {=bool:?} }}" , self . port_size_1 () , self . port_size_2 () , self . port_size_3 () , self . port_size_4 () , self . port_size_5 () , self . port_size_6 () , self . port_size_7 () , self . port_size_8 () , self . port_size_9 () , self . port_size_10 () , self . port_size_11 () , self . port_size_12 () , self . port_size_13 () , self . port_size_14 () , self . port_size_15 () , self . port_size_16 () , self . port_size_17 () , self . port_size_18 () , self . port_size_19 () , self . port_size_20 () , self . port_size_21 () , self . port_size_22 () , self . port_size_23 () , self . port_size_24 () , self . port_size_25 () , self . port_size_26 () , self . port_size_27 () , self . port_size_28 () , self . port_size_29 () , self . port_size_30 () , self . port_size_31 () , self . port_size_32 ())
            }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedtriggermodes(pub u32);
        impl Supportedtriggermodes {
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[inline(always)]
            pub const fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[must_use]
            #[inline(always)]
            pub const fn tcount8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[inline(always)]
            pub const fn set_tcount8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[must_use]
            #[inline(always)]
            pub const fn triggered(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[inline(always)]
            pub const fn set_triggered(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[must_use]
            #[inline(always)]
            pub const fn trgrun(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[inline(always)]
            pub const fn set_trgrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Supportedtriggermodes {
            #[inline(always)]
            fn default() -> Supportedtriggermodes {
                Supportedtriggermodes(0)
            }
        }
        impl core::fmt::Debug for Supportedtriggermodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedtriggermodes")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .field("tcount8", &self.tcount8())
                    .field("triggered", &self.triggered())
                    .field("trgrun", &self.trgrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedtriggermodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Supportedtriggermodes {{ mult_0: {=bool:?}, mult_1: {=bool:?}, mult_2: {=bool:?}, mult_3: {=bool:?}, mult_4: {=bool:?}, tcount8: {=bool:?}, triggered: {=bool:?}, trgrun: {=bool:?} }}" , self . mult_0 () , self . mult_1 () , self . mult_2 () , self . mult_3 () , self . mult_4 () , self . tcount8 () , self . triggered () , self . trgrun ())
            }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Suppportedtestpatternmodes(pub u32);
        impl Suppportedtestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[must_use]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[must_use]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Suppportedtestpatternmodes {
            #[inline(always)]
            fn default() -> Suppportedtestpatternmodes {
                Suppportedtestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Suppportedtestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Suppportedtestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Suppportedtestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Suppportedtestpatternmodes {{ patw1: {=bool:?}, patw0: {=bool:?}, pata5: {=bool:?}, patf0: {=bool:?}, ptimeen: {=bool:?}, pconten: {=bool:?} }}" , self . patw1 () , self . patw0 () , self . pata5 () , self . patf0 () , self . ptimeen () , self . pconten ())
            }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tprcr(pub u32);
        impl Tprcr {
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[must_use]
            #[inline(always)]
            pub const fn pattcount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[inline(always)]
            pub const fn set_pattcount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Tprcr {
            #[inline(always)]
            fn default() -> Tprcr {
                Tprcr(0)
            }
        }
        impl core::fmt::Debug for Tprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tprcr")
                    .field("pattcount", &self.pattcount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tprcr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tprcr {{ pattcount: {=u8:?} }}", self.pattcount())
            }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggercountervalue(pub u32);
        impl Triggercountervalue {
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[must_use]
            #[inline(always)]
            pub const fn trig_count(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[inline(always)]
            pub const fn set_trig_count(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Triggercountervalue {
            #[inline(always)]
            fn default() -> Triggercountervalue {
                Triggercountervalue(0)
            }
        }
        impl core::fmt::Debug for Triggercountervalue {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggercountervalue")
                    .field("trig_count", &self.trig_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggercountervalue {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Triggercountervalue {{ trig_count: {=u8:?} }}",
                    self.trig_count()
                )
            }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggermultiplier(pub u32);
        impl Triggermultiplier {
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[must_use]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Triggermultiplier {
            #[inline(always)]
            fn default() -> Triggermultiplier {
                Triggermultiplier(0)
            }
        }
        impl core::fmt::Debug for Triggermultiplier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggermultiplier")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggermultiplier {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Triggermultiplier {{ mult_0: {=bool:?}, mult_1: {=bool:?}, mult_2: {=bool:?}, mult_3: {=bool:?}, mult_4: {=bool:?} }}" , self . mult_0 () , self . mult_1 () , self . mult_2 () , self . mult_3 () , self . mult_4 ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Access(u32);
        impl Access {
            #[doc = "Unlock register interface."]
            pub const UN_LOCK: Self = Self(0xc5ac_ce55);
        }
        impl Access {
            pub const fn from_bits(val: u32) -> Access {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Access {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xc5ac_ce55 => f.write_str("UN_LOCK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Access {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xc5ac_ce55 => defmt::write!(f, "UN_LOCK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Access {
            #[inline(always)]
            fn from(val: u32) -> Access {
                Access::from_bits(val)
            }
        }
        impl From<Access> for u32 {
            #[inline(always)]
            fn from(val: Access) -> u32 {
                Access::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afready {
            #[inline(always)]
            fn from(val: u8) -> Afready {
                Afready::from_bits(val)
            }
        }
        impl From<Afready> for u8 {
            #[inline(always)]
            fn from(val: Afready) -> u8 {
                Afready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afvalid {
            #[inline(always)]
            fn from(val: u8) -> Afvalid {
                Afvalid::from_bits(val)
            }
        }
        impl From<Afvalid> for u8 {
            #[inline(always)]
            fn from(val: Afvalid) -> u8 {
                Afvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atbytes {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Atbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atbytes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atbytes {
            #[inline(always)]
            fn from(val: u8) -> Atbytes {
                Atbytes::from_bits(val)
            }
        }
        impl From<Atbytes> for u8 {
            #[inline(always)]
            fn from(val: Atbytes) -> u8 {
                Atbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata0 {
            #[inline(always)]
            fn from(val: u8) -> Atdata0 {
                Atdata0::from_bits(val)
            }
        }
        impl From<Atdata0> for u8 {
            #[inline(always)]
            fn from(val: Atdata0) -> u8 {
                Atdata0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata1 {
            #[inline(always)]
            fn from(val: u8) -> Atdata1 {
                Atdata1::from_bits(val)
            }
        }
        impl From<Atdata1> for u8 {
            #[inline(always)]
            fn from(val: Atdata1) -> u8 {
                Atdata1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata2 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata2 {
            #[inline(always)]
            fn from(val: u8) -> Atdata2 {
                Atdata2::from_bits(val)
            }
        }
        impl From<Atdata2> for u8 {
            #[inline(always)]
            fn from(val: Atdata2) -> u8 {
                Atdata2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata3 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata3 {
            #[inline(always)]
            fn from(val: u8) -> Atdata3 {
                Atdata3::from_bits(val)
            }
        }
        impl From<Atdata3> for u8 {
            #[inline(always)]
            fn from(val: Atdata3) -> u8 {
                Atdata3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata4 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata4 {
            #[inline(always)]
            fn from(val: u8) -> Atdata4 {
                Atdata4::from_bits(val)
            }
        }
        impl From<Atdata4> for u8 {
            #[inline(always)]
            fn from(val: Atdata4) -> u8 {
                Atdata4::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Atid(u8);
        impl Atid {
            #[doc = "Pin is logic 0."]
            pub const LOW: Self = Self(0x0);
            #[doc = "Pin is logic 1."]
            pub const HIGH: Self = Self(0x01);
        }
        impl Atid {
            pub const fn from_bits(val: u8) -> Atid {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Atid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("LOW"),
                    0x01 => f.write_str("HIGH"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Atid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "LOW"),
                    0x01 => defmt::write!(f, "HIGH"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Atid {
            #[inline(always)]
            fn from(val: u8) -> Atid {
                Atid::from_bits(val)
            }
        }
        impl From<Atid> for u8 {
            #[inline(always)]
            fn from(val: Atid) -> u8 {
                Atid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atready {
            #[inline(always)]
            fn from(val: u8) -> Atready {
                Atready::from_bits(val)
            }
        }
        impl From<Atready> for u8 {
            #[inline(always)]
            fn from(val: Atready) -> u8 {
                Atready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalid {
            #[inline(always)]
            fn from(val: u8) -> Atvalid {
                Atvalid::from_bits(val)
            }
        }
        impl From<Atvalid> for u8 {
            #[inline(always)]
            fn from(val: Atvalid) -> u8 {
                Atvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit0 {
            #[doc = "Claim bit 0 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit0 {
                ClaimclrBit0::from_bits(val)
            }
        }
        impl From<ClaimclrBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit0) -> u8 {
                ClaimclrBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit1 {
            #[doc = "Claim bit 1 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit1 {
                ClaimclrBit1::from_bits(val)
            }
        }
        impl From<ClaimclrBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit1) -> u8 {
                ClaimclrBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit2 {
            #[doc = "Claim bit 2 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit2 {
                ClaimclrBit2::from_bits(val)
            }
        }
        impl From<ClaimclrBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit2) -> u8 {
                ClaimclrBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit3 {
            #[doc = "Claim bit 3 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit3 {
                ClaimclrBit3::from_bits(val)
            }
        }
        impl From<ClaimclrBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit3) -> u8 {
                ClaimclrBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit0 {
            #[doc = "Claim bit 0 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 0 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit0 {
                ClaimsetBit0::from_bits(val)
            }
        }
        impl From<ClaimsetBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit0) -> u8 {
                ClaimsetBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit1 {
            #[doc = "Claim bit 1 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 1 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit1 {
                ClaimsetBit1::from_bits(val)
            }
        }
        impl From<ClaimsetBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit1) -> u8 {
                ClaimsetBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit2 {
            #[doc = "Claim bit 2 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 2 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit2 {
                ClaimsetBit2::from_bits(val)
            }
        }
        impl From<ClaimsetBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit2) -> u8 {
                ClaimsetBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit3 {
            #[doc = "Claim bit 3 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 3 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit3 {
                ClaimsetBit3::from_bits(val)
            }
        }
        impl From<ClaimsetBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit3) -> u8 {
                ClaimsetBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clkrelat {
            #[doc = "atclk and traceclkin are synchronous."]
            SYNCHRONOUS = 0x0,
            #[doc = "atclk and traceclkin are asynchronous."]
            ASYNCHRONOUS = 0x01,
        }
        impl Clkrelat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clkrelat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clkrelat {
            #[inline(always)]
            fn from(val: u8) -> Clkrelat {
                Clkrelat::from_bits(val)
            }
        }
        impl From<Clkrelat> for u8 {
            #[inline(always)]
            fn from(val: Clkrelat) -> u8 {
                Clkrelat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin0 {
            #[doc = "Input EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlin0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin0 {
                Extctlin0::from_bits(val)
            }
        }
        impl From<Extctlin0> for u8 {
            #[inline(always)]
            fn from(val: Extctlin0) -> u8 {
                Extctlin0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin1 {
            #[doc = "Input EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlin1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin1 {
                Extctlin1::from_bits(val)
            }
        }
        impl From<Extctlin1> for u8 {
            #[inline(always)]
            fn from(val: Extctlin1) -> u8 {
                Extctlin1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin2 {
            #[doc = "Input EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlin2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin2 {
                Extctlin2::from_bits(val)
            }
        }
        impl From<Extctlin2> for u8 {
            #[inline(always)]
            fn from(val: Extctlin2) -> u8 {
                Extctlin2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin3 {
            #[doc = "Input EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlin3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin3 {
                Extctlin3::from_bits(val)
            }
        }
        impl From<Extctlin3> for u8 {
            #[inline(always)]
            fn from(val: Extctlin3) -> u8 {
                Extctlin3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin4 {
            #[doc = "Input EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlin4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin4 {
                Extctlin4::from_bits(val)
            }
        }
        impl From<Extctlin4> for u8 {
            #[inline(always)]
            fn from(val: Extctlin4) -> u8 {
                Extctlin4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin5 {
            #[doc = "Input EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlin5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin5 {
                Extctlin5::from_bits(val)
            }
        }
        impl From<Extctlin5> for u8 {
            #[inline(always)]
            fn from(val: Extctlin5) -> u8 {
                Extctlin5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin6 {
            #[doc = "Input EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlin6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin6 {
                Extctlin6::from_bits(val)
            }
        }
        impl From<Extctlin6> for u8 {
            #[inline(always)]
            fn from(val: Extctlin6) -> u8 {
                Extctlin6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin7 {
            #[doc = "Input EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlin7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin7 {
                Extctlin7::from_bits(val)
            }
        }
        impl From<Extctlin7> for u8 {
            #[inline(always)]
            fn from(val: Extctlin7) -> u8 {
                Extctlin7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout0 {
            #[doc = "Output EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlout0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout0 {
                Extctlout0::from_bits(val)
            }
        }
        impl From<Extctlout0> for u8 {
            #[inline(always)]
            fn from(val: Extctlout0) -> u8 {
                Extctlout0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout1 {
            #[doc = "Output EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlout1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout1 {
                Extctlout1::from_bits(val)
            }
        }
        impl From<Extctlout1> for u8 {
            #[inline(always)]
            fn from(val: Extctlout1) -> u8 {
                Extctlout1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout2 {
            #[doc = "Output EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlout2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout2 {
                Extctlout2::from_bits(val)
            }
        }
        impl From<Extctlout2> for u8 {
            #[inline(always)]
            fn from(val: Extctlout2) -> u8 {
                Extctlout2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout3 {
            #[doc = "Output EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlout3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout3 {
                Extctlout3::from_bits(val)
            }
        }
        impl From<Extctlout3> for u8 {
            #[inline(always)]
            fn from(val: Extctlout3) -> u8 {
                Extctlout3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout4 {
            #[doc = "Output EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlout4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout4 {
                Extctlout4::from_bits(val)
            }
        }
        impl From<Extctlout4> for u8 {
            #[inline(always)]
            fn from(val: Extctlout4) -> u8 {
                Extctlout4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout5 {
            #[doc = "Output EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlout5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout5 {
                Extctlout5::from_bits(val)
            }
        }
        impl From<Extctlout5> for u8 {
            #[inline(always)]
            fn from(val: Extctlout5) -> u8 {
                Extctlout5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout6 {
            #[doc = "Output EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlout6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout6 {
                Extctlout6::from_bits(val)
            }
        }
        impl From<Extctlout6> for u8 {
            #[inline(always)]
            fn from(val: Extctlout6) -> u8 {
                Extctlout6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout7 {
            #[doc = "Output EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlout7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout7 {
                Extctlout7::from_bits(val)
            }
        }
        impl From<Extctlout7> for u8 {
            #[inline(always)]
            fn from(val: Extctlout7) -> u8 {
                Extctlout7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fifosize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "FIFO size of 4 entries, that is, 16 bytes."]
            ENTRIES4 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fifosize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fifosize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fifosize {
            #[inline(always)]
            fn from(val: u8) -> Fifosize {
                Fifosize::from_bits(val)
            }
        }
        impl From<Fifosize> for u8 {
            #[inline(always)]
            fn from(val: Fifosize) -> u8 {
                Fifosize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushin {
            #[inline(always)]
            fn from(val: u8) -> Flushin {
                Flushin::from_bits(val)
            }
        }
        impl From<Flushin> for u8 {
            #[inline(always)]
            fn from(val: Flushin) -> u8 {
                Flushin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushinack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushinack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushinack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushinack {
            #[inline(always)]
            fn from(val: u8) -> Flushinack {
                Flushinack::from_bits(val)
            }
        }
        impl From<Flushinack> for u8 {
            #[inline(always)]
            fn from(val: Flushinack) -> u8 {
                Flushinack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ftstopped {
            #[doc = "Formatter has not stopped."]
            RUNNING = 0x0,
            #[doc = "Formatter has stopped."]
            STOPPED = 0x01,
        }
        impl Ftstopped {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ftstopped {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ftstopped {
            #[inline(always)]
            fn from(val: u8) -> Ftstopped {
                Ftstopped::from_bits(val)
            }
        }
        impl From<Ftstopped> for u8 {
            #[inline(always)]
            fn from(val: Ftstopped) -> u8 {
                Ftstopped::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IttrflinTrigin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl IttrflinTrigin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IttrflinTrigin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IttrflinTrigin {
            #[inline(always)]
            fn from(val: u8) -> IttrflinTrigin {
                IttrflinTrigin::from_bits(val)
            }
        }
        impl From<IttrflinTrigin> for u8 {
            #[inline(always)]
            fn from(val: IttrflinTrigin) -> u8 {
                IttrflinTrigin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a trace sink."]
            TRACE_SOURCE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Indicates that this component is a trace port component."]
            TRACE_PORT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tclkdata {
            #[doc = "Trace clock and data is supported."]
            SUPPORTED = 0x0,
            #[doc = "Trace clock and data is not supported."]
            NOT_SUPPORTED = 0x01,
        }
        impl Tclkdata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tclkdata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tclkdata {
            #[inline(always)]
            fn from(val: u8) -> Tclkdata {
                Tclkdata::from_bits(val)
            }
        }
        impl From<Tclkdata> for u8 {
            #[inline(always)]
            fn from(val: Tclkdata) -> u8 {
                Tclkdata::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Triginack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Triginack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Triginack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Triginack {
            #[inline(always)]
            fn from(val: u8) -> Triginack {
                Triginack::from_bits(val)
            }
        }
        impl From<Triginack> for u8 {
            #[inline(always)]
            fn from(val: Triginack) -> u8 {
                Triginack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            #[doc = "This component implements a 32-bit Lock Access Register."]
            BITS32 = 0x0,
            #[doc = "This component implements an 8-bit Lock Access Register."]
            BITS8 = 0x01,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
    }
}
pub mod twim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twim {
        ptr: *mut u8,
    }
    unsafe impl Send for Twim {}
    unsafe impl Sync for Twim {}
    impl Twim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "SUSPEND task has been issued, TWI traffic is now suspended."]
        #[inline(always)]
        pub const fn events_suspended(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Byte boundary, starting to receive the last byte"]
        #[inline(always)]
        pub const fn events_lastrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "Byte boundary, starting to transmit the last byte"]
        #[inline(always)]
        pub const fn events_lasttx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event SUSPENDED"]
        #[inline(always)]
        pub const fn publish_suspended(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event LASTRX"]
        #[inline(always)]
        pub const fn publish_lastrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event LASTTX"]
        #[inline(always)]
        pub const fn publish_lasttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c4usize) as _) }
        }
        #[doc = "Enable TWIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0524usize) as _) }
        }
        #[doc = "Address used in the TWI transfer"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0588usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address used in the TWI transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address used in the TWI transfer"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Address used in the TWI transfer"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Config {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Enable TWIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIM"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIM"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn anack(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_anack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("anack", &self.anack())
                    .field("dnack", &self.dnack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overrun: {=bool:?}, anack: {=bool:?}, dnack: {=bool:?} }}",
                    self.overrun(),
                    self.anack(),
                    self.dnack()
                )
            }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "TWI master clock frequency"]
            #[must_use]
            #[inline(always)]
            pub const fn frequency(&self) -> super::vals::Frequency {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Frequency::from_bits(val as u32)
            }
            #[doc = "TWI master clock frequency"]
            #[inline(always)]
            pub const fn set_frequency(&mut self, val: super::vals::Frequency) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Frequency {{ frequency: {:?} }}", self.frequency())
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[must_use]
            #[inline(always)]
            pub const fn suspended(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[inline(always)]
            pub const fn set_suspended(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[inline(always)]
            pub const fn set_lastrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[inline(always)]
            pub const fn set_lasttx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("suspended", &self.suspended())
                    .field("lastrx", &self.lastrx())
                    .field("lasttx", &self.lasttx())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, suspended: {=bool:?}, lastrx: {=bool:?}, lasttx: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . stopped () , self . error () , self . suspended () , self . lastrx () , self . lasttx () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[inline(always)]
            pub const fn set_lasttx_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_suspend(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[inline(always)]
            pub const fn set_lasttx_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lasttx_stop(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[inline(always)]
            pub const fn set_lasttx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_dma_tx_start(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[inline(always)]
            pub const fn set_lastrx_dma_tx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn lastrx_stop(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[inline(always)]
            pub const fn set_lastrx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("lasttx_dma_rx_start", &self.lasttx_dma_rx_start())
                    .field("lasttx_suspend", &self.lasttx_suspend())
                    .field("lasttx_stop", &self.lasttx_stop())
                    .field("lastrx_dma_tx_start", &self.lastrx_dma_tx_start())
                    .field("lastrx_stop", &self.lastrx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ lasttx_dma_rx_start: {=bool:?}, lasttx_suspend: {=bool:?}, lasttx_stop: {=bool:?}, lastrx_dma_tx_start: {=bool:?}, lastrx_stop: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . lasttx_dma_rx_start () , self . lasttx_suspend () , self . lasttx_stop () , self . lastrx_dma_tx_start () , self . lastrx_stop () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            #[doc = "Enable TWIM"]
            ENABLED = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frequency(u32);
        impl Frequency {
            #[doc = "100 kbps"]
            pub const K100: Self = Self(0x0198_0000);
            #[doc = "250 kbps"]
            pub const K250: Self = Self(0x0400_0000);
            #[doc = "400 kbps"]
            pub const K400: Self = Self(0x0640_0000);
        }
        impl Frequency {
            pub const fn from_bits(val: u32) -> Frequency {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0198_0000 => f.write_str("K100"),
                    0x0400_0000 => f.write_str("K250"),
                    0x0640_0000 => f.write_str("K400"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0198_0000 => defmt::write!(f, "K100"),
                    0x0400_0000 => defmt::write!(f, "K250"),
                    0x0640_0000 => defmt::write!(f, "K400"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Frequency {
            #[inline(always)]
            fn from(val: u32) -> Frequency {
                Frequency::from_bits(val)
            }
        }
        impl From<Frequency> for u32 {
            #[inline(always)]
            fn from(val: Frequency) -> u32 {
                Frequency::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod twis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twis {
        ptr: *mut u8,
    }
    unsafe impl Send for Twis {}
    unsafe impl Sync for Twis {}
    impl Twis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a write command"]
        #[inline(always)]
        pub const fn tasks_preparerx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a read command"]
        #[inline(always)]
        pub const fn tasks_preparetx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARERX"]
        #[inline(always)]
        pub const fn subscribe_preparerx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARETX"]
        #[inline(always)]
        pub const fn subscribe_preparetx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Write command received"]
        #[inline(always)]
        pub const fn events_write(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
        #[doc = "Read command received"]
        #[inline(always)]
        pub const fn events_read(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event WRITE"]
        #[inline(always)]
        pub const fn publish_write(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bcusize) as _) }
        }
        #[doc = "Publish configuration for event READ"]
        #[inline(always)]
        pub const fn publish_read(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04d0usize) as _) }
        }
        #[doc = "Status register indicating which address had a match"]
        #[inline(always)]
        pub const fn match_(self) -> crate::common::Reg<regs::TwisMatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04d4usize) as _) }
        }
        #[doc = "Enable TWIS"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Description collection: TWI slave address n"]
        #[inline(always)]
        pub const fn address(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Address, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0588usize + n * 4usize) as _) }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::TwisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0594usize) as _) }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: TWI slave address n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "TWI slave address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "TWI slave address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Enable TWIS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIS"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIS"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "RX buffer overflow detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[must_use]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[inline(always)]
            pub const fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[must_use]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overflow", &self.overflow())
                    .field("dnack", &self.dnack())
                    .field("overread", &self.overread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Errorsrc {{ overflow: {=bool:?}, dnack: {=bool:?}, overread: {=bool:?} }}",
                    self.overflow(),
                    self.dnack(),
                    self.overread()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ stopped: {=bool:?}, error: {=bool:?}, write: {=bool:?}, read: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?} }}" , self . stopped () , self . error () , self . write () , self . read () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Orc {{ orc: {=u8:?} }}", self.orc())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn write_suspend(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[inline(always)]
            pub const fn set_write_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[must_use]
            #[inline(always)]
            pub const fn read_suspend(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[inline(always)]
            pub const fn set_read_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("write_suspend", &self.write_suspend())
                    .field("read_suspend", &self.read_suspend())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ write_suspend: {=bool:?}, read_suspend: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?} }}" , self . write_suspend () , self . read_suspend () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 ())
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisConfig(pub u32);
        impl TwisConfig {
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[inline(always)]
            pub const fn set_address0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn address1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[inline(always)]
            pub const fn set_address1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for TwisConfig {
            #[inline(always)]
            fn default() -> TwisConfig {
                TwisConfig(0)
            }
        }
        impl core::fmt::Debug for TwisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisConfig")
                    .field("address0", &self.address0())
                    .field("address1", &self.address1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TwisConfig {{ address0: {=bool:?}, address1: {=bool:?} }}",
                    self.address0(),
                    self.address1()
                )
            }
        }
        #[doc = "Status register indicating which address had a match"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisMatch(pub u32);
        impl TwisMatch {
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[must_use]
            #[inline(always)]
            pub const fn match_(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[inline(always)]
            pub const fn set_match_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TwisMatch {
            #[inline(always)]
            fn default() -> TwisMatch {
                TwisMatch(0)
            }
        }
        impl core::fmt::Debug for TwisMatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisMatch")
                    .field("match_", &self.match_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisMatch {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TwisMatch {{ match_: {=bool:?} }}", self.match_())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIS"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "Enable TWIS"]
            ENABLED = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod uarte {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for TXD signal"]
        #[inline(always)]
        pub const fn txd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for CTS signal"]
        #[inline(always)]
        pub const fn cts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for RXD signal"]
        #[inline(always)]
        pub const fn rxd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for RTS signal"]
        #[inline(always)]
        pub const fn rts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "UART with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uarte {
        ptr: *mut u8,
    }
    unsafe impl Send for Uarte {}
    unsafe impl Sync for Uarte {}
    impl Uarte {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Flush RX FIFO into RX buffer"]
        #[inline(always)]
        pub const fn tasks_flushrx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task FLUSHRX"]
        #[inline(always)]
        pub const fn subscribe_flushrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "CTS is activated (set low). Clear To Send."]
        #[inline(always)]
        pub const fn events_cts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "CTS is deactivated (set high). Not Clear To Send."]
        #[inline(always)]
        pub const fn events_ncts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Data sent from TXD"]
        #[inline(always)]
        pub const fn events_txdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Data received in RXD (but potentially not yet transferred to Data RAM)"]
        #[inline(always)]
        pub const fn events_rxdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Error detected"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Receiver timeout"]
        #[inline(always)]
        pub const fn events_rxto(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Transmitter stopped"]
        #[inline(always)]
        pub const fn events_txstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Timed out due to bus being idle while receiving data."]
        #[inline(always)]
        pub const fn events_frametimeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
        }
        #[doc = "Publish configuration for event CTS"]
        #[inline(always)]
        pub const fn publish_cts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event NCTS"]
        #[inline(always)]
        pub const fn publish_ncts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event TXDRDY"]
        #[inline(always)]
        pub const fn publish_txdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event RXDRDY"]
        #[inline(always)]
        pub const fn publish_rxdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXTO"]
        #[inline(always)]
        pub const fn publish_rxto(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event TXSTOPPED"]
        #[inline(always)]
        pub const fn publish_txstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMETIMEOUT"]
        #[inline(always)]
        pub const fn publish_frametimeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01f4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
        #[doc = "Enable UART"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn baudrate(self) -> crate::common::Reg<regs::Baudrate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0524usize) as _) }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::UarteConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x056cusize) as _) }
        }
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0574usize) as _) }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[inline(always)]
        pub const fn frametimeout(
            self,
        ) -> crate::common::Reg<regs::Frametimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0578usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0604usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Set address"]
            #[must_use]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Set address"]
            #[inline(always)]
            pub const fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Address {{ address: {=u8:?} }}", self.address())
            }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Baudrate(pub u32);
        impl Baudrate {
            #[doc = "Baud rate"]
            #[must_use]
            #[inline(always)]
            pub const fn baudrate(&self) -> super::vals::Baudrate {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Baudrate::from_bits(val as u32)
            }
            #[doc = "Baud rate"]
            #[inline(always)]
            pub const fn set_baudrate(&mut self, val: super::vals::Baudrate) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Baudrate {
            #[inline(always)]
            fn default() -> Baudrate {
                Baudrate(0)
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Baudrate")
                    .field("baudrate", &self.baudrate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Baudrate {{ baudrate: {:?} }}", self.baudrate())
            }
        }
        #[doc = "Enable UART"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable UARTE"]
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable UARTE"]
            #[inline(always)]
            pub const fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Enable {{ enable: {:?} }}", self.enable())
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[must_use]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity error"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Parity error"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Framing error occurred"]
            #[must_use]
            #[inline(always)]
            pub const fn framing(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Framing error occurred"]
            #[inline(always)]
            pub const fn set_framing(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Break condition"]
            #[must_use]
            #[inline(always)]
            pub const fn break_(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Break condition"]
            #[inline(always)]
            pub const fn set_break_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("parity", &self.parity())
                    .field("framing", &self.framing())
                    .field("break_", &self.break_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Errorsrc {{ overrun: {=bool:?}, parity: {=bool:?}, framing: {=bool:?}, break_: {=bool:?} }}" , self . overrun () , self . parity () , self . framing () , self . break_ ())
            }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frametimeout(pub u32);
        impl Frametimeout {
            #[doc = "Number of UARTE bits before timeout."]
            #[must_use]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Number of UARTE bits before timeout."]
            #[inline(always)]
            pub const fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Frametimeout {
            #[inline(always)]
            fn default() -> Frametimeout {
                Frametimeout(0)
            }
        }
        impl core::fmt::Debug for Frametimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frametimeout")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frametimeout {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Frametimeout {{ countertop: {=u16:?} }}",
                    self.countertop()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CTS"]
            #[must_use]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CTS"]
            #[inline(always)]
            pub const fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[must_use]
            #[inline(always)]
            pub const fn ncts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[inline(always)]
            pub const fn set_ncts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn txdrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[inline(always)]
            pub const fn set_txdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[must_use]
            #[inline(always)]
            pub const fn rxdrdy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[inline(always)]
            pub const fn set_rxdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[must_use]
            #[inline(always)]
            pub const fn rxto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[inline(always)]
            pub const fn set_rxto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn txstopped(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[inline(always)]
            pub const fn set_txstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[must_use]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[inline(always)]
            pub const fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cts", &self.cts())
                    .field("ncts", &self.ncts())
                    .field("txdrdy", &self.txdrdy())
                    .field("rxdrdy", &self.rxdrdy())
                    .field("error", &self.error())
                    .field("rxto", &self.rxto())
                    .field("txstopped", &self.txstopped())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ cts: {=bool:?}, ncts: {=bool:?}, txdrdy: {=bool:?}, rxdrdy: {=bool:?}, error: {=bool:?}, rxto: {=bool:?}, txstopped: {=bool:?}, dmarxend: {=bool:?}, dmarxready: {=bool:?}, dmarxbuserror: {=bool:?}, dmarxmatch0: {=bool:?}, dmarxmatch1: {=bool:?}, dmarxmatch2: {=bool:?}, dmarxmatch3: {=bool:?}, dmatxend: {=bool:?}, dmatxready: {=bool:?}, dmatxbuserror: {=bool:?}, frametimeout: {=bool:?} }}" , self . cts () , self . ncts () , self . txdrdy () , self . rxdrdy () , self . error () , self . rxto () , self . txstopped () , self . dmarxend () , self . dmarxready () , self . dmarxbuserror () , self . dmarxmatch0 () , self . dmarxmatch1 () , self . dmarxmatch2 () , self . dmarxmatch3 () , self . dmatxend () , self . dmatxready () , self . dmatxbuserror () , self . frametimeout ())
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[must_use]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[must_use]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "MatchConfig {{ enable_0: {=bool:?}, enable_1: {=bool:?}, enable_2: {=bool:?}, enable_3: {=bool:?}, oneshot_0: {:?}, oneshot_1: {:?}, oneshot_2: {:?}, oneshot_3: {:?} }}" , self . enable_0 () , self . enable_1 () , self . enable_2 () , self . enable_3 () , self . oneshot_0 () , self . oneshot_1 () , self . oneshot_2 () , self . oneshot_3 ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "RxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "RxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[inline(always)]
            pub const fn set_dma_rx_end_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn set_dma_rx_end_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_tx_end_dma_tx_stop(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[inline(always)]
            pub const fn set_dma_tx_end_dma_tx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn set_frametimeout_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("dma_rx_end_dma_rx_start", &self.dma_rx_end_dma_rx_start())
                    .field("dma_rx_end_dma_rx_stop", &self.dma_rx_end_dma_rx_stop())
                    .field("dma_tx_end_dma_tx_stop", &self.dma_tx_end_dma_tx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .field("frametimeout_dma_rx_stop", &self.frametimeout_dma_rx_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Shorts {{ dma_rx_end_dma_rx_start: {=bool:?}, dma_rx_end_dma_rx_stop: {=bool:?}, dma_tx_end_dma_tx_stop: {=bool:?}, dma_rx_match0_dma_rx_enablematch1: {=bool:?}, dma_rx_match1_dma_rx_enablematch2: {=bool:?}, dma_rx_match2_dma_rx_enablematch3: {=bool:?}, dma_rx_match3_dma_rx_enablematch0: {=bool:?}, dma_rx_match0_dma_rx_disablematch0: {=bool:?}, dma_rx_match1_dma_rx_disablematch1: {=bool:?}, dma_rx_match2_dma_rx_disablematch2: {=bool:?}, dma_rx_match3_dma_rx_disablematch3: {=bool:?}, frametimeout_dma_rx_stop: {=bool:?} }}" , self . dma_rx_end_dma_rx_start () , self . dma_rx_end_dma_rx_stop () , self . dma_tx_end_dma_tx_stop () , self . dma_rx_match0_dma_rx_enablematch1 () , self . dma_rx_match1_dma_rx_enablematch2 () , self . dma_rx_match2_dma_rx_enablematch3 () , self . dma_rx_match3_dma_rx_enablematch0 () , self . dma_rx_match0_dma_rx_disablematch0 () , self . dma_rx_match1_dma_rx_disablematch1 () , self . dma_rx_match2_dma_rx_disablematch2 () , self . dma_rx_match3_dma_rx_disablematch3 () , self . frametimeout_dma_rx_stop ())
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[must_use]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxAmount {{ amount: {=u16:?} }}", self.amount())
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[must_use]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "TxMaxcnt {{ maxcnt: {=u16:?} }}", self.maxcnt())
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[must_use]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "TxTerminateonbuserror {{ enable: {=bool:?} }}",
                    self.enable()
                )
            }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct UarteConfig(pub u32);
        impl UarteConfig {
            #[doc = "Hardware flow control"]
            #[must_use]
            #[inline(always)]
            pub const fn hwfc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware flow control"]
            #[inline(always)]
            pub const fn set_hwfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity"]
            #[must_use]
            #[inline(always)]
            pub const fn parity(&self) -> super::vals::ConfigParity {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::ConfigParity::from_bits(val as u8)
            }
            #[doc = "Parity"]
            #[inline(always)]
            pub const fn set_parity(&mut self, val: super::vals::ConfigParity) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "Stop bits"]
            #[must_use]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::ConfigStop {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ConfigStop::from_bits(val as u8)
            }
            #[doc = "Stop bits"]
            #[inline(always)]
            pub const fn set_stop(&mut self, val: super::vals::ConfigStop) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Even or odd parity type"]
            #[must_use]
            #[inline(always)]
            pub const fn paritytype(&self) -> super::vals::Paritytype {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Paritytype::from_bits(val as u8)
            }
            #[doc = "Even or odd parity type"]
            #[inline(always)]
            pub const fn set_paritytype(&mut self, val: super::vals::Paritytype) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Set the data frame size"]
            #[must_use]
            #[inline(always)]
            pub const fn framesize(&self) -> super::vals::Framesize {
                let val = (self.0 >> 9usize) & 0x0f;
                super::vals::Framesize::from_bits(val as u8)
            }
            #[doc = "Set the data frame size"]
            #[inline(always)]
            pub const fn set_framesize(&mut self, val: super::vals::Framesize) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val.to_bits() as u32) & 0x0f) << 9usize);
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[must_use]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[inline(always)]
            pub const fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable packet timeout."]
            #[must_use]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable packet timeout."]
            #[inline(always)]
            pub const fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for UarteConfig {
            #[inline(always)]
            fn default() -> UarteConfig {
                UarteConfig(0)
            }
        }
        impl core::fmt::Debug for UarteConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("UarteConfig")
                    .field("hwfc", &self.hwfc())
                    .field("parity", &self.parity())
                    .field("stop", &self.stop())
                    .field("paritytype", &self.paritytype())
                    .field("framesize", &self.framesize())
                    .field("endian", &self.endian())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for UarteConfig {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "UarteConfig {{ hwfc: {=bool:?}, parity: {:?}, stop: {:?}, paritytype: {:?}, framesize: {:?}, endian: {:?}, frametimeout: {=bool:?} }}" , self . hwfc () , self . parity () , self . stop () , self . paritytype () , self . framesize () , self . endian () , self . frametimeout ())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Baudrate(u32);
        impl Baudrate {
            #[doc = "1200 baud (actual rate: 1205) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1200: Self = Self(0x0004_f000);
            #[doc = "2400 baud (actual rate: 2396) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD2400: Self = Self(0x0009_d000);
            #[doc = "4800 baud (actual rate: 4808) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD4800: Self = Self(0x0013_b000);
            #[doc = "9600 baud (actual rate: 9598) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD9600: Self = Self(0x0027_5000);
            #[doc = "14400 baud (actual rate: 14401) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD14400: Self = Self(0x003a_f000);
            #[doc = "19200 baud (actual rate: 19208) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD19200: Self = Self(0x004e_a000);
            #[doc = "28800 baud (actual rate: 28777) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD28800: Self = Self(0x0075_c000);
            #[doc = "31250 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD31250: Self = Self(0x0080_0000);
            #[doc = "38400 baud (actual rate: 38369) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD38400: Self = Self(0x009d_0000);
            #[doc = "56000 baud (actual rate: 55944) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD56000: Self = Self(0x00e5_0000);
            #[doc = "57600 baud (actual rate: 57554) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD57600: Self = Self(0x00eb_0000);
            #[doc = "76800 baud (actual rate: 76923) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD76800: Self = Self(0x013a_9000);
            #[doc = "115200 baud (actual rate: 115108) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD115200: Self = Self(0x01d6_0000);
            #[doc = "230400 baud (actual rate: 231884) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD230400: Self = Self(0x03b0_0000);
            #[doc = "250000 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD250000: Self = Self(0x0400_0000);
            #[doc = "460800 baud (actual rate: 457143) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD460800: Self = Self(0x0740_0000);
            #[doc = "921600 baud (actual rate: 941176) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD921600: Self = Self(0x0f00_0000);
            #[doc = "1 megabaud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1M: Self = Self(0x1000_0000);
        }
        impl Baudrate {
            pub const fn from_bits(val: u32) -> Baudrate {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0004_f000 => f.write_str("BAUD1200"),
                    0x0009_d000 => f.write_str("BAUD2400"),
                    0x0013_b000 => f.write_str("BAUD4800"),
                    0x0027_5000 => f.write_str("BAUD9600"),
                    0x003a_f000 => f.write_str("BAUD14400"),
                    0x004e_a000 => f.write_str("BAUD19200"),
                    0x0075_c000 => f.write_str("BAUD28800"),
                    0x0080_0000 => f.write_str("BAUD31250"),
                    0x009d_0000 => f.write_str("BAUD38400"),
                    0x00e5_0000 => f.write_str("BAUD56000"),
                    0x00eb_0000 => f.write_str("BAUD57600"),
                    0x013a_9000 => f.write_str("BAUD76800"),
                    0x01d6_0000 => f.write_str("BAUD115200"),
                    0x03b0_0000 => f.write_str("BAUD230400"),
                    0x0400_0000 => f.write_str("BAUD250000"),
                    0x0740_0000 => f.write_str("BAUD460800"),
                    0x0f00_0000 => f.write_str("BAUD921600"),
                    0x1000_0000 => f.write_str("BAUD1M"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0004_f000 => defmt::write!(f, "BAUD1200"),
                    0x0009_d000 => defmt::write!(f, "BAUD2400"),
                    0x0013_b000 => defmt::write!(f, "BAUD4800"),
                    0x0027_5000 => defmt::write!(f, "BAUD9600"),
                    0x003a_f000 => defmt::write!(f, "BAUD14400"),
                    0x004e_a000 => defmt::write!(f, "BAUD19200"),
                    0x0075_c000 => defmt::write!(f, "BAUD28800"),
                    0x0080_0000 => defmt::write!(f, "BAUD31250"),
                    0x009d_0000 => defmt::write!(f, "BAUD38400"),
                    0x00e5_0000 => defmt::write!(f, "BAUD56000"),
                    0x00eb_0000 => defmt::write!(f, "BAUD57600"),
                    0x013a_9000 => defmt::write!(f, "BAUD76800"),
                    0x01d6_0000 => defmt::write!(f, "BAUD115200"),
                    0x03b0_0000 => defmt::write!(f, "BAUD230400"),
                    0x0400_0000 => defmt::write!(f, "BAUD250000"),
                    0x0740_0000 => defmt::write!(f, "BAUD460800"),
                    0x0f00_0000 => defmt::write!(f, "BAUD921600"),
                    0x1000_0000 => defmt::write!(f, "BAUD1M"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Baudrate {
            #[inline(always)]
            fn from(val: u32) -> Baudrate {
                Baudrate::from_bits(val)
            }
        }
        impl From<Baudrate> for u32 {
            #[inline(always)]
            fn from(val: Baudrate) -> u32 {
                Baudrate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigParity {
            #[doc = "Exclude parity bit"]
            EXCLUDED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Include even parity bit"]
            INCLUDED = 0x07,
        }
        impl ConfigParity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigParity {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigParity {
            #[inline(always)]
            fn from(val: u8) -> ConfigParity {
                ConfigParity::from_bits(val)
            }
        }
        impl From<ConfigParity> for u8 {
            #[inline(always)]
            fn from(val: ConfigParity) -> u8 {
                ConfigParity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigStop {
            #[doc = "One stop bit"]
            ONE = 0x0,
            #[doc = "Two stop bits"]
            TWO = 0x01,
        }
        impl ConfigStop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigStop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigStop {
            #[inline(always)]
            fn from(val: u8) -> ConfigStop {
                ConfigStop::from_bits(val)
            }
        }
        impl From<ConfigStop> for u8 {
            #[inline(always)]
            fn from(val: ConfigStop) -> u8 {
                ConfigStop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable UARTE"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "Enable UARTE"]
            ENABLED = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Data is trimmed from MSB end."]
            MSB = 0x0,
            #[doc = "Data is trimmed from LSB end."]
            LSB = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framesize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "4 bit data frame size."]
            _4BIT = 0x04,
            #[doc = "5 bit data frame size."]
            _5BIT = 0x05,
            #[doc = "6 bit data frame size."]
            _6BIT = 0x06,
            #[doc = "7 bit data frame size."]
            _7BIT = 0x07,
            #[doc = "8 bit data frame size."]
            _8BIT = 0x08,
            #[doc = "9 bit data frame size. 9th bit is treated as address bit."]
            _9BIT = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Framesize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framesize {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framesize {
            #[inline(always)]
            fn from(val: u8) -> Framesize {
                Framesize::from_bits(val)
            }
        }
        impl From<Framesize> for u8 {
            #[inline(always)]
            fn from(val: Framesize) -> u8 {
                Framesize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Paritytype {
            #[doc = "Even parity"]
            EVEN = 0x0,
            #[doc = "Odd parity"]
            ODD = 0x01,
        }
        impl Paritytype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Paritytype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Paritytype {
            #[inline(always)]
            fn from(val: u8) -> Paritytype {
                Paritytype::from_bits(val)
            }
        }
        impl From<Paritytype> for u8 {
            #[inline(always)]
            fn from(val: Paritytype) -> u8 {
                Paritytype::to_bits(val)
            }
        }
    }
}
pub mod uicr {
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Approtect {
        ptr: *mut u8,
    }
    unsafe impl Send for Approtect {}
    unsafe impl Sync for Approtect {}
    impl Approtect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Authopkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Authopkey {}
    unsafe impl Sync for Authopkey {}
    impl Authopkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::AuthopkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Auxapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Auxapprotect {}
    unsafe impl Sync for Auxapprotect {}
    impl Auxapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Erase Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Pubkey {}
    unsafe impl Sync for Pubkey {}
    impl Pubkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PubkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Assets installed to establish initial Root of Trust in the device."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rot {
        ptr: *mut u8,
    }
    unsafe impl Send for Rot {}
    unsafe impl Sync for Rot {}
    impl Rot {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pubkey(self, n: usize) -> Pubkey {
            assert!(n < 4usize);
            unsafe { Pubkey::from_ptr(self.ptr.add(0x0usize + n * 44usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn authopkey(self, n: usize) -> Authopkey {
            assert!(n < 4usize);
            unsafe { Authopkey::from_ptr(self.ptr.add(0xb0usize + n * 44usize) as _) }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Secureapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Secureapprotect {}
    unsafe impl Sync for Secureapprotect {}
    impl Secureapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "User Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Uicr {}
    unsafe impl Sync for Uicr {}
    impl Uicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn approtect(self, n: usize) -> Approtect {
            assert!(n < 1usize);
            unsafe { Approtect::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn secureapprotect(self, n: usize) -> Secureapprotect {
            assert!(n < 1usize);
            unsafe { Secureapprotect::from_ptr(self.ptr.add(0x20usize + n * 32usize) as _) }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn auxapprotect(self, n: usize) -> Auxapprotect {
            assert!(n < 1usize);
            unsafe { Auxapprotect::from_ptr(self.ptr.add(0x40usize + n * 32usize) as _) }
        }
        #[doc = "Erase Protection Registers"]
        #[inline(always)]
        pub const fn eraseprotect(self, n: usize) -> Eraseprotect {
            assert!(n < 1usize);
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x60usize + n * 32usize) as _) }
        }
        #[doc = "Immutable boot region configuration."]
        #[inline(always)]
        pub const fn bootconf(self) -> crate::common::Reg<regs::Bootconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn user(self) -> User {
            unsafe { User::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Description collection: One time programmable memory"]
        #[inline(always)]
        pub const fn otp(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 320usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct User {
        ptr: *mut u8,
    }
    unsafe impl Send for User {}
    unsafe impl Sync for User {}
    impl User {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Assets installed to establish initial Root of Trust in the device."]
        #[inline(always)]
        pub const fn rot(self) -> Rot {
            unsafe { Rot::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect0(pub u32);
        impl ApprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::ApprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect0 {
            #[inline(always)]
            fn default() -> ApprotectProtect0 {
                ApprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect1(pub u32);
        impl ApprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::ApprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect1 {
            #[inline(always)]
            fn default() -> ApprotectProtect1 {
                ApprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "ApprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuthopkeyRevoke(pub u32);
        impl AuthopkeyRevoke {
            #[doc = "Revocation status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::AuthopkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuthopkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::AuthopkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuthopkeyRevoke {
            #[inline(always)]
            fn default() -> AuthopkeyRevoke {
                AuthopkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for AuthopkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuthopkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuthopkeyRevoke {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect0(pub u32);
        impl AuxapprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::AuxapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect0 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect0 {
                AuxapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxapprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect1(pub u32);
        impl AuxapprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::AuxapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect1 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect1 {
                AuxapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "AuxapprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Immutable boot region configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bootconf(pub u32);
        impl Bootconf {
            #[doc = "Read access"]
            #[must_use]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[must_use]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[must_use]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[must_use]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write-once"]
            #[must_use]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock of configuration register"]
            #[must_use]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock of configuration register"]
            #[inline(always)]
            pub const fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Immutable boot region size"]
            #[must_use]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Immutable boot region size"]
            #[inline(always)]
            pub const fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
        }
        impl Default for Bootconf {
            #[inline(always)]
            fn default() -> Bootconf {
                Bootconf(0)
            }
        }
        impl core::fmt::Debug for Bootconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bootconf")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bootconf {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Bootconf {{ read: {=bool:?}, write: {=bool:?}, execute: {=bool:?}, secure: {=bool:?}, writeonce: {=bool:?}, lock: {=bool:?}, size: {=u8:?} }}" , self . read () , self . write () , self . execute () , self . secure () , self . writeonce () , self . lock () , self . size ())
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect0(pub u32);
        impl EraseprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::EraseprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect0 {
            #[inline(always)]
            fn default() -> EraseprotectProtect0 {
                EraseprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect1(pub u32);
        impl EraseprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::EraseprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect1 {
            #[inline(always)]
            fn default() -> EraseprotectProtect1 {
                EraseprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "EraseprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PubkeyRevoke(pub u32);
        impl PubkeyRevoke {
            #[doc = "Revocation status."]
            #[must_use]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::PubkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::PubkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn set_status(&mut self, val: super::vals::PubkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PubkeyRevoke {
            #[inline(always)]
            fn default() -> PubkeyRevoke {
                PubkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for PubkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PubkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "PubkeyRevoke {{ status: {:?} }}", self.status())
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect0(pub u32);
        impl SecureapprotectProtect0 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::SecureapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect0 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect0 {
                SecureapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SecureapprotectProtect0 {{ pall: {:?} }}", self.pall())
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect1(pub u32);
        impl SecureapprotectProtect1 {
            #[must_use]
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub const fn set_pall(&mut self, val: super::vals::SecureapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect1 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect1 {
                SecureapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "SecureapprotectProtect1 {{ pall: {:?} }}", self.pall())
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect0Pall(u32);
        impl ApprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect0Pall {
                ApprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect0Pall) -> u32 {
                ApprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect1Pall(u32);
        impl ApprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect1Pall {
                ApprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect1Pall) -> u32 {
                ApprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuthopkeyRevokeStatus(u32);
        impl AuthopkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl AuthopkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> AuthopkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuthopkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuthopkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> AuthopkeyRevokeStatus {
                AuthopkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<AuthopkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: AuthopkeyRevokeStatus) -> u32 {
                AuthopkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect0Pall(u32);
        impl AuxapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN and SPIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect0Pall {
                AuxapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect0Pall) -> u32 {
                AuxapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect1Pall(u32);
        impl AuxapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN and SPIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect1Pall {
                AuxapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect1Pall) -> u32 {
                AuxapprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect0Pall(u32);
        impl EraseprotectProtect0Pall {
            #[doc = "The device can be erased using the CTRL-AP Erase all function and TAMPC PROTECT.ERASEPROTECT signal protector is unlocked."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl EraseprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect0Pall {
                EraseprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect0Pall) -> u32 {
                EraseprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect1Pall(u32);
        impl EraseprotectProtect1Pall {
            #[doc = "The device canbe erased using the CTRL-AP Erase all function and TAMPC PROTECT.ERASEPROTECT signal protector is unlocked."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl EraseprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect1Pall {
                EraseprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect1Pall) -> u32 {
                EraseprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct PubkeyRevokeStatus(u32);
        impl PubkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl PubkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> PubkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for PubkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for PubkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> PubkeyRevokeStatus {
                PubkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<PubkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: PubkeyRevokeStatus) -> u32 {
                PubkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect0Pall(u32);
        impl SecureapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect0Pall {
                SecureapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect0Pall) -> u32 {
                SecureapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect1Pall(u32);
        impl SecureapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect1Pall {
                SecureapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect1Pall) -> u32 {
                SecureapprotectProtect1Pall::to_bits(val)
            }
        }
    }
}
pub mod vpr {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Debugif {
        ptr: *mut u8,
    }
    unsafe impl Send for Debugif {}
    unsafe impl Sync for Debugif {}
    impl Debugif {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Abstract Data 0. Read/write data for argument 0"]
        #[inline(always)]
        pub const fn data0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Abstract Data 1. Read/write data for argument 1"]
        #[inline(always)]
        pub const fn data1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Debug Module Control"]
        #[inline(always)]
        pub const fn dmcontrol(self) -> crate::common::Reg<regs::Dmcontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Debug Module Status"]
        #[inline(always)]
        pub const fn dmstatus(self) -> crate::common::Reg<regs::Dmstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Hart Information"]
        #[inline(always)]
        pub const fn hartinfo(self) -> crate::common::Reg<regs::Hartinfo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Halt Summary 1"]
        #[inline(always)]
        pub const fn haltsum1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Hart Array Window Select"]
        #[inline(always)]
        pub const fn hawindowsel(self) -> crate::common::Reg<regs::Hawindowsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Hart Array Window"]
        #[inline(always)]
        pub const fn hawindow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Abstract Control and Status"]
        #[inline(always)]
        pub const fn abstractcs(self) -> crate::common::Reg<regs::Abstractcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Abstract command"]
        #[inline(always)]
        pub const fn abstractcmd(self) -> crate::common::Reg<regs::Abstractcmd, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "Abstract Command Autoexec"]
        #[inline(always)]
        pub const fn abstractauto(
            self,
        ) -> crate::common::Reg<regs::Abstractauto, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Description collection: Configuration String Pointer \\[n\\]"]
        #[inline(always)]
        pub const fn confstrptr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize + n * 4usize) as _) }
        }
        #[doc = "Next Debug Module"]
        #[inline(always)]
        pub const fn nextdm(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Description collection: Program Buffer \\[n\\]"]
        #[inline(always)]
        pub const fn progbuf(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Authentication Data"]
        #[inline(always)]
        pub const fn authdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Halt Summary 2"]
        #[inline(always)]
        pub const fn haltsum2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "Halt Summary 3"]
        #[inline(always)]
        pub const fn haltsum3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "System Bus Addres 127:96"]
        #[inline(always)]
        pub const fn sbaddress3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
        }
        #[doc = "System Bus Access Control and Status"]
        #[inline(always)]
        pub const fn sbcs(self) -> crate::common::Reg<regs::Sbcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "System Bus Addres 31:0"]
        #[inline(always)]
        pub const fn sbaddress0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
        }
        #[doc = "System Bus Addres 63:32"]
        #[inline(always)]
        pub const fn sbaddress1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
        }
        #[doc = "System Bus Addres 95:64"]
        #[inline(always)]
        pub const fn sbaddress2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xecusize) as _) }
        }
        #[doc = "System Bus Data 31:0"]
        #[inline(always)]
        pub const fn sbdata0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "System Bus Data 63:32"]
        #[inline(always)]
        pub const fn sbdata1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "System Bus Data 95:64"]
        #[inline(always)]
        pub const fn sbdata2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "System Bus Data 127:96"]
        #[inline(always)]
        pub const fn sbdata3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
        #[doc = "Halt summary 0"]
        #[inline(always)]
        pub const fn haltsum0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
    }
    #[doc = "VPR peripheral registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vpr {
        ptr: *mut u8,
    }
    unsafe impl Send for Vpr {}
    unsafe impl Sync for Vpr {}
    impl Vpr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: VPR task \\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task TASKS_TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: VPR event \\[n\\] register"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event EVENTS_TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn debugif(self) -> Debugif {
            unsafe { Debugif::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "State of the CPU after a core reset"]
        #[inline(always)]
        pub const fn cpurun(self) -> crate::common::Reg<regs::Cpurun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "Initial value of the PC at CPU start."]
        #[inline(always)]
        pub const fn initpc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0808usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Abstract Command Autoexec"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractauto(pub u32);
        impl Abstractauto {
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[must_use]
            #[inline(always)]
            pub const fn autoexecdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn set_autoexecdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[must_use]
            #[inline(always)]
            pub const fn autoexecprogbuf(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn set_autoexecprogbuf(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Abstractauto {
            #[inline(always)]
            fn default() -> Abstractauto {
                Abstractauto(0)
            }
        }
        impl core::fmt::Debug for Abstractauto {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractauto")
                    .field("autoexecdata", &self.autoexecdata())
                    .field("autoexecprogbuf", &self.autoexecprogbuf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractauto {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Abstractauto {{ autoexecdata: {=u16:?}, autoexecprogbuf: {=u16:?} }}",
                    self.autoexecdata(),
                    self.autoexecprogbuf()
                )
            }
        }
        #[doc = "Abstract command"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcmd(pub u32);
        impl Abstractcmd {
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[must_use]
            #[inline(always)]
            pub const fn control(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[inline(always)]
            pub const fn set_control(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[must_use]
            #[inline(always)]
            pub const fn cmdtype(&self) -> super::vals::Cmdtype {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::Cmdtype::from_bits(val as u8)
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[inline(always)]
            pub const fn set_cmdtype(&mut self, val: super::vals::Cmdtype) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Abstractcmd {
            #[inline(always)]
            fn default() -> Abstractcmd {
                Abstractcmd(0)
            }
        }
        impl core::fmt::Debug for Abstractcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcmd")
                    .field("control", &self.control())
                    .field("cmdtype", &self.cmdtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcmd {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Abstractcmd {{ control: {=u32:?}, cmdtype: {:?} }}",
                    self.control(),
                    self.cmdtype()
                )
            }
        }
        #[doc = "Abstract Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcs(pub u32);
        impl Abstractcs {
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[must_use]
            #[inline(always)]
            pub const fn datacount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[inline(always)]
            pub const fn set_datacount(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Command error when the abstract command fails."]
            #[must_use]
            #[inline(always)]
            pub const fn cmderr(&self) -> super::vals::Cmderr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cmderr::from_bits(val as u8)
            }
            #[doc = "Command error when the abstract command fails."]
            #[inline(always)]
            pub const fn set_cmderr(&mut self, val: super::vals::Cmderr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Abstract command execution status."]
            #[must_use]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Abstract command execution status."]
            #[inline(always)]
            pub const fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[must_use]
            #[inline(always)]
            pub const fn progbufsize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[inline(always)]
            pub const fn set_progbufsize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for Abstractcs {
            #[inline(always)]
            fn default() -> Abstractcs {
                Abstractcs(0)
            }
        }
        impl core::fmt::Debug for Abstractcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcs")
                    .field("datacount", &self.datacount())
                    .field("cmderr", &self.cmderr())
                    .field("busy", &self.busy())
                    .field("progbufsize", &self.progbufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Abstractcs {{ datacount: {=u8:?}, cmderr: {:?}, busy: {=bool:?}, progbufsize: {=u8:?} }}" , self . datacount () , self . cmderr () , self . busy () , self . progbufsize ())
            }
        }
        #[doc = "State of the CPU after a core reset"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cpurun(pub u32);
        impl Cpurun {
            #[doc = "Controls CPU running state after a core reset."]
            #[must_use]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::CpurunEn {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CpurunEn::from_bits(val as u8)
            }
            #[doc = "Controls CPU running state after a core reset."]
            #[inline(always)]
            pub const fn set_en(&mut self, val: super::vals::CpurunEn) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Cpurun {
            #[inline(always)]
            fn default() -> Cpurun {
                Cpurun(0)
            }
        }
        impl core::fmt::Debug for Cpurun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cpurun").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cpurun {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Cpurun {{ en: {:?} }}", self.en())
            }
        }
        #[doc = "Debug Module Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmcontrol(pub u32);
        impl Dmcontrol {
            #[doc = "Reset signal for the debug module."]
            #[must_use]
            #[inline(always)]
            pub const fn dmactive(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal for the debug module."]
            #[inline(always)]
            pub const fn set_dmactive(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[must_use]
            #[inline(always)]
            pub const fn ndmreset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[inline(always)]
            pub const fn set_ndmreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Clear the halt on reset request."]
            #[must_use]
            #[inline(always)]
            pub const fn clrresethaltreq(&self) -> super::vals::Clrresethaltreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clrresethaltreq::from_bits(val as u8)
            }
            #[doc = "Clear the halt on reset request."]
            #[inline(always)]
            pub const fn set_clrresethaltreq(&mut self, val: super::vals::Clrresethaltreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set the halt on reset request."]
            #[must_use]
            #[inline(always)]
            pub const fn setresethaltreq(&self) -> super::vals::Setresethaltreq {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Setresethaltreq::from_bits(val as u8)
            }
            #[doc = "Set the halt on reset request."]
            #[inline(always)]
            pub const fn set_setresethaltreq(&mut self, val: super::vals::Setresethaltreq) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "The high 10 bits of hartsel."]
            #[must_use]
            #[inline(always)]
            pub const fn hartselhi(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "The high 10 bits of hartsel."]
            #[inline(always)]
            pub const fn set_hartselhi(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u32) & 0x03ff) << 6usize);
            }
            #[doc = "The low 10 bits of hartsel."]
            #[must_use]
            #[inline(always)]
            pub const fn hartsello(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "The low 10 bits of hartsel."]
            #[inline(always)]
            pub const fn set_hartsello(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
            #[doc = "Definition of currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn hasel(&self) -> super::vals::Hasel {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Hasel::from_bits(val as u8)
            }
            #[doc = "Definition of currently selected harts."]
            #[inline(always)]
            pub const fn set_hasel(&mut self, val: super::vals::Hasel) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Clear the havereset."]
            #[must_use]
            #[inline(always)]
            pub const fn ackhavereset(&self) -> super::vals::Ackhavereset {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Ackhavereset::from_bits(val as u8)
            }
            #[doc = "Clear the havereset."]
            #[inline(always)]
            pub const fn set_ackhavereset(&mut self, val: super::vals::Ackhavereset) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Reset harts."]
            #[must_use]
            #[inline(always)]
            pub const fn hartreset(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Reset harts."]
            #[inline(always)]
            pub const fn set_hartreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Resume currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn resumereq(&self) -> super::vals::Resumereq {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Resumereq::from_bits(val as u8)
            }
            #[doc = "Resume currently selected harts."]
            #[inline(always)]
            pub const fn set_resumereq(&mut self, val: super::vals::Resumereq) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Halt currently selected harts."]
            #[must_use]
            #[inline(always)]
            pub const fn haltreq(&self) -> super::vals::Haltreq {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Haltreq::from_bits(val as u8)
            }
            #[doc = "Halt currently selected harts."]
            #[inline(always)]
            pub const fn set_haltreq(&mut self, val: super::vals::Haltreq) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dmcontrol {
            #[inline(always)]
            fn default() -> Dmcontrol {
                Dmcontrol(0)
            }
        }
        impl core::fmt::Debug for Dmcontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmcontrol")
                    .field("dmactive", &self.dmactive())
                    .field("ndmreset", &self.ndmreset())
                    .field("clrresethaltreq", &self.clrresethaltreq())
                    .field("setresethaltreq", &self.setresethaltreq())
                    .field("hartselhi", &self.hartselhi())
                    .field("hartsello", &self.hartsello())
                    .field("hasel", &self.hasel())
                    .field("ackhavereset", &self.ackhavereset())
                    .field("hartreset", &self.hartreset())
                    .field("resumereq", &self.resumereq())
                    .field("haltreq", &self.haltreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmcontrol {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dmcontrol {{ dmactive: {=bool:?}, ndmreset: {=bool:?}, clrresethaltreq: {:?}, setresethaltreq: {:?}, hartselhi: {=u16:?}, hartsello: {=u16:?}, hasel: {:?}, ackhavereset: {:?}, hartreset: {=bool:?}, resumereq: {:?}, haltreq: {:?} }}" , self . dmactive () , self . ndmreset () , self . clrresethaltreq () , self . setresethaltreq () , self . hartselhi () , self . hartsello () , self . hasel () , self . ackhavereset () , self . hartreset () , self . resumereq () , self . haltreq ())
            }
        }
        #[doc = "Debug Module Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmstatus(pub u32);
        impl Dmstatus {
            #[doc = "Version of the debug module."]
            #[must_use]
            #[inline(always)]
            pub const fn version(&self) -> super::vals::Version {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Version::from_bits(val as u8)
            }
            #[doc = "Version of the debug module."]
            #[inline(always)]
            pub const fn set_version(&mut self, val: super::vals::Version) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Configuration string."]
            #[must_use]
            #[inline(always)]
            pub const fn confstrptrvalid(&self) -> super::vals::Confstrptrvalid {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Confstrptrvalid::from_bits(val as u8)
            }
            #[doc = "Configuration string."]
            #[inline(always)]
            pub const fn set_confstrptrvalid(&mut self, val: super::vals::Confstrptrvalid) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Halt-on-reset support status."]
            #[must_use]
            #[inline(always)]
            pub const fn hasresethaltreq(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Halt-on-reset support status."]
            #[inline(always)]
            pub const fn set_hasresethaltreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Authentication busy status."]
            #[must_use]
            #[inline(always)]
            pub const fn authbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication busy status."]
            #[inline(always)]
            pub const fn set_authbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Authentication status."]
            #[must_use]
            #[inline(always)]
            pub const fn authenticated(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication status."]
            #[inline(always)]
            pub const fn set_authenticated(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Any currently selected harts halted status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyhalted(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts halted status."]
            #[inline(always)]
            pub const fn set_anyhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "All currently selected harts halted status."]
            #[must_use]
            #[inline(always)]
            pub const fn allhalted(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts halted status."]
            #[inline(always)]
            pub const fn set_allhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Any currently selected harts running status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyrunning(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts running status."]
            #[inline(always)]
            pub const fn set_anyrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "All currently selected harts running status."]
            #[must_use]
            #[inline(always)]
            pub const fn allrunning(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts running status."]
            #[inline(always)]
            pub const fn set_allrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[must_use]
            #[inline(always)]
            pub const fn anyunavail(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn set_anyunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "All currently selected harts unavailable status."]
            #[must_use]
            #[inline(always)]
            pub const fn allunavail(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn set_allunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[must_use]
            #[inline(always)]
            pub const fn anynonexistent(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn set_anynonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[must_use]
            #[inline(always)]
            pub const fn allnonexistent(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn set_allnonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[must_use]
            #[inline(always)]
            pub const fn anyresumeack(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[inline(always)]
            pub const fn set_anyresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[must_use]
            #[inline(always)]
            pub const fn allresumeack(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[inline(always)]
            pub const fn set_allresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[must_use]
            #[inline(always)]
            pub const fn anyhavereset(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[inline(always)]
            pub const fn set_anyhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[must_use]
            #[inline(always)]
            pub const fn allhavereset(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[inline(always)]
            pub const fn set_allhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[must_use]
            #[inline(always)]
            pub const fn impebreak(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[inline(always)]
            pub const fn set_impebreak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Dmstatus {
            #[inline(always)]
            fn default() -> Dmstatus {
                Dmstatus(0)
            }
        }
        impl core::fmt::Debug for Dmstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmstatus")
                    .field("version", &self.version())
                    .field("confstrptrvalid", &self.confstrptrvalid())
                    .field("hasresethaltreq", &self.hasresethaltreq())
                    .field("authbusy", &self.authbusy())
                    .field("authenticated", &self.authenticated())
                    .field("anyhalted", &self.anyhalted())
                    .field("allhalted", &self.allhalted())
                    .field("anyrunning", &self.anyrunning())
                    .field("allrunning", &self.allrunning())
                    .field("anyunavail", &self.anyunavail())
                    .field("allunavail", &self.allunavail())
                    .field("anynonexistent", &self.anynonexistent())
                    .field("allnonexistent", &self.allnonexistent())
                    .field("anyresumeack", &self.anyresumeack())
                    .field("allresumeack", &self.allresumeack())
                    .field("anyhavereset", &self.anyhavereset())
                    .field("allhavereset", &self.allhavereset())
                    .field("impebreak", &self.impebreak())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Dmstatus {{ version: {:?}, confstrptrvalid: {:?}, hasresethaltreq: {=bool:?}, authbusy: {=bool:?}, authenticated: {=bool:?}, anyhalted: {=bool:?}, allhalted: {=bool:?}, anyrunning: {=bool:?}, allrunning: {=bool:?}, anyunavail: {=bool:?}, allunavail: {=bool:?}, anynonexistent: {=bool:?}, allnonexistent: {=bool:?}, anyresumeack: {=bool:?}, allresumeack: {=bool:?}, anyhavereset: {=bool:?}, allhavereset: {=bool:?}, impebreak: {=bool:?} }}" , self . version () , self . confstrptrvalid () , self . hasresethaltreq () , self . authbusy () , self . authenticated () , self . anyhalted () , self . allhalted () , self . anyrunning () , self . allrunning () , self . anyunavail () , self . allunavail () , self . anynonexistent () , self . allnonexistent () , self . anyresumeack () , self . allresumeack () , self . anyhavereset () , self . allhavereset () , self . impebreak ())
            }
        }
        #[doc = "Hart Information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hartinfo(pub u32);
        impl Hartinfo {
            #[doc = "Data Address"]
            #[must_use]
            #[inline(always)]
            pub const fn dataaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Data Address"]
            #[inline(always)]
            pub const fn set_dataaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Data Size"]
            #[must_use]
            #[inline(always)]
            pub const fn datasize(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Data Size"]
            #[inline(always)]
            pub const fn set_datasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Data Access"]
            #[must_use]
            #[inline(always)]
            pub const fn dataaccess(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data Access"]
            #[inline(always)]
            pub const fn set_dataaccess(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Number of dscratch registers"]
            #[must_use]
            #[inline(always)]
            pub const fn nscratch(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of dscratch registers"]
            #[inline(always)]
            pub const fn set_nscratch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for Hartinfo {
            #[inline(always)]
            fn default() -> Hartinfo {
                Hartinfo(0)
            }
        }
        impl core::fmt::Debug for Hartinfo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hartinfo")
                    .field("dataaddr", &self.dataaddr())
                    .field("datasize", &self.datasize())
                    .field("dataaccess", &self.dataaccess())
                    .field("nscratch", &self.nscratch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hartinfo {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Hartinfo {{ dataaddr: {=u16:?}, datasize: {=u8:?}, dataaccess: {=bool:?}, nscratch: {=u8:?} }}" , self . dataaddr () , self . datasize () , self . dataaccess () , self . nscratch ())
            }
        }
        #[doc = "Hart Array Window Select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hawindowsel(pub u32);
        impl Hawindowsel {
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[must_use]
            #[inline(always)]
            pub const fn hawindowsel(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[inline(always)]
            pub const fn set_hawindowsel(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Hawindowsel {
            #[inline(always)]
            fn default() -> Hawindowsel {
                Hawindowsel(0)
            }
        }
        impl core::fmt::Debug for Hawindowsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hawindowsel")
                    .field("hawindowsel", &self.hawindowsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hawindowsel {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Hawindowsel {{ hawindowsel: {=u16:?} }}",
                    self.hawindowsel()
                )
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[inline(always)]
            pub const fn set_triggered16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[inline(always)]
            pub const fn set_triggered17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[inline(always)]
            pub const fn set_triggered18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[inline(always)]
            pub const fn set_triggered19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[inline(always)]
            pub const fn set_triggered20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[inline(always)]
            pub const fn set_triggered21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[must_use]
            #[inline(always)]
            pub const fn triggered22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[inline(always)]
            pub const fn set_triggered22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered16", &self.triggered16())
                    .field("triggered17", &self.triggered17())
                    .field("triggered18", &self.triggered18())
                    .field("triggered19", &self.triggered19())
                    .field("triggered20", &self.triggered20())
                    .field("triggered21", &self.triggered21())
                    .field("triggered22", &self.triggered22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Int {{ triggered16: {=bool:?}, triggered17: {=bool:?}, triggered18: {=bool:?}, triggered19: {=bool:?}, triggered20: {=bool:?}, triggered21: {=bool:?}, triggered22: {=bool:?} }}" , self . triggered16 () , self . triggered17 () , self . triggered18 () , self . triggered19 () , self . triggered20 () , self . triggered21 () , self . triggered22 ())
            }
        }
        #[doc = "System Bus Access Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbcs(pub u32);
        impl Sbcs {
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess8(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess16(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess32(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess64(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess64(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess128(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbaccess128(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[must_use]
            #[inline(always)]
            pub const fn sbasize(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x7f;
                val as u8
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[inline(always)]
            pub const fn set_sbasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 5usize)) | (((val as u32) & 0x7f) << 5usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sberror(&self) -> super::vals::Sberror {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Sberror::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sberror(&mut self, val: super::vals::Sberror) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbreadondata(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbreadondata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbautoincrement(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbautoincrement(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbaccess(&self) -> super::vals::Sbaccess {
                let val = (self.0 >> 17usize) & 0x07;
                super::vals::Sbaccess::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sbaccess(&mut self, val: super::vals::Sbaccess) {
                self.0 =
                    (self.0 & !(0x07 << 17usize)) | (((val.to_bits() as u32) & 0x07) << 17usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbreadonaddr(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbreadonaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbbusy(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbbusyerror(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub const fn set_sbbusyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[must_use]
            #[inline(always)]
            pub const fn sbversion(&self) -> super::vals::Sbversion {
                let val = (self.0 >> 29usize) & 0x07;
                super::vals::Sbversion::from_bits(val as u8)
            }
            #[inline(always)]
            pub const fn set_sbversion(&mut self, val: super::vals::Sbversion) {
                self.0 =
                    (self.0 & !(0x07 << 29usize)) | (((val.to_bits() as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Sbcs {
            #[inline(always)]
            fn default() -> Sbcs {
                Sbcs(0)
            }
        }
        impl core::fmt::Debug for Sbcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbcs")
                    .field("sbaccess8", &self.sbaccess8())
                    .field("sbaccess16", &self.sbaccess16())
                    .field("sbaccess32", &self.sbaccess32())
                    .field("sbaccess64", &self.sbaccess64())
                    .field("sbaccess128", &self.sbaccess128())
                    .field("sbasize", &self.sbasize())
                    .field("sberror", &self.sberror())
                    .field("sbreadondata", &self.sbreadondata())
                    .field("sbautoincrement", &self.sbautoincrement())
                    .field("sbaccess", &self.sbaccess())
                    .field("sbreadonaddr", &self.sbreadonaddr())
                    .field("sbbusy", &self.sbbusy())
                    .field("sbbusyerror", &self.sbbusyerror())
                    .field("sbversion", &self.sbversion())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbcs {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Sbcs {{ sbaccess8: {=bool:?}, sbaccess16: {=bool:?}, sbaccess32: {=bool:?}, sbaccess64: {=bool:?}, sbaccess128: {=bool:?}, sbasize: {=u8:?}, sberror: {:?}, sbreadondata: {=bool:?}, sbautoincrement: {=bool:?}, sbaccess: {:?}, sbreadonaddr: {=bool:?}, sbbusy: {=bool:?}, sbbusyerror: {=bool:?}, sbversion: {:?} }}" , self . sbaccess8 () , self . sbaccess16 () , self . sbaccess32 () , self . sbaccess64 () , self . sbaccess128 () , self . sbasize () , self . sberror () , self . sbreadondata () , self . sbautoincrement () , self . sbaccess () , self . sbreadonaddr () , self . sbbusy () , self . sbbusyerror () , self . sbversion ())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackhavereset {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the havereset for selected harts."]
            CLEAR = 0x01,
        }
        impl Ackhavereset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackhavereset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackhavereset {
            #[inline(always)]
            fn from(val: u8) -> Ackhavereset {
                Ackhavereset::from_bits(val)
            }
        }
        impl From<Ackhavereset> for u8 {
            #[inline(always)]
            fn from(val: Ackhavereset) -> u8 {
                Ackhavereset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clrresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Clrresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clrresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clrresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Clrresethaltreq {
                Clrresethaltreq::from_bits(val)
            }
        }
        impl From<Clrresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Clrresethaltreq) -> u8 {
                Clrresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmderr {
            #[doc = "No error."]
            NO_ERROR = 0x0,
            #[doc = "An abstract command was executing while command, abstractcs, or abstractauto was written, or when one of the data or progbuf registers was read or written. This status is only written if cmderr contains 0"]
            BUSY = 0x01,
            #[doc = "The requested command is notsupported, regardless of whether the hart is running or not."]
            NOT_SUPPORTED = 0x02,
            #[doc = "An exception occurred while executing the command (e.g. while executing theProgram Buffer)."]
            EXCEPTION = 0x03,
            #[doc = "The abstract command couldn't execute because the hart wasn't in the required state (running/halted). or unavailable."]
            HALT_RESUME = 0x04,
            #[doc = "The abstract command failed due to abus error (e.g. alignment, access size, or timeout)."]
            BUS = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "The command failed for another reason."]
            OTHER = 0x07,
        }
        impl Cmderr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmderr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmderr {
            #[inline(always)]
            fn from(val: u8) -> Cmderr {
                Cmderr::from_bits(val)
            }
        }
        impl From<Cmderr> for u8 {
            #[inline(always)]
            fn from(val: Cmderr) -> u8 {
                Cmderr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Cmdtype(u8);
        impl Cmdtype {
            #[doc = "Register Access Command"]
            pub const REGACCESS: Self = Self(0x0);
            #[doc = "Quick Access Command"]
            pub const QUICKACCESS: Self = Self(0x01);
            #[doc = "Memory Access Command"]
            pub const MEMACCESS: Self = Self(0x02);
        }
        impl Cmdtype {
            pub const fn from_bits(val: u8) -> Cmdtype {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Cmdtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("REGACCESS"),
                    0x01 => f.write_str("QUICKACCESS"),
                    0x02 => f.write_str("MEMACCESS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdtype {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "REGACCESS"),
                    0x01 => defmt::write!(f, "QUICKACCESS"),
                    0x02 => defmt::write!(f, "MEMACCESS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Cmdtype {
            #[inline(always)]
            fn from(val: u8) -> Cmdtype {
                Cmdtype::from_bits(val)
            }
        }
        impl From<Cmdtype> for u8 {
            #[inline(always)]
            fn from(val: Cmdtype) -> u8 {
                Cmdtype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Confstrptrvalid {
            #[doc = "The confstrptr0..confstrptr3 holds information which is not relevant to the configuration string."]
            NOT_RELEVANT = 0x0,
            #[doc = "The confstrptr0..confstrptr3 holds the address of the configuration string."]
            ADDRESS = 0x01,
        }
        impl Confstrptrvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Confstrptrvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Confstrptrvalid {
            #[inline(always)]
            fn from(val: u8) -> Confstrptrvalid {
                Confstrptrvalid::from_bits(val)
            }
        }
        impl From<Confstrptrvalid> for u8 {
            #[inline(always)]
            fn from(val: Confstrptrvalid) -> u8 {
                Confstrptrvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpurunEn {
            #[doc = "CPU stopped. If this is the CPU state after a core reset, setting this bit will change the CPU state to CPU running."]
            STOPPED = 0x0,
            #[doc = "CPU running. If this is the CPU state after a core reset, clearing this bit will change the CPU state to CPU stopped after a core reset."]
            RUNNING = 0x01,
        }
        impl CpurunEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CpurunEn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CpurunEn {
            #[inline(always)]
            fn from(val: u8) -> CpurunEn {
                CpurunEn::from_bits(val)
            }
        }
        impl From<CpurunEn> for u8 {
            #[inline(always)]
            fn from(val: CpurunEn) -> u8 {
                CpurunEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Haltreq {
            #[doc = "Clears halt request bit for all currently selected harts."]
            CLEAR = 0x0,
            #[doc = "Currently selected harts halted."]
            HALT = 0x01,
        }
        impl Haltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Haltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Haltreq {
            #[inline(always)]
            fn from(val: u8) -> Haltreq {
                Haltreq::from_bits(val)
            }
        }
        impl From<Haltreq> for u8 {
            #[inline(always)]
            fn from(val: Haltreq) -> u8 {
                Haltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hasel {
            #[doc = "Single hart selected."]
            SINGLE = 0x0,
            #[doc = "Multiple harts selected"]
            MULTIPLE = 0x01,
        }
        impl Hasel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hasel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hasel {
            #[inline(always)]
            fn from(val: u8) -> Hasel {
                Hasel::from_bits(val)
            }
        }
        impl From<Hasel> for u8 {
            #[inline(always)]
            fn from(val: Hasel) -> u8 {
                Hasel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resumereq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Currently selected harts resumed."]
            RESUMED = 0x01,
        }
        impl Resumereq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resumereq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resumereq {
            #[inline(always)]
            fn from(val: u8) -> Resumereq {
                Resumereq::from_bits(val)
            }
        }
        impl From<Resumereq> for u8 {
            #[inline(always)]
            fn from(val: Resumereq) -> u8 {
                Resumereq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbaccess {
            #[doc = "8-bit."]
            SIZE8 = 0x0,
            #[doc = "16-bit."]
            SIZE16 = 0x01,
            #[doc = "32-bit."]
            SIZE32 = 0x02,
            #[doc = "64-bit."]
            SIZE64 = 0x03,
            #[doc = "128-bit."]
            SIZE128 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbaccess {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbaccess {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbaccess {
            #[inline(always)]
            fn from(val: u8) -> Sbaccess {
                Sbaccess::from_bits(val)
            }
        }
        impl From<Sbaccess> for u8 {
            #[inline(always)]
            fn from(val: Sbaccess) -> u8 {
                Sbaccess::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sberror {
            #[doc = "There was no bus error."]
            NORMAL = 0x0,
            #[doc = "There was a timeout."]
            TIMEOUT = 0x01,
            #[doc = "A bad address was accessed."]
            ADDRESS = 0x02,
            #[doc = "There was an alignment error."]
            ALIGNMENT = 0x03,
            #[doc = "An access of unsupported size was requested."]
            SIZE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Other."]
            OTHER = 0x07,
        }
        impl Sberror {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sberror {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sberror {
            #[inline(always)]
            fn from(val: u8) -> Sberror {
                Sberror::from_bits(val)
            }
        }
        impl From<Sberror> for u8 {
            #[inline(always)]
            fn from(val: Sberror) -> u8 {
                Sberror::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbversion {
            #[doc = "The System Bus interface conforms to mainline drafts of thia RISC-V External Debug Support spec older than 1 January, 2018."]
            VERSION0 = 0x0,
            #[doc = "The System Bus interface conforms to RISC-V External Debug Support version 0.14.0-DRAFT. Other values are reserved for future versions."]
            VERSION1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbversion {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbversion {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbversion {
            #[inline(always)]
            fn from(val: u8) -> Sbversion {
                Sbversion::from_bits(val)
            }
        }
        impl From<Sbversion> for u8 {
            #[inline(always)]
            fn from(val: Sbversion) -> u8 {
                Sbversion::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Setresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Sets the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Setresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Setresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Setresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Setresethaltreq {
                Setresethaltreq::from_bits(val)
            }
        }
        impl From<Setresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Setresethaltreq) -> u8 {
                Setresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Version {
            #[doc = "Debug module not present."]
            NOT_PRESENT = 0x0,
            #[doc = "There is a Debug Module and it conforms to version 0.11 of this specifcation."]
            V011 = 0x01,
            #[doc = "There is a Debug Module and it conforms to version 0.13 of this specifcation."]
            V013 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "There is a Debug Module but it does not conform to any available version of the spec."]
            NON_CONFORM = 0x0f,
        }
        impl Version {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Version {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Version {
            #[inline(always)]
            fn from(val: u8) -> Version {
                Version::from_bits(val)
            }
        }
        impl From<Version> for u8 {
            #[inline(always)]
            fn from(val: Version) -> u8 {
                Version::to_bits(val)
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start WDT"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop WDT"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Watchdog timeout"]
        #[inline(always)]
        pub const fn events_timeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Watchdog stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event TIMEOUT"]
        #[inline(always)]
        pub const fn publish_timeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn nmienset(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn nmienclr(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0328usize) as _) }
        }
        #[doc = "Run status"]
        #[inline(always)]
        pub const fn runstatus(self) -> crate::common::Reg<regs::Runstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Request status"]
        #[inline(always)]
        pub const fn reqstatus(self) -> crate::common::Reg<regs::Reqstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Counter reload value"]
        #[inline(always)]
        pub const fn crv(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Enable register for reload request registers"]
        #[inline(always)]
        pub const fn rren(self) -> crate::common::Reg<regs::Rren, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Task stop enable"]
        #[inline(always)]
        pub const fn tsen(self) -> crate::common::Reg<regs::Tsen, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Description collection: Reload request n"]
        #[inline(always)]
        pub const fn rr(self, n: usize) -> crate::common::Reg<regs::Rr, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0600usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[must_use]
            #[inline(always)]
            pub const fn sleep(&self) -> super::vals::Sleep {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleep::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[inline(always)]
            pub const fn set_sleep(&mut self, val: super::vals::Sleep) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[must_use]
            #[inline(always)]
            pub const fn halt(&self) -> super::vals::Halt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Halt::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[inline(always)]
            pub const fn set_halt(&mut self, val: super::vals::Halt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Allow stopping WDT"]
            #[must_use]
            #[inline(always)]
            pub const fn stopen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn set_stopen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("sleep", &self.sleep())
                    .field("halt", &self.halt())
                    .field("stopen", &self.stopen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Config {{ sleep: {:?}, halt: {:?}, stopen: {=bool:?} }}",
                    self.sleep(),
                    self.halt(),
                    self.stopen()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Int {{ timeout: {=bool:?}, stopped: {=bool:?} }}",
                    self.timeout(),
                    self.stopped()
                )
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmi(pub u32);
        impl Nmi {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[must_use]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[must_use]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Nmi {
            #[inline(always)]
            fn default() -> Nmi {
                Nmi(0)
            }
        }
        impl core::fmt::Debug for Nmi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmi")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmi {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Nmi {{ timeout: {=bool:?}, stopped: {=bool:?} }}",
                    self.timeout(),
                    self.stopped()
                )
            }
        }
        #[doc = "Request status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reqstatus(pub u32);
        impl Reqstatus {
            #[doc = "Request status for RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Request status for RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Reqstatus {
            #[inline(always)]
            fn default() -> Reqstatus {
                Reqstatus(0)
            }
        }
        impl core::fmt::Debug for Reqstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reqstatus")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reqstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Reqstatus {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Description collection: Reload request n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rr(pub u32);
        impl Rr {
            #[doc = "Reload request register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self) -> super::vals::Rr {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rr::from_bits(val as u32)
            }
            #[doc = "Reload request register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, val: super::vals::Rr) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rr {
            #[inline(always)]
            fn default() -> Rr {
                Rr(0)
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rr").field("rr", &self.rr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Rr {{ rr: {:?} }}", self.rr())
            }
        }
        #[doc = "Enable register for reload request registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rren(pub u32);
        impl Rren {
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[must_use]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[inline(always)]
            pub const fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Rren {
            #[inline(always)]
            fn default() -> Rren {
                Rren(0)
            }
        }
        impl core::fmt::Debug for Rren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rren")
                    .field("rr[0]", &self.rr(0usize))
                    .field("rr[1]", &self.rr(1usize))
                    .field("rr[2]", &self.rr(2usize))
                    .field("rr[3]", &self.rr(3usize))
                    .field("rr[4]", &self.rr(4usize))
                    .field("rr[5]", &self.rr(5usize))
                    .field("rr[6]", &self.rr(6usize))
                    .field("rr[7]", &self.rr(7usize))
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rren {
            fn format(&self, f: defmt::Formatter) {
                defmt :: write ! (f , "Rren {{ rr[0]: {=bool:?}, rr[1]: {=bool:?}, rr[2]: {=bool:?}, rr[3]: {=bool:?}, rr[4]: {=bool:?}, rr[5]: {=bool:?}, rr[6]: {=bool:?}, rr[7]: {=bool:?} }}" , self . rr (0usize) , self . rr (1usize) , self . rr (2usize) , self . rr (3usize) , self . rr (4usize) , self . rr (5usize) , self . rr (6usize) , self . rr (7usize))
            }
        }
        #[doc = "Run status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Runstatus(pub u32);
        impl Runstatus {
            #[doc = "Indicates whether or not WDT is running"]
            #[must_use]
            #[inline(always)]
            pub const fn runstatuswdt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether or not WDT is running"]
            #[inline(always)]
            pub const fn set_runstatuswdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Runstatus {
            #[inline(always)]
            fn default() -> Runstatus {
                Runstatus(0)
            }
        }
        impl core::fmt::Debug for Runstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Runstatus")
                    .field("runstatuswdt", &self.runstatuswdt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Runstatus {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(
                    f,
                    "Runstatus {{ runstatuswdt: {=bool:?} }}",
                    self.runstatuswdt()
                )
            }
        }
        #[doc = "Task stop enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsen(pub u32);
        impl Tsen {
            #[doc = "Allow stopping WDT"]
            #[must_use]
            #[inline(always)]
            pub const fn tsen(&self) -> super::vals::Tsen {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Tsen::from_bits(val as u32)
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn set_tsen(&mut self, val: super::vals::Tsen) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Tsen {
            #[inline(always)]
            fn default() -> Tsen {
                Tsen(0)
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsen").field("tsen", &self.tsen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                defmt::write!(f, "Tsen {{ tsen: {:?} }}", self.tsen())
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Halt {
            #[doc = "Pause WDT while the CPU is halted by the debugger"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is halted by the debugger"]
            RUN = 0x01,
        }
        impl Halt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Halt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Halt {
            #[inline(always)]
            fn from(val: u8) -> Halt {
                Halt::from_bits(val)
            }
        }
        impl From<Halt> for u8 {
            #[inline(always)]
            fn from(val: Halt) -> u8 {
                Halt::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rr(u32);
        impl Rr {
            #[doc = "Value to request a reload of the watchdog timer"]
            pub const RELOAD: Self = Self(0x6e52_4635);
        }
        impl Rr {
            pub const fn from_bits(val: u32) -> Rr {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("RELOAD"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "RELOAD"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rr {
            #[inline(always)]
            fn from(val: u32) -> Rr {
                Rr::from_bits(val)
            }
        }
        impl From<Rr> for u32 {
            #[inline(always)]
            fn from(val: Rr) -> u32 {
                Rr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleep {
            #[doc = "Pause WDT while the CPU is sleeping"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is sleeping"]
            RUN = 0x01,
        }
        impl Sleep {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleep {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleep {
            #[inline(always)]
            fn from(val: u8) -> Sleep {
                Sleep::from_bits(val)
            }
        }
        impl From<Sleep> for u8 {
            #[inline(always)]
            fn from(val: Sleep) -> u8 {
                Sleep::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tsen(u32);
        impl Tsen {
            #[doc = "Value to allow stopping WDT"]
            pub const ENABLE: Self = Self(0x6e52_4635);
        }
        impl Tsen {
            pub const fn from_bits(val: u32) -> Tsen {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("ENABLE"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "ENABLE"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Tsen {
            #[inline(always)]
            fn from(val: u32) -> Tsen {
                Tsen::from_bits(val)
            }
        }
        impl From<Tsen> for u32 {
            #[inline(always)]
            fn from(val: Tsen) -> u32 {
                Tsen::to_bits(val)
            }
        }
    }
}
